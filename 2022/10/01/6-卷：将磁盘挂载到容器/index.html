<!DOCTYPE html>












  


<html class="theme-next pisces use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">




  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link rel="stylesheet" href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2">





















<link rel="stylesheet" href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/css/main.css?v=7.0.1">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=7.0.1">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon.ico?v=7.0.1">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=7.0.1">


  <link rel="mask-icon" href="/images/logo.svg?v=7.0.1" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '7.0.1',
    sidebar: {"position":"left","display":"post","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta name="description" content="思考并回答以下问题：">
<meta name="keywords" content="Kubernetes in Action">
<meta property="og:type" content="article">
<meta property="og:title" content="6-卷：将磁盘挂载到容器">
<meta property="og:url" content="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/index.html">
<meta property="og:site_name" content="车斌的技术博客">
<meta property="og:description" content="思考并回答以下问题：">
<meta property="og:locale" content="zh-CN">
<meta property="og:image" content="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/1.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/2.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/3.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/4.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/5.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/6.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/7.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/8.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/9.png">
<meta property="og:image" content="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/10.png">
<meta property="og:updated_time" content="2023-08-30T03:23:14.932Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="6-卷：将磁盘挂载到容器">
<meta name="twitter:description" content="思考并回答以下问题：">
<meta name="twitter:image" content="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/1.png">






  <link rel="canonical" href="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>6-卷：将磁盘挂载到容器 | 车斌的技术博客</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">车斌的技术博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
      
        <p class="site-subtitle">放弃会成为一种习惯</p>
      
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>

      
      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br>搜索</a>
        </li>
      
    </ul>
  

  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off" placeholder="搜索..." spellcheck="false" type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
            

          
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2022/10/01/6-卷：将磁盘挂载到容器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="CheBin">
      <meta itemprop="description" content="先得寸再进尺，既得陇复望蜀">
      <meta itemprop="image" content="/images/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="车斌的技术博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">6-卷：将磁盘挂载到容器

              
            
          </h1>
        

        <div class="post-meta">

          

          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2022-10-01 09:58:35" itemprop="dateCreated datePublished" datetime="2022-10-01T09:58:35+08:00">2022-10-01</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2023-08-30 11:23:14" itemprop="dateModified" datetime="2023-08-30T11:23:14+08:00">2023-08-30</time>
              
            
          </span>

          
            <span class="post-category">
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing"><a href="/categories/Kubernetes/" itemprop="url" rel="index"><span itemprop="name">Kubernetes</span></a></span>

                
                
              
            </span>
          

          
            
            
          

          
          

          

          
            <div class="post-symbolscount">
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">本文字数：</span>
                
                <span title="本文字数">23k</span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">21 分钟</span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>思考并回答以下问题：</p>
<a id="more"></a>
<p>【本章内容包括】</p>
<ul>
<li>创建多容器pod</li>
<li>创建一个可在容器间共享磁盘存储的卷</li>
<li>在pod中使用git仓库</li>
<li>将持久性存储（如GCE持久磁盘）挂载到pod</li>
<li>使用预先配置的持久性存储</li>
<li>动态调配持久存储</li>
</ul>
<p>在前面三个章节中，我们介绍了pod和与之交互的其他Kubemetes资源，即：ReplicationController（复制控制器）、ReplicaSet（副本服务器）、DaemonSet（守护进程集）、作业和服务。现在，我们回到pod中，来了解容器是如何访问外部磁盘存储的，以及如何在它们之间共享存储空间。</p>
<p>我们之前说过，pod类似逻辑主机，在逻辑主机中运行的进程共享诸如CPU、RAM、网络接口等资源。人们会期望进程也能共享磁盘，但事实并非如此。需要谨记一点，pod中的每个容器都有自己独立的文件系统，因为文件系统来自容器镜像。</p>
<p>每个新容器都是通过在构建镜像时加入的详细配置文件来启动的。将此与pod中容器重新启动的现象结合起来（也许是因为进程崩溃，也许是存活探针向Kubemetes发送了容器状态异常的信号），你就会意识到新容器并不会识别前一个容器写入文件系统内的任何内容，即使新启动的容器运行在同一个pod中。</p>
<p>在某些场景下，我们可能希望新的容器可以在之前容器结束的位置继续运行，比如在物理机上重启进程。可能不需要（或者不想要）整个文件系统被持久化，但又希望能保存实际数据的目录。</p>
<p>Kubernetes通过定义存储卷来满足这个需求，它们不像pod这样的顶级资源，而是被定义为pod的一部分，并和pod共享相同的生命周期。这意味着在pod启动时创建卷，并在删除pod时销毁卷。因此，在容器重新启动期间，卷的内容将保持不变，在重新启动容器之后，新容器可以识别前一个容器写入卷的所有文件。另外，如果一个pod包含多个容器，那这个卷可以同时被所有的容器使用。</p>
<h1 id="介绍卷"><a href="#介绍卷" class="headerlink" title="介绍卷"></a><span style="color:#339AFF;">介绍卷</span></h1><p>Kubernetes的卷是pod的一个组成部分，因此像容器一样在pod的规范中就定义了。它们不是独立的Kubernetes对象，也不能单独创建或删除。pod中的所有容器都可以使用卷，但必须先将它挂载在每个需要访问它的容器中。在每个容器中，都可以在其文件系统的任意位置挂载卷。</p>
<h2 id="卷的应用示例"><a href="#卷的应用示例" class="headerlink" title="卷的应用示例"></a><span style="color:#00ACC1;">卷的应用示例</span></h2><p>假设有一个带有三个容器的pod（如图6.1所示），一个容器运行了一个web服务器，该web服务器的HTML页面目录位于/var/htdocs，并将站点访问日志存储到/var/logs目录中。第二个容器运行了一个代理来创建HTML文件，并将它们存放在/var/html中，第三个容器处理在/var/logs目录中找到的日志（转换、压缩、分析它们或者做其他处理）。</p>
<p>每个容器都有一个很明确的用途，但是每个容器单独使用就没有多大用处了。在没有共享磁盘存储的情况下，用这三个容器创建一个pod没有任何意义。因为内容生成器（contentgenerator）会在自己的容器中存放生成的HTML文件，而web服务器无法访问这些文件，因为它运行在一个隔离的独立容器内。正好相反，它会托管放置在容器镜像的/var/htdocs目录下的任意内容，或者是放置在容器镜像中/var/htdocs路径下的任意内容。同样，日志转换器（logrotator）也无事可做，因为它的/var/logs目录始终是空的，并没有日志写入。一个有这三个容器而没有挂载卷的pod基本上什么也做不了。</p>
<p>但是，如果将两个卷添加到pod中，并在三个容器的适当路径上挂载它们，如图6.2所示，就已经创建出一个比其各个部分之和更完善的系统。Linux允许在文件树中的任意位置挂载文件系统，当这样做的时候，挂载的文件系统内容在目录中是可以访问的。通过将相同的卷挂载到两个容器中，它们可以对相同的文件进行操作。在这个例子中，只需要在三个容器中挂载两个卷，这样三个容器将可以一起工作，并发挥作用。下面解释一下：</p>
<p>首先，pod有一个名为publicHtml的卷，这个卷被挂载在WebServer容器的/var/htdocs中，因为这是web服务器的服务目录。在ContentAgent容器中也挂载了相同的卷，但在/var/html中，因为代理将文件写入/var/html中。通过这种方式挂载这个卷，web服务器现在将为contentagent生成的内容提供服务。</p>
<p>同样，pod还拥有一个名为logVol的卷，用于存放日志，此卷在WebServer和LogRotator容器中的/var/log中挂载，注意，它没有挂载在ContentAgent容器中，这个容器不能访问它的文件，即使容器和卷是同一个pod的一部分，在pod的规范中定义卷是不够的。如果我们希望容器能够访问它，还需要在容器的规范中定义一个VolumeMount。</p>
<blockquote>
<p>图6.1 同一个pod的三个容器没有共享存储</p>
</blockquote>
<img src="/2022/10/01/6-卷：将磁盘挂载到容器/1.png">
<p>在本例中，两个卷最初都是空的，因此可以使用一种名为emptyDir的卷。Kubernetes还支持其他类型的卷，这些卷要么是在从外部源初始化卷时填充的，要么是在卷内挂载现有目录。这个填充或装入卷的过程是在pod内的容器启动之前执行的。</p>
<p>卷被绑定到pod的lifecycle（生命周期）中，只有在pod存在时才会存在，但取决于卷的类型，即使在pod和卷消失之后，卷的文件也可能保持原样，并可以挂载到新的卷中。让我们来看看卷有哪些类型。</p>
<blockquote>
<p>图6.2 三个容器共享挂载在不同安装路径的两个卷上</p>
</blockquote>
<img src="/2022/10/01/6-卷：将磁盘挂载到容器/2.png">
<h2 id="介绍可用的卷类型"><a href="#介绍可用的卷类型" class="headerlink" title="介绍可用的卷类型"></a><span style="color:#00ACC1;">介绍可用的卷类型</span></h2><p>有多种卷类型可供选择。其中-些是通用的，而另-些则相对于当前常用的存储技术有较大差别。如果从来没有听说过这些技术，也别太担心一其中至少一半笔者也没有听说过。你有可能只会用到那些自己熟悉和曾经用过的卷技术。以下是几种可用卷类型的列表：</p>
<ul>
<li>emptyDir-一用于存储临时数据的简单空目录。</li>
<li>hostPath—用于将目录从工作节点的文件系统挂载到pod中。</li>
<li>gitRepo—通过检出Git仓库的内容来初始化的卷。</li>
<li>nfs-挂载到pod中的NFS共享卷。</li>
</ul>
<p>gcePersistentDisk（Google高效能型存储磁盘卷）、awsElasticBlockStore（AmazonWeb服务弹性块存储卷）、azureDisk（MicrosoftAzure磁盘卷）一用于挂载云服务商提供的特定存储类型。</p>
<p>cinder、cephfs、iscsi、flocker、glusterfs、quobyte、rbd、flexVolume、vsphere-Volume、photonPersistentDisk、scaleI0用于挂载其他类型的网络存储。</p>
<p>configMap、secret、downwardAPI—用于将Kubernetes部分资源和集群信息公开给pod的特殊类型的卷。</p>
<p>persistentVolumeClaim一种使用预置或者动态配置的持久存储类型（我们将在本章的最后一节对此展开讨论）。</p>
<p>这些卷类型有各种用途。我们将在下面的部分中了解其中一些内容。特殊类型的卷（secret、downwardAPI、configMap）将在接下来的两章中讨论，因为它们不是用于存储数据，而是用于将Kubernetes元数据公开给运行在pod中的应用程序。</p>
<p>单个容器可以同时使用不同类型的多个卷，而且正如我们前面提到的，每个容器都可以装载或不装载卷。</p>
<h1 id="通过卷在容器之间共享数据"><a href="#通过卷在容器之间共享数据" class="headerlink" title="通过卷在容器之间共享数据"></a><span style="color:#339AFF;">通过卷在容器之间共享数据</span></h1><p>尽管一个卷即使被单个容器使用也可能很有用，但是我们首先要关注它是如何用于在一个pod的多个容器之间共享数据的。</p>
<h2 id="使用emptyDir卷"><a href="#使用emptyDir卷" class="headerlink" title="使用emptyDir卷"></a><span style="color:#00ACC1;">使用emptyDir卷</span></h2><p>最简单的卷类型是emptyDir卷，所以作为第一个例子让我们看看如何在pod中定义卷。顾名思义，卷从一个空目录开始，运行在pod内的应用程序可以写入它需要的任何文件。因为卷的生存周期与pod的生存周期相关联，所以当删除pod时，卷的内容就会丢失。</p>
<p>一个emptyDir卷对于在同一个pod中运行的容器之间共享文件特别有用。但是它也可以被单个容器用于将数据临时写入磁盘，例如在大型数据集上执行排序操作时，没有那么多内存可供使用。数据也可以写入容器的文件系统本身（还记得容器的顶层读写层吗？），但是这两者之间存在着细微的差别。容器的文件系统甚至可能是不可写的（我们将在书的末尾讨论这个问题），所以写到挂载的卷可能是唯一的选择。</p>
<p>在pod中使用emptyDir卷</p>
<p>让我们重新回顾一下前面的例子，其中web服务器、内容代理和日志转换器共享两个卷，但让我们简化一下，现在将构建一个仅有web服务器容器内容代理和单独HTML的卷的pod<br>我们将使用Nginx作为Web服务器和UNIXfortune命令来生成HTML内容，fortune命令每次运行时都会输出一个随机引用，可以创建一个脚本每10秒调用一次执行，并将其输出存储在index.html中，在DockerHub上可以找到一个现成的Nginx镜像，但是需要自己创建fortune镜像，或者使用笔者已经构建并推送到DockerHubluksa/Fortune下的镜像。如果你希望了解如何构建Docker镜像，请参考下面的注解（构建fortune容器镜像）。</p>
<p>构建fortune容器镜像</p>
<p>这里描述如何创建镜像，创建一个名为fortune的新目录，然后在其中创建一个具有以下内容的fortuneloop.sh的shell脚本：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">trap"exit"SIGINT</span><br><span class="line">mkdir/var/htdocs</span><br><span class="line">while:</span><br><span class="line">dc</span><br><span class="line"><span class="meta">echo$</span><span class="bash">(date)Writingfortuneto/var/htdocs/index.html/usr/games/fortune&gt;/var/htdocs/index.html</span></span><br><span class="line">sleep10</span><br><span class="line">done</span><br></pre></td></tr></table></figure></p>
<p>然后，在同一个目录中，创建一个名为Dockerfle的文件，其中包含以下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">FROMubuntu:latest</span><br><span class="line">RUNapt-getupdate;apt-get-yinstallfortune</span><br><span class="line">ADDfortuneloop.sh/bin/fortuneloop.sh</span><br><span class="line">ENTRYPOINT/bin/fortuneloop.sh</span><br></pre></td></tr></table></figure></p>
<p>该镜像基于ubuntu：latest镜像，默认情况下不包括fortune二进制文件。这就是为什么在Dockerfile的第二行中，需要使用apt-get安装它的原因。之后，可以向镜像的/bin文件夹中添加fortuneloop.sh脚本。在Dockerfile的最后一行中，指定镜像启动时执行fortuneloop.sh脚本。</p>
<p>准备好这两个文件之后，使用以下两个命令（用自己的DockerHub用户ID替换luksa）构建镜像并上传到DockerHub：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sdockerbuild-tluksa/fortune$dockerpushluksa/fortune</span><br></pre></td></tr></table></figure></p>
<p>创建pod</p>
<p>现在有两个镜像需要运行在pod上，是时候创建pod的manifest了，创建一个名为fortune-pod.yaml的文件，其内容包含在下面的代码清单中。</p>
<blockquote>
<p>代码清单6.1 一个pod中有两个共用同一个卷的容器：fortune-pod.yaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>pod包含两个容器和一个挂载在两个容器中的共用的卷，但在不同的路径上。当html-generator容器启动时，它每10秒启动一次fortune命令输出到/var/htdocs/index.html文件。因为卷是在/var/htdocs上挂载的，所以index.html文件被写入卷中，而不是容器的顶层。一旦web-server容器启动，它就开始为/usr/share/nginx/html目录中的任意HTML文件提供服务（这是Nginx服务的默认服务文件目录）。因为我们将卷挂载在那个确切的位置，Nginx将为运行fortune循环的容器输出的index.html文件提供服务。最终的效果是，一个客户端向pod上的80端口发送一个HTTP请求，将接收当前的fortune消息作为响应。</p>
<p>查看pod状态</p>
<p>为了查看fortune消息，需要启用对pod的访问，可以尝试将端口从本地机器转发到pod来实现：</p>
<p>注意作为练习，还可以通过服务来访问该pod，而不是单纯使用端口转发。现在可以通过本地计算机的8080端口来访问Nginx服务器。通过执行curl命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">curlhttp://localhost:8080</span></span><br><span class="line">Bewareofatallblondmanwithoneblackshoe.</span><br></pre></td></tr></table></figure></p>
<p>如果等待几秒发送另一个请求，则应该会接收到另一条信息。通过组合两个容器，就创建了一个简单的应用，通过这个应用可以观察到卷是如何将两个容器组合在一起，并分别增强它们各自的功能的。</p>
<p>指定用于EMPTYDIR的介质</p>
<p>作为卷来使用的emptyDir，是在承载pod的工作节点的实际磁盘上创建的，因此其性能取决于节点的磁盘类型。但我们可以通知Kubernetes在tmfs文件系统（存在内存而非硬盘）上创建emptyDir。因此，将emptyDir的medium设置为Memory:<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"><span class="attr">-name:</span><span class="string">html</span></span><br><span class="line"><span class="string">emptyDir的文件将会存</span></span><br><span class="line"><span class="attr">emptyDir:</span></span><br><span class="line"><span class="string">储在内存中</span></span><br><span class="line"><span class="attr">medium:</span><span class="string">Memory</span></span><br></pre></td></tr></table></figure></p>
<p>emptyDir卷是最简单的卷类型，但是其他类型的卷都是在它的基础上构建的，在创建空目录后，它们会用数据填充它。有一种称作gitRepo的卷类型，我们将在下面进行介绍。</p>
<h2 id="使用Git仓库作为存储卷"><a href="#使用Git仓库作为存储卷" class="headerlink" title="使用Git仓库作为存储卷"></a><span style="color:#00ACC1;">使用Git仓库作为存储卷</span></h2><p>gitRepo卷基本上也是一个emptyDir卷，它通过克隆Git仓库并在pod启动时（但在创建容器之前）检出特定版本来填充数据，如图6.3所示。</p>
<blockquote>
<p>图6.3 gitRepo卷是一个emptyDir卷，最初填充了Git仓库的内容</p>
</blockquote>
<img src="/2022/10/01/6-卷：将磁盘挂载到容器/3.png">
<p>注意在创建gitRepo卷后，它并不能和对应repo保持同步。当向Git仓库推送新增的提交时，卷中的文件将不会被更新。然而，如果所用的pod是由ReplicationController管理的，删除这个pod将触发新建一个新的pod，而这个新pod的卷中将包含最新的提交。</p>
<p>例如，我们可以使用Git仓库来存放网站的静态HTML文件，并创建一个包含web服务器容器和gitRepo卷的pod。每当pod创建时，它会拉取网站的最新版本并开始托管网站。唯一的缺点是，每次将更改推送到gitRepo时，都需要删除pod，才能托管新版本的网站。</p>
<p>让我们现在开始，这跟你以前做的很接近。</p>
<p>从一个克隆的Git仓库中运行web服务器pod的服务文件</p>
<p>在创建pod之前，需要有一个包含HTML文件并实际可用的Git仓库，笔者在GitHub创建了一个repo，链接为:<code>https://github.com/luksa/kubia-website-example.git</code>。我们需要fork这个项目（在github.上创建你自己的repo副本），这样就可以在后面对其进行变更修改。</p>
<p>当我们完成了fork操作，就可以继续创建pod了。这次，只需要一个Nginx容器和一个gitRepo卷（确保已将gitRepo卷指向fork来的repo副本），如下面的代码清单所示。</p>
<blockquote>
<p>代码清单6.2 使用gitRepo卷的pod：gitrepo-volume-pod.yaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>在创建pod时，首先将卷初始化为一个空目录，然后将制定的Git仓库克隆到其中。如果没有将目录设置为.（句点），存储库将会被克隆到kubia-website-example示例目录中，这不是我们想要的结果。我们预期将repo克隆到卷的根目录中。在设置存储库时，我们还需要指明让Kubernetes切换到master分支所在的版本来创建存储卷修订变更。</p>
<p>在pod运行时，我们可以尝试通过端口转发、服务或在pod（或集群中的任意其他pod）中运行curl命令来访问pod。</p>
<p>确认文件未与Git仓库保持同步</p>
<p>现在，我们将对Github项目中的index.html文件进行更改。如果不在本地使用Git，可以直接在Github上编辑文件—单击Github存储库中的文件以打开该文件，然后单击铅笔图标开始编辑它。更改文本，然后单击底部的按钮提交更改。</p>
<p>Git仓库的主分支现在包含对HTML文件所做的更改。而这些更改在Nginxweb服务器上不可见，因为gitrepo卷与Git仓库未能保持同步。可以通过再次访问pod来确认这一点。</p>
<p>要查看新版本的站点，需要删除pod并重建，每次进行更改时，没必要每次都删除pod，可以运行一个附加进程来使卷与Git仓库保持同步。在这里不详细解释如何实现，相反，建议自己多做练习，这里可以给到一些指引。</p>
<p>介绍sidecar容器</p>
<p>Git同步进程不应该运行在与Nginx站点服务器相同的容器中，而是在第二个容器：sidecarcontainer。它是一种容器，增加了对pod主容器的操作。可以将一个sidecar添加到pod中，这样就可以使用现有的容器镜像，而不是将附加逻辑填入主应用程序的代码中，这会使它过于复杂和不可复用。</p>
<p>为了找到一个保持本地目录与Git仓库同步的现有容器镜像，转到DockerHub并搜索“gitsyc”，可以看到很多可以实现的镜像。然后在示例中，从pod的一个新容器使用镜像，挂载pod现有的gitRepo卷到新容器中，并配置Git同步容器来保持文件与Gitrepo同步。如果正确设置了所有的内容，应该能看到web服务器正在加载的文件与GitHubrepo同步。</p>
<p>注意第18章中的一个例子包含了类似的Git同步容器，所以可以等读到第18章，再跟着分步说明做这个练习。</p>
<p>使用带有专用Git仓库的gitRepo卷</p>
<p>另外还有一个原因，使得我们必须依赖于Gitsyncsidecar容器。我们还没有讨论过是否可以使用对应私有Gitrepo的gitRepo卷，其实不可行。Kubernetes开发人员的共识是保持gitRepo卷的简单性，而不添加任何通过SSH协议克隆私有存储库的支持，因为这需要向gitRepo卷添加额外的配置选项。</p>
<p>如果想要将私有的Gitrepo克隆到容器中，则应该使用gitsyncsidecar或类似的方法，而不是使用gitRepo卷。</p>
<p>总结gitRepo存储卷</p>
<p>gitRepo容器就像emptyDir卷一样，基本上是一个专用目录，专门用于包含卷的容器并单独使用。当pod被删除时，卷及其内容被删除。然而，其他类型的卷并不创建新目录，而是将现有的外部目录挂载到pod的容器文件系统中。该卷内容可以保存多个pod实例化，接下来我们将了解这些类型的卷。</p>
<h1 id="访问工作节点文件系统上的文件"><a href="#访问工作节点文件系统上的文件" class="headerlink" title="访问工作节点文件系统上的文件"></a><span style="color:#339AFF;">访问工作节点文件系统上的文件</span></h1><p>大多数pod应该忽略它们的主机节点，因此它们不应该访问节点文件系统上的任何文件。但是某些系统级别的pod（切记，这些通常由DaemonSet管理）确实需要读取节点的文件或使用节点文件系统来访问节点设备。Kubermetes通过hostPath卷实现了这一点。</p>
<h2 id="介绍hostPath卷"><a href="#介绍hostPath卷" class="headerlink" title="介绍hostPath卷"></a><span style="color:#00ACC1;">介绍hostPath卷</span></h2><p>hostPath卷指向节点文件系统上的特定文件或目录（请参见图6.4）。在同个节点上运行并在其hostPath卷中使用相同路径的pod可以看到相同的文件。</p>
<blockquote>
<p>图6.4 hostPath卷将工作节点上的文件或目录挂载到容器的文件系统中</p>
</blockquote>
<img src="/2022/10/01/6-卷：将磁盘挂载到容器/4.png">
<p>hostPath卷是我们介绍的第一种类型的持久性存储，因为gitRepo和emptyDir卷的内容都会在pod被删除时被删除，而hostPath卷的内容则不会被删除。如果删除了一个pod，并且下一个pod使用了指向主机上相同路径的hostPath卷，则新pod将会发现上一个pod留下的数据，但前提是必须将其调度到与第一个pod相同的节点上。</p>
<p>如果你正在考虑使用hostPath卷作为存储数据库数据的目录，请重新考虑。因为卷的内容存储在特定节点的文件系统中，所以当数据库pod被重新安排在另-个节点时，会找不到数据。这解释了为什么对常规pod使用hostPath卷不是一个好主意，因为这会使pod对预定规划的节点很敏感。</p>
<h2 id="检查使用hostPath卷的系统pod"><a href="#检查使用hostPath卷的系统pod" class="headerlink" title="检查使用hostPath卷的系统pod"></a><span style="color:#00ACC1;">检查使用hostPath卷的系统pod</span></h2><p>让我们看看如何正确地使用hostPath卷。我们先看一下是否有系统层面的pod已经在使用这种类型的卷，而不是直接创建一个新pod。你可能还记得前面一章中，有几个这样的pod正在kube-system命名空间中运行，再次列出它们：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectlgetpod8--namespacekube-system</span></span><br><span class="line">READY</span><br><span class="line">STATUSRESTARTSAGERunning14d</span><br><span class="line">fluentd-kubia-4ebc2fle-9a3e1/1fluentd-kubia-4ebc2fle-e2vz1/1...</span><br><span class="line">Running</span><br><span class="line">31d</span><br></pre></td></tr></table></figure></p>
<p>选择第一个并查看其使用的卷大小（在下面的代码清单中显示）。</p>
<blockquote>
<p>提示 如果你使用的是Minikube，试试kube-addon-manager-minikubepod.pod使用两个hostPath卷来访问节点的/var/log和/var/lib/docker/containers目录。</p>
</blockquote>
<p>也许你认为在第一次尝试时就找到一个在使用hostPath卷的pod很幸运，但实际上并不是这样（至少在GKE不是）。检查其他文件，将能看到大多数情况下都使用这种类型的卷来访问节点的日志文件、kubeconfig（Kubemetes配置文件）或CA证书。</p>
<p>如果检查其他pod，则会看到其中没有一个使用hostPath卷来存储自己的数据，都是使用这种卷来访问节点的数据。但是，正如我们在本章后面将看到的，hostPath卷通常用于尝试单节点集群中的持久化存储，譬如Minikube创建的集群。继续阅读，我们将了解即使在多节点集群中也应该使用哪些类型的卷来正确地存储持久化数据。</p>
<blockquote>
<p>提示 请记住仅当需要在节点上读取或写入系统文件时才使用hostPath，切勿使用它们来持久化跨pod的数据。</p>
</blockquote>
<h1 id="使用持久化存储"><a href="#使用持久化存储" class="headerlink" title="使用持久化存储"></a><span style="color:#339AFF;">使用持久化存储</span></h1><p>当运行在一个pod中的应用程序需要将数据保存到磁盘.上，并且即使该pod重新调度到另一个节点时也要求具有相同的数据可用。这就不能使用到目前为止我们提到的任何卷类型，由于这些数据需要可以从任何集群节点访问，因此必须将其存储在某种类型的网络存储（NAS）中。</p>
<p>要了解允许保存数据的卷，我们将创建-个运行MongoDB（文件类型NoSQL数据库）的pod。除了测试目的，运行没有卷或非持久卷的数据库pod没有任何意义，所以需要为该pod添加适当类型的卷并将其挂载在MongoDB容器中。</p>
<h2 id="使用GCE持久磁盘作为pod存储卷"><a href="#使用GCE持久磁盘作为pod存储卷" class="headerlink" title="使用GCE持久磁盘作为pod存储卷"></a><span style="color:#00ACC1;">使用GCE持久磁盘作为pod存储卷</span></h2><p>如果是在GoogleKubernetesEngine中运行这些示例，那么由于集群节点是运行在GoogleComputeEngine（GCE）之上，则将使用GCE持久磁盘作为底层存储机制。</p>
<p>在早期版本中，Kubernetes没有自动配置底层存储，必须手动执行此操作。自动配置现在已经可以实现，我们将在本章的后面部分进一步了解。首先，我们需要手动配置存储，这样可以让你有机会了解背后发生了什么。</p>
<p>创建GCE持久磁盘</p>
<p>首先创建GCE持久磁盘。我们需要在同一区域的Kubernetes集群中创建它，如果你不记得是在哪个区域创建了集群，可以通过使用gcloud命令来查看：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">gcloudcontainerclusterslist</span></span><br><span class="line">NAMEZONE</span><br><span class="line">MASTER_VERSIONMASTER_TP</span><br><span class="line">kubiaeurope-west1-b1.2.5</span><br><span class="line">104.155.84.137</span><br></pre></td></tr></table></figure></p>
<p>以上输出说明已经在europe-west1-b区域中创建了集群，因此也需要在同一区域中创建GCE持久磁盘。可以像这样创建磁盘：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">gcloudcomputediskscreate--size=1GiB--zone=europe-west1-bmongodb</span></span><br><span class="line">WARNING:Youhaveselectedadisksizeofunder[200GB].ThismayresultinpoorI/Operformance.Formoreinformation,see:</span><br><span class="line">https://developers.google.com/compute/docs/disks#pdperformance.</span><br><span class="line">Created[https://www.googleapis.com/compute/v1/projects/rapid-pivot-</span><br><span class="line">136513/zones/europe-west1-b/disks/mongodbl.</span><br><span class="line">NAME</span><br><span class="line">ZONE</span><br><span class="line">SIZE_GBTYPE</span><br><span class="line">STATUS</span><br><span class="line">mongodbeurope-west1-b1</span><br><span class="line">pd-standardREADY</span><br></pre></td></tr></table></figure></p>
<p>这个命令创建了一个1GiB容量并命名为mongodb的GCE持久磁盘。可以忽略有关磁盘大小的告警，因为我们无须关心用于测试的磁盘性能。</p>
<p>创建一个使用GCE持久磁盘卷的pod</p>
<p>现在我们已经正确设置了物理存储，可以在MongoDBpod的卷中使用它。着手为pod准备YAML，如下面的代码清单所示。</p>
<blockquote>
<p>提示 如果要使用Minikube，就不能使用GCE持久磁盘，但是可以部署mongodb-pod-hostpath.yaml，这个使用的是hostpath卷而不是GCE持久磁盘。</p>
</blockquote>
<p>pod包含一个容器和一个卷，被之前创建的GCE持久磁盘支持（如图6.5所示）。因为MongoDB就是在/data/db.上存储数据的，所以容器中的卷也要挂载在这个路径上。</p>
<blockquote>
<p>图6.5 带有单个运行Mongodb的容器的pod，该容器挂载引用外部的GCE持久磁盘</p>
</blockquote>
<img src="/2022/10/01/6-卷：将磁盘挂载到容器/5.png">
<p>通过向MongoDB数据库添加文档来将数据写入持久化存储</p>
<p>现在已经创建了pod并且容器也已经启动，我们可以在容器中运行MongoDBshell，从而向数据存储写入一些数据。</p>
<p>如下面的代码清单所示执行shlle命令。</p>
<blockquote>
<p>代码清单6.5 在mongodbpod中执行MongoDBshell</p>
</blockquote>
<p>MongoDB允许存储JSON文档，所以我们将存放一个文档，以查看其是否被持久化存储，并且可以在重新创建pod后检索到。使用以下命令插入一个新的JSON文档：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt;usemystore</span><br><span class="line">switchedtodbmystore</span><br><span class="line">&gt;db.foo.ingert(&#123;name:'foo'&#125;)</span><br><span class="line">"nInserted":1&#125;)WriteResult(&#123;</span><br></pre></td></tr></table></figure></p>
<p>你已经插入了一个简单的JSON文档（name：’foo’），现在，可以通过find（）命令来查看插入的文档：<br><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;db.foo.find()</span><br><span class="line">&#123;<span class="attr">"_id"</span>:ObjectId(<span class="string">"57a61eb9de0cfd512374cc75"</span>),<span class="attr">"name"</span>:<span class="string">"foo"</span>&#125;</span><br></pre></td></tr></table></figure></p>
<p>文档现在已经被存储在GCEPersistentDisk中了。</p>
<p>重新创建pod并验证其可以读取由前一个pod保存的数据</p>
<p>现在可以退出mongodbshell（输入exit并按Enter键），然后删除pod并重建：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectldeletepodmongodb</span></span><br><span class="line">pod"mongodb"deleted</span><br><span class="line"><span class="meta">$</span><span class="bash">kubectlcreate-fmongodb-pod-gcepd.yaml</span></span><br><span class="line">pod"mongodb"created</span><br></pre></td></tr></table></figure></p>
<p>新的pod使用与前一个pod完全相同的GCEPersistentDisk，所以运行在其中的MongoDB容器应该会看到完全相同的数据，即便将pod调度到不同的节点也是一样的。</p>
<p>提示可以通过执行kubectlgetpo-owide来查看pod被调度到哪个节点上。容器启动后，可以再次运行MongoDBshell来检查是否还可以检索之前存储的文档，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单6.6 在新pod中检索MongoDB的持久化数据</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectlexec-itmongodbmongo</span></span><br><span class="line">MongoDBshellversion:3.2.8</span><br><span class="line">connectingto:mongodb://127.0.0.1:27017WelcometotheMongoDBshell.</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">usemystore</span></span><br><span class="line">switchedtodbmystore</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">db.foo.findl)</span></span><br><span class="line">&#123;"_id":Objectld("57a61eb9de0cfd512374cc75"),"name":"foo"&#125;</span><br></pre></td></tr></table></figure>
<p>符合预期，数据仍然存在，即便删除了pod并重建。这证实了可以使用GCE持久磁盘在多个pod实例中持久化数据。</p>
<p>我们完成了MongoDBpod的操作，所以继续清理这个pod，但是不要删除底层的GCE持久磁盘，我们将在本章后面再次用到。</p>
<h2 id="通过底层持久化存储使用其他类型的卷"><a href="#通过底层持久化存储使用其他类型的卷" class="headerlink" title="通过底层持久化存储使用其他类型的卷"></a><span style="color:#00ACC1;">通过底层持久化存储使用其他类型的卷</span></h2><p>因为你的Kubemetes集群运行在GoogleKubemetes引擎上所以需要创建GCEpersistentdisk。当在其他地方运行Kubemetes集群时，应该根据不同的基础设施使用其他类型的卷。</p>
<p>例如，如果你的Kubemetes集群运行在Amazon的AWSEC2上，就可以使用awsElasticBlockStore卷给你的pod提供持久化存储。如果集群在MicrosoftAzure上运行，则可以使用azureFile或者azureDisk卷。我们无法在这里详细介绍如何去实现，实际上与前面的示例是一样的。首先，需要创建实际的底层存储，然后在卷定义中设置适当的属性。</p>
<p>使用AWS弹性块存储卷</p>
<p>例如，要使用AWS弹性块存储（AwsElasticBlockStore）而不是GCE持久磁盘，只需要更改卷定义。如下面的代码清单所示（请参阅以粗体标注的行）。</p>
<blockquote>
<p>代码清单6.7 使用awsElasticBlockStore卷的pod：mongodb-pod-aws.yaml</p>
</blockquote>
<p>使用NFS卷</p>
<p>如果集群是运行在自有的一组服务器上，那么就有大量其他可移植的选项用于在卷内挂载外部存储。例如，要挂载一个简单的NFS共享，只需指定NFS服务器和共享路径，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单6.8 使用NFS的pod：mongodb-pod-nfs.yaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">volumes:</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="string">这个卷受NFS共享</span></span><br><span class="line"><span class="attr">-name:</span><span class="string">mongodb-data</span></span><br><span class="line"><span class="string">支持</span></span><br><span class="line"><span class="attr">nfs:</span></span><br><span class="line"><span class="number">8</span><span class="attr">erver:1.2.3.4</span></span><br><span class="line"><span class="string">NFS服务</span></span><br><span class="line"><span class="attr">path:</span><span class="string">/some/path</span></span><br><span class="line"><span class="string">服务器提供</span></span><br><span class="line"><span class="string">器的IP</span></span><br><span class="line"><span class="string">的路径</span></span><br><span class="line"><span class="string">使用其他存储技术</span></span><br></pre></td></tr></table></figure>
<p>其他的支持选项包括用于挂载ISCSI磁盘资源的iscsi，用于挂载GlusterFS的glusterfs，适用于RADOS块设备的bd，还有flexVolume、cinder、cephfs、flocker、fc（光纤通道）等。rbd如果你不会使用到它们，就不需要知道所有的信息。这里提到是为了展示Kubernetes支持广泛的存储技术，并且可以使用喜欢和习惯的任何存储技术。</p>
<p>要了解每个卷类型设置需要哪些属性的详细信息，可以转到KubernetesAPI引用中的KubernetesAPI定义，或者通过第三章展示的通过kubectlexplain查找信息。如果你已经熟悉了一种特定的存储技术，那么使用explain命令可以让你轻松地了解如何挂载一个适当类型的卷，并在pod中使用它。</p>
<p>但是开发人员需要知道所有信息吗？开发人员在创建pod时，应该处理与基础设施相关的存储细节，还是应该留给集群管理员处理？</p>
<p>通过pod的卷来隐藏真实的底层基础设施，不就是Kubernetes存在的意义吗？举个例子，让研发人员来指定NFS服务器的主机名会是一件感觉很糟糕的事情。而这还不是最糟糕的。<br>将这种涉及基础设施类型的信息塞到一个pod设置中，意味着pod设置与特定的Kubernetes集群有很大耦合度。这就不能在另一个pod中使用相同的设置了。所以使用这样的卷并不是在pod中附加持久化存储的最佳实践。在下一节中，我们将学习如何改进这一点。</p>
<h1 id="从底层存储技术解耦pod"><a href="#从底层存储技术解耦pod" class="headerlink" title="从底层存储技术解耦pod"></a><span style="color:#339AFF;">从底层存储技术解耦pod</span></h1><p>到目前为止，我们探索过的所有持久卷类型都要求pod的开发人员了解集群中可用的真实网络存储的基础结构。例如，要创建支持NFS协议的卷，开发人员必须知道NFS节点所在的实际服务器。这违背了Kubernetes的基本理念，这个理念旨在向应用程序及其开发人员隐藏真实的基础设施，使他们不必担心基础设施的具体状态，并使应用程序可在大量云服务商和数据企业之间进行功能迁移。</p>
<p>理想的情况是，在Kubernetes上部署应用程序的开发人员不需要知道底层使用的是哪种存储技术，同理他们也不需要了解应该使用哪些类型的物理服务器来运行pod，与基础设施相关的交互是集群管理员独有的控制领域。</p>
<p>当开发人员需要一定数量的持久化存储来进行应用时，可以向Kubernetes请求，就像在创建pod时可以请求CPU、内存和其他资源一样。系统管理员可以对集群进行配置让其可以为应用程序提供所需的服务。</p>
<h2 id="介绍持久卷和持久卷声明"><a href="#介绍持久卷和持久卷声明" class="headerlink" title="介绍持久卷和持久卷声明"></a><span style="color:#00ACC1;">介绍持久卷和持久卷声明</span></h2><p>在Kubemetes集群中为了使应用能够正常请求存储资源，同时避免处理基础设施细节，引入了两个新的资源，分别是持久卷和持久卷声明，这名字可能有点误导，因为正如在前面几节中看到的，甚至常规的Kubernetes卷也可以用来存储持久性数据。</p>
<p>在pod中使用PersistentVolume（持久卷，简称PV）要比使用常规的pod卷复杂一些，所以让我们通过图6.6来说明持久卷、持久卷声明和真实底层存储是如何相互关联的。</p>
<p>研发人员无须向他们的pod中添加特定技术的卷，而是由集群管理员设置底层存储，然后通过KubernetesAPI服务器创建持久卷并注册。在创建持久卷时，管理员可以指定其大小和所支持的访问模式。</p>
<p>当集群用户需要在其pod中使用持久化存储时，他们首先创建持久卷声明（PersistentVolumeClaim，简称PVC）清单，指定所需要的最低容量要求和访问模式，然后用户将持久卷声明清单提交给KubernetesAPI服务器，Kubernetes将找到可匹配的持久卷并将其绑定到持久卷声明。</p>
<p>持久卷声明可以当作pod中的一个卷来使用，其他用户不能使用相同的持久卷，除非先通过删除持久卷声明绑定来释放。</p>
<blockquote>
<p>图6.6 持久卷由集群管理员提供，并被pod通过持久卷声明来消费</p>
</blockquote>
<img src="/2022/10/01/6-卷：将磁盘挂载到容器/6.png">
<h2 id="创建持久卷"><a href="#创建持久卷" class="headerlink" title="创建持久卷"></a><span style="color:#00ACC1;">创建持久卷</span></h2><p>让我们重新讨论MongoDB示例，但与之前操作不同的是，这次不会直接引用在pod中的GCE持久磁盘。相反，你将首先承担集群管理员的角色，并创建一个支持GCE持久磁盘的持久卷。然后，你将承担应用程序研发人员的角色，首先声明持久卷，然后在pod中使用。</p>
<p>在6.4.1节中，我们通过使用GCE持久磁盘来设置物理存储，这次不用再这么操作。你所需要做的就是在Kubernetes中创建持久卷，方法是准备如下所示的代码清单，并将其提交给API服务器。</p>
<blockquote>
<p>代码清单6.9 一个gcePersistentDisk持久卷：mongodb-pv-gcepd.yaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 如果在用Minikube，请用mongodb-pv-hostpath.yaml文件创建PV。</p>
</blockquote>
<p>在创建持久卷时，管理员需要告诉Kubernetes其对应的容量需求，以及它是否可以由单个节点或多个节点同时读取或写入。管理员还需要告诉Kubernetes如何处理PersistentVolume（当持久卷声明的绑定被删除时）。最后，无疑也很重要的事情是，管理员需要指定持久卷支持的实际存储类型、位置和其他属性。如果仔细观察，当直接在pod卷中引用GCE持久磁盘时，最后一部分配置与前面完全相同（在下面的代码清单中再次显示）。</p>
<blockquote>
<p>代码清单6.10 在pod卷中引用GCEPD</p>
</blockquote>
<p>在使用<code>kubectl create</code>命令创建持久卷之后，应该可以声明它了。看看是否列出了所有的持久卷：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectlgetpv</span></span><br><span class="line">NAME</span><br><span class="line">CAPACITY</span><br><span class="line">RECLAIMPOLICY</span><br><span class="line">ACCESSMODES</span><br><span class="line">STATUS</span><br><span class="line">CLAIM</span><br><span class="line">mongodb-pv</span><br><span class="line">1Gi</span><br><span class="line">Retain</span><br><span class="line">RWO,ROX</span><br><span class="line">Available</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意 部分省略，同时pv也用作persistentvolume的简写。</p>
</blockquote>
<p>正如预期的那样，持久卷显示为可用，因为你还没创建持久卷声明。</p>
<p>注意持久卷不属于任何命名空间（见图6.7），它跟节点一样是集群层面的资源。</p>
<blockquote>
<p>图6.7 和集群节点-样，持久卷不属于任何命名空间，区别于pod和持久卷声明</p>
</blockquote>
<img src="/2022/10/01/6-卷：将磁盘挂载到容器/7.png">
<h2 id="通过创建持久卷声明来获取持久卷"><a href="#通过创建持久卷声明来获取持久卷" class="headerlink" title="通过创建持久卷声明来获取持久卷"></a><span style="color:#00ACC1;">通过创建持久卷声明来获取持久卷</span></h2><p>假设现在需要部署一个需要持久化存储的pod，将要用到之前创建的持久卷，但是不能直接在pod内使用，需要先声明一个。</p>
<p>声明一个持久卷和创建一个pod是相对独立的过程，因为即使pod被重新调度（切记，重新调度意味着先前的pod被删除并且创建了一个新的pod），我们也希望通过相同的持久卷声明来确保可用。</p>
<p>创建持久卷声明</p>
<p>现在开始创建一个声明。先参考下面的代码清单所示的内容来准备一个持久卷声明清单，并通过kubectlcreate将其发布到KubernetesAPI。</p>
<blockquote>
<p>代码清单6.11 PersistentColumeClaim：mongodb-pvc.yaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>当创建好声明，Kubernetes就会找到适当的持久卷并将其绑定到声明，持久卷的容量必须足够大以满足声明的需求，并且卷的访问模式必须包含声明中指定的访问模式。在该示例中，声明请求1GiB的存储空间和ReadWrite0nce访问模式。之前创建的持久卷符合刚刚声明中的这两个条件，所以它被绑定到对应的声明中。我们可以通过检查声明来查看。</p>
<p>列举持久卷声明</p>
<p>列举出所有的持久卷声明来查看PVC的状态：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectlgetpvcNAME</span></span><br><span class="line">STATUS</span><br><span class="line">VOLUME</span><br><span class="line">CAPACITY1Ci</span><br><span class="line">ACCESSMODESRWO,ROX</span><br><span class="line">AGE</span><br><span class="line">mongodb-pvc</span><br><span class="line">Bound</span><br><span class="line">mongodb-pv</span><br><span class="line">3s</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意 我们使用pvc来代称persistentvolumeclaim。</p>
</blockquote>
<p>PVC状态显示已与持久卷的mongodb-pv绑定。请留意访问模式的简写：</p>
<ul>
<li>RWO-ReadWriteOnce 仅允许单个节点挂载读写。</li>
<li>ROX-ReadOnlyMany 允许多个节点挂载只读。</li>
<li>RWX ReadWriteMany 允许多个节点挂载读写这个卷。</li>
</ul>
<blockquote>
<p>注意 RWO、ROX、RWX涉及可以同时使用卷的工作节点的数量而并非pod的数量。</p>
</blockquote>
<p>列举持久卷</p>
<p>通过使用kubectlget命令，我们还可以看到持久卷现在已经Bound，并且不再是Available。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectlgetpvNAME</span></span><br><span class="line">CAPACITY</span><br><span class="line">ACCESSMODESRWO,ROX</span><br><span class="line">STATUSBound</span><br><span class="line">CLAIM</span><br><span class="line">mongodb-pv</span><br><span class="line">1Gi</span><br><span class="line">default/mongodb-pr</span><br></pre></td></tr></table></figure></p>
<p>持久卷显示被绑定在default/mongodb-pvc的声明上，这个default部分是声明所在的命名空间（在默认命名空间中创建的声明），我们之前有提到过持久卷是集群范围的，因此不能在特定的命名空间中创建，但是持久卷声明又只能在特定的命名空间创建，所以持久卷和持久卷声明只能被同一命名空间内的pod创建使用。</p>
<h2 id="在pod中使用持久卷声明"><a href="#在pod中使用持久卷声明" class="headerlink" title="在pod中使用持久卷声明"></a><span style="color:#00ACC1;">在pod中使用持久卷声明</span></h2><p>持久卷现在已经可用了，除非先释放掉卷，否则没有人可以申明相同的卷。要在pod中使用持久卷，需要在pod的卷中引用持久卷声明名称，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单6.12 使用PVC卷的pod：mongodb-pod-pvc.yaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>继续创建pod，现在检查这个pod是否确实在使用相同的持久卷和底层GCEPD。通过再次运行MongoDBshell，应该可以看到之前存储的数据，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单6.13 在已使用PVC和PV的pod中检索MongoDB的持久化数据</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>符合预期，可以检索之前存储到MongoDB的文档。</p>
<h2 id="了解使用持久卷和持久卷声明的好处"><a href="#了解使用持久卷和持久卷声明的好处" class="headerlink" title="了解使用持久卷和持久卷声明的好处"></a><span style="color:#00ACC1;">了解使用持久卷和持久卷声明的好处</span></h2><p>通过图6.8，展示了pod可以直接使用，或者通过持久卷和持久卷声明，这两种方式使用GCE持久磁盘。</p>
<blockquote>
<p>图6.8 直接使用通过PVC和PV使用GCE持久磁盘</p>
</blockquote>
<img src="/2022/10/01/6-卷：将磁盘挂载到容器/8.png">
<p>考虑如何使用这种间接方法从基础设施获取存储，对于应用程序开发人员（或者集群用户）来说更加简单。是的，这需要额外的步骤来创建持久卷和持久卷声明，但是研发人员不需要关心底层实际使用的存储技术。</p>
<p>此外，现在可以在许多不同的Kubernetes集群上使用相同的pod和持久卷声明清单，因为它们不涉及任何特定依赖于基础设施的内容。声明说：“我需要x存储量，并且我需要能够支持一个客户端同时读取和写入。”然后pod通过其中一个卷的名称来引用声明。</p>
<h2 id="回收持久卷"><a href="#回收持久卷" class="headerlink" title="回收持久卷"></a><span style="color:#00ACC1;">回收持久卷</span></h2><p>在结束关于持久卷的本节前，让我们先做一个快速实验，删除pod和持久卷声明：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectldeletepodmongodb</span></span><br><span class="line">pod"mongodbudeleted</span><br><span class="line"><span class="meta">$</span><span class="bash">kubectldeletepvcmongodb-pvc</span></span><br><span class="line">persistentvolumeclaim"mongodb-pvcudeleted</span><br></pre></td></tr></table></figure></p>
<p>如果再次创建持久卷声明会怎样？它是否会被绑定到持久卷？在创建声明后，kubectlgetpvc命令返回的结果是什么？<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectlgetpvcNAME</span></span><br><span class="line">STATUS</span><br><span class="line">VOLUME</span><br><span class="line">CAPACITY</span><br><span class="line">ACCESSMODES</span><br><span class="line">AGE</span><br><span class="line">mongodb-pvc</span><br><span class="line">Pending</span><br><span class="line">13s</span><br></pre></td></tr></table></figure></p>
<p>这个持久卷声明的状态显示为Pending，有趣。之前创建声明的时候，它立即绑定到了持久卷，那么为什么现在不绑定呢？也许列出持久卷可以看得更清楚一些：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectlgetpv</span></span><br><span class="line">NAME</span><br><span class="line">CAPACITYACCESSMODESSTATUS</span><br><span class="line">CLAIM</span><br><span class="line">REASONAGE</span><br><span class="line">mongodb-pv</span><br><span class="line">1Gi</span><br><span class="line">RWO,ROX</span><br><span class="line">Released</span><br><span class="line">default/mongodb-pvc</span><br><span class="line">5m</span><br></pre></td></tr></table></figure></p>
<p>STATUS列显示持久卷的状态是Released，不像之前那样是Available.原因在于之前已经使用过这个卷，所以它可能包含前一个声明人的数据，如果集群管理员还没来得及清理，那么不应该将这个卷绑定到全新的声明中。除此之外，通过使用相同的持久卷，新的pod可以读取由前一个pod存放的数据，即使声明和pod是在不同的命名空间中创建的（因此有可能属于不同的集群租户）。</p>
<p>手动回收持久卷</p>
<p>通过将persistentVolumeReclaimPolicy设置为Retain从而通知到Kubernetes，我们希望在创建持久卷后将其持久化，让Kubernetes可以在持久卷从持久卷声明中释放后仍然能保留它的卷和数据内容。据我所知，手动回收持久卷并使其恢复可用的唯一方法是删除和重新创建持久卷资源。当这样操作时，你将决定如何处理底层存储中的文件：可以删除这些文件，也可以闲置不用，以便在下一个pod中复用它们。</p>
<p>自动回收持久卷</p>
<p>存在两种其他可行的回收策略：Recycle和Delete。第一种删除卷的内容并使卷可用于再次声明，通过这种方式，持久卷可以被不同的持久卷声明和pod反复伸田，如图6.9所示。</p>
<blockquote>
<p>图6.9 持久卷和持久卷声明的生命周期，以及在pod中的使用</p>
</blockquote>
<img src="/2022/10/01/6-卷：将磁盘挂载到容器/9.png">
<p>而另一边，Delete策略删除底层存储。需要注意当前GCE持久磁盘无法使用Recycle选项。这种类型的持久卷只支持Retain和Delete策略，其他类型的持久磁盘可能支持这些选项，也可能不支持这些选项。因此，在创建自己的持久卷之前，一定要检查卷中所用到的特定底层存储支持什么回收策略。</p>
<p>提示可以在现有的持久卷上更改持久卷回收策略。比如，如果最初将其设置为Delete，则可以轻松地将其更改为Retain，以防止丢失有价值的数据。</p>
<h1 id="持久卷的动态卷配置"><a href="#持久卷的动态卷配置" class="headerlink" title="持久卷的动态卷配置"></a><span style="color:#339AFF;">持久卷的动态卷配置</span></h1><p>如你所见，使用持久卷和持久卷声明可以轻松获得持久化存储资源，无须研发人员处理下面实际使用的存储技术，但这仍然需要一个集群管理员来支持实际的存储。幸运的是，Kubernetes还可以通过动态配置持久卷来自动执行此任务。</p>
<p>集群管理员可以创建一个持久卷配置，并定义一个或多个StorageClass对象，从而让用户选择他们想要的持久卷类型而不仅仅只是创建持久卷。用户可以在其持久卷声明中引用StorageClass，而配置程序在配置持久存储时将采用这一点。</p>
<blockquote>
<p>注意 与持久卷类似，StorageClass资源并非命名空间。</p>
</blockquote>
<p>Kubernetes包括最流行的云服务提供商的置备程序provisioner，所以管理员并不总是需要创建一个置备程序。但是如果Kubernetes部署在本地，则需要配置定制的置备程序。<br>与管理员预先提供一组持久卷不同的是，它们需要定义一个或两个（或多个）StorageClass，并允许系统在每次通过持久卷声明请求时创建一个新的持久卷。最重要的是，不可能耗尽持久卷（很明显，你可以用完存储空间）。</p>
<h2 id="通过StorageClass资源定义可用存储类型"><a href="#通过StorageClass资源定义可用存储类型" class="headerlink" title="通过StorageClass资源定义可用存储类型"></a><span style="color:#00ACC1;">通过StorageClass资源定义可用存储类型</span></h2><p>在用户创建持久卷声明之前，管理员需要创建一个或多个StorageClass资源，然后才能创建新的持久卷。我们来看下面代码清单中的一个例子。</p>
<blockquote>
<p>代码清单6.14 一个StorageClass定义：storageclassfast-gcepd.yaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">apiversion:</span><span class="string">storage.k8s.io/v1</span></span><br><span class="line"><span class="attr">kind:</span><span class="string">storageclass</span></span><br><span class="line"><span class="attr">metadata:</span></span><br><span class="line"><span class="attr">name:</span><span class="string">fast</span></span><br><span class="line"><span class="string">用于配置持久卷的</span></span><br><span class="line"><span class="attr">provisioner:</span><span class="string">kubernetes.io/gce-pd</span></span><br><span class="line"><span class="string">卷插件</span></span><br><span class="line"><span class="attr">parameters:</span></span><br><span class="line"><span class="attr">type:</span><span class="string">pd-ssd</span></span><br><span class="line"><span class="string">传递给parameters</span></span><br><span class="line"><span class="attr">zone:</span><span class="string">europe-west1-b</span></span><br><span class="line"><span class="string">he出</span></span><br><span class="line"><span class="string">zone;europe</span></span><br><span class="line"><span class="string">的参数</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意 如果使用Minikube，请部署文件storageclass-fast-hostpath.yaml.</p>
</blockquote>
<p>StorageClass资源指定当久卷声明请求此StorageClass时应使用哪个置备程序来提供持久卷。StorageClass定义中定义的参数将传递给置备程序，并具体到每个供应器插件。StorageClass使用GCE持久磁盘的预配置器，这意味着当Kubernetes在GCE中运行时可供使用。对于其他云提供商，需要使用其他的置备程序。</p>
<h2 id="请求持久卷声明中的存储类"><a href="#请求持久卷声明中的存储类" class="headerlink" title="请求持久卷声明中的存储类"></a><span style="color:#00ACC1;">请求持久卷声明中的存储类</span></h2><p>创建StorageClass资源后，用户可以在其持久卷声明中按名称引用存储类。创建一个请求特定存储类的PVC定义</p>
<p>可以修改mongodb-pvc以使用动态配置。以下代码清单显示了PVC中更新后的YAML定义。</p>
<blockquote>
<p>代码清单6.15 一个采用动态配置的PVC：mongodbpve-dpyaml</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>除了指定大小和访问模式，持久卷声明现在还会指定要使用的存储类别。在创建声明时，持久卷由fastStorageClass资源中引用的provisioner创建。即使现有手动设置的持久卷与持久卷声明匹配，也可以使用provisionero</p>
<blockquote>
<p>注意 如果在PVC中引用一个不存在的存储类，则PV的配置将失败（在PVC上使用kubectldescribe时，将会看到ProvisioningFailed事件）。</p>
</blockquote>
<p>检查所创建的PVC和动态配置的PV</p>
<p>接着，创建PVC，然后使用<code>kubectl get</code>进行查看：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectlgetpvcmongodb-pvc</span></span><br><span class="line">NAME</span><br><span class="line">STATUS</span><br><span class="line">VOLUME</span><br><span class="line">CAPACITY1Gi</span><br><span class="line">ACCESSMODESRWO</span><br><span class="line">STORAGECLASSfast</span><br><span class="line">mongodb-pvc</span><br><span class="line">Bound</span><br><span class="line">pvc-1e6bc048</span><br></pre></td></tr></table></figure></p>
<p>VOLUME列显示了与此声明绑定的持久卷（实际名称比上面显示的长）。现在可以尝试列出持久卷，看看是否确实自动创建了一个新的PV：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectlgetpv</span></span><br><span class="line">NAME</span><br><span class="line">CAPACITYACCESSMODESRECLAIMPOLICYSTATUS</span><br><span class="line">STORAGECLASS</span><br><span class="line">mongodb-pv</span><br><span class="line">1Gi</span><br><span class="line">RWO,ROX</span><br><span class="line">Retain</span><br><span class="line">Released</span><br><span class="line">pvc-1e6bc048</span><br><span class="line">1Gi</span><br><span class="line">RWO</span><br><span class="line">Delete</span><br><span class="line">Bound</span><br><span class="line">fast</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意 仅显示相关的列。</p>
</blockquote>
<p>可以看到动态配置的持久卷其容量和访问模式是在PVC中所要求的。它的回收策略是Delete，这意味着当PVC被删除时，持久卷也将被删除。除了PV，置备程序还提供了真实的存储空间，fastStorageClass被配置为使用kubernetes.io/gce-pd从而提供了GCE持久磁盘。可以使用以下命令查看磁盘：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">gcloudcomputediskslistNAME</span></span><br><span class="line">ZONE</span><br><span class="line">SIZE_GB</span><br><span class="line">TYPE</span><br><span class="line">STATUSREADYREADYREADYREADYREADY</span><br><span class="line">gke-kubia-dyn-pvc-1e6bc048gke-kubia-default-pool-71dfgke-kubia-default-pool-79cdgke-kubia-default-pool-blc4mongodb</span><br><span class="line">europe-westl-d</span><br><span class="line">1</span><br><span class="line">pd-ssd</span><br><span class="line">europe-westl-d100europe-westl-d</span><br><span class="line">pd-standardpd-standardpd-standardpd-standard</span><br><span class="line">100</span><br><span class="line">europe-westl-d</span><br><span class="line">100</span><br><span class="line">europe-westl-d</span><br><span class="line">1</span><br></pre></td></tr></table></figure></p>
<p>如你所见，第一个持久磁盘的名称表明它是动态配置的，同时它的类型显示为一个SSD，正如在前面创建的存储类中所指定的那样。</p>
<p>了解存储类的使用</p>
<p>集群管理员可以创建具有不同性能或其他特性的多个存储类，然后研发人员再决定对应每一个声明最适合的存储类。</p>
<p>StorageClasses的好处在于，声明是通过名称引用它们的。因此，只要StorageClass名称在所有这些名称中相同，PVC定义便可跨不同集群移植。要自己查看这个可移植性，可以尝试在Minikube上运行相同的示例，假设你一直在使用GKE。作为集群管理员，你必须创建一个不同的存储类（但名称相同）。storageclass-fast-hostpath.yaml文件中定义的存储类是专用于Minikube的。然后，一旦部署了存储类，作为集群用户，就可以像以前一样部署完全相同的PVC清单和完全相同的pod清单。这展示了pod和PVC在不同集群间的移植性。</p>
<h2 id="不指定存储类的动态配置"><a href="#不指定存储类的动态配置" class="headerlink" title="不指定存储类的动态配置"></a><span style="color:#00ACC1;">不指定存储类的动态配置</span></h2><p>正如我们在本章中所做的那样，将持久性存储附加到pod.上变得越来越简单。本章中的章节反映了存储配置是如何从早期的Kubernetes版本发展到现在的。在最后一节中，我们将看看将持久卷附加到pod的最新和最简单的方法。</p>
<p>列出存储类</p>
<p>当你创建名为fast的自定义存储类时，并未检查集群中是否已定义任何现有存储类。现在为什么不这样试试？以下是GKE中可用的存储类：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">.kubectigetcTYPE</span></span><br><span class="line"><span class="meta">$</span><span class="bash">kubectl</span></span><br><span class="line">NAME</span><br><span class="line">tast</span><br><span class="line">kubernetes.io/gce-pd</span><br><span class="line">standard(default)kubernetes.io/gce-pd</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意 我们使用sc作为storageclass的简写。</p>
</blockquote>
<p>除了你自己创建的fast存储类，还存在standard存储类并标记为默认存储类。很快就会知道其含义了，让我们列举Minikube中可用的存储类，以便我们进行比较：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectlgetsC</span></span><br><span class="line">NAME</span><br><span class="line">ast</span><br><span class="line">k8s.io/minikube-hostpathstandard(default)</span><br><span class="line">k8s.io/minikube-hostpath</span><br></pre></td></tr></table></figure></p>
<p>再来看看，fast存储类是由你创建的，并且此处也存在默认的standard存储类，比较两个列表中的TYPE列，你会看到GKE正在使用kubernetes.io/gce-pd置备程序，而Minikube正在使用k8s.io/minikube-hostpath。</p>
<p>检查默认存储类</p>
<p>使用kubectlget可查看有关GKE集群中标准存储类的更多信息，如下面的代码清单所示。</p>
<blockquote>
<p>代码清单6.16 GKE上的标准存储类的定义</p>
</blockquote>
<p>如果仔细观察清单的顶部，会看到存储类定义会包含一个注释，这会使其成为默认的存储类。如果持久卷声明没有明确指出要使用哪个存储类，则默认存储类会用于动态提供持久卷的内容。</p>
<p>创建一个没有指定存储类别的持久卷声明</p>
<p>可以在不指定storageClassName属性的情况下创建PVC，并且（在GoogleKubernetes引擎上）将为你提供一个pd-standard类型的GCE持久磁盘。试试通过下面的代码清单中的YAML来创建一个声明。</p>
<blockquote>
<p>代码清单6.17 不指定存储类别的PVC：mongodb-pvc-dp-nostorageclass.yam</p>
</blockquote>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>此PVC定义仅包含存储大小请求和所需访问模式，并不包含存储级别。在创建PVC时，将使用任何标记为默认的存储类。可以通过如下代码确认：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">kubectlgetpvcmongodb-pvc2NAME</span></span><br><span class="line">STATUS</span><br><span class="line">VOLUME</span><br><span class="line">CAPACITY1Gi</span><br><span class="line">ACCESSMODESRWO</span><br><span class="line">STORAGECLASSstandard</span><br><span class="line">mongodb-pvc2</span><br><span class="line">Bound</span><br><span class="line">pvc-95a5ec12</span><br><span class="line"><span class="meta">$</span><span class="bash">kubectlgetpvpvc-95a5ec12</span></span><br><span class="line">NAME</span><br><span class="line">CAPACITYACCESSMODESRECLAIMPOLICYSTATUSSTORAGECLASS</span><br><span class="line">pvc-95a5ec12</span><br><span class="line">1Gi</span><br><span class="line">RWO</span><br><span class="line">Delete</span><br><span class="line">Bound</span><br><span class="line">standard</span><br><span class="line"><span class="meta">$</span><span class="bash">gcloudcomputediskglistNAME</span></span><br><span class="line">ZONE</span><br><span class="line">SIZEGB</span><br><span class="line">TYPE</span><br><span class="line">STATUSREADY</span><br><span class="line">gke-kubia-dyn-pvc-95a5ec12</span><br><span class="line">europe-westl-d</span><br><span class="line">1</span><br><span class="line">pd-standard</span><br></pre></td></tr></table></figure></p>
<p>强制将持久卷声明绑定到预配置的其中一个持久卷</p>
<p>这最后会告诉我们为什么要在代码清单6.11中将storageClassName设置为一个空字符串（当你想让PVC绑定到你手动配置的PV时）。在这里回顾一下这个PVC定义的相关行：<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">kind:</span><span class="attr">PersistentvolumeClaimspec:</span></span><br></pre></td></tr></table></figure></p>
<p>将空字符串指定为存储类名可确保PVC绑定到预先配置的PV，而不是动态配置新的PV<br>storageClassName:uu。</p>
<p>如果尚未将storageClassName属性设置为空字符串，则尽管已存在适当的预配置持久卷，但动态卷置备程序仍将配置新的持久卷。此时，笔者想演示一个声明如何绑定到手动预先配置的持久卷，同时不希望置备程序干涉。</p>
<blockquote>
<p>提示 如果希望PVC使用预先配置的PV，请将storageClassName显式设置为””。</p>
</blockquote>
<p>了解动态持久卷供应的全貌</p>
<p>这将我们带到本章的最后。总而言之，将持久化存储附加到一个容器的最佳方式是仅创建PVC（如果需要，可以使用明确指定的storgeClassName）和容器（其通过名称引用PVC），其他所有内容都由动态持久卷置备程序处理。</p>
<p>要全面了解获取动态的持久卷所涉及的步骤，请查看图6.10。</p>
<blockquote>
<p>图6.10 持久卷动态配置的完整图示</p>
</blockquote>
<img src="/2022/10/01/6-卷：将磁盘挂载到容器/10.png">
<h1 id="本章小结"><a href="#本章小结" class="headerlink" title="本章小结"></a><span style="color:#339AFF;">本章小结</span></h1><p>本章向你展示了如何使用卷来为pod的容器提供临时或持久存储。你已经学会了如何：</p>
<ul>
<li>创建一个多容器pod，并通过为pod添加一个卷并将其挂载到每个容器中，来让pod中的容器操作相同的文件</li>
<li>使用emptyDir卷存储临时的非持久数据</li>
<li>使用gitRepo卷可以在pod启动时使用Git库的内容轻松填充目录·使用hostPath卷从主机节点访问文件</li>
<li>将外部存储装载到卷中，以便在pod重启之前保持pod数据读写</li>
<li>通过使用持久卷和持久卷声明解耦pod与存储基础架构</li>
<li>当需要将持久卷声明绑定到预配置的持久卷时，防止动态置备程序干扰</li>
</ul>
<p>在下一章中，你将看到Kubernetes提供了什么机制来将配置数据、机密信息，以及有关pod和容器的元数据提供给在pod内运行的进程。这是通过本章中提到的特殊类型的卷完成的，但尚未探索。</p>

      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Kubernetes-in-Action/" rel="tag"># Kubernetes in Action</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/10/01/5-服务：让客户端发现pod并与之通信/" rel="next" title="5-服务：让客户端发现pod并与之通信">
                <i class="fa fa-chevron-left"></i> 5-服务：让客户端发现pod并与之通信
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2022/10/01/7-ConfigMap和Secret：配置应用程序/" rel="prev" title="7-ConfigMap和Secret：配置应用程序">
                7-ConfigMap和Secret：配置应用程序 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>


  </div>


          </div>
          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image" src="/images/avatar.jpg" alt="CheBin">
            
              <p class="site-author-name" itemprop="name">CheBin</p>
              <div class="site-description motion-element" itemprop="description">先得寸再进尺，既得陇复望蜀</div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/archives/">
                
                    <span class="site-state-item-count">1153</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-categories">
                  
                    
                      <a href="/categories/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">29</span>
                    <span class="site-state-item-name">分类</span>
                  </a>
                </div>
              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                      <a href="/tags/">
                    
                  
                    
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">78</span>
                    <span class="site-state-item-name">标签</span>
                  </a>
                </div>
              
            </nav>
          

          

          

          

          

          
          


          
            <div class="links-of-blogroll motion-element links-of-blogroll-block">
              <div class="links-of-blogroll-title">
                <!-- modify icon to fire by szw -->
                <i class="fa fa-history fa-" aria-hidden="true"></i>
                近期文章
              </div>
              <ul class="links-of-blogroll-list">
                
                
                  <li>
                    <a href="/2023/11/22/技术领导力实战笔记/" title="技术领导力实战笔记" target="_blank">技术领导力实战笔记</a>
                  </li>
                
                  <li>
                    <a href="/2023/11/22/技术管理实战36讲/" title="技术管理实战36讲" target="_blank">技术管理实战36讲</a>
                  </li>
                
                  <li>
                    <a href="/2023/11/21/Go面试题（一）/" title="Go面试题（一）" target="_blank">Go面试题（一）</a>
                  </li>
                
                  <li>
                    <a href="/2023/11/10/模拟面试｜NoSQL面试思路一图懂/" title="模拟面试｜NoSQL面试思路一图懂" target="_blank">模拟面试｜NoSQL面试思路一图懂</a>
                  </li>
                
                  <li>
                    <a href="/2023/11/10/42｜MongoDB高性能：怎么优化MongoDB的查询性能？/" title="42｜MongoDB高性能：怎么优化MongoDB的查询性能？" target="_blank">42｜MongoDB高性能：怎么优化MongoDB的查询性能？</a>
                  </li>
                
              </ul>
            </div>
        

          
            
          
          

        </div>
      </div>

      
      <!--noindex-->
        <div class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
            
            
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#介绍卷"><span class="nav-number">1.</span> <span class="nav-text">介绍卷</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#卷的应用示例"><span class="nav-number">1.1.</span> <span class="nav-text">卷的应用示例</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍可用的卷类型"><span class="nav-number">1.2.</span> <span class="nav-text">介绍可用的卷类型</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#通过卷在容器之间共享数据"><span class="nav-number">2.</span> <span class="nav-text">通过卷在容器之间共享数据</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用emptyDir卷"><span class="nav-number">2.1.</span> <span class="nav-text">使用emptyDir卷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#使用Git仓库作为存储卷"><span class="nav-number">2.2.</span> <span class="nav-text">使用Git仓库作为存储卷</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#访问工作节点文件系统上的文件"><span class="nav-number">3.</span> <span class="nav-text">访问工作节点文件系统上的文件</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍hostPath卷"><span class="nav-number">3.1.</span> <span class="nav-text">介绍hostPath卷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#检查使用hostPath卷的系统pod"><span class="nav-number">3.2.</span> <span class="nav-text">检查使用hostPath卷的系统pod</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#使用持久化存储"><span class="nav-number">4.</span> <span class="nav-text">使用持久化存储</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#使用GCE持久磁盘作为pod存储卷"><span class="nav-number">4.1.</span> <span class="nav-text">使用GCE持久磁盘作为pod存储卷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过底层持久化存储使用其他类型的卷"><span class="nav-number">4.2.</span> <span class="nav-text">通过底层持久化存储使用其他类型的卷</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#从底层存储技术解耦pod"><span class="nav-number">5.</span> <span class="nav-text">从底层存储技术解耦pod</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#介绍持久卷和持久卷声明"><span class="nav-number">5.1.</span> <span class="nav-text">介绍持久卷和持久卷声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#创建持久卷"><span class="nav-number">5.2.</span> <span class="nav-text">创建持久卷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#通过创建持久卷声明来获取持久卷"><span class="nav-number">5.3.</span> <span class="nav-text">通过创建持久卷声明来获取持久卷</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#在pod中使用持久卷声明"><span class="nav-number">5.4.</span> <span class="nav-text">在pod中使用持久卷声明</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#了解使用持久卷和持久卷声明的好处"><span class="nav-number">5.5.</span> <span class="nav-text">了解使用持久卷和持久卷声明的好处</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#回收持久卷"><span class="nav-number">5.6.</span> <span class="nav-text">回收持久卷</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#持久卷的动态卷配置"><span class="nav-number">6.</span> <span class="nav-text">持久卷的动态卷配置</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#通过StorageClass资源定义可用存储类型"><span class="nav-number">6.1.</span> <span class="nav-text">通过StorageClass资源定义可用存储类型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#请求持久卷声明中的存储类"><span class="nav-number">6.2.</span> <span class="nav-text">请求持久卷声明中的存储类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#不指定存储类的动态配置"><span class="nav-number">6.3.</span> <span class="nav-text">不指定存储类的动态配置</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#本章小结"><span class="nav-number">7.</span> <span class="nav-text">本章小结</span></a></li></ol></div>
            

          </div>
        </div>
      <!--/noindex-->
      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 – <span itemprop="copyrightYear">2023</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">CheBin</span>

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-area-chart"></i>
    </span>
    
      <span class="post-meta-item-text">站点总字数：</span>
    
    <span title="站点总字数">9m</span>
  

  
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    
      <span class="post-meta-item-text">站点阅读时长 &asymp;</span>
    
    <span title="站点阅读时长">136:18</span>
  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Pisces</a></div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
          <span id="scrollpercent"><span>0</span>%</span>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/js/src/utils.js?v=7.0.1"></script>

  <script src="/js/src/motion.js?v=7.0.1"></script>



  
  


  <script src="/js/src/affix.js?v=7.0.1"></script>

  <script src="/js/src/schemes/pisces.js?v=7.0.1"></script>



  
  <script src="/js/src/scrollspy.js?v=7.0.1"></script>
<script src="/js/src/post-details.js?v=7.0.1"></script>



  


  <script src="/js/src/next-boot.js?v=7.0.1"></script>


  

  

  

  


  


  
  <script>
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url).replace(/\/{2,}/g, '/');
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x"></i></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x"></i></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  
  

  
  

  


  

  

  

  

  

  

  

  

  
<script>
  $('.highlight').each(function(i, e) {
    var $wrap = $('<div>').addClass('highlight-wrap');
    $(e).after($wrap);
    $wrap.append($('<button>').addClass('copy-btn').append('复制').on('click', function(e) {
      var code = $(this).parent().find('.code').find('.line').map(function(i, e) {
        return $(e).text();
      }).toArray().join('\n');
      var ta = document.createElement('textarea');
      var yPosition = window.pageYOffset || document.documentElement.scrollTop;
      ta.style.top = yPosition + 'px'; // Prevent page scroll
      ta.style.position = 'absolute';
      ta.style.opacity = '0';
      ta.readOnly = true;
      ta.value = code;
      document.body.appendChild(ta);
      ta.select();
      ta.setSelectionRange(0, code.length);
      ta.readOnly = false;
      var result = document.execCommand('copy');
      
        if (result) $(this).text('复制成功');
        else $(this).text('复制失败');
      
      ta.blur(); // For iOS
      $(this).blur();
    })).on('mouseleave', function(e) {
      var $b = $(this).find('.copy-btn');
      setTimeout(function() {
        $b.text('复制');
      }, 300);
    }).append(e);
  })
</script>


  

  

</body>
</html>

<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[第四章 反转形态]]></title>
    <url>%2F2021%2F01%2F17%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E5%8F%8D%E8%BD%AC%E5%BD%A2%E6%80%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 技术分析师瞪大眼睛盯着价格的涨落，为的是及早发现市场心理变化和趋势变化的警告信号。反转价格形态就是这样的技术线索。在西方技术分析理论中，反转信号包括双重顶和双重底、反转日、头肩形、岛形反转顶和岛形反转底等各种价格形态。 然而，从一定意义上来说，“反转形态”这一术语的用词是不准确的。听到反转形态这个术语，往往使人误以为现有趋势将会突兀地结束，立即反转为新的趋势、实际上，这种情况很少发生。趋势的逆转，一般都是伴随着市场心理的逐渐改变进行的，通常需要经过一个缓慢的、分阶段的演变过程。 确切地说，趋势反转信号的出现，意味着之前的市场趋势可能发生变化，但是市场并不一定就此逆转到相反的方向上，弄清楚这一点，是至关重要的。我们不妨用行驶中的汽车来打个比方。一场上升趋势就相当于一辆以时速30英里前进的汽车。汽车的刹车灯亮了，汽车随后停了下来．刹车灯相当于趋势反转信号，它表明先前的趋势（相当于汽车向前行驶）即将终止。现在，汽车静止不动，那么下一步，司机是打算调头向相反方向行驶呢？还是停在那里不动呢？亦或是继续向前行驶呢？如果没有更多的线索，我们根本无从知晓。 图4.1到图4.3分别显示的是，当同一种顶部反转形态出现后，市场可能会经历的各种不同的变化过程。图4.1情况是，市场从之前的上升趋势先转化为一段横向调整的行情，然后再开始形成方向相反的新趋势。在图4.2中，市场后来重新恢复到原先的上升趋势之中。在图4.3中，市场原先的上升趋势突然掉转为下降趋势。 把反转形态理解成趋势变化形态，才是慎重可取的考虑。在写作本书的过程中，本来我有心采用“趋势变化形态”这个术语，而不采取“反转形态’的说法．但是，为了与其它的技术分析文字协调一致，我还是忍痛割爱，选择了所谓的反转形态。因此请务必留意，当我说“反转形态”的时候．这个术语仅仅意味着之前的趋势将发生变化，但是未必一定会反转。及时判别反转形态的发生，是一项极有实用价值的市场分析技巧。交易的成功，需要两个方面的保证，既要能够正确地把握趋势、追随趋势，也要能够正确地把握趋势即将发生变化的各种可能性。反转形态，便是市场以其特有的方式为我们提供的一种指路牌，牌子上写着：“当心；趋势正在发生变化。”也就是说，市场的心理状态正在发生变化、那么，为了适应这种新的市场环境，我们就应当及时调整自已的交易方式。当反转形态出现时，如何建立新头寸，如何了结旧头寸，存在多种多样的选择。本书从头至尾所讨论的，就是相应的各种应对方法。这里有一条重要原则：仅当反转信号所指的方向与市场的主要趋势方向一致时，我们才可以依据这个反转信号来开立新头寸。举个例子，假定在牛市的发展过程中，出现了一个顶部反转形态。虽然这是一个看跌的信号，却并不能保证卖出做空是有把握的。这是因为，市场当前的主要趋势依然是上升的。无论如何，就这个反转形态的实质意义来说，它构成了了结既有多头头寸的交易信号。如果当前主要趋势为下降趋势，那么，虽然还是这个顶部反转形态，但是它就足以构成卖出做空的凭据了。关于反转形态这一主题，我们将进行详细深入的探讨，因为在蜡烛图技术中，大部分形态均属于反转信号。现在，就让我们把注意力转向蜡烛图反转信号的第一种类型，锤子线和上吊线。 锤子线和上吊线 如图4.4所示的蜡烛图线具有明显特点。它们的下影线较长，而实体较小并且在其全天价格区间里，实体处在接近顶端的位置上。在本图上，我们同时列出了黑白两种蜡烛线。有趣的是，这两条蜡烛线都既可能是看涨的，也可能是看跌的，具体情况要由它们在趋势中所处的位置来决定。在这两种蜡烛线中，不管是哪一个，只要它出现在下降趋势中，那么，它就是下降趋势即将结束的信号。在这种情况下，这种蜡烛线称为锤子线，意思是说“市场正用锤子夯砸底部”。请看图4.5。在日语里，这类蜡烛线原来的名称是“深水竿”。这个词在日文中大体的意思是“试一下水的深浅。” 在图4.4所示的两种蜡烛线中，无论哪一种，如果出现在上冲行情之后，就表明之前的市场运动也许已经结束。显而易见，这类蜡烛线就称为上吊线（如图4.6所示）。上吊线的名字是从它的形状得来的，这类蜡烛线看上去就像吊在绞刑架上双腿晃荡的一个死人。形状相同的蜡烛线，有时是看涨的，有时又是看跌的，看起来或许有些不合常情。但是，如果您熟悉西方技术分析理论中的岛形顶和岛形底，那就不难看出，在这个问题上．东西双方的思路如出一辙。对岛形反转形态来说，既可以是看涨的，也可以是看跌的，取决于它在市场趋势中所处的位置。如果岛形反转形态出现在长期的上升趋势之后，则构成看跌信号；如果岛形反转形态出现在下降趋势之后，则构成看涨信号。我们可以根据三个方面的标准来识别锤子线和上吊线：l、实体处于整个价格区间的上端。而实体本身的颜色是无所谓的。2、下影线的长度至少达到实体高度的2倍。3、在这类蜡烛线中，应当没有上影线，即使有上影线，其长度也是极短的。在看涨的锤子线的情况下，或者在看跌的上吊线的情况下其下影线越长、上影线越短、实体越小，那么，这类蜡烛线就越有意义、虽然锤子线或者上吊线的颜色既可以是白的，也可以是黑的，但是，如果锤子线的实体是红色的，其看涨的意义则更坚挺几分；如果上吊线的实体是白的，其看跌的意义则更疲软一点。如果锤子线的实体是白色的，就意味着在当天的交易过程中，市场起先曾急剧下挫，后来却完全反弹上来，收市在当日的最高价处，或者收市在接近最高价的水平上。这一点本身就具有小小的看涨的味道。如果上吊线的实体是黑色的，就表明当日的收市价格无力向上返回到开市价的水平。这一点或许就有潜在的看跌意味。当上吊线出现时。一定要等待其它看跌信号的证实，这一点特别重要。为什么呢？当中的缘由要从上吊线的形成过程说起。通常，在出现这种蜡烛线之前，市场充满了向上的冲劲。突然，上吊线出现了。在上吊线这一天，市场的开市价就是当日最高价（或者当日的开市价接近最高价）。之后市场一度剧烈下跌，后来再上冲，最后收市于最高价的水平，或者接近最高价的水平。从上吊线的价格演化过程本身看来。未必令人联想到顶部反转形态。然而，这个价格变化过程预示着，一旦市场遭到空方的打压，就会不堪一击，迅速引发市场的向下突破。 次日，如果市场开市在较低的水平，那么，凡是在上吊线当日的开市收市时买进的交易商，现在统统背上了亏损的头寸，被“吊”在上面。综合上述分析，我们就得到了关于上吊线的一条普遍原则；上吊线的实体与上吊线次日的开市价之间向下的缺口越大，那么上吊线就越有可能构成市场的顶部。在上吊线之后，如果市场形成了一条黑色的实体，并且它的收市价低于上吊线的收市价，那么，这也可以看作上吊线成立的一种佐证。图4.7所示的实例颇精采，从中我们可以看到，同样一种蜡烛线既可以是看跌的（如7月3日的上吊线），也可以是看涨的（如7月23日的锤子线）。尽管在这个实例中，上吊线和锤子线的实体都是黑色的，但是它们实体的颜色并没有太大意义。 图4.8是另一个实例，也显示出了这类蜡烛线的双重特性。如图所示，4月中旬有一个看跌的上吊线，它标志着市场先前的上涨行情的终止，而且这轮上涨行情是从4月2日的一条看涨的锤子线开始的。3月中旬。出现了另一个上吊线的变体。虽然这条变体上吊线的下影线也比较长，但未能达到实体高度的2倍。不过，另外两项标准它还是满足的（即它的实体位于当日价格区间的上端。并且它几乎没有上影线）。再往后看，次日的收市价低于这根蜡烛线的收市价，因而构成了它的验证信号。综合起来，尽管这条蜡烛线不是理想的上吊线，但它也是成立的。如图所示，这条蜡烛线确实成功地标志着起步于1个月之前的上涨行情的结束。蜡烛图技术为我们提供了一套图表分析要领，这一点与其它回表分析技术或者其它形态识别技术是一致的。然而，我们应当清楚地了解，这些要领并不是一成不变的定律。前面曾经交代，对上吊线和锤子线形态来说，特定的图形特征能够加强它们的技术意义。但是，正如本图3月中旬的上吊线所示，上吊线下影线的长度并不是非得达到实体高度的2倍不可，才足以构成反转信号。一般说来，在这类形态中，不影线越长，形态就越完美。 在图4.9所示的实例中，出现了一系列的看涨锤子线，我们用从1到4的数字给它们作了记号（锤子线2虽然有一段小小的上影线，但我们还是把它看作一根锤子线）。本例的有趣之处是这张图表于1990年初发出的那个买入信号。在锤子线3和锤子线4上。市场曾经两度向下越过了锤于线2处的7月份的低点，两度创出新的低价位（新低）。然而，熊方没能乘机扩大战果，继续把球控制在己方脚下。他们失了手，球丢了。这两条锤子线（3和4）表明，牛方重新执掌了市场的主动权。锤子线3并不是一条理想的锤子线，因为它的下影线达不到实体高度的2倍。但是，这条蜡烛线确确实实地显示，熊方没有能力维持新低价格水平。紧接着，下一周又是一根锤子蜡烛线，这就再度强调了如下的结论：很可能即将发生底部反转过程。 在图4.10中，锤子线1和3都属于底部形态。锤子线2标志着先前的下降趋势的结束，于是市场趋势从下降转为自向延伸。锤子线4未起作用。这条锤子线就引出了关于锤子线形态分析的一项重要的注意事项（其实，这也是我将讨论的所有其它形态的一个关键点）。只有把价格形态与它之前的价格变化相结合，进行通盘的考虑，才能准确把握价格形态的意义。带着这样的全局观，再来观察一下锤子线4。我们注意到，在这条锤子线的前一天。市场走出了一条极其疲软的蜡烛线。这是一条长长的、黑色的秃头秃脚蜡烛线（全秃蜡烛线，就是说，开市价位于当日最高处，收市价位于当日最低处）。这条蜡烛线清晰地说明，市场具有强劲的向下动力。此外，锤子线4也向下穿透了市场过去在1月24日建立起来的支撑水平。再考虑到前面所分析的看跌因素，那么，当锤子线4出现时，稳妥的做法是，先等一等其它验证信号，看看牛方是否确实已经重新占据了上风，然后见机而作。比如说，如果在锤子线4之后，再出现一根白色的蜡烛线，并且它的收市价高于锤子线4的收市价，那么，后来的这条蜡烛线就可以看作是一个验证信号。 我们也可以采用蜡烛图形式来绘制日内时间单位的图表。在这种情况下，蜡烛线显示的是相应时间段内的最高价、最低价、最初价和最后价（如图4.11所示）。举例来看，如果我们以小时为基本时间单位，那么，每根蜡烛图线将采用相应一小时的最初价和最后价来绘制其实体，而用这一小时的最高价和最低价来绘制上下影线。如果我们仔细地观察这张图表，就会看到，在4月11日的头一个小时，市场形成了一根锤子线。与图 4.10中的锤子线4一样，在这根锤子线处，市场也形成了一个向下的价格跳空。但是与之不同的是，在本锤子线之后，跟随着一根白色的蜡烛线，并且这根白色蜡烛线的收市价高于本锤子线的收市价。这对证实市场底部的形成是很有帮助的。再看4月12日的第二根小时蜡烛线。虽然它的外形同锤子线有相似之处．但它并不是一根真正的锤子蜡烛线。锤子线后于底部反转形态。在锤子线的判别准则中，其中有一条是，在锤子线之前，必定先有一段下降趋势（哪怕是较小规模的下降趋势），这样锤子线才能够逆转这个趋势。这条蜡烛线也不是上吊线，因为上吊线必须出现在一段上升趋势之后。在本图所示的情况下，如果把这根蜡烛线提高到前一根黑色蜡烛线的顶部附近，那么，我们就可以将它判定为上吊线了。 在图4.12中，4月初有一根锤子线，它成功地预示了一轮持续数月的主要下降行情的终结。这根蜡烛线下影线很长（其长度是实体高度的许多倍），实体很小，又没有上影线，于是就成了一条经典的锤线。 图4.13显示的是一例经典的上吊线形态。在上吊线出现的这一天。市场向上跳空开市，并由此创出了新的高价位（新高）。第二天，市场向下跳空，于是凡是在上吊线的开市或收市时买进的新多头，都被高高“吊起” ，处于亏损状态． 在图4.14中我们看到，自2月初开始的上升行情随着两条连续的上吊线的到来而宣告破产。在上吊线出现后，还需要其它看跌信号的验证。这一原则的重要性，在本图例中也得到了体现。在上吊线的看跌验证信号中，有一种情况是，次日的开市价低于上吊线的实体，这是为上吊线求得证实的第一个办法。请注意，当第一根上吊线出现后，次日市场是以较高的价格开市的。但是，在第二根上吊线之后，第二天市场终于开市在这条上吊线的实体之下，于是，市场便掉头下行了。 如图 4.15所示，如果在上吊线之后，是一条具有黑色实体的蜡烛线，并且它的收市价低于上吊线的收市价，那么，这种情况也构成了上吊线的看跌验证信号。这是我们为上吊线求得证实的第二个办法。在本图例中，蜡烛线1、2和3形成了一系列上吊线。在上吊线1和2之后，均没有发生看跌验证信号，这就意味着在这两处，上升趋势依然处在照常发展的状态之下。请注意上吊线3。接踵而来的那条黑色蜡烛线，为这条上吊线提供了看跌验证信号。在上吊线3的次日，虽然市场的开市价几乎没有变化，但是到收市的时候，那些在上吊线的开市或收市时买进的多头，已经统统给“上吊”在亏损状态了（在本例中，在次日这根长长的黑色蜡烛线上，市场的抛售过程激烈到了日热化的程度，以致于凡是在上吊线当日买进的人，不仅仅是那些在开市和收市买进的人，统统被套牢在亏损头寸里）。图4.16所示，是橙汁市场的一个实例。从1989年底到1990年初，在本图上出现了一段触目惊心的上涨行情。请注意这场上升行情是在何处结束的。1990年的第三周是一根上吊线，挡住了上述涨势。本实例充分说明了下面这个要点：反转形态的出现，并不意味着市场必定向相反的方向逆转。这一点，我们在第三章曾经做过研究。准确地说，反转形态的出现，预示着之前的趋势即将发生变化。本图例中的情形，正是上述分析的现实体现。在图示的上吊线反转形态形成后，之前的上升趋势就结束了，市场演变成了新的横向延伸趋势。 在本图例中，7月里出现了另一条上吊线。这一次，市场很快就从上升反转为下降。但是，正如我们前面曾经反复强调的，当遇上顶部反转形态时，我们不应当总是期待这种情景的出现。 在图 4.17中，5月里显示出了一个经典的上吊线形态。从这个蜡烛线的形状来看，其实体极小、没有上影线、下影线很长。次日的黑色实体证实了这根上吊线的可靠性，提示我们，现在是出清多头头寸的时候了（请注意，在本图上，4月初有一个看涨的锤子线）。 吞没形态（抱线形态） 锤子线形态和上吊线形态是由单独的一根蜡烛线构成的。如前面所讨论，它们能够就市场的健康情况发出重要的技术信号。不过，在绝大多数情况下，蜡烛图技术信号都是由数根蜡烛线组合在一起形成的。吞没形态（或者说，抱线形态）是我们将介绍的第一类由数根蜡烛线组成的复合形态。吞没形态属于主要反转形态，是由两根颜色相反的蜡烛线实体所构成的。图4.18显示的是看涨吞没形态（看涨抱线形态）。在本图中，市场本来处于下降趋势之中，但是后来出现了一根坚挺的白色实体，这根白色实体将它前面的那根黑色实体“抱进怀里了”，或者说把它吞没了。这种情形说明市场上买进的压力已经压倒了卖出压力。图4.19是看跌吞没形态（看跌抱线形态）的示意图。在本例中，市场原本正向着更高的价位趋升，但是当前一个白色实体被后一个黑色实体吞没后，就构成了顶部反转的信号。这种情形说明，熊方已经从牛方手中夺走了统治权。 关于吞没形态，我们有三条判别标准：1、 在吞没形态之前，市场必须处在清晰可辨的上升趋势或下降趋势中，哪伯这个趋势只是短期的。2、 吞没形态必须由2条蜡烛线组成。其中第二根蜡烛线的实体必须覆盖第一根蜡烛线的实体（但是不一定需要吞没前者的上下影线）。3 、吞没形态的第二个实体必须与第一个实体的颜色相反。这一条标准有例外的情况，条件是，第一条蜡烛线的实体的必须非常小，小得几乎构成了一根十字线（或者它就是一根十字线）。如此一来，如果在长期的下降趋势之后，一个小小的白色实体为一个巨大的白色实体所吞没，那么也可能构成了底部反转形态。反之，在上升趋势中，如果一个小小的黑色实体为一个巨大的黑色实体所吞没，那么也可能构成了顶部反转形态。在西方的技术分析理论中，与日本蜡烛图吞没形态最近似的形态是反转日形态。西方反转日形态的具体情形是，在上升趋势（或下降趋势）的发展过程中，某一日市场曾经创出了新高（或新低），然而，当日的收市价却低于（或高于）前一日的收市价。您将发现，有的时候，蜡烛图的吞没形态发出的反转信号，按照西方的反转日概念是看不出来的。凭着抱线形态的这一优势，同那些采用传统的反转日概念作为反转信号的同行相比，您就占据了上风。关于这个问题，我们在图4.21、4.22和4.23中还有进一步的探讨。下面列出了一些参考性要素，如果吞没形态具有这样的特征，那么它们构成重要反转信号的可能性将大大地增强：l 在吞没形态中，第一天的实体非常小，而第二天的实体非常大。这种情况可能说明原有趋势的驱动力正在消退，而新趋势的潜在力量正在壮大。2 吞没形态出现在超长期的或非常急剧的市场运动之后。如果存在超长期的上升趋势，则增加了以下这种可能性潜在的买家已经入市买进，持有多头。在这种情况下，市场可能缺少足够的新的多头头寸的供应，无力继续推动市场上升。如果存在非常急剧的市场运动，则市场可能已经朝一个方向走得太远，容易遭受获利平仓头寸的打击。3 在吞没形态中，第二个实体伴有超额的交易量。这种情形可能属于胀爆现象（如何在蜡烛图上进行交易量的配合分析，我们将在第十五章讨论）。4 在吞没形态中，第二天的实体向前吞没的实体不止一个。 如图 4.20所示，5月15日和 5月 22日所在的两个星期组成了一个看涨吞没形态。7月的最后2个星期形成了一个看跌吞没形态。9月份有一个看涨吞没形态。在图示主要上涨行情之前，有一小段抛售行情。它是这段抛售行情的底部。 图 4.21是原油的月蜡烛线图，从中既可以看到看涨吞没形态，也可以发现看跌吞没形态。从1985年末开始，市场走出了一场幅度达20美元的陡直下跌行情。1986年的第3个月和第4个月，先后形成了图示看涨吞没形态的两根蜡烛线。这一形态标志着之前的下降趋势的结束。从这个看涨吞没形态起，发生了一段上涨行情，但是1987年年中的看跌吞没形态给它划上了句号。1988年2月和3月形成的较小的看涨吞没形态，又将从1987年中的看跌吞没形态开始的下降趋势终结了。在这个看涨吞没形态之后，市场从下降趋势转为横向趋势，并持续了5个月之久。1990年2月是一根黑色的蜡烛线，虽然它也将1月的白色蜡烛线的实体覆盖起来了，但是它超出1月实体的幅度还不到8个基本价格变化单位。从这一点来看，这不是一个理想的看跌吞没形态。然而，在进行蜡烛图技术分析的时候，必须包括一定程度的灵活性，这一点与其它图表分析手段相比并没有什么不同。考虑到本形态内在的种种疲软的迹象，将这个形态认定为看跌吞没形态是稳妥的，如果我们仅仅因为8个基本价格变化单位的差距不够大，而排除了它们构成看跌吞没形态的可能性，那么反倒是非常危险的。所有的图表分析技术都不例外，始终为分析者留有发挥主观判断的余地。1987年和1990年的两个看跌吞没形态，充分体现了蜡烛图吞没形态的优越之处，它们发出的反转信号，如果用西方技术分析理论的反转日的标准来判断、是得不到的。根据西方顶部反转日概念的判别准则（在本例中，实际上是反转月的情形），其中第二条图线必须创出当前行情的新高。而在上述两个看跌吞没形态的实例中，第二根黑色蜡烛线并没有为当前行情创出新高。因此，按照美国的西方反转日的标准来衡量，它们就构不成反转形态。然而，按照蜡烛图技术的标准，这两个反转形态则是成立的。 图4.22是另一个很好的实例，从中我们也能体会到，相对于常规的线图分析工具来说，蜡烛图技术可能具有更大的优势。请注意7月7日和8日这两天的价格变化。这里的情况与上例类似，第二天与第一天比较，并没有创出新高，如果我们采用西方传统的反转日概念来衡量，那么这里丝毫没有发生顶部反转的迹向。然而，以蜡烛图技术来分析，这却是一个看跌反转信号，即此时市场确实形成了一个所谓的看跌吞没形态。6月初有两根蜡烛线，蜡烛线1和2，看上去似乎是一个看涨吞没形态。但是，看涨吞没形态属于底部反转信号。这就是说，它们只有出现在下降趋势之后（或者在有的时候，出现在横向交易区间的下边界）才是成立的。在本图例中，虽然6月初出现了这个形似的看涨吞没形态，但是由于它并不处在下降趋势之中，因此，并不具有通常的预测意义。 在图 4.23中，发生了一系列看跌吞没形态。吞没形态1将市场从之前的上升趋势，拖入一段持续了数月的水平交易区间。吞没形态2仅仅为当时的上涨行情带来了短暂的喘息机会。看跌吞没形态3、4、5所发出的反转信号，统统是西方技术分析工具提供不来的（这是因为在这三个反转形态中，它们的第二周均没有创下当前行情的新高，所以三者均不符合反转周的标准）。 乌云盖顶形态（乌云线形态） 下面我们要研究的反转形态是乌云盖顶形态（或者说乌云线形态，如图 4.24所示）。这种形态也是由两根蜡烛线组成的，属于顶部反转形态。它们一般出现在上升趋势之后，在有些情况下也可能出现在水平调整区间的顶部。在这一形态中，第一天是一根坚挺的白色实体；第二天的开市价超过了第一天的最高价（这就是说超过了第一天的上影线的顶端），但是，市场却收市在接近当日的最低价的水平，并且收市价明显地向下扎入到第一天白色实体的内部。第二天的黑色实体向下穿进第一天的白色实体的程度越深，则该形态构成顶部反转过程的可能性就越大。有些日本技术分析师要求，第二天黑色实体的收市价必须向下穿过前一天白色实体的50％。如果黑色实体的收市价没有向下穿过白色蜡烛线的中点，那么，当这类乌云盖须形态发生后，或许我们最好等一等，看看是否还有进一步的看跌验证信号。这种看跌形态背后的道理是很容易理解的。在形态发生之前，市场本来处于上升趋势之中。有一天，出现了一根坚挺的白色蜡烛线。第二天，市场在开市时便向上跳空。到此刻为止，牛方完全掌握着主动权。然而，此后，市场却没有继续上冲！事实上，市场收市在当日的最低价处，或者在最低价附近，并且这个收市价明显地向下扎进了前一天的实体内部。在这种情况下，多头头寸持有者的信心便开始动摇。还有一些人一直在找机会卖出做空，那么现在他们就得到了一个设置止报指令的参考水平——在乌云盖顶形态的第二日形成的新高价格水平。下面列出了一些参考性因素，如果乌云盖顶形态具有这样的特征，则有助于增强其技术分量：1、在乌云盖顶形态中，黑色实体的收市价向下穿入前一个白色实体的程度越深测该形态构成市场顶部的机会越大。如果黑色实体覆盖了前一天的整个白色实体，那就形成了看跌吞没形态。在乌云盖顶形态中，黑色实体仅仅向下覆盖了白色实体的一部分。我们不妨把乌云盖顶形态比作日偏食，在这种情况下，月亮只遮住了太阳的一部分（换句话说，覆盖了部分白色实体）。那么，看跌吞没形态就成了日全食，在这的情况下，月亮遮住了太阳的全部（也就是说，覆盖了整个白色实体）。从这一点上说，作为顶部反转信号，看跌吞没形态比乌云盖顶形态具有更重要的技术意义。如果在乌云盖顶形态之后，或者在看跌吞没形态之后，出现了一根长长的白色实体，而且其收市价超过了这两种形态的最高价，那么这可能预示着新一轮上冲行情的到来。2、乌云盖顶形态发生在一个超长期的上升趋势中，它的第一天是一根坚挺的白色实体，其开市价就是最低价（就是说，是秃脚的），而且其收市价就是最高价（就是说，是秃头的）；它的第二天是一根长长的黑色实体，其开市价位于最高价，而旦收市价位于最低价（这是一个秃头秃脚黑色蜡烛线）。3、在乌云盖顶形态中，如果第二个实体（即黑色的实体）的开市价高于某个重要的阻挡水平，但是市场未能成功地坚守住，那么可能证明牛方已经无力控制市场了。4、如果在第二天开市的时候，市场的交易量非常大，那么这里就可能发生胀爆现象。具体说来，当日开市价创出了新高。而且开市时的成交量极重，可能意味着很多新买家终于下决心入市，踏上了牛市的“船”。随后，市场却发生了抛售行情。那么，很可能用不了太久，这群人数众多的新多头（还有那些早已在上升趋势中坐了轿子的老多头）就会认识到，他们上的这条船原来是“泰坦尼克”号。对期货交易商来说，极高的持仓量也是一种警告信号。 图4.25显示了乌云盖顶形态与看跌吞没形态的区别。1989年6月，有两根蜡烛线组成了一个乌云盖顶形态。前一根具有长长的白色实体，后一根具有长长的黑色实体黑色实体的开市价为当前这轮涨势创出了新高但它的收市价则接近其最低价，并且显著地向下穿入了前一天的白色实体之中。本图例所示为市政债券市场，当这个顶部反转形态出现后，该市场就向下回落了。几个星期后，市场遭到了最后的致命一击，此时出现了一个看跌吞没形态。从本实例可以看到，在乌云盖顶形态中，黑色的实体仅仅覆盖了前一日白色实体的一部分。而在看跌吞没形态中，黑色实体则完全地覆盖了前一日的白色实体。 在图4.26中，可以看到3个乌云盖顶形态。这三个形态每一个都有其它的看跌信号对它们进行了验证。下面我们依次进行单独的研究。1、乌云盖顶形态1。这是理想乌云盖顶形态的一种变体。在这个乌云盖顶形态中，第二天的黑色实体的开市价与前一日的最高价一致，而不是向上超过了它。本形态仅仅足以构成警告信号，但是，我们仍然应当把它视为一项负面因素。另一方面，这个乌云盖顶形态还标志着牛方曾经企图向上突破由2月中旬的最高点形成的阻挡水平，但是这个企图已经遭到了挫败。2、乌云盖顶形态2。在这里，除了这个乌云盖顶形态以外，还有其它的理由说明21美元的价格水平值得我们留神。在技术分析中，有一条基本的定理：原先的支撑水平一旦被突破，则转化为新的阻挡水平。这正是在21美元处发生的情况。请注意，21美元原本是一个支撑水平。但是一旦在3月9日被向下突破后，就转化为阻挡水平了。这一例乌云盖顶形态发生在4月的头两个交易日，在此期间，市场曾有过上冲的尝试，但失败了，由此证明了该阻挡水平的存在（第十一章将要研究支撑水平与阻挡水平角色变换的问题）。3、乌云盖顶形态3。这里也显示了一个市场向上挑战阻挡区的失败过程，该阻挡区是由4月下旬的最高价形成的。在上面这些实例中。疲弱的乌云盖顶形态恰巧都与阻挡水平不谋而合。其实这中间的关系并不简单，它揭示出一个重要的概念，其意义不仅在于一种技术指标与另一种技术指标的相互验证，而且还有更深刻的内容。有关问题是本书第二部分的核心内容。届时我们将研究如何把蜡烛图技术与其它技术分析工具结合起来。 在图4.27中，3月上旬出现了乌云盖顶形态1，它中止了之前为时2个星期的上冲行情。随后，市场展开了1个星期的调整。4月份，又形成了另外两个乌云盖顶形态。鸟云盖顶2显示，之前2天的急剧上升可能已告完成。乌云盖顶形态3发生在4月中旬，这个形态尤其疲弱。为什么这个乌云盖顶形态的结果会如此软弱呢？其中的缘由与本形态形成时市场的心理过程有关。正如过去所指出，乌云盖顶形态之所以具有负面意义，是因为以下基本原理：该形态第二根线的开市价本来已经创出了新高，但是在收币时，市场反而深深地向下穿入了前一个白色实体的内部。那么如果在某个乌云盖顶形态中，第二天的开市价不仅向上突破了前一天的最高价，同时还向上突破了数天之前的、数周之前的、甚而至于数月之前的最高价，然后当日再从这样的新高水平上失守下跌，后果会是什么样的呢？这样的局面将具有极其疲软的内涵。而这正是在本实例中4月里发生的情况。在乌云线形态3中，黑色的蜡烛线本来已经向上触及了至少过去3个月内的最高价格水平。但是，市场无力维持这样的高位，并且在收市时显著地返回到前一日的白色实体之内。在图 4.28中我们看到，自 2月 10日开始，市场一路上扬，但当2月中旬的乌云盖顶形态出现后，这段行情就截然地中止了。 刺进形态（斩回线形态） 在我的许多讲座中，当我介绍完看跌的乌云盖须形态以后，过不了多会儿，就会有听众提问，有没有与乌云盖顶形态相反的形态。是的，有这样的形态，它的名称为刺透形态（或者说，斩回线形态）。乌云盖顶形态属于顶部反转信号。那么，刺透形态作为它的反面形态，当然是底部反转信号（如图 4.29所示）。斩回线形态出现在下跌的市场上，也是由两根蜡烛线组成的。其中第一根蜡烛线具有黑色实体，而第二根蜡烛线则具有长长的白色实体。在白色蜡烛线这一天，市场的开市价曾急剧地下跌至前一个黑色蜡烛线的最低价之下，但是不久市场又将价格推升回来，形成了一根相对较长的白色实体，并且其收市价已经向上超越了前一天的黑色实体的中点。看涨的刺透形态与看涨吞没形态同属一个家族，在看涨吞没形态中，白色实体吞没了前面的那条黑色实体。而在看涨的刺透形态中，白色实体仅仅向上刺入了前一个黑色实体的内部。在刺透形态中，白色实体向上刺入黑色实体的程度越大，那么，该形态构成底部反转信号的可能性就越大．在理想的刺透形态中，白色实体必须向上穿入到前一个黑色实体的中点水平以上。在看涨吞没形态之后，或者在看涨的刺透形态之后，如果跟着出现了一条长长的黑色蜡烛线，并且它的收市价低于上述两种形态的最低点，则说明下降趋势已经卷土重来，新一轮下跌行情开始了。 关于刺透形态背后的心理过程，可以作如下理解：市场本来处于下降趋势中，刺透形态第一天的疲弱的黑色实体加强了这种市场预期。第二天，市场以向下跳空的形式开市。到此刻为止，熊方观察着行情的发展，感觉诸事顺遂。可是后来，到当日收市的时候，市场却涨了回去，结果收市价不仅完全回到了前一天收市价的水平，而且变本加厉地向上大大超越了这个水平。现在，熊方开始对手上的空头头寸忐忑不安起来。有些市场参与者一直在寻找买进的机会，他们据此推断，市场不能够维持这个新低价位，或许这正是入市做多的大好时机。关于刺透形态，也有四项参考性因素，如果刺透形态兼具这些特征，那么它们的技术分量将大为增强。这四项参考因素与乌云盖顶形态的四项参考因素内容相同，而方向相反（参见前一部分的有关内容）。在讲述乌云盖顶的时候，我曾经提到，虽然有些日本交易商更愿意看到黑色实体的收市价向下穿过了前一个白色实体的中点，但是在这一条判别准则上，还是有一定的灵活余地的。然而，在斩回线形态中，却没有任何灵活的余地。在斩回线形态中，白色蜡烛线的实体必须向上推进到黑色蜡烛线实体的中点之上。之所以看涨的刺透形态不如乌云盖顶形态灵活，是因为日本人认为处理底部反转形态必须更加谨慎。他们对形状近似的价格形态做了进一步的区分，将它们分为三种情况，分别称为待入线形态、切入线形态、插入线形态（参见图 4.30到图 4.32）。这三种形态虽然与刺透形态在基本构造上是相似的，但是，正是由于其中的白色实体向上穿入黑色实体的程度达不到黑色实体的中点，它们被看作是看跌的信号。综上所达，上述三类潜在的看跌信号（如图 4.30到图 4.32所示）与看涨的斩回线形态（如图 4.29所示）在图形上统统是一样的。它们之间的区别仅仅在于，其中的白色蜡烛线实体向上穿入黑色蜡烛线实体的程度是不同的。在待入线形态中，白色蜡烛线（其外形通常是比较小的）的收市价位于前一个蜡烛线的最低价下方附近。在切入线形态中，白色蜡烛线（它也应当是较小的白色蜡烛线）的收市价稍稍进入到前一个黑色实体的范围之内。在插入线形态中，白色蜡烛线比上述两个形态的更长一些，其收市价也更多地刺入前一个黑色实体之内，但是没有达到黑色实体中点的水平。本形态同前两个形态相比，稍稍坚挺一些。 在市场形成了上述三类形态的情况下，只要价格再次下跌到其中的白色蜡烛线的最低点以下，交易商就应当明日，卖出的好机会来了（请注意，图 4.32所示的插入线形态如果处在下跌行情中，是看跌的，但是，如果它处在上升行情中倒应该视为看涨信号。另外，在下跌行情中，如果市场在数天之内接连形成了两个插入线形态，那么，这种情况也属于看涨信号）。能不能将图 4.30到 4.32所示的每种形态都牢记于心，并不要紧。您只要记住，在斩回线形态中，白色蜡烛线的实体必须向上推进到黑色蜡烛线实体的中点以上，才能够构成底部反转信号。如图 4.33所示，4月27日，熊方成功地将市场打庄到当前行情的新低水平，形成了一根长长的黑色实体。次日，市场以较低的价位开市，但是后来，这个开市价竟演化为当日的最低价，到收市时，图示波音公司的股票价格已经深深地向上穿进了前一日的黑色实体之内。于是，4月27日和28日的两根蜡烛线构成了一个看涨的刺透形态。 在图 4.34中，在 3月 26日所在的一个星期里，出现了一个经典的斩回线形态。请注意，在其中的白色实体之前，是一根非常疲软的长长的黑色实体。在白色蜡烛线当日，市场开市于当前行情的新低水平。但是，当日的收市价非常坚挺，深深地向上推进到前一个黑色实体的内部。这一事实有力地说明，熊方已经丧失了对市场的控制权。这根白色蜡烛线是一个极其坚挺的交易日。它开市于最低价（也就是说，它是秃脚的），收市于最高价（也就是说，它是秃头的）。请注意，这个坚挺的刺透形态终结了之前的那轮抛售行情。这段抛售行情是由3月19日和20日的看跌吞没形态引发的。 上图例为小麦市场。在3月12日所在的那个星期里，产生了另一个变体的刺透形态。为什么说这个刺透形态是一个变体呢？因为其中的白色实体的开市价仅仅低于前一天的实体，但是没有低于前一天的最低点。尽管如此，由于该白色实体的收市价穿入了前一天黑色实体的5O％以上，本形态还是足以构成一个警告信号，说明先前的下跌行情已经是强弩之末。 图 4.35表明，蜡烛图形态能够帮助分析者对市场的健康状况作出一个快速的诊断。在1990年2月后半个月里，曾经有位经纪商问我对燕麦市场怎么看。实际上，我很少留心燕麦市场。虽然如此，我还是调出了如图 4.35所示的燕麦市场的蜡烛图，然后告诉他，当前的下降趋势可能已经结束了。为什么这么说呢？因为我注意到在2月20日所在的一周里，该市场出现了一个几乎堪称经典的刺透形态。另一方面我还发现，市场在形成上述刺透形态的同时，恰巧对2月上旬的低点进行了成功的试探。这种巧合，增加了市场完成双重底反转过程的机会。 图 4.36显示了一轮长达数年的下降趋势。该下降趋势始于1984年底的看跌吞没形态，终于1987年中的斩回线形态。尽管在这个底部反转信号出现后。市场并没有形成上冲行情，但是这个信号确实预示着卖方压力的消解。从1984年中起，至1987年中为止，这股卖方力量曾经驱使市场下跌不止。在这个刺透形态之后，市场稳定了一年，然后开始上涨。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>日本蜡烛图技术</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九章 持仓量的研判]]></title>
    <url>%2F2021%2F01%2F13%2F%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8C%81%E4%BB%93%E9%87%8F%E7%9A%84%E7%A0%94%E5%88%A4%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>战期货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章 临盘实战]]></title>
    <url>%2F2021%2F01%2F13%2F%E7%AC%AC%E5%85%AB%E7%AB%A0-%E4%B8%B4%E7%9B%98%E5%AE%9E%E6%88%98%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>战期货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章 行情调整的规则]]></title>
    <url>%2F2021%2F01%2F11%2F%E7%AC%AC%E4%B8%83%E7%AB%A0-%E8%A1%8C%E6%83%85%E8%B0%83%E6%95%B4%E7%9A%84%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 把握趋势的最小的代价就是—识别调整。我生来一贫如洗，但决不能死时仍旧贫困潦倒！—索罗斯 调整，即是平常所说的震荡。 行情总是处在趋势中的某个位置，对于趋势的识别犹如一加一等于二这么简单，但是调整会随时发生。 如果我们可以相信趋势，那我们就必须直面调整。 行情的运行因为结构而有了规则，调整当然是含在行情运行里，则必然有规则。 行情性质行情的性质有两个：一是行进；二是调整。 行进 行情方向的主推动浪。涨势的行进就是不断地创新高，跌势的行进就是不断地创新低。 调整 是市场各要素的和谐发展需要，是化解矛盾的必要手段。 如果价格过快的向上行进，明显违背了经济发展的规律，在整体消费水平跟不上的情况下，则只能用回调来化解，如果在回调的过程中，而整体的消费水平有所上升，则回调到一定的位置就会得到支撑。 在前几年的时间里，所有人都知道房价上涨的过快，尤其是在经济比较发达的大城市，房价上涨的速度明显超过了大多数人的可承受能力。但仍有少部分收入较高的仍可承受，所以房价仍在上涨。 直到2011年的下半年，过高的房价让少部分较高收入中的大部分人也难以承受了，这时房价开始滞涨，慢慢转而调整。这其中有政府调控的因素，但究其内因仍是其涨速过快，过高的房价脱离了整体社会经济发展，和人均收入水平的增速差距过大。 但这次房价的调整明显从开始就是以时间换空间的方法，部分地产商以各种名义的促销手法来售房，而并不愿意大幅度向下调价。时至此时半年多过去了，房价仍未下跌太多。或者，在经过一定的时间之后，在社会整体经济环境再度趋好时，或者，在股市走出一波牛市后，房价会重拾涨势。 对于行情来说，调整是指价格逆着大一级的趋势逆向而行。 调整的幅度小则需要的时间长，反之，调整的幅度大可能时间并不需要太长。在同一轮行情中相邻两次的调整，通常会呈现时间与幅度互换的交替情况。 通常所说的调整到位，就是指市场各要素之间的重新又合理和谐。具体就是价格、时间、量能、幅度、相关品种协调度、市场整体背景等重新聚合到某一合理的位置。 调整，即是相对于行进而言的 在第四章“交易的真相”已说明这个真相是指大多数能够稳定盈利的交易者赚钱的真相，他们所共同遵守的法则第一条便是顺势，本章即主要解决这个问题。 势，怎么顺？ 在趋势中，识别调整何时结束。 用这句话就可以把前一章提到的问题解答了。 我们，可以在交易中盈利！ 是因为我们会顺势！会顺势是因为趋势本来很简单。 我们可以凭什么在交易中盈利？ 是因为我们可以识别调整将在什么时候结束，因为调整也有调整的规则，并且这规则已形成定式。 在股市里即有谚语云：选股不如选时。在这里，识别调整何时结束仍然是指时机的选择，更确切地说应该是等待进场时机的出现。 我们将前文中趋势怎样定义在此直接改为：涨势怎样定义和跌势怎样定义。 涨势，这样定义！ 一轮涨势，在其发展过程中必然会有回调，回调结束后，只有两个可能供选择： ①继续上涨，创出新高； ②虽继续上涨，却没能创新高。 如果没有创新高，则仍只有两个可能供选择： ①继续回调（俗称二次调整）； ②调完了，再创出新高。 如果最终没有创新高，则第三条路是转为跌势。 跌势，这样定义！ 一轮跌势，在其发展过程中必然会有反弹，反弹结束后，只有两个可能供选择： ①继续下跌，创出新低； ②虽继续下跌，却没能创新低。 如果没有创新低，则仍只有两个可能供选择： ①继续反弹（俗称二次反弹）； ②弹完了，再创出新低。 如果最终没有创新低，则第三条路是转为涨势。 趋势从起点开始在其发展过程中有三条路①调整（即震荡）；②创新高或创新低；③在不能创新高（或新低）后，就转为了另一个趋势了。 在这三条路框定下，市场根据自身的结构用波浪的形式呈现出来。 在波浪的基础之上，我们发展出一套规则图—结构的规则。在这规则之内，我们又总结出四个路线。在初始模式完成之后，便有了规则的结构点。 我们根据这个结构点建立起进出场规则。 这样一个完整的交易框架就出来了，这个框架的首要问题就是找到关键的结构所在，这个关键的结构会明确地指出： （1）行情现在是处于什么趋势的什么位置？ （2）在这个位置如果我们进场，所能产生的极限风险有多大？ 如果这个最大的风险都属于我们可控的最小风险值之内，则不会引发心态的问题，以保证在即使看错的情况下仍能客观地看待行情。 以上两点，是实际交易中首要解决的问题，进场的位置和风险的控制，解决了这两个问题则毫无疑问顺上了势，剩下的就是顺势的单子能随着趋势走多远的问题了。 行情的运行，一旦触及到结构便会产生规则，这是行情运行的规则，既然有规则相应的就会有破绽。我们理解了这些规则与破绽的相互转化关系，就是为了解决识别在趋势中的震荡，即调整终究会在什么时候结束。这时我们顺着趋势的方向，把单子开在调整结束的时候，这个就是最好的进场时机。 根据规则图—结构的规则的四个路线，我们找出规则中的破绽，然而竟然发现行情的调整也有着特定的路线，于是这个路线就成了调整的定式了，既然成了定式，那么理所当然也就成了规则。我们称其为“调整的规则”或“调整的定式”。 如图1所示，读者朋友一眼看到此图，会不会有些诧异，这个“调整的规则”不是和“结构的规则”一样？ 图1 调整的四种定式 是的，是一样的。一样的市场、一样的行情、一样的结构、一样的参与者，如果整出另一套规则来岂不是找兽医给人治病。 行情的发展会按照这个规则，然而行情的调整仍然会按照这个规则来，在这调整定式的图里，我们把路线二至路线四后面各加了上与下虚线箭头，表示着后续的两种可能性。 可能大多数人还是会对此视而不见。 原因在于尚未能看到结构点和结构的重要性，以及更不了解规则在这些重要的结构处所代表的意义。 请再回顾一下“突破”的概念和性质。 突破—如果代表着性质的变化，即表示突破之后要发动一轮行情，如果真要发动行情就不要再回来了，这是突破的规则。如果又回来了，则代表着质变的破绽，破绽可以理解为潜规则。 调整的规则次级周期逆向运行的结束，就是调整的结束点。 如果5分钟周期的行情是个跌势，则这个跌势的调整肯定是个反弹，而这个反弹对于1分钟周期来说就是个上涨，是1分钟周期级别的涨势，当这个1分钟周期涨势结束之时，就是5分钟周期跌势的反弹结束之时。 作为交易，最佳的时机选择是在1分钟涨势结束后开空单，进场之后， 1分钟也转为跌势了，同时更是处在5分钟的下跌趋势中。这个时间周期适合于日内交易。如图2和图3所示。 图2 股指期货的5分钟周期的跌势 图3 1分钟周期的涨势是5分钟周期的反弹 图2是股指5分钟图表，是个很清晰下跌趋势，从12月23日的周五这天一直跌到28日的周三结束，这段下跌趋势横跨4个交易日，但实际运行时间不足4个交易日。 第一段的反弹是从26日早上开盘后不久开始的，但其反弹的时间不长，在中午收盘前就结束了。而这一段5分钟周期的反弹放到1分钟周期，却是一次涨势（图3）。在这1分钟的涨势结束后便转为了跌势，而同时5分钟周期本身就是个跌势。 这即是5分钟的次级周期1分钟，在1分钟周期逆着5分钟周期上涨结束之时，就是5分钟周期的反弹结束。 把时间周期放到30分钟基本上属于波段性质了。 如果30分钟周期是个涨势，则这个级别的调整是必然小于该周期，（15分钟太靠近不能算是有转换关系的大小周期）那么5分钟周期的下跌就是对30分钟的调整，当5分钟的下跌结束了，就代表着30分钟原本涨势的调整结束了，波段单的最佳进场时当然是在5分钟周期下跌的结束点，而这时开进多单之后， 5分钟这时从跌势转为涨势了，而30分钟级别本身就处于涨势中（图4和图5）。 图4 股指期货的30分钟周期的涨势 图5 5分钟周期的跌势是30分钟周期的回调 图4是股指30分钟周期的上涨趋势，但由于换月和休市关系，该图没能完全显示30分钟的一个完整浪形周期。从2475点到2340点这一段的下跌，是对前面涨势的调整，而这段下跌转到5分种周期看就是规规矩矩的下跌趋势，图5中下跌的浪形也比较完美。在这个5分钟周期下跌趋势结束开多单是最佳的波段进场点，在这之后5分钟和30分钟两个周期同时是处在了上涨趋势中。 与此同时，在图5这样的5分钟下跌趋势中，我们团队研发的智能交易系统，这一款专门针对股指的日内操作会在图中所标示的几个地方给出卖开仓信号。这种信号是基于5分钟的下跌趋势，而在其反弹时跟踪小一级别即1分钟周期的上涨，在1分钟周期涨势结束后给出5分钟级别的卖开仓信号。如图6所示。 图6 在5分钟周期的跌势中跟踪1分钟的上涨结束 调整的顺序5浪式，③浪1式，③浪3式，7浪式。 这个就是规则图的顺序，调整一定是按照这个顺序，渐次推进。并且调整会在这4个方式中，必然地选择一种。 了解调整的顺序，就是为了解决势怎么顺的问题，我们的目的是找到可以量化的调整结束点。 下面用定式一、定式二、定式三三张图表来理解规则图的顺序及含义。在大级别的下跌趋势中出现调整，即反弹。这反弹必然是次级周期—小级别周期的上涨。 如图7所示，在定式一里第一次上涨其模式仍然是完整的5浪式，当其5浪形态完成后，即代表着这个小周期的上涨结束了，之后便又转为跌势了，如果直接创了新低，则价格就说明了跌势仍然在继续。 图7 调整的规则—定式一 如果没有创新低，则可能会是进行第二次反弹。于是又进入了定式二的范围内。 如图8所示，在定式二里第一次反弹结束后并没有创出价格的新低，而选择了第二次反弹，然而在反弹到前高处遇到阻力了，又折而向下，这时如果能直接创出新低，同样是用价格肯定了跌势确实仍然存在。 图8 调整的规则—定式二 如果经过两次反弹后还是没能创新低，那价格很可能会选择向上突破前两次反弹的高点，这样便又进入了定式三的范围里。 如图9所示，在定式三里价格向上突破，在这个小周期内就确认涨势形成了，在这个周期里选择突破开多也是个不错的交易。但后如果行情并没走太远便又折而回落到突破点之后，多单就要处理了。 图9 调整的规则—定式三 这时把空单开进去，则是顺着原本的大趋势，又在小周期内找到明确的止损点了。 我们无论在哪个调整的定式里，只要价格折而向下的时候，就是进场做空的时机，这时的止损就在前面的高点处，而我们预期的是大的下跌趋势仍然存在，则价格很可能会创出新低，至于这波大的跌势能跌到哪里，没有人可以预先知道，作为交易者，只需跟随着趋势的发展以及变化修改相应的对策。 这里没有画出定式四，是因为前面在“规则图-结构的规则”里已经讲明了，路线四只是路线三的变体，所以这里定式四也只是定式三的变体。 这会在视觉感受上有些差异，但本书在形态方面主要从结构入手，而两者的结构是一样的，画出来稍显重复之感。 所以，有兴趣的朋友可以自己在软件里找找看，比较一下。 另外需要说明的是，这两套规则图，都只是一个单方向图，当行情的趋势改变后，或者是我们在分析相反趋势的行情，我们只需把图颠倒过来就可以了。 总结本章在回顾趋势的定义、结构的规则等基础上，展开调整的规则与顺序，主要的目的就是解决：势，怎么顺？ 大行情有大势，小行情有小势，根据个人的性格问题选择的交易周期会有不同，因此在顺势的问题上要明确以下三点: 1、确立周期级别 是做日内、波段、还是大的趋势，这主要取决于个人的性格，有些人偏爱交易的乐趣，可能每天都会有数次交易，则把握小周期图表更重于大级别的趋势。而不爱动的交易者则无须太关注日内小级别的波动。 2、确立突破点 但无论做什么周期的趋势，最关键的是要明确当下这波行情是在什么位置确立的，此时离突破点已有多大距离，以考量风险度与预期收益比划不划算。 3、趋势与交易的关系 →既然知道是涨势，何必再追涨？→既然知道是跌市，何必再杀跌？→追涨杀跌，一般是用在刚突破的时候。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>战期货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六章 行情运行的规则]]></title>
    <url>%2F2021%2F01%2F11%2F%E7%AC%AC%E5%85%AD%E7%AB%A0-%E8%A1%8C%E6%83%85%E8%BF%90%E8%A1%8C%E7%9A%84%E8%A7%84%E5%88%99%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 我们，可以在交易中盈利！我们，凭什么可以在交易中盈利？ 规则，是指约定俗成的，可以是法律明文规定的，也可以是不以白纸黑字出现的潜规则。 行情会呈现规律性的变化，在规律之后规则便会呈现出来，这种规则是指行情在某些具体的位置本应该怎么走，是规定好了的。但市场时常会在表象上让交易者误以为行情要行使规则，但事实却是假象，于是，便有了破绽。 规则与破绽—相生相克，便成了我们判断行情性质的重要因素。 对每个浪的特性重新定位我们接着上一章，波浪是市场的根本结构，行情的发展总是以波浪的形式出现。《市场行为的关键》仅仅只是总结了各个浪的市场背景，对每个浪的定性又太过于宏观。纵览全书其观赏性大于实战性，也可能是因为这个原因导致：事后数浪总是对，而事中却没法应用。 没法应用的原因在于：书中所讲的浪都是已经走完的行情，即使此时你数的100%正确，但行情已经走完了，我们只能做历史回忆，却无法回到历史去交易。 而恰恰这一点是从理论到实战的分水岭。 时差，让我们无法回到过去，但我们可以在当下把行情预期到未来，这才是实战所需要的。 各个浪的特性→在其位，谋其事。 在其位，谋其事，这即是规则！指各个浪需按标号各自运行自己份内的行情。如果交易者认为此时行情要走第3浪，则买进后行情果然是突破第1浪并连续地行进，这就是第3浪的规则。 如果买进后行情未能如预期发展，反而掉头向下。则先前认为的第3浪实际是c浪，因为行情的运行符合了c浪的规则。 打个比方，有两个人一个是老板，另一个是老板的司机，但这俩人在外表上很像，以致于我们一眼看到时可能会把司机误以为老板，就像把c浪误以为是第3浪了。这边在想这个司机可能是老板，于是上去套近乎，刚说上话这时司机打开车门坐上了驾驶位，这样我们立即就能知道刚才的判断是错误的。虽然俩人有着相像的外表，但在什么位置该干什么事是规则，司机就应该坐到驾驶位。我们的判断只是我们的想象，老板与司机各自坐到哪个位置才是真实身份的反映。 c浪与3浪，在刚开始时也是具有相似的外表，但是当行情掉头而行之时，我们就要立即判断出：这不是第3浪，而是c浪。 《市场行为的关键》已经对各个浪的特性做了大量的描述，我们重新来解释一次，基于实战的角度，实盘首要考虑是风险。对各个浪的定性以及规则要义稍做一些补充和简化，以及可能性的对策。 第1浪：定性第1浪，或先定性为回调（或反弹），这取决于第2浪是否成立。 第2浪：对第1浪的修正，之所以称为修正，是因为第2浪的最低点绝不能低于第1浪的起点。如果低过了第1浪的起点，则第1浪原本的定性就被否定了。 第3浪：为主推动波。必须要高于第1浪的顶部，其特性就是连续地行进再行进，速度快幅度大已然成为第3浪的规则。但并不是幅度小于第1浪就不能称之为第3浪，在上升三角形中就有第5浪幅度小于第3浪，第3浪的幅度小于第1浪之说。 第4浪：与第2浪或交替、互换，第4浪在时间上总是相对于第2浪，如果第2浪的调整时间较短，则第4浪的时间很可能会较长；如果第2浪的时间较长则第4浪可能会较短，交替的原则不仅体现在时间，在幅度上也会呈现这种关系，这几乎成了通用标准。 第5浪：既然第4浪可以与第2浪交替，没理由第5浪就不可以与第3浪交替。尤其在商品期货中，在多通空的行情里，第5浪的延长幅度会是第3浪的很多倍。 5浪完成后，自动转为大一级别周期一个浪。 a浪：以第1浪的思路—只有当b浪不高于第5浪时，a浪才成立。 b浪：以第2浪的思路—b浪如果高于了第5浪（第5浪的结束点即是a浪的起点），则跟第2浪低于第1浪的起点一样，把a浪的定性已经否定了。 c浪：以第3浪的思路—c浪在大多数时候都会超过a浪的结束点，但也会有不超过a浪结束点的情况。实战中狙击c浪时，可以同时考虑两种可能:如果确实是c浪，则幅度会与a浪差不多；如果一旦幅度明显地超过了a浪，则有可能原先认为的c浪其实是第3浪。 a-b-c的思路：交易中以第3浪为超预期，以c浪尾为止预期。 下面用两个实例（图1至图4）来看一下当行情出现一个拐点之后，我们如何对行情定性。一个趋势的开始，必然是从另一个趋势结束为分界线。 我们以涨势的开始说起：上涨趋势的第1浪的起点，必然是从下跌趋势结束时开始的。 图1和图2，仅从第一根K线到最后一根K线，这两幅图的格局是一样的。 第1浪：主观上定性第1浪，或先定性为反弹。因为在高点之后价格在下跌，下跌仍有两个可能： 一是跌破了图中的最低点，则说明对高点定性为第1浪是错误的，原先认为的第1浪只是下跌途中的反弹而已； 二是没跌破图中的最低点，再向后走如果向上突破了第1浪，则可能是第3浪，那么第2浪成立，同时说明对高点定性为第1浪是正确的。第2浪是对第1浪的修正，之所以称为修正而不是改变，是因为第2浪的最低点绝不能低于第1浪的起点。 这两个案例都是股指期货一分钟周期，从左上角的第一根K线的最高点一路下跌，直到在某个低点止跌，并出现一轮反弹，而在反弹的高点出现后，作为交易者这时需要判断这个高点的性质，以作为相应的交易对策。 是下跌趋势中的反弹？还是转为涨势的上涨第一波？ 在不考虑其他因素如政策面、基本面等的情况下，交易者仅仅看图表，是绝对不能妄下定论的。至少要把这两种可能性都要考虑到，这才是技术分析的根本。基于这个根本再看“千人千浪”一词原来也不准，1000人应该数出2000个浪才对，而这2000个浪要有两类性质，一为上涨的性质；二为下跌的性质。 而对于这个高点的性质，如果说判断，用“判断”这一词则一定是加入了此图表以外的其他因素，或政策消息面、或整体的市场氛围、或道琼斯指数、或恒生指数等等情况。否则交易者是不能判断的，根据图表只能给出两种可能性。 如何将理论知识应用到实战中作为实战，交易者必须有所选择，多与空的方向只能选择一个。 我们无法回到过去，但我们可以在当下把行情预期到未来。 如果选择做多，首要考虑的是风险，风险就在于这个高点实际情况是跌势中的反弹，而在价格创新低时就确切知道做多是看错了。 如果选择做空，首要考虑的仍然是风险，风险在于高点之后的下跌只是开始涨势的第2浪回调，在后面价格突破高点时就明确了看空是错误的。 风险的考虑在投资中永远是放在第一位的，这一点请不要争论。 在交易者选择之后，便是等待行情的发展了，再以图3和图64两图中的圆圈处为例，如果开仓买入了后面怎么办？如果开仓卖出了，后面又怎么办？见图5。 图5的开仓、止损、持仓、加仓的选择，仅仅针对该图表的技术形态所做的动作，并未考虑图表之外的其他因素。在实战中会有一些其他的辅助信号加入进来，以提高进出场点位的准确性。 还以图3和图4为例，从第1浪的起点开始说起，当第3浪突破第1浪时，则说明对于高点的定性明确了：这个高点是转入涨势的第一波上涨。同时也说明了第2浪的最低点绝不能低于第1浪的起点。 但如果先前认为的第2浪实际跌破了第1浪的起点，则对于高点两种可能性的定性确定了是属于反弹性质的。 这是技术分析在实战中的意义，要同时考虑到后续的行情有两种可能。在用波浪理论进行交易决策时，也符合大多技术分析的思路。 我们要将复杂的问题简单化…… 实战以简单为美。 根据艾略特波浪由“五个主波和三个修正波”构成的基本韵律为基础，我们将其再加以归纳、简化，以更贴近实战为目的。 实战首要解决的是方向、进场点、明确的止损位，当这些问题解决之后，我们将“亏损限于小幅，让利润奔跑”，不再是句口号！ 由此，我们再发展出一套价格运行的路线图，为了后面章节的续写方便，我们将这套路线图命名为“规则图—结构的规则”。 因为行情本身是有规律可循的，有规律就导致必然有规则，我们可以根据行情的规则制订出一套交易的规则。 在行情运行在其规则规定必须做什么的时候，我们果断行动。当行情运行在其规则规定该做什么，但行情却没有按规则运行，这时就产生了破绽，而当破绽出现时，我们仍然可以果断行动。 “规则与破绽”都会在关键的结构处给出明确的信号，如果识别了这个明确的信号，相当于掌握了交易的命门。 行情运行的规则 其初始模式：是5浪式！（5浪代表着一个完整的波段）5浪式，是价格形态的根本，是各种形态演化的基础。 价格运行路线—规则图我们仍以艾略特波浪作为基础，根基的东西不能变，如图6所示。 第1幅图，规则路线一：是完全的照搬，当走完上升5浪之后便步入调整，同时上升5浪完成后自动转为大一级别的1个浪。接着进入第2幅路线图，第2幅图表示的是比第1幅图大了一个周期级别，如果第1幅图表示的是1分钟周期，则第2幅图就表示是5分钟周期，图中特地用了粗细不一样的线条以示区别。我们这里暂时用5分钟与1分钟两个周期表示大小周期的相互关系。 第2幅图，规则路线二：是5分钟周期的上涨第①浪和调整第②浪完成之后，掉头向上走第③浪，当第③浪涨到第①浪的顶点时，遇到阻力回落。能不能突破第①浪是后话，于是转到第3幅图。 第3幅图，规则路线三：表示的是5分钟的第③浪在第①浪顶点遇阻后稍作调整，再向上突破了第①浪的顶点，而这时突破的是两个高点连线，突破后即确立了进入5分钟周期第3浪的主升段，即是大家常常能听到的一个词③浪3。“③浪3”的意思是指大周期处于第3浪，而小一周期级别也处于第3浪，是大小两个周期同时处于第3浪，这就是大小周期共振。 第4幅图，规则路线四：是路线三的变体，细微的区别之处在于第②浪的幅度不同，路线三中第 浪对第0浪的回撤较大，在形态视觉上第②浪的感觉比较明显。 而路线四中第②浪对第①浪的回撤幅度很小，以致于也可以不把它当成第②浪，而是理解成在1分钟上涨5浪完成后开始调整，而这个调整当作第6浪看，随后向上突破第5浪顶点便成了第7浪。7浪式的走法通常以小级别的形式出现在大级别的主推动浪第③浪或第⑤浪中，而使主推动浪成为单边式的延长浪。 路线四在形态上与路线三虽然视觉感受不一样，但是两者的结构是一样的，两者的第①浪、第②浪结构完全一样，第③浪的结构也一样，仅仅是在突破的时候路线三遇到阻力有个较明显的回落动作，而路线四是仅稍做调整便直接突破前高点。 图6，第1幅图是个初始模式，第2幅图表示大一周期的第③浪仍未确立，后2幅图都是仅仅刚进入可以预期的第③浪的途中。 如果后面按照波浪的原理论：则是5分钟周期把第③浪走完，走第④浪、再走第⑤浪、再转为a-b-c的调整。如此这般完成之后便又成为原理论的翻版了。 之所以这里仅仅把图画到第3浪途中，因为后面相对来说就是前面的重复，重要的结构点都在这四幅图中，这里的结构即代表着规则所在。一旦触及到结构处，规则就出现了，既是行情的规则，也是交易的规则。 规则（潜规则）的概念突破：如果代表着性质的变化，即表示突破之后要发动一轮行情，如果真要发动行情就不要再回来了，这是突破的规则。 如果又回来了，则代表着质变的破绽，破绽可以理解为潜规则。 趋势：是唯一可以相信的，并且要坚信的。趋势并不需要判断，趋势在没有走到尽头之前，在所有的震荡结束之后，必须创新高/低。 跳空：主要指商品期货。内盘早盘开盘的跳空幅度必须与外盘的幅度相对应，这是规则。因为同是一样的商品，没理由走势不一样。如果跳空的幅度与外盘晚间的幅度不相匹配，这就是破绽。 行情运行规则的解析规则之路线一（图6中第1幅图） 涨势从最低点开始算，跌势从最高点开始算，行情的开始其初始模式：是5浪式！ 5浪代表着一个完整的波段。5浪式是价格形态的根本，是各种形态演化的基础。 因为绝大多数行情软件的最小默认周期是1分钟，则我们就以1分钟的完整5浪作为行情开始的初始模式，在行情的初始模式里，我们仅观察而不做单，因为只有在初始模式完成之后，结构才会显示出来。 在这个初始模式完成之后，则各个浪的高低点就有了明确的价格，和高低点之间的价差幅度。然后我们就根据这个初始模式在大一级别周期5分钟里开始交易。 当1分钟的初始模式完成后自动转为5分钟周期的1个浪。 在1个浪完成之后，我们交易的是5分钟的第2个浪、或第3个浪、或第4或第5个浪，或第2到第5浪之间的连续浪。 则我们选择交易的周期是5分钟，但我们选择的进场点是在1分钟周期里。这里考量的是大周期的位置，和小周期的浪形属性。这种级别基本是属于日内交易的时间周期。 依此类推，如果我们要在30分钟周期级别做单，则我们就等5分钟周期的初始模式完成之后再作进场的打算。依30分钟的浪形位置，我们在5分钟的周期里找进场点，这时如果想在进场点位把握更加精准，其实已经可以同时把1分钟周期考虑进来，在30分钟周期的适当位置把5分钟和1分钟结合起来效果更佳。30分钟级别的交易大致上已属于波段性的交易。 比30分钟更大一级的周期是日线，依图表做技术分析的交易思路仍然是类推，但日线级别的交易已肯定涉及到隔夜，所以需要考虑的因素绝不仅仅是技术面。 规则之路线二（图6中第2幅图） 在初始模式完整之后，便开始了第2幅图，在时间周期上已经大了一个级别。 这时已经有可以量化的依据进行交易了，因为初始模式完成后就有了两个结构点， 5分钟第0浪的起点和第0浪的结束点，这两个结构点是最初的最低价和最高价。 这第2幅图当做5分钟的周期。 第①浪的内部是1分钟周期的完整5浪结构，第②浪开始用了一条实线和二条虚线，共有3个最低点，这二条虚线的最低点代表着第②浪的最低点可能会比原先预计的最低点可能高一些、也可能低一些，但这不重要，重要的是只要最低点高于第①浪的起点便可以认定为第②浪。 第②浪结束后开始了第③浪，在运行到第①浪的最高点处（这里同样用了一条实线和两条虚线，代表着第③浪在运行至第 浪高点处不一定要完全平齐，可能会高一点儿，也可能会低一点儿） ，遇到了阻力便暂停了上涨的步伐，开始回调。这里的暂停上涨即是行情触及到了重要的结构点位—是第①浪的最高点。 一旦触及到结构，规则便出现了，第③浪能不能有效突破第①浪的最高点，关系到行情的定性问题。 第③浪规则是必须高于第0浪，并且是连续地行进，如果这里在第①浪高点处遇阻回调，而回调的幅度过深以至于跌破了第①浪的起点。则之前所有的定性，都在跌破第①浪最低点时被否定。如图7所示。 图中第③浪在运行至第①浪的最高点处遇阻回落，则这个高，暂时被定性为③浪1，因为它还没有完成完整的第③浪，没完成第③浪规则内的规定动作。所以只能先暂定为③浪1。随后的回调是在调完后重新向上突破、还是调整过深是后话。 图7中这种形态，如果不以此种结构、规则、路线的方式解读，仍然有种大多数人都熟悉的方式，即三角形。这也印证了波浪理论其实与其他形态理论是完全的相互包容关系。如图8所示。 图7 规则之路线二的③浪1式 图8 路线二的另一种解读方式 规则之路线三（图6中第3幅图） 第3幅图，路线三是路线二的后续走势中的一种，它在运行第③浪的过程中，由于在重要的结构处，即第①浪的最高点处，遇到阻力而回调，但回调之后又重新向上突破了结构点位，而形成了③浪3。 突破的概念—-如果突破是行情性质的变化，就代表着要发动一轮行情，则突破后就不要再回来了，这也是质变性突破的规则。 行情性质的改变有两种：一种是由原先的趋势改变为另一个趋势；另一种是原先的横盘状态变为了有趋势状态。 “③浪3”的意思是指大周期处于第3浪，而小一周期级别也处于第3浪，是大小两个周期同时处于第3浪，这就是大小周期共振，这种走势是最具获利潜力的行情。 图9是图8的后续行情，在第②浪结束后向上运行，遇到了第①浪的最高点而回落，稍有回落后便重新向上突破，形成了③浪3。 图9 规则之路线三的③浪3式 图10是规则法与形态法两种方法的综合运用。 图10 波浪的规则与三角形形态相互包容 规则之路线四（图6中第4幅图） 第4幅图，路线四是路线三的变体，而不是路线三的后续走势。 第4幅图和第3幅图的大结构是一样的，最大的区别在于第②浪对第①浪的回撤幅度不同，也正因为是路线四中第②浪的幅度小，相对于第①浪最高点的距离近，所以在行情运行到第①浪最高点处就直接突破了。 虽然其在结构上可以做相同的理解，但毕竟视觉差较大，所以用另一种方式“7浪式”加以重复解读。 打个比方，如果你需要一个数字十，可以用三加七，也可以用四加六，甚至可以跳出加法这个框之外。这个意思即是指用几种算法能得出同一结果即可。道理是相同的，做期货要的是结果，如何分析行情只是一种手段。 在任何投机市场里，也没有所谓道德与良心这一概念，在生活中为人处事除了要遵守法律之外，做事绝不可不择手段。 但做期货没有这一说法，目的只有一个，在法律法规允许的范围之内，可以使用个人所擅长的任何技术手段去获利。 “7浪式”这种理解，可以认为是在1分钟上涨5浪完成后开始调整，而这个调整当做第6浪看，随后向上突破第5浪顶点便成了第7浪，这种7浪式的走法通常以小级别的形式出现在大级别的主推动浪第③浪或第⑤浪中，而使主推动浪成为单边式的延长浪。如图11所示。 图11 规则之路线四的7浪式 同时作为路线三变体的理解见图12。 图12 规则之路线四作为路线三变体的理解 并且，“7浪式”这种形式，从国内的股指期货诞生之后，便频频地出现在股指期货的各个周期级别里，而常常竟是以确立趋势反转的结构出现（在后面的股指期货实战案例中将有介绍）。 图13是股指期货小级别周期图，这是个比1分钟级别更小的秒级K线图，这里没用1分钟而用秒级K线图是为更完整地显示其细节。 图13 规则之路线四的7浪式在股指的小周期 由于A股的独立性较强，所以股指期货不像商品期货受外盘的影响而会产较大跳空。商品期货由于外盘而可以导致开盘跳空的幅度太大，很多时候大行情都在跳空里了。 而股指期货跳空较小，一般来说跳空的幅度都不足以破坏5分钟周期的完整形态，因此股指如产生大行情基本都是在日内解决，所以会在如1分钟这个级别里频频出现这种7浪式的单边行情。 图14是股指期货15分钟周期图（15分钟仅作为30分钟的一种补充周期，当30分钟周期的K线数量稍少，用15分钟周期看会清晰一些），该图在前面以转势的例子出现过。 图14 规则之路线四的7浪式在股指15分钟 它是这整个一节中唯一以下跌的形式出现，图中的最高点之前本来是个涨势，在最高点后向下先是跌了个完整的5浪结构，这个5浪结构虽然在此图上也能清晰看出，但它是属于5分钟周期的完整5浪。随后稍做反弹，便直接突破下跌5浪的最低点。 该图无论是用“7浪式”的思路，还是以“路线三变体”的结构思路去理解都可以，因为结果是一样的。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>战期货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章 市场的根本结构]]></title>
    <url>%2F2021%2F01%2F11%2F%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%B8%82%E5%9C%BA%E7%9A%84%E6%A0%B9%E6%9C%AC%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 了解期货市场真正的运作方式。所有的商品市场都是由一群对于价值看法不同，而对于价格看法相同的人们所创造。 心脏在正常情况下都必须呈现规则的跳动，否则你将死亡。然而脑部大体上必须呈现不规则的活动，否则你将发生癫痫。这显示不规则性（混沌）将导致复杂的系统。 它并不是完全的无秩序。恰好相反，我认为生命与智慧便是基于混沌才可能发生。脑部在设计上如此不稳定，所以最小的影响便可以导致秩序的形成。—伊利亚·普利高津 市场呈波浪式结构艾略特波浪理论这么多年一直饱受争议，然而饱受争议正是证明它的生命力所在。贬损的言论大多是来自于无法使用它的人，无法使用它的人既不了解它是什么，也不了解它的运作方式。 艾略特并非是凭空创造出波浪理论，他也是经过长期的观察，根据市场的历史走势而总结出来的，而这种总结直接的结果是用价格运行轨迹来概括市场的运动方式，是来自于市场又返回到市场。 仅凭这一点，波浪理论已经比任何衍生指标更接近价格运行的步伐了。似乎这样说还是不够准确：应该不是更接近，而是完全同步于价格的市场理论。 因此可以说，波浪理论并不是创造发明，只是总结、归纳，并不像互联网，是由柏纳斯在30多年前发明创造的产物。似乎可以再大胆的想象一下，如果没有艾略特，或许波浪理论会被其他人所冠名。 波浪的基本韵律我们在这里直接把艾略特的研究成果拿来用了，因为它的确可以反映市场周而复始的运行行为。 价格的运行轨迹是由“五个主波和三个修正波”构成，这即是波浪理论的基本韵律，这种韵律的循环无论在任何周期级别始终保持不变，任何市场、任何品种只要可以保证最低的必要交易量，就可以显示出这个韵律。 如图1所示，这便是波浪理论的基本韵律了。当一个完整的5波完成之后，就自动成为大一级别的第①、第③或第⑤浪了，这5波序列是驱动浪，也可以叫推动浪，然后调整浪以a、b，c方式进行，在完成之后则又自动成为大一级别的第②或第④浪了。第①、第①或第③浪 第④或第④浪 图1波浪理论的基本韵律 在这之前我又专门再看了《市场行为的关键》一书，此书堪称为波浪理论的经典之作。但书中对各个浪的特性所描述太为宏观，理论虽好但书中并没有实战的案例，这需要我们在实战中以更贴近市场的实际因素加以深入。“千人千浪”一说，一般是一个人在说另一人使用波浪理论的不屑之语，殊不知，千人千浪这种说法，和三角形收敛到末端必然选择一个方向突破一样，这正是技术分析的普遍要义，作为技术分析交易者在数浪时至少要数出两个方向相反的可能性，如果只能看到一种可能，则必然是一个看不到风险的交易者。 波浪理论和其他技术理论都属于技术分析范畴，只是方法不同，没有谁更好谁更差之分，也并没有任何一种技术分析方法对使用者的盈利情况负有责任。如果真能出现千人一浪的局面，则意味着交易将找不对手了，市场也就无法继续存在下去。 做期货使用技术分析犹如下象棋，水平的高低在于弈棋者能比对手多看到几步棋。 引个均线的例子: “均线之上做多，均线之下做空”这句话似乎可以得到所有人的共识，说法也是对的，但结果如何?在均线之上做多、和在均线之下做空的交易者，亏损的仍然是多数，这个结果谁也无法改变。 关于依均线定多空的说法应该可以再完整一些:多均线向上呈多头发散，代表着现在是涨势，可以追涨或找低点做多，并设好止损，反之亦然。 经过改造的波浪理论 事实上，实际的市场早已把教科书的理论加以改造，教科书上画的都是比较经典的标准走势，即使不标准也至少是已经过去了的行情。但之前我们说过，市场是由人参与的，所以市场是人心的函数。在某些位置突然来一个利多或利空的消息必然会对当时的价格有所影响，所谓的主力也不可能去按照教科书的描述来运作，如果这样所有人都可以按书上所说来做了。再往深处想一想，如果所有人都能赚到钱，明显又是市场规则所不能允许的。 我们每天所看到的走势，基本上很少能看到规规矩矩标准形态，例如三角形这个形态绝大多数技术分析者都知道，三角形收敛到末端必然会向一个方向突破，这是因为三角形收敛到末端时已经无路可走，只能选择上或下其中一个方向。 但遗憾的是三角形并不是每天都能看到，其他的如头肩、箱体、旗形、圆弧等等，统称形态，但中规中矩的不多。大多数的形态都会变形，变形就是实际的市场对书本理论加以改造。在变形的图上画一条线可能仅仅因为中间的某个K线上影线或下影线稍稍长了一些，而让画线者心存疑虑，疑虑这条线到底以哪个点为准，是以收盘价、最高价、还是最低价? 如图2所示，就是在确定两个高点之后连两条线，一个三角形便显示出来了，但随后的情况可能会让技术分析者有所迷惑:第一次向上突破A线，随后回落在三角形下轨处获支撑，于是不得不重新画一条B线，但突破B线后又回落整理，于是又画了一条C线。最终突破C线后才向上快速地涨了一波，总算是把三角形突破了。 这样变形的例子不胜枚举，而图3就标准多了，但仍然不能做到连线的绝对精准。 图2和图3把品种、价格、周期等全部隐去，这样就是纯粹的技术分析了。 类似的变形并不仅仅体现在三角形这个形态，箱体的上沿或下沿价格对不齐，也时常会让人不能确定到底把线连在哪个价格点上。 以上费了些笔墨，只是为了说明市场是由人参与的，主力资金有时可能就是针对某些位置故意打掉止损，使上影线或下影线超过了预定的位置，同时也可能会因为突发的消息而在短时间内影响价格的变动，从而也就影响了形态的标准。 但诸如此类的情况只能在短时间内影响局部，而大的结构不会遭到破坏，三角形还是三角形、5浪的结构还是5浪结构。 我们使用技术分析也是从结构入手，变形的形态并未改变形态的结构属性，而艾略特波浪就是市场的根本结构（这句话可能又会引来争议），作为技术分析，波浪理论作为众多技术分种的一种，是完全依附于价格形态来解释市场本身。 知道牛顿就知道“万有引力” ，牛顿是个比较爱钻牛角尖的人，也正因为如此，他在天文、物理、数学等方面都有很高的造诣。有一天树上掉下个苹果砸到他头上，就让他琢磨出万有引力了，但万有引力是从哪里来的?结果牛顿这下钻到牛角尖里出不来了，不知道是不是因为这个，最后到晚年的时候去研究神学了。可是在100年后的马克思就不像牛顿那么钻牛角尖了，一句“客观规律” ，就解释了万有引力是哪里来的了。 那什么是客观规律呢?万有引力就是客观規律啊。凡事想的开，竟然成就了“马克思主义”是放之四海而皆准的真理了。 再如果说，当时牛顿没有正好在苹果树下，那是不是就没有万有引力了呢，实际情况是万有引力仍然是客观存在的，只不过是让这个爱钻牛角尖的牛顿发现了。 那如果没有艾略特，是不是就没有波浪了呢?答案显然也是否定的，波浪仍然是客观存在的。再比如百分比回撒的比率，所有人都在用，只因江思最早用书面的形式加以总结、归纳，因此命名为江恩百分比线。如果没有江恩，是否百分比线就不存在了呢，答案仍然是否定的。 所以说，爱钻牛角尖是好事，但太钻牛角尖就不好了，许多事情还是要中庸、辩证地看待。 波浪理论与技术形态 波浪理论就是形态理论，波浪中有形态、形态中含有波浪，完全地相互包容关系。 两者无论是放在一起还是独立来看，都是由价格的运动形成的，而重点都是在结构上入手，是用价格形成的结构形态反过来解释价格本身，是100%原版语言，既不夸大事实也不会有一丝一毫隐瞒真相。 波浪理论与技术指标 都属于技术分析的范畴，但波浪解释价格本身是原版语言，而所有常用的技术指标都是从价格翻译过来的，充当的只是个翻译的作用。我们在看盘时，上方看的是K线图或分时图（成交量不是技术指标，成交量只反映成交的数量，代表的是交投活跃度） ;下方看的是诸如RSI， KDJ之类的技术指标。 交易者犹如在听两种语言，上方是在用原版语言说话，下方的翻译即时翻译着，但翻译的准确度有多高并不知道。简单地评价一下翻译就知道，大多的指标都有上下各有100这个数值的限定，当价格连续上涨而指标到达100时就不再翻译了。而K线仍然在对交易者说话， 这时仍能听懂原版语言的交易者，其优势也就显示出来了。 当然，技术指标既然存在，也必然有其存在的必要性。大多的技术指标都有金叉、死叉，指示背离这一功能，其作用更应该是提示技术分析者不要去干什么，而不是指示交易者要干什么。 当RSI、 KDJ在低位背离向上金叉时，其作用更应该是提示不要杀跌，或空单注意回避风险，而不是提示去抄底，如果确实可以在低位买进，则这个做多买进的提示不应该由技术指标来充当主角。 波浪的一个必然规律 波浪理论作为技术分析，其结构在呈现5浪之后，必然会有调整!即上涨5浪之后，必然会有调整，下跌亦然（这句话似乎有点儿多余，但客观规律从推论到求证的过程，其表现形式就是以“因为一加一等于二，所以二减一等于一”这个方式来表达） ，并且这个”5浪之后必然调整”的规律并不在意K线图表周期级别。在交易中我们要注意这个必然的调整，如果我们看涨，但很明显此时是处在第5浪的尾部，我们不等它走完5浪再调整完就进场了，买进后很快开始调整了。 这时会有三个可能的情况:一是调整结束后确实继续上涨，那么就持有不动;二是调整在没结束时突然有个利空的消息，结果是调整变成了下跌;三是我们本身对于看涨的思路是错的，我们所看的上涨原本只是反弹。但不管我们看对或是看错，如果我们以一定等调整完了再进场的思路等待着，之后如果行情如预期，确实调完了，那我们进场买进。 之后如果行情未如预期，则我们在等调整结束的信号其实是不会出现的。结果是:没出现调整结束的信号，即使原先是看错了，但我们实际没有买 这就应验了一句话叫做:看对看错不重要，重要的是做对!在这里我们的做对，就是指没出现信号之前仅仅等待，而不出手。 特别强调这一个点，是为了在交易系统里，在不做单的规则中加入一条：5浪尾不做单，即使对后续大趋势的运行有把握，但当下如果处于小级别的第5浪尾部，也不开仓，等它调整完了再进场，这对短线尤其重要！即使不做短线，那么好的进场点也是衡量一个交易者专业操作水平的重要因素。 技术分析的局限性 执于一念，将受制于一念。“术是表，道才是本”。 作为技术分析，都有其局限性，波浪理论也不例外。形态让步1服从于幅度，幅度代表是价格，价格具有一票决定权和一票否定权。 任何人也不可能数清所有的波浪，细节上的不完美是市场的常态，不可计较太多，交易的始终是价格。 波浪理论也有个致命的误区，它主观地认定了和谐结构在事物运动变化模式上的唯一性。 技术只是一种工具，价格才是根本，我们用技术去获取信号，但交易的仍是价格，成交的是一个固定的价格。 收盘后看看账户盈亏就明白，交易者无论用哪一种技术手段去做交易，但实际的盈亏仅以差价来计算。账户里的资金也并不知道交易者用的是哪种交易模式，所以无论用哪种方法去分析行情，即使所有的技术和指标都说明要涨，但价格一旦低于了买入成交价时，则所有的看涨技术信号都改变不了账面处于浮亏的事实。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>战期货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章 交易的真相]]></title>
    <url>%2F2021%2F01%2F11%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%BA%A4%E6%98%93%E7%9A%84%E7%9C%9F%E7%9B%B8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 人类决不可放弃对真理的追求，但必须谨防以为总能拥有真理的幻觉。—卡尔·波普尔 真相，相对于谎言。我们一眼能看到的事物，仅仅只是表象，在能看到的表象中有多少是谎言，又有多少是真相。你是看到你所相信的，还是相信你所看到的？这需要做出选择，事实上无论你做出何种选择，都是因为你的信念。 而信念，不是一个口号，并不是靠说的，是靠做的。当你选择了一条正确的方向，并用信念支持着自己的行动，最终将会越来越接近成功。 本章的标题是交易的真相，其实真正要表达的意思是赚钱的真相，这个真相是在这个市场里大多数盈利者所共同遵守的法则。 真相一：顺势 日常的交易其实很简单，并不需要太多的背景，只要你有足够参与最小单位的交易资金就可以了，这只是一桩小生意，就像做零售一样，只要把别人需要的商品贩过来做差价就行了。 生意的好坏，只要你知道你所在地段的客户在哪里，需要什么。但这恰恰是最关键的，选择好地段就是选择大势。 对于绝大多数的交易者而言，研究顶部在哪里和研究底部在哪里，根本没有意义，这样的事情绝大多数交易者也没有资格去考虑，你只要及时加入别人做好的趋势，在资金的流动中分一杯羹已经足够了。技术分析在常态的交易中用得最多。K线的变动表面上记录的是资金的流动，实际上是记录我们所观察到交易群体的行为，如果要顺应市场，我们只要选择跟随着主流群体的方向。 顺势是一种选择，进入这个市场做交易，开始都是处于学习阶段，你会看到交易的方法有很多种，但你最终要选择一种方法。“顺势而为”这个词将是你听到最多的一个词，于是笔者选择了顺势。然而在交易的过程中发现“顺势”竟然这么难! 于是，有很多人开始怀疑，开始放弃，慢慢地会发现自己看不清趋势了。这是为什么呢？ 选择比努力更重要 选择和努力本身是属于两个不同的范畴。在我们一生中，随时会面临着选择，而每次选择都会或多或少地影响着以后的发展。 这里仅狭义地讲一讲期货这个行业。我们进入了期货这一行业，这已经是一种选择，有些人把期货当成是主业，也有些人是当副业，但选择进入这个行业的人，大多数的最终理想是把期货或投机作为主业，这是行业的选择。 在进入市场之后，会听说也会发现很多赚钱的故事，于是我们又开始选择了学习对象，选择操作的方法，你得根据自己的性格特点，最终确定自己的看盘思路与操作模式。 而这个模式一旦选择好，接下来就是努力的问题了。但如果你的思路没确定好，或没有选择一个正确的方向，你所有的努力只会是事倍功半，虽然很努力，但结果不会太好。 如果你选择了一个正确的并能适合自己的操作模式，并按这个思路去努力，其结果必然是少走几年弯路。 当然，努力并不可少，也没有人能随随便便成功。在成功的路上也不会从头到尾一帆风顺，最终坚持下来的就是“剩者为王”了。 纠正一些错误的说法 可能有的人会说：我逆着涨势摸顶，然后在行情回调中平了空单，我逆势却也赚到钱了。 这有什么好抬杠的吗？这一笔单虽然说逆市摸顶，但这笔单是顺了更小的势，是在大势上涨中的回调，这回调其实就是小的跌势。操作的行情周期不同，所顺的势大小级别不同。 还有人会说：我在震荡势能赚到钱，我在震荡势里抄底摸顶，做震荡就是要逆市，我不做趋势。 其实又说错了。“震荡”如果是箱体的震荡，是指无趋势状态，在30分钟周期级别的箱体震荡，会在30分钟线以下级别：如5分钟周期级别反复地出现涨势、跌势。当这个5分钟级别的涨势走到30分钟周期的箱体上沿遇阻会折而向下，再走出一波5分钟级别的跌势，在跌势走到30分钟周期级别的下沿时，又会遇到支撑再转为5分钟级别的涨势。 而专做这类震荡势的交易者，能盈利是因为顺着了小级别的趋势，但几乎绝大多数会在行情突破箱体上沿或下沿时出现不同程度的亏损，如果不设止损后果可能会很严重。 这是两个比较常见的所谓不顺势的例子，但如果这两类的交易者都能够长期稳定盈利，那么必然是他的交易模式已经固化，经过一定时间的实战检验盈多亏少，有着严格的进出场信号，并且能够把这个交易模式作为信念在交易中严格执行和捍卫!这种交易模式也是一种选择。 信念一旦成型，交易将是稳定的 注意，这里用的是模型的型，而不是形状的形。这两个字读音相同，意思也差不多，但其在根本上是有区别的，这里不做过多解释。关于信念问题我们先来看两个小故事。 1，傻子抱树的故事 从前有个村庄，这个村里的人几乎个个都练武，有一个道行很深的教练教他们武功。这个村庄里有一户人家，这家有个傻孩子。有一天，这个傻孩子的父亲把他带到教练面前希望教练能教傻子一些武功，教练想了半天也不知道该教他什么，突然看到教场边上有一棵大树，于是对傻子说，从今天开始你就每天去抱那棵大树吧，傻子听了非常开心，于是就每天按照教练说的刻苦地抱树，因为他傻所以他对教练说的毫不怀疑，所以就不会偷懒，天天玩命练习抱树，就这样一过几年。有一天来了一帮人踢场子，教练的徒弟们都被打败了，正在教练准备亲自出马的时候，傻子上来说：“师傅让我来试一下。”还没等师傅回答，傻子已经和对方交上了手，只一下就把踢场子的人抱死了，给师傅争了面子。 2，许三多的故事 电视剧《士兵突击》相信大家都看过，许三多也是够笨的，做任何事执拗的像个傻子，刚入部队时，练个立正、稍息能把班副伍六一活活气死。但他的可贵之处就是知道自己笨，所以肯努力，更愿意听从指挥。 从与部队结缘到最终成为兵王，首先是选择了正确的道路，参军适合他执拗的性格。然后在这一路，因为自身的刻苦努力，身边的人都成了他的贵人：史今班长、老马班长、高城连长、王庆瑞团长、袁朗大队长。 这些人之所以成为他的贵人，是因为许三多的坚持并坚信。他坚信上级叫他做的事都是正确的、有意义的。在草原的五班，天天坚持练习正步，最后听了马班长的话一个人修了路，因而被王团长又重新分配到了钢七连。 最具分水岭意义的一件事是因为史班长说的一句话，说只要能做够50个腹部绕杠，高城连长就把先进锦旗挂在他们班上。 为了史班长的关心，也为了这份集体荣誉，许三多去了用拼了命的力气，坚持做了330个腹部绕杠，其实他自己开始并不知道做了多少个，以为50个还没够，直到旁边人说够50个了才停下来，他要坚持做够50个，是因为他坚信史班长说的话。 当做完之后，高城其实心里也有所触动，虽然他当时仍看不上许三多，直到最后钢七连解散了，高城才真正意识到许三多的可贵之处，并借以反省自身，在接到升任副营长命令之际与王团长有一段对话。王庆瑞：看清楚了吧，还有什么话说？高城：这事，跟我父亲有关系吧？ 王庆瑞：我就晓得你要问这个问题。师里边有几个晓得你父亲是军长的。 高城：团里都知道，师里怎么会不知道？我在团里威，营里横，16个连长我老大，跟您都照常顶着干。我一直以为是靠我自己本事挣来的，可实际上，我就像公园里的一只猴子。王庆瑞：你今天怎么想起说这种话来？ 高城：也没怎么的，就是终于有空儿想想了呗。 王庆瑞：想想好啊，那我就告诉你，这件事是和你父亲有关系，哪个军官的调动没有军长签字啊？说没关系是开玩笑，说有关系呢，也就只是那点儿关系，看你怎么想。高城：我服从命令呗。 王庆瑞：哦，你今天有点儿不大对啊。 高城：不是，这两天刚明白个道理。有容乃大，无欲则刚。容是别人，欲是自己，这样的天地才跑得欢敞嘛，尤其合适机动部队。王庆瑞：你是怎么样搞明白的呀？ 高城：其实这个，这个早熟的人吧，通常都晚熟。骄做的人又很性急，这两样我都占了。我认识一个人，就他，他每做一件小事的时候他都像救命稻草一样抓着，有一天我一看，唯，好家伙，他抱着的是已经让我仰望的参天大树了。王庆瑞：你说的是许三多？ 高城：对，这要搁以前，他做什么事我都瞧不上。执拗的像个傻子。可现在这么一看，这个信念这玩意儿真不是说出来的，是做出来的，您还记得他呐？ 王庆瑞：我怎么不记得他呢，当初七连的连长死活都不要人家。高城：那都是过去的事了。王叔。王庆瑞：嗯？ 高城：我，我有个要求。王庆瑞：讲。 高城：我想带几个兵去装甲侦察营。王庆瑞：许三多？高城：对。 王庆瑞：不可能。高城：那么我，我带伍六一吧。王庆瑞：更不可能。你走我已经蛮后悔了，特别是通过这次谈话!还有什么事？高城：那就没了。王庆瑞：那你走吧，高城？高城：哎？王庆瑞：三年的军校，一年得排长，三年的连长，我希望你不要辜负这7年。高城：如果我再走了，这七连就剩下许三多一个人了。王庆瑞：这不是你操心的事。上面这两个故事有几个关键词：相信、坚信、坚持、信念。相信值得你相信的人或事，并坚信这是正确的，形成信念，然后无论在什么情况下都要坚持自己的信念。 信念：是自己认为可以确信的看法。 信仰：是对某种主张、主义、宗教或某人极其相信和尊敬。 信念和信仰既有共同性，又有差异性，两者在一定条件下相互作用。在结构要素、主要功能、个性倾向性方面有共同之处;在意识对象、理性水平和感情体验等方面又相互区别。 信仰在信念的基础上升华，信念在信仰支配下发展，其发生联系的桥梁是主体的自我意识。 让顺势成为信念 绝对的敬畏，用信仰支配信念的发展。科学需要证明，信仰并不需要。信仰有三层含义：一是相信、信任;二是敬爱、畏惧;三是仰仗、依靠。信仰是内心的体悟、灵魂的响应。已归属于情感，无需证明必须坚信，信佛的人一定是有信仰的。 在期货市场，我们的投机信仰就是什么是该做的，和什么是不该做的，一定要规定好。 但是，能不能坚持下来，就一定涉及“信念”这个问题，这其中包含着信心的意思。在期货市场中稳定盈利的交易者，绝大多数是顺势而为，因此顺势理当成为我们的信念。 其实，可以简单地想一想，任何人所做的交易中能赚钱的单一定是顺势的。你只有买在低位，卖在高位，只有卖的价格比买的价格高才能盈利，这是盈亏的绝对法则。 依趋势进行交易就一定要顺势，不管你是做多大周期的趋势。止损设好了，就要无其他附带条件的执行。信仰的规定已经具体化了，不是什么虚无、漂渺、不着实际的理想了。 真相二：控制亏损 会不会控制亏损，是输家和赢家的分野! 首先在观念上需正确认识亏损—亏损是交易的一部分。 没有任何一个人在其所有的交易中绝对没有一笔亏损的单子，索罗斯不行，巴菲特也不行，以前没有，以后也不会出现。这是亏损的绝对现象，我们穷尽人类的力量也改变不了。明白了这一点，心理才能坦然接受亏损了，从而做个擅亏的人。 在交易中我们可以控制亏损的幅度，可以控制亏损的相对次数，控制住亏损也就控制了心态。 我们先来看一下亏损者是如何亏损的。 所有亏大钱的原因：过度交易和单笔亏损过大 1.过度交易 过度交易是短线交易者的通病。每天早上开盘开始，一直辛苦地忙到下午收盘结束，刚平了多单随后便又急急地做空，反反复复地进出。只要是手里没有持仓便坐不住，耐不住性子，眼看着行情的涨涨跌跌，生怕错过了机会，越是怕错过机会，越是不区分市场的整体况状、品种的位置。往往在急涨时买进，在急跌时卖出，这是属于追涨杀跌型。另有喜欢抄底摸顶的交易者，在没分清行情是处于尾部还是中继时，看到1分钟K线出现上影线便卖出，看到1分钟K线出现下影线即刻买入。然而进场的时机不对，却由于本身做短线的原因，对更大的趋势并没有把握，或由于仓位过重，想扛也不能扛，只能是频繁止损。这一类的亏损，每笔交易的单次亏损并不大，但累积起来就是积小亏为大亏了。 2，单笔亏损过大 这一类的亏损并不仅仅是做所谓中线或长线的，也包括做短线的，有些做短线的交易者，怕盈利不怕亏损。一笔单子下进去后，账面稍有浮盈首先想到的是不能把盈利回吐了，于是本可盈利更大的单子匆匆出局了。 但如果单子下进去后，行情未如预期时账面出现浮亏，本设好的止损在行情快速超过后，没能及时止损，却心有不甘，这时反而有耐心了-是耐心等待解套。 但随后行情一去不回头，导致浮亏加大，这时行情已不在控制内，最后在心理承受达到极限时砍仓出局。 还有一些是不设止损的，这类交易者在震荡市中还真亏不了大钱，只要不是开在极端的高点或极端的低点，行情在震荡中总还有赚钱的机会，但震荡结束后，持有反向头寸的交易者会在趋势中大伤元气。这类交易者在进场之前几乎都没考虑过单次交易的亏损底限，结果是单笔亏损亏过头了，这样的单次过大亏损很可能会使一个交易者从此离开市场。 市场并不关心你是新手还是老手，只要你违背这两个原则，必然会受到市场的惩罚。这与你的交易技术没有关系，市场也不关心你以前的赚钱经历，即使你在其他行业里已经是成功人士，市场对每个交易者都是公平的。 亏损的类型就这两类，但亏损的原因又是什么？大部分的交易者是怎么亏的？ ①没有一个有效的交易系统&amp;固化的交易模式;@有了有效的系统，但没有很好的执行力; ③亏了以后立即想在第一时间立刻扳回来，于是在没有把握的情况下盲目下单。 第一个情况是交易理念与交易技术仍不成熟，通过自身的努力可以改善;第二个情况主要是性格问题，建议每次开仓后即时设好条件止损单;第三个情况是最为可怕的，失衡的心态会让一个人很快陷入恶性循环，从而在短时间内创造出惊人的亏损。在此再重申一下“执行力”这个概念。 很多交易者口头语是“对就留，错就砍”，以为天天喊着这样的口号就是执行力，就能稳定盈利。 殊不知，对，对在哪儿，错，错在哪儿？是不是真得对了，是不是真得错了？这要对市场和自身有个客观的判断，并不是说浮亏就一定是错了，浮盈就一定是对了。 很多交易者都有这样的经历，在某个时候对行情确实有把握，但人场点不精准，刚一进场行情就开始回调，然而仅仅是因为当时账面上的浮亏，就认为只要亏着就是错了，或是根本不容忍亏损，于是止损了。但之后行情如预期发展，再次进场再遭遇同样的情况，如此反复几次，结果是看对了行情亏了钱，收了盘一看，暗骂一句，如果没有盲目止损持有到现在我还是赚钱的。 因此要明白，这不叫执行力，这叫乱止损，这样的止损全都白扯了，市场也不因为这个而安慰你。 可以反向推论过来，如果这笔单子是顺势的，只要仓位合理，凭什么要止损？要知道趋势只要没改变，所有的调整在结束之后，仍将继续原趋势运行，因为能量永远会遵循阻力最小的途径。作为一个交易者，我们要执行好我们的执行力。 说到“执行力”就自然地引到了如何控制亏损的话题了。 如何控制亏损 1，做有把握的单 如何做有把握的单，可以先引用一下赌博的术语：跟注、加注。打过德州扑克的人都知道，每一个牌局都下注的玩家基本上会很快把钱输光，而能赢钱的人必定是弃牌的局数远远多于跟注的局数。 首先是每个玩家发两张牌，皆为暗牌，称底牌或起手牌，这时从大小盲注后就要选择跟不跟注了，如果起手牌还行可以选择跟注，如果不好就直接弃牌了，这是第一轮下注。 然后第二轮下注发三张牌到牌桌中央，称为“翻牌” ，为公共牌，所有人可见，这时每个人都有五张可供组合的牌了，如果五张牌里连一个对子也没有，而又没有四个同花或四张连牌，就基本没有再跟注的必要了，直接弃牌或让牌（这叫不跟无把握的注）。 第三轮下注发第四张牌，称为“转牌”，为公共牌，所有人可见，这时在局的人共有六张可供组合的牌，如果六张牌没有两个对子、或三条或四个同花或四张连牌，同样直接弃牌或让牌，跟注的胜算太小（这还是叫不跟无把握的注）。 跟注这个概念是花钱买看牌的权利，看到牌之后只有两个结果，要么赢要么输，平手的概念太小，作为玩家需要计算，没有七成以上能赢的胜算，花这个钱值不值？ 但如果有单牌为K或A的四张同花，或三条，或比较大的两对牌，则属于胜算比较大的成手牌了，这个注是一定要跟的，花多少筹码也要看到“和牌”，同时观察其他玩家的表情，决定是否加注。可以连弃十次牌局，但是在有把握的情况下，则要有一和得天下的勇气。 德州扑克这种賭博技巧性并不强，玩的主要是心态。 “賭”仍然是賭，但大多数的輸家总是在没把握的情况下抱着碰运气，或不服气的态度去赌，而少数的赢家只是在胜算很大的情况下才出手。说它技巧性不强，是因为在赌局过程中并没震荡洗盘这一说，牌面情况一目了然，最关键的是能耐住性子等到好牌。 反观到期货市场，作为交易者就是一定要耐心等到行情明确，在自己有把握的机会才出手。 前面在“市场的本质”一章里已比较透彻地讲了趋势的本质，以及在“重要的概念”一章讲了趋势不需要判断，并不比一加一等于二更有难度。 只要你能认清趋势，就把建立头寸的方向押在这个你能认清并无需再判断的趋势上。 但实际上由于期货的杠杆作用，在顺势的基础上把握好行情的节奏就至关重要了，这需要能辨识市场的震荡—即调整的规则。在后面的章节里会具体说这个细节。 2.会设止损 止损怎么止？ （善用兵者，不虑胜，先虑败） 从技术分析的角度来说，大致是分两类，做突破的把止损设在启动突破这个位置，做高抛低吸的把止损设在一个次级周期逆向运行的结束点，这是技术分析中比较通用的原则。这个属于技术形态的止损。但止损并不仅仅体现在技术分析方面，另有如： 幅度方面：当资金亏到本金的一定比例时，如5%。投入100万元，亏到5万这个幅度就止损。 观念方面：就是说原先认为行情会如何运行，进场后在一定的时间内发现行情未如预期发展，即使未到原先设定的止损位也先出局。 但是不管用哪种方法，都需要在实战中逐步提高止损的合理性。我们来浅谈一下止损的三个层次/境界。 止损的三个层次/境界 1，盲目止损 不知对错，在煎熬中埋怨市场、埋怨运气，内心的承受力达到极限后被迫砍仓出局。 2，能遵守模糊的计划及时止损 对与错也并不十分确定，原因在于进场的时机不对，以致在浮亏时判断力下降，只记得在哪儿止损，却不能客观地判断当时行情的性质。止损后内心总有一种怅然若失，对砍掉的钱念念不忘，患得患失的心理导致思路混乱，以至于再次出现机会不敢果断进场，而随后行情如预期发展时又产生冲动，若行情又产生变化时，思路再次混乱。这种止损是在有一定技术功底的人当中比较普遍的。 3，合理的止损 能按照交易规则、资金管理原则和交易计划严格执行，把亏损控制在绝不影响心态的范围之内。 止损之后知对错，在自己交易的时间架构里，客观地分析趋势在这个位置是暂停还是反转？仍能保持客观的心态跟随并判断行情，从而在随后机会出现时可以再次从容进场，其结果使自己在判断行情出错时亏小钱，正确时赚大钱，这才是止损的最高境界。 止损的终极归宿是单条件一票止损 最后要特别强调的是，每次操作的每笔单子，在进场时我们都要多条件、多周期、多要素的考量，但在止损时只能使用一个条件设止损。如技术性的止损，本来是看着前面的一个支撑点做止损，但价格跌到这个止撑位置没止跌，就要即时止损出局，绝不能再改到更下面的一个支撑位。另外，如果到了支撑位但因为仓位轻，资金幅度没达到5%，也不能充许用这种借口来拖延止损的时间。 止损-是在进场时就必须设好，一旦达到条件，不要再找任何借口，必须坚决执行。说到底…. 止损主要还是靠自己，这个事情别人帮不上忙。交易在某种程度上是一种个性的体现，如果由于经验不足等原因不能较好地把握节奏，那就应该用规则来约束自己。 我们无法把握所有的行情，但一定要做到按规则交易!]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>战期货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章 重要的概念]]></title>
    <url>%2F2021%2F01%2F11%2F%E7%AC%AC%E4%B8%89%E7%AB%A0-%E9%87%8D%E8%A6%81%E7%9A%84%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 行情只有涨与跌，交易也只能多或空，非此即彼。因此我们要排除一些模棱两可的，容易让我们左右摇摆的潜意识。 概念，是意义的载体，而不是意义的主动者。概念就是反映事物的本质属性及其分子的思维形式，从生动的直观到抽象的思维，形成一系列概念，这些概念的真理性又要返回实践中接受检验。如此循环往复，是使我们的认识日益接近于客观现实的途径。接近市场的主要方法就是形成和发展并明确一些概念。 概念越深刻、越正确，就越能理解客观的市场。 趋势，不需要去判断客观方面，是不需要；主观方面，是不应该。 对于趋势的认识，并不比一加一等于二更有难度。 在第二章我们举了铜的例子，整个图表里针对周线级别的行情，仅仅是两轮涨势和两轮跌势，最后这一轮跌势到最后一根K线为止还未确定结束。 有没有确定结束，用一个很简单的反向思维即可得出结论，自己问一句，现在是涨势吗？如果答案是否定的就只能是跌势，当然这目前的跌势途中产生震荡是可以的。这两轮上涨和两轮下跌的趋势即使是没做过期货的人，一眼看上去也能明白。 但往往很多交易者自己把事情搞复杂了，一年到头，一天到晚，频繁地进出，做完了多便转手做空，平掉了空头又开始做多，就这样来回地进进出出，结果自己把方向迷失了。 有时在和人聊天的时候，对于某一品种或某个市场，对方会问某个品种现在是什么趋势？而且从语气中也明显感觉到对方是真的有点儿模糊，甚至有些还并不是刚进入市场的所谓新手。 如果对方有此疑问，便可立即判断出此人的交易至少仍没达到稳定的状况，因为对于市场本质的东西还没有深刻地理解。当然，做套利的和仅以委买委卖盘口价格来做炒单的不用看趋势，本书也不涉及此方面的内容。 趋势，不需要去判断。 这是一个概念，既不需要，也不应该再去判断。在K线图上有着量化的突破点，在突破之后趋势就确定了，这个并不给任何人留下任何可判断的余地。 至于是真突破还是假突破，那是突破之后的事。突破之后不再回到突破点就是真突破，如果又回到突破点之内就是假突破。对于做突破这种交易，就是在突破时跟进，止损则设在突破点附近。 作为一个交易者，必须绝对相信图表的真实性，不需要、也不应该再与任何人来讨论这个趋势的真实性。 市场中的特例是V形反转和A形反转，这种反转的底部和顶部不是用一个区域来确认底和顶，而是用快速的大阳和大阴来确认。是价格在形成另一个趋势后，并没有明显的突破点供参考，但幅度会说明现在的行情格局已经改变。 突破是指形态上的改变，突破点是对于形态来说的，但幅度代表的是价格变动，交易的始终是价格，因而幅度比形态更为重要。 对于V形反转和A形反转这种走势，往往会使人措手不及，特别是在日内短线交易中，稍有迟疑就会错失进场良机，等明白过来却已经太迟了，但这也仅仅对日内而言，并且这种情况并不常见。 对于波段，由于时间周期基本跨日，即使出现这种V形或A形反转，也有充足的时间去判断并找到进场点。 趋势的改变：突破的两种方式图1是一种突破方式，直接突破前高点，是单点式突破。 图1 突破方式一 图2是另一种突破方式，图中④在前高点@处受阻回落至3，然后再突破④与@形成的连线。这种方式属于多点连线式突破，很多时候并不止是两个点，三个点与四个点连成一条线也比较常见，形态上也并不要求价格连线一定是水平线。 图2突破方式二 但是不管是以哪种方式，只要是突破了，就可以确认趋势形成了，或者说趋势得到确认了。 图3和图4是反过来的图，代表下跌趋势的形成。 图3 突破方式一 图4 突破方式二 趋势，在突破之后不用再判断，那突破怎么做 突破，是个标志性的信号，很多人都喜欢做突破，但突破就在那么一瞬间，如果错过了则就错过了，行情也不可能再倒回来。 事实上，我们在绝大多数的时间里都是处于某个级别的趋势中，做突破的机会并不多。明白这个，突破怎么做也就简单了。看盘时第一件事是向左看，看现在所处行情就属于什么周期级别的和该周期级别的行情是在何处突破的，如果前面的突破是向上突破，则我们只考虑做多。 我们下面来以图5至图8为例。 图5 沪锌1203合约30分钟K线图 图5的重点：在①处之后，操作方向上只做多。 图中①处对B点进行了向上突破，突破后行情就确认进入了涨势！这之后，对于30分钟周期的当下趋势，就不要再去判断了。这一切决定于一个前提是C点15480不低于A点14460；一个确认是①处突破了B点14950，就这么简单。 在突破之后，如果你是依30分钟为操作周期，则只有一个方向：做多，并设好止损，如果追求好的进场点就是逢回调结束时做多。 在突破之后我们确认涨势并假设这波涨势没结束，在2处和③处是上涨中的回调，调整结束后创出新高就是市场自身以实际走势证明我们依突破来假设涨势仍是成立的。 调整才是技术分析要研究的重点。只有调整才会有形态，单边行情并不需要研究，因为预期是向一边倒，没有分歧，性质单一，连续行进的K线只需关注在何时停滞。 图6 股指5分钟周期的单点突破 图7 股指5分钟周期的多点连线突破 图6和图7都是股指期货5分钟周期，突破的方式不同，但相同的是在突破之后，行情就明确进入了上涨趋势，这时就不要再判断趋势了。 在这两个5分钟周期里，操作上只考虑做多，可以追涨，更好的选择是找低点做多，同时不要忘了设好止损。 图7这个突破应该是大多数人都一眼就看出来的三角形的突破，但诸如这类很标准的形态可惜不会经常出现，这就要我们对突破有个明确的定性。 图8 螺纹钢1205合约5分钟K线图 前面三个例子是突破后确立上涨的趋势，图8螺纹钢是向下突破确立下跌的趋势。 图中最高点是4198，之后一波下跌至4152再向上没有创新高仅到4187，然后再向下一路下滑到4152这个前低点附近稍稍反弹后，便以大阴线向下突破与4152的连线，①处这里就代表了下跌的趋势确立了，在这之后，趋势不要再去判断！ 依这个5分钟周期操作上只用考虑做空的方向。在③处圆圈内实际上是趋势中的反弹，是一次完整的调整，调整之后再次向下突破，继续①处定性的下跌趋势。 价格突破，是一切趋势确定的源头； 只有突破了，就能称之为趋势形成了…… 突破，有两种性质性质一：质的变化；性质二：量的变化。 性质，从严格意义上来说是指事物的本质，是一个事物区别于其他事物的根本属性。性质一旦发生了变化，则根本就发生了变化。 质的变化 代表着要发动一轮行情，这种突破是质的变化，把原先的横盘震荡的无趋势变为涨势或跌势，或把反弹变为反转、回调变为下跌。 前文图5至图8表述的都是这种性质的突破，这种突破在操作上必须追单，否则在突破后价格不会再回到突破点，因为既然是要发动行情，就不会再回来。 如同体育比赛中跑步一样，发令枪一响，参赛选手便跑离起点，起步后就不会再回来了，如果再回到起跑点只有两个可能，一是某个选手退赛；二是有人抢跑需要重新开始。但不管哪种原因这轮比赛都取消了。 对比到行情来说，就是突破后又回来了则是行情结束了，表示这一轮行情并不是真的要发动。 图5至图8这种突破，是真正的突破，是平日里大多数交易者所说的做突破。但这种性质的突破，在每个行情周期内只有一个。当一个行情周期运行结束后，即转为另一个运行周期，在重新开始的行情周期内又会重新有一个这种质变的突破。 可以大致估算一下各个行情周期在多长时间内出现一次这类的突破，看1分钟K线图表，一天内少则一次，多则三次； 5分钟周期则两三天内少则一次，多则两次；30分钟周期在有了这种突破后，行情至少要延续一个周期左右才能转到另一个周期；日线级别的行情以此类推。 但很多时候会有两个周期级别的突破出现在同一时间段内，这就是所谓的大小周期共振。 再回顾一下图5至图8中①处所标的，都是指质变的突破。 图5是沪锌30分钟周期，①处的突破改变了原先的箱体震荡格局； 图6是股指期货5分钟周期，①处的突破是把原来是跌势的反弹变为了反转； 图7可以先不管原先是什么趋势，在三角形整理收敛到末端，①处的突破结束了这个相对平衡的格局； 图8是螺纹钢5分钟周期，这个周期内原本是个涨势，在涨到4198后开始回调，①处的突破改变了原先上涨的趋势，突破后即确立转为跌势了。 量的变化 是指在行情已处在趋势里，在运行过程中价格创出前面的新高或新低。或者是指价格突破某个整数关口，这种突破可能是质变也可能仅仅是量变，取决于当时行情所处的位置和形态。 本身已在趋势中的量变突破，每天都会有很多次，但往往是一追就遇回调，眼看着像个假突破，止损后行情却又重新突破了，于是天天都能听到有人说“又是一个假突破”。 其实突破并没有真假之分。突破反映在图表上，就是现在价格过了前面某个价格点，至于突破之后又回来了，并不能改变刚才已经突破的事实，即使比前高点只高出一个价位也是突破。 因此在临盘实战中我们要分清此时的突破是什么性质，突破后的预期如何，哪个是该追的，哪个是不能追的？ 就“突破”这个词的字面意思，是相对而言，是指突破谁的意思。 创新高是相对于前面某个高点，创新低是相对于前面某个低点。所以要不要做突破，需要区分清楚参照物的性质。 参照物处在无趋势的区间内，则突破可能就是要走出这个区间，参照物处在趋势中则突破只是在趋势里行进，只能一次又一次的突破前面的高点才能把上涨的趋势走完，但趋势里随时会产生调整，所以每天都会有所谓的假突破出现。 图9是借用了前面的图例，是为了说明同在一张图里，此突破与彼突破是不同的。 图9 股指5分钟周期趋势途中的量变突破 我们看一下在质变之后的量变突破在盘中是怎样表现的，在后半部的虚线框内，行情已步入明确的上涨趋势里，假设涨势还没结束，结果只能是不断地创新高，这是一个前提。 但趋势的途中可能会有各种因素来干扰行情的发展，所以调整可能随时会发生。图中B点从价格来说是对A点的突破，通常会有人在这个位置做突破买入，但刚一买入即逢回调，如果这里没对行情的性质把握好，很容易把这个突破当作假突破来处理，结果是止损却止错了。 之后，C点又高过了B点的价格，再次创新高，又是一个突破，但买入后的结果与在B点时买入一样，只是这次调整的时间稍短，随后D点又突破了C点，但仍然是刚一创新高就立即回调。 价格的创新高总是能激发交易者买入的热情，然而这是个负和的市场，主力资金或说市场不可能让所有人每次一买就赚。 B突破A，C突破B，D突破C，在属性上是完全一样的，每次的突破都为证明上涨的趋势仍在继续，所以每次突破从根本上来说只是原趋势的行进，行进的最终结果是为了把现有的趋势走完。 趋势与突破，这两个词可以算做是最重要的概念了。是属于在行情图表上可以量化的、可以客观定性的概念。 然而在交易的理念中还有一些主观性的概念，这些概念几乎天天都能听到有人在讨论。大多是以仁者见仁、智者见智的方式，但争论不出一个明确的结果。 因为这些概念无法量化，并不是数学式的加减乘除可以得出一个具体的数字。但这些概念如果不理清楚，同样会在潜意识中影响我们的实际交易。 试错—致命的试错不要去试错。既然知道是错的，就不要去尝试。 卡尔·波普尔曾说：“科学是在不断试错的过程中发展的。 他是20世纪批判极权主义最重要的人物，也是这一世纪科学空前发展最重要的哲学家，他也是索罗斯的老师。 爱迪生经过1001次实验，成功发明了电灯，这就是科学，科学需要不断地尝试，科学的试错是必须的。 在分析行情的过程中，我们可以用排除法。即排除行情演化的最小可能性，得出行情演化的最大可能性。但实盘操作不能真刀真枪地用资金去测试行情的方向。 你可以在确认方向后，或在已确认的方向上建立仓位，这时可以称之为试验性仓位，在后续行情证明试验性仓位正确后再加码。 试验性仓位，在说法上是试仓，但这种试仓与试错在概念上是完全不一样的。 试仓，是指在方向已经确定的基础上才进场。 既然方向已经明确了，为什么不满仓进场，还要试仓呢？ 这是因为交易中最重要的仍是控制风险，不管在任何情况下，首先要考虑的都是风险。 即使在方向明确的行情中，在资金博弈的市场里也可能会出现一种最极端的风险，这种风险是在你刚进场之后的一分钟时间内，行情的方向改变了。这样，试仓时所设的止损会被打掉。 还有一种常见的风险情况，是进场时的点位不是太好，进场后即遇到调整，这时由于仓位轻即使账面浮亏，也可以保持一个平静的心态客观地看待行情的发展。 试错，是指交易者本身并不清楚地知道当下行情的确定方向，先进场然后被动地等待市场给出方向。开仓的方向是对是错对于交易者来说是概率对半的。 这种试错的做法在遇到宽幅震荡时，会频繁地被止损，会导致在真正的方向还没明确之前就大幅损失本金。 在这个市场里我们要用科学的方法去交易，但绝不提倡用金钱去做无把握的试错，每一单的错误都会带来本金的损失。市场中有一句话很流行，叫做“我连亏几次，最后一次就把前面所有的亏损扳回来了”。 事实上，这种情况也确实存在。但是要知道，最后一笔能赚回来是因为行情的配合，而绝不是在有过几次试错后，就肯定能在预定的最后一次一定扳回先前的试错损失。 如果一个交易者在不断试错的过程中把本金损失太多，但想要的行情却迟迟没有出现，怎么办？继续试错，最终会倒在试错中。这还仅仅是交易的表象问题，更深的影响是对信心的打击。 一个成熟的交易者可能会在连续几次的小亏后，仍能按照系统信号进场交易。但大多数的交易者，在其交易模式没固定下来之前，在连续几次亏损之后，损失的并不仅仅是金钱，更重要的是信心。当信心受到挫折后，会直接怀疑自己的交易方法是否有问题，但最终行情如预期来临时却不敢再次果断进场了。 预测—不等同于猜测预测并非是陷阱，但预测要有理有据、有一定的因果关系。 预测和猜测是两码事。 预测是一门科学，是一门并不精确的科学，但有理有据的预测可以得出相对正确的准确范围。 比如说天气预报，根据气象观测资料，应用天气学、动力学、统计学，对某区域未来一定时段的天气状况做出定性或定量的预测。都说天气预报不准，不准是指精确性，但没人怀疑天气预报是准确的，虽然实际的阴睛或气温会比预报的有些不一致，但大概的范围不会错。 再比如说某商业旺区在节假日的人流量预测，如果再结合天气预报，在某个特定假日如果天气睛好，再预测大概会有多大人流量，基本上与实际情况会相差不多。 这种预测是根据历史资料统计后总结推测出来的，确实是因为在一定条件下可以导致一个差不多的结果，因为历史是可以重演的。所以类似这种预测是有科学和历史根据的。 并且这一类的预测，其必然性远远大于偶然性。 在投机市场，如果你觉得只要是预测就一定是个陷阱，那是因为没有明白预测与猜测是不一样的。 根据利多或利空的相关因素对后市做出大致的判断，这是预测。这种预测是根据历史的走势具有自我相似性而做出的判断。但如果对后市的发展一定要给出一个精确的点位，这就是猜测。 研究政策面以及研究基本面也不是简单地看表面的利多还是利空，而是看它们之间的相关性以及如何对价格产生作用，从历史中总结出一些规律性的东西，谨慎地加以运用，这就是预测。 加息，对股市是利空，但在股市的牛市中，每次加息股市都低开高走，直到最后一次加息，牛市才结束。这个叫相关性，因为只有股市处于涨势中才会加息。 在交易中，我们可以把预测换一个说法，叫做预期。 我们根据现阶段政策面、基本面的相关综合情况，再配合技术形态，对后市可以有个大概的预期。而这种预期是基于-市场在此之前曾因为相同的原因，多次出现过类似的结果，所以现在仍有可能再次出现类似走势。 这种预期就是交易者的观点，而这种观点是来自于客观的市场。 但如果一个刚刚进入市场，毫无交易经验的交易者，对着行情图看了一会儿后，做了一些预测，则很明显这就是猜测了，就如一个不懂气象的人去预报天气。 天气预报可以相对准确地预测，是因为天气不会因为人的准确预测而故意反其言而行，预测也只有在不影响未来时才有可能是有效的。而市场不能准确预测，很多时候是因为人为地主观能动或突发事件而破坏了行情的原本运行轨迹。例如一波很顺畅的下跌趋势的途中，突然在晚间的新闻发布了降息的消息，或铜的主产国发生地震，则必然会影响第二天的价格。 但这类情况是属于偶然性的，是小概率事件，作为交易者不能总是把偶然事件纳入到常态的交易中去。我们在市场中要选择大概率方向去研判，例如现在如果市场是处于涨势中，则大概率的情况是明天或后天，以至更多天后，价格仍将创出新高，这就是最简单的预测。 依着这一思路，在一波涨势的途中，每一次预测继续上涨都是对的，只有在涨势结束的最后一次，才会是错的。 一个好的交易师，是没有观点的交易师让人茫然的一句名言。 这句话常常让人感到茫然，茫然的是这句话似乎是正确的，但好像也不是让人能很愉悦地接受。 有很多人喜欢说自己从不预测市场，只是根据行情来交易，看见涨了就做多，看见跌了就做空。这就说明这样的交易者是没有观点了，但真实的情况真的就如”涨了就多、跌了就空”这么简单吗？ 其实这句话与“对就留、错就砍”一样，这两话句的一个共同特点就是只说了标题，没说内容。 这两句话究其根源，是无数的市场前辈们在实际交易中总结出的精练之语。在交易经验尚不足的情况下，显然并不能真正理解这话的内涵。 首先一点，没有观点，如何交易？ 如果说“涨了就做多、跌了就做空”，代表着是没有观点的好交易，那么它与“高抛低吸”这句话，显然是对立的。两句都是正确的话，但在其动作发生后的结果指向却产生了对立。 如何化解这一矛盾？ 矛盾的根源在于震荡，震荡其实就是市场自身在调整不和谐的因素，调整结束之时就是矛盾化解之时。 任何人进场交易，都必须选择一个方向，这个方向就是交易者的观点。这个世上没有人能做出一个无方向的交易(即便是套利交易者，同时下出多与空两个方向的单子，至少也代表了其对价差有缩小或扩大的判断)。反映到交易软件中即是任何一次交易，都不可能在软件中找到既不是卖出，又不是买入的下单指令。 这种情况即表明，只要你交易了，则必然是有观点的，但这个观点是顺应了市场，还是仅仅自己的随心所欲？随着交易境界的不断提高，逐步将自身的观点融入到市场中顺应市场，从而逐步消除自身的主观性。 所以说，有没有观点不重要，重要是的这个观点来自何处，是客观的市场，还是主观的自我。 概率—并没有“一定赚钱”的机会统计学中有个概念叫做大数法则，指的就是概率。 大数法则大意是说，相似个体所组成的大型群体的平均行为，要比小型群体或群体中的个体行为更加容易预见。大数法则来源于统计数字所表现出来的规律性。 根据规律性而得出后市涨与跌的概率，这就是投机的根本。任何市场都没有“一定赚钱”的机会。 必须敢于承担可以接受的可能风险，然后去获取预期中的可能收益，才是与市场兼容的实战思维。如果你无法正确评估风险，也就无法管理风险，进而无法获取可能的预期收益。 作为一个交易者，首先要明白什么是投机，投机是指交易者根据自己的判断，愿意承担一定的市场风险所做出的买卖决定。决策的根本在于根据投机经验对市场形势进行判断。如果没有经验，做不出正确的判断，则不可能长久生存。 在任何一个市场中，我们做交易，如果确实可以存在“一定赚钱”的机会，则很容易推导出一个结论，那就是你可以把自己所有的资本投入进去，很快市场中所有的钱将会被你一个人赚走。 如果这个人不是你，相信你也不会愿意有这种情况发生。 心态—不要总是拿心态来说事在交易纪律和交易技术成形后，不要再谈心态。 如果心态不好，则结果必然不会太好。但即使心态好，也不能确保结果一定好。如果日本的篮球队与美国的篮球队打比赛， 日本队的心态再好，输球也是必然的，这是因为技不如人。 在交易中，心态的好坏不是你亏了钱也无动于衷，如果是这样的话就是麻木了，能理解亏损是交易的一部分，把风险控制在可以承受的范围内，自然就不会有心态问题了。 这个前提就是可以控制住风险，而控制风险的前提是技术过关、纪律过关。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>战期货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章 市场的本质]]></title>
    <url>%2F2021%2F01%2F10%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E5%B8%82%E5%9C%BA%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 涨和跌，仅存在这两种趋势。涨完了跌，跌完了涨，往复循环，周而复始，仅此无他。 本质的东西都是简单的，本章的内容试图让读者透过表象，真正明白市场其实很简单，市场也并不随机，只是我们任何人都无法看清其全貌。但大自然的规律市场也无法违背。 如果这是一场竞技游戏，则我们必须了解其游戏的规则。 如果把金融市场的一举一动当做是某个数学公式中的一部分来把握，是不会奏效的。数学不能控制金融市场，而心理因素才是控制市场的关键。更确切地说，只有掌握住群众的本能才能控制市场，即必须了解群众将在何时、以何种方式聚在某一种股票、货币或商品周围，投资者才有成功的可能。—索罗斯 趋势的内在含义趋势，是一条有角度的线，含有形态、但不是形态。 任何一个市场，股市、期市、汇市，仅存在着两种趋势，一种是上涨的趋势，另一种是下跌的趋势。从一个最低点到一个最高点，结束一轮涨势；然后从这个最高点开始转为下跌，再跌到一个另一个最低点，再然后…… 市场就是这样，周而复始地循环着涨与跌。 一个市场的历史大顶与大底，必然是对应着经济周期的繁荣与衰退。政策市的顶与底由政策决定，资金市的顶与底由主力资金决定。 当一个底部确立之后，开始步入涨势，在这个涨势没结束之前，所有的震荡结束之后，必然仍将沿着原先的涨势向上运行，当市场没有给出明确的转势信号之前，则原先的涨势就不能说结束。 但涨势之中会有回调，跌势之中会有反弹，就是所谓的震荡。在此需要解释一下，“震荡”这一词并非专业的说法，专业的说法应该叫“调整”。 相对于价格运行趋势来说，涨势中的回调是对上涨的调整，跌势中的反弹是对下跌的调整。调整只是改变其运行的节奏与姿态，并不改变其趋势的原本性质。 对于交易来说，我们如果做多，要尽量去做涨势的上涨，而不是去做跌势的反弹，反之亦然。 趋势的定义趋势发展的三条路：①调整（震荡）；②创新高/低；③转势。 我们拿涨势来解释一下上涨的趋势：一轮上涨行情，在运行过程中必然会有震荡，即调整，对上涨的回撤，但调整终归要结束的，那么调整结束之后，行情则一定要创新高，这就是上涨的趋势继续存在的必然结果。 如果行情没有创新高，则涨势的假设就被推翻了，那么，上涨的趋势就不存在了，则只能进入到下跌的趋势中，除了这两种趋势，行情的发展再没有第三种趋势。 如果说横盘状态是第三种趋势，那市场存在的意义也就消失了，横盘是指无趋势的状态，在这种状态下任何人也无法获利，也无法亏损，那么多空对弈、辛辛苦苦又所为何事？ 横盘，对于趋势来说，属于途中休息的性质。则休息完了就必须沿着原先的方向继续前进，如果休息完了不再运行原趋势，那么第三条路，只能是转势! 如果爬山代表着涨势，在途中累了是随时可以休息的，但休息好了起身就还得往上爬，如果确实爬不动了，最终的结果必然休息完了下山，这就是转势。 趋势，这样定义！ 趋势发展的三条路： （1）一轮趋势发展的途中必然会有调整（震荡）。 （2）调整（震荡）结束后，继续上涨/下跌，创新高/低。 如果没有创新高／低，则只有两个可能供选择： * ①继续调整（俗称二次调整） * ②第二次调整结束了，再创新高/低。 （3）如果最终没有创新高/低，则第三条路是转势。 关于趋势的本质，就这么简单，并不比一加一等于二更复杂。 不要去研究一加一为什么等于二。 我们进入这个市场是来赚钱的，不是来做学术研究的，这样的事情不属于我们的研究范畴。我们只需知道一加一确实是等于二就可以了，可以说这是定义，也可以说这是公理，不用费尽心思去用其他任何方法去证明。先有鸡还是先有蛋的问题，也不要去研究，只需知道鸡可以生出蛋，蛋可以孵出鸡就可以了。 要有所相信，并坚信：趋势，是我们唯一的，并完全值得信赖的朋友。 趋势的本质并不比一加一等于二更复杂，一眼看上去，难道我们真得看不出来现在是涨势还跌势？ 但为什么顺势这么难！？ 只是大多数人并没有搞明白其本质的东西，或是搞明白了为什么仍觉得这么难，那是因为大多数人不敢相信：趋势真得这么简单，简单的让人难以相信。 趋势就摆在那里，只是你相信！抑或不相信？ 趋势的形成→趋势的发展→趋势的结束，一个趋势的结束代表着另一个趋势的开始→即转势。 我们用几张图表，进一步阐述趋势周而复始的循环过程。 在这个周线级别的图表里，仅存在四次趋势，两轮涨势和两轮跌势，事实就是这么简单。 例：如图1所示 图1 沪铜03周线图，2005年10月到2011年12月30日 图1显示的是沪铜03周线图，从2005年10月开始的一轮涨势直到2006年5月份达到最高点81580，然后开始了跌势直到2008年底跌到22210点，完成了一轮牛熊转换。 从2009年初开始又进入了牛市征途，直到2011年2月份再涨到75950点结束了第二轮涨势，之后再次转为跌势至此图的最后一根K线。 转势，代表着反向的趋势形成了，然后以突破的形式来确定。即原先的趋势在经过震荡调整，在调整结束后，没能沿着原趋势的方向运行，创出更高或更低的价格，反而以反向的突破形式确认了另一个趋势。 如图2中的①处，向下突破支撑线，确认下跌趋势形成了，即代表着原先向上的趋势确定结束了。可能有人会问下跌明明是从A处开始的，为什么说跌势是在①处确认的？ 因为价格运行到①处之际，如果不向下突破，或仅突破一点立即又回升到支撑线上方，则仍有可能再创新高，而D处就成了原先上涨趋势的调整结束点了。所以在①处：突破就代表着跌势的确认，不突破则代表着对原先涨势中，调整结束的确认。 从A处开始和从①处确认，代表着两个不同的概念。如果现在时间只是到D处，那我们看A处可能是个顶，也可能不是顶，只是价格到A处这个位置，需要调整，那么调整结束之后，必须要创新高才能证明上涨的趋势是仍然存在的。 但实际上调整到①处之时价格选择了向下突破，则确认在调整结束后，原趋势确实从①处确认不再继续了。 例一说的是周线级别的趋势，下面再看一下5分钟级别的趋势。 例：如图3所示 图3 股指期货5分钟周期在三天内的趋势转换 图中左上角的小框内是30分钟周期的图，仅从这个周期看是一个横盘的震荡状态，但分解到5分钟级别就形成了一波涨势和一波跌势。 价格在2918.2见底后，向上反弹至2941.4，这一波可先定性为反弹，随后价格再向下运行至2921，这时不再创新低转而向上突破前高点2941.2，在A处就形成了突破，于是涨势在这里便形成了，先前定性的反弹在这里要改为反转了。 随后向上发展至B圆圈处进行了一次完整的横盘调整，调整结束后便继续向上创新高。直至到最高点2995.8，在C框处又开始了调整，但这次调整结束，没能创新高，这第二条路没走成，于是在①处选择了第三条路向下突破，转为跌势了。 我们再进入5分钟周期的内部分析： 在图中B圈处和C框处各有1分钟周期的K线运行情况：在两个1分钟的图表里都标注了“调整形态完整了”，这句话的意思即是趋势在运行过程中产生了调整，这是第一条路。 第一条路走完了即进入第二条路，第二条路该干什么？ 根据趋势的定义是：第二条路要创新高，于是，在①处当时的价格是2958.8已经创出了前面的新高，在新高后短暂的停留后继续上涨，它当时确实在走第二条路，那么对涨势继续存在的假设仍然成立。 然而在③处当时的价格是2991.2，前面的最高价是2995.8，并没有创出新高，甚至连前面的次高点都没过。 再看一下趋势的定义：价格的运行如果最终没创新高，没别的路可走，只能进入第三条路，转势! 最终，在①处价格向下突破调整时形成的最低价支撑线，于是下跌的趋势从2995.8开始，在①处得以确认。 下面再看一下橡胶1201合约5分钟级别的上涨趋势。 例：如图4所示 图4是5分钟周期从底部到顶部的一个全部过程，左上角小框内是30分钟周期，说明这整个5分钟的一波涨势只是30分钟级别的一个局部。 从左下角开始看起，向右看，图中的最低价是24465，之后向上反弹的第一个高点是25650，随后又开始下跌到24595没创新低。这里开始上涨一举突破前高点25650。 图5 RU1201合约1分钟周期的向上假突破 其实这里并没有什么利多消息的刺激，基本面也不可能在半天之内改变，宏观面更不可能了。只是因为当天下午股指期货在1点钟开盘后到1：30这半个小时上涨了35个点。1：30商品期货开盘后借股指之势而整体向上暴涨，橡胶在短短5分钟内上涨1000多，点摸到涨停板，这里又是一个短时间换大空间的玩法，对于橡胶来说，5分钟涨1000多点是不合理的，所以在摸上涨停后并没有封住而是回落整理，至收盘前虽再次冲击涨停但仍没能封住，所以可以说在涨停后的回落就是以小空间换长时间了。 图中A处，以突破前高点25650确立了5分钟周期的涨势确认了，随着涨势的发展第二天10月25日盘中涨到27050后开始调整了，这是趋势发展途中的第一条路。 到26日的最低价B处25820止跌，再经过震荡整理后于26日下午再次上涨创了25日的新高，这是第二条路。 之后震荡向上一路调整一路创新高，到28日以跳空形式最高涨到C处28835，这里又开始向下调整了，这一波一直调到D处27900才止跌，这里再把它看做是第一条路走完了，接下来该走第二条路了，就是要创新高了。 但从随后的形态上可以看出来，随后的28360是对前面28250的突破，但突破后却又跌回来了。如图5所示，这就是所谓的假突破。 再回到第二条路的话题，第二条路是要创新高的，但最终没能创新高并在形态上给出了一个假突破的信号，二者综合起来判定，第二条路不通，那接下来只能走第三条路了—转势! 注意一下，D处和②处的区别，这是我们看盘—要看什么的关键所在。在关键的结构处，盘面微妙的变化决定了后面是继续运行原趋势，抑或是转势的盘口语言。 ①处是在B处结束后走第二条路的向上突破，并成功创出前面的新高，这第二条路走的正确。而处是在D处结束后走第二条路，但突破后不但没能创出前面的新高，反而以假突破的形态跌回来，即说明第二条路没走成或失败了。 这时如果市场还将继续运行，它就没有别的路可走，只能走第三条路—转势！ 看盘，看盘，看什么？ 就是要看在一些关键的位置市场在干什么。 转势的定义趋势，怎样定义的，转势之后就回到了趋势的定义中。 某个市场或说某个品种的顶或底，必须有一个从形成到确认的过程，而图表会将它忠实的记录并显示出来。 关于趋势的描述可以再简单一些，就涨势而言：只要调整结束，就要创新高，不创新高就必须转为跌势！ 只要多空双方仍在交易，就必须分出胜负，无其他路可走。如果横盘是一个结果，将不会再有人参与。 转势：代表着另一个趋势的开始，市场就这样周而复始…… 例四：转势的定义如图6所示 图6是15分钟同期K线图；图7是60分钟周期的K线图。图7最低点是2863.4，之后反弹到2917.8，再向下探至2884.2没有再创新底。然后在Z处向上突破，随后便确立了涨势从这里开始了，一直涨到A处3146.8这里形成了一个短期的顶部，随后向下回调至B处3091.6，运行了一个完整的5浪，这种转势看图6的15分钟周期显示更为清晰。 从A处到B处，我们可以做两个方面的可能性定性： （1）如果假设涨势仍未结束，则A至B的下跌，可以作为上涨趋势中的回调，则根据据趋势的定义，调完了就应该创新高。 （2）如果假设涨势已经在A处结束，则A至B的下跌，就是跌势开始的第一波，则根据趋势的定义，第一波跌完了要回调，回调对应于跌势来说就是反弹，则反弹完了就应该创新低。 接着向后面看，在B处之后，价格向上运行了一段之后，在①处所指箭头的地方对B处3091. 6做出了向下突破的行为，这里我们可以认为转势了。 图7 股指期货从涨势转为跌势，60分钟K线 这里的关键点是3091.6，突破这个价在这里就可定性为向下的趋势确立了。但对比一下图7在Z处向上突破后的价格运行情况，是向上突破后不会再回到突破点。 而图6在D处向下突破之后运行到C处后，价格转而向上又回升到突破线之处，量化点就是B处的3091.6。 到这里，对于0至C这一段跌势可以做两个方面的解释： （1）①处向下突破B点，下跌趋势确立，但这一波的下跌趋势仅仅到C处就结束了，之后又转为涨势了。 （2）①处对B处的突破，因为仅运行到C处又回到了突破的起点，就是所谓的假突破。那么，本就处于上涨趋势中的向下突破是个假突破，则只能再次回到本身还没结束的上涨趋势中。 之后，价格确实继续上涨，并且创出了原先认为的A处3146.8的新高，到D处3157.0。这时又开始的回调，从D处下调到E处3070.4，自身的形态上又运了一个下跌的5浪结构，而5个浪是代表着一个完整的周期，一个周期结束之后就会转到另一个周期。 从D处到E处，我们又可以做两个方面的可能性定性：（和从A处到B处的定性保持一致性） （1）如果假设涨势仍未结束，则D至E的下跌，可以作为上涨趋势中的回调，则根据据趋势的定义，调完了就应该创新高。 （2）如果假设涨势已经在D处结束，则D至E的下跌，就是跌势开始的第一波，则根据趋势的定义，第一波跌完了要回调，回调对应于跌势来说就是反弹，则反弹完了就应该创新低。 再接着向后面看，从E处之后，价格向上运行到3090.6之后，第二天在 处以跳空的方式对E处进行了向下突破，而这次突破之后，就没有再反弹回升到E处的价格点了，这就是转势。 这里我们要注意到形态、结构、周期、关键点。 图中有两个需要特别注意的地方是B和E，这两处从高点下来到此位置后，都代表着这个级别一轮完整的行情周期，因而B和E是个关键点。 看图、分析行情一定要找到图中的关键位置所在，所谓打蛇打七寸，擒贼先擒王，都是一个道理。这样的关键点决定了形态上的结构所在。 在一个周期完成之后，行情转入另一个周期， B和E都有两种可能性的定性，其一是假设涨势仍在，其二是假设涨势已经结束。后面的关键即是看行情的突破是真突破还是假突破。在0处和②处我们无论建立什么方向的头寸，都可以随即知道对与错。错了即行情很快会回到突破点，做空要出局。对了则是一出手就赢，账面的浮盈会让你清楚地知道做对了。 趋势途中震荡的起因前面已经讲过，“震荡”这一词并非专业的说法，只是大家说习惯了，专业的说法应该叫“调整”。相对于价格运行趋势来说，涨势中的回调是对上涨的调整，跌势中的反弹是对下跌的调整。 价格变动最直接的原因是心理预期 价格的初始来自于成本方面的定价，这是一个基础，也就是所谓的基本面，然而价格的变动更重要的是供求关系所致。 供大于求，价格必然下跌，供不应求，则必然导致价格上涨，而供求关系更为直接地影响人们的心理预期。当一件商品被太多人追捧时，大量的买家竟相买入，可能会导致价格会高于成本很多，甚至于到离谱的程度。 就拿iphone的市场价来说，能热销首先当然是乔·布斯的伟大之处，但有多少人关心这仅仅巴掌大电子元件成本值多少钱。除了苹果公司的成功营销之处，则完全是人们热捧的结果。 而热捧背后更深层次的原因来自心理，心理原因大致可分为三类：一是这件产品确实物有所值；二是大家认为它好，所以我也认为它好； 三是因为拿在手里很体面。 不管因为哪方面的原因或几个原因综合在一起，实际上是在心理对它产生了需求并预期拿到手后会产生什么样的效果。因而这个成交的主要推动力是心理预期。 心理预期产生分歧，是换手的主要原因 趋势的发展其动力来自于预期的加大，这个预期由宏观面、基本面、政策面、消息面等诸多因素传导至交易者的心理。 但随着趋势的发展，市场中的交易者（包括主力在内）的心理也会产生变化，于是便产生了震荡，在股市中大多数人都把震荡理解为洗盘这种说法，因为只能单向做多，因而股价下跌主力也无利可图，那么震荡的目的就很单一，就是清洗浮筹。 期货市场的震荡更倾向于“换手”这个概念 很多品种每天的成交量都远远大于总持仓量，这只能是单日内多次换手的结果。有人预期涨势仍将上涨，原有的多头持仓不动，空仓的发出买单。有人预期涨势已尽便平掉多单，或反手做空，或新空进场，于是多头与空头便产生了换手。 就当下来看，心理预期产生了分歧即是换手的主要原因。当市场在某个区间多头与空头力量无明显优劣时，反映在K线图里就是区间震荡，震荡的行情从性质上来说是多空双方的相对平衡。 当震荡行情延续一定的时间，或某个关键的位置，当平衡被打破了表现为价格突破了震荡区间或震荡中枢，这时预期就会明显倒向一方，原本预期正确的加仓，原本预期错误的止损，于是产生趋势、原先趋势得以延续或原先趋势在震荡之后转势。理解震荡的两种思路 有主力的思路 在股市，都知道没有主力的股票不会有行情产生，这是一个当然的有主力思路，甚至很多人都清楚某只个股知道主力是谁。 那么一推论便可得知，震荡是由主力主导的，当某个主力要控制某只股票时，必然会有进驻吸筹、拉高成本、吸引散户跟风、中途洗盘、高位出货的过程。中途的洗盘就是体现在图表上就是震荡，其震荡的目的就是为了洗出跟风的散户，同时为了更好的控制筹码，好自己轻松地拉高。 一句话，主力不可能带着所有散户一起去盈利。 无主力的思路 在期货市场，我们要把这思路给重新理一理。 由于股市与期市的交易方式有着根本的区别，也导致了其做盘思路的完全不同。期货市场有没有主力，可以很肯定地说有，但又可以很肯定地说，上涨时的主力和下跌时主力是同一个人，或是同一伙人。你总不能说这一波的涨势做完了，转为跌势时又换了主力，那原先的主力怎么可能会同意？所以换主力一说不用考虑。 那么既然多空是一家，我们也就没必要知道主力是谁了，因为大的趋势也并不是由主力说了算，而是由宏观面以及基本面来主导。 所以我们更倾向于无主力的思路，无主力的思路并不是说没有主力，而是用主流资金的思路来跟随价格的上涨或下跌。震荡—只是调整； 调整—是因为要换手； 换手—是因为心理预期产生了分歧。 我们对于行情的走势，可以引史为鉴，从历史的走势图我们可以很清晰地看到市场的顶在哪里、底在哪里，每一轮趋势中都会有震荡出现，但震荡结束之后，涨势终将涨完才会转为跌势，跌势也终须跌到尽头才又会转为涨势，市场就这样周而复始地进行着牛熊转换。 因此对于当下的行情，我们就可以假设，如果现在是处在下跌的趋势中，那么这波跌势在途中不管怎么震荡，其结局都是这波跌势终将跌完。 可以再用爬山为例，我们决定周末去爬山，于是从山底开始了一波涨势，在爬山的途中我们走累了便会停下来休息，这休息的过程便是震荡/调整，对向上爬山的调整，当我们休息好了便又会接着向上爬，于是趋势继续向上，直到到达山顶，我们又会休息，过后则是开始了下跌的趋势，下山。 这个世上，不会有人从山底开始向山顶行进，然后在山顶折而向下至山底，在这个一上一下的过程中一直保持着匀速行进吧？至少笔者没见过! 趋势的运行与爬山这个道理是一样的。见图8白糖1205合约从底部涨到顶部，再由顶部跌到底部的整个运行过程。行情的发展也要休息，休息是为了调整体力、调整节奏。 对于行情更为直观的说法应该是调整仓位、调整布局，当调整妥当后便会继续原本没结束的趋势。 图8中①23处方框内的震荡最直观的表现就是对ABC原来形成的趋势角度和时间的调整，同时调整持仓布局。 当然，在途中会调整几次，这个并不会在起点就能确定好，即使在起点之前有所计划，那也不应该没有意处情况的应对方案，因为途中会有很多不确定的因素随时来干扰原先的计划。 图8 白糖1205日K线图 后半部下跌趋势，大体上可划出三个主要的震荡区； D处是对A线的调整； ②处是对B线的调整；③处是对C线的调整；调整原先趋势运行的角度，同时调整行情发展的时间。 说了这么多其实就是为了引出一句话-震荡只是调整。 抛开一切盘面之外的因素，我们仅对着行情图表来看趋势。对于趋势来说，震荡就是为了调整趋势的节奏、调整趋势的运行角度、调整趋势的运行时间，调整一切须要调整的因素。 行情发展的根本就是周而复始的涨与跌，而行进途中的震荡只是调整。只要理解了趋势，当一个趋势确定形成之后，是不会在短时间内结束的，如果趋势发展到尽头，那么图表上也会告诉你转势的确认点在哪里。 只需看着图表，图表会告诉你—趋势并不需要判断，并不比一加一等于二更难。 在此之后，我们作为技术分析交易者，对于交易我们就只剩下一件事可做了。那就是利用一切可利用的工具，找到调整的结束点-进场!]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>战期货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章 了解市场，了解自己]]></title>
    <url>%2F2021%2F01%2F10%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E4%BA%86%E8%A7%A3%E5%B8%82%E5%9C%BA%EF%BC%8C%E4%BA%86%E8%A7%A3%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在这个市场中如果说有一本最通用的著作是可以向所有人推荐的，则非《孙子兵法》莫属。 书中的许多理论都蕴涵着交易的智慧，其中最简扼的一句是：“知彼知己，百战不贻；不知彼而知己，一胜一负；不知彼不知己，每战必败。” 内视自我，我们都是诚实的人—我们无法欺骗自己。 我们进入这个市场进行交易，表面上我们是依据技术的形态，或基本面的供求，或政策面的消息等等来进行交易的决策。 事实上我们交易的是自己的心境，因为面对同样的价格图表，买与卖的动作总是同时发生。所以对于同样的形态、同样的供求、同样的消息，不同的交易者所理解是不同的，同样的理由并不能导致同样的交易—因此说：我们仅仅只能交易自己的心境。 因而，对于交易中的自我，我们是诚实的。但大多数诚实的交易者，其交易结果为什么不是那么好。 诚实有错吗？答案显然是否定的。 诚实，本身没有错，错在我们并没了解真相，没有了解市场的内在真相。在没了解真相的基础上，我们即使怀着一颗虔诚的心，也无法真正地表达出市场的真实想法。 大自然的法则—能量遵循原则能量会永远遵循阻力最小的途径。 奔腾的江河和涓涓的溪流都会因为自身的重力顺流而下，在顺流而下的过程中如果遇到石块，便会绕开石块，重新寻找阻力更小的途径，继续顺流而下。 市场就如同河流一样，价格的变动也会遵循阻力最小的方向。这不是投机或投资市场的独有性质，事实上—你、我、所有人，以及大自然万物都遵循阻力最小的途径，这是大自然的法则。 在实盘交易中，你认为再不进场就会错失行情了，则你就会进场了。当你觉得再多损失一个点的痛苦不能再承受，你便出场了。而这同样是遵循阻力最小途径，这个重力来自于心理。 但你的进场、出场与市场本身并没有关系，因为市场仍然依自身阻力最小途径运行。同时在你进场买入的那个时刻，另一个人做出了卖出的动作，而这个人也是遵循着他自身的阻力最小途径，因为他认为再不卖出就会错过机会了。 阻力最小的途径是由结构决定的假如你现在身处50层高楼的办公室，下班后你决定要下楼，你一定会选择乘电梯而下，这是下楼的阻力最小途径。如果电梯因客观原因无法使用，那么你还有一个选择是步行走楼梯，这时步行走楼梯成为了阻力最小的途径。 这是由建筑物的结构决定的。 还有更为直线的距离是穿过每层楼的地板，或从窗口直接跳到地面，但这种路线不是建筑物的根本结构，也不是人的心理结构所能允许的。因为你很清楚，这样肯定会受伤。因而这种途径即使距离再短，却因为阻力太大你不会选择。 由此可以得出一个结论：阻力最小并不代表距离最短。 但是，如果因不可抗力因素导致电梯和楼梯都无法通行了，如火灾、地震等。这时你会选择等待救援，因此，等待便又成为了阻力最小的途径了。 由此又可得出一个结论：客观的结构与主体的重力相结合，就是最终的阻力最小途径。 结构决定行为，价格的走向由市场的结构决定同样的道理，交易者自身的根本结构会决定交易者的交易方法。很多交易者总是不断重复相同的行为，却期待着不同的结果，原因在于仅仅在表面上下功夫，而没有真正从结构入手，通常表现在用这项指标不灵时就改用另一项指标，或修改诸如均线这样的参数。而问题是这些指标犹如一棵大树的枝叶，你想真正地改变这棵大树，则必须从树根入手。 同理，如果想真正地改变交易的结果，则必须从市场的根本结构入手。 市场的根本结构决定着价格运行的阻力最小途径，当我们将自身的结构融入到市场的结构中，盈利会是阻力最小的途径。让我们一步一步来剖析市场的结构。 市场有四大要素：价、量、时、空价：价格 这是最根本的，因为我们买卖活动的盈亏仅依附于价格的变化，而与其他任何指标无关。 量：成交量 股市中有量在价先一说，因为主力要拉高某只股票，必须要先有吃货的动作，这在图表上就体现出了在某段时间内成交量稳步放大，然后再慢慢缩量锁定筹码的盘面特征。 但在期货市场，成交量的表现和作用与股市并不一样，把周期稍稍放长一些，成交量已然没有太大的意义了。 对比股市，一只股票的完整运作周期长达几年，主力运作某只个股，只要是进而未出，则之后必然会有拉升的过程。进驻时会稳步而集中的放量，拉高后出货时会凌乱地放量。 而期货由于换月的关系，在图表上看三个月前的成交量对于当下的行情，基本已没有任何意义了。这还仅仅只体现在主力合约的交换，需要跨三个月以上的品种。对于上海市场的金属类品种与中金所的股指，主力合约一个月一换，你要研究一个月以前的成交量，对于当下的行情也已经没有任何意义了。 但成交量对于短线的操作却有着不可忽视的作用，尤其对于在某段时间内成交量与总持仓的比例关系，直接关系到其日内盘口的活跃度，这表示交易者的参与积极性。 大成交量代表着大换手（成交量在行情软件右侧的信息窗口以“总手”两字显示，总手就是当天的成交量，而“换手”的意思是指当日总手与总持仓之比）。大换手代表着日内行情随时会产生大的波动，更重要的是越大的成交换手，越是说明参与的人多，越能使技术形态更好把握，形态越标准则越能让短线高手找到精准的进出场点位。 对于国内期货市场，现有20多个品种，真正具备每天都可有效参与的日内品种不超过一半。流动性是短线参与的首要考量因素，对于日换手量达不到持仓量1.5倍以上的品种，已经不是日内短线的首选了。能达到2倍基本上日内走势技术形态就比较准了，如果能达到5倍以上则日内行情相当活跃了，在换手这方面总的原则是越大越好。 时：时间，指速度 行情的运行需要时间，时间是大自然的规律，正如人生老病死一样，时间会化解一切，时间也会抹平一切。任何事物的发展都有其自身的特定时间，可以外在地加快或拖慢一些，但并不能改变过程这一时间要素。 就如现在的科技是日新月异，但再怎么发达，从深圳到上海，无论你选择任何交通工具，也不可能在3分钟内从此地到彼地。 行情的发展也是一样的，从一个底部到顶部，多大的级别就要多长的时间，走走停停是根本的规律，时快时慢是其节奏，因为市场是由人参与的。人具有喜怒哀乐、七情六欲，不同的情绪会导致效率的不同。就是纯粹的机械化的机器，也要在没有任何外力的影响下才能保持匀速运行。 空：空间，即幅度 这是我们参与这个市场的根本理由，如果我们已选择了一个市场，我们更愿意参与波幅较大的品种。 时间与空间的互换，是所有市场的常态，在国内的期货市场表现的更为淋漓尽致。 最常见的是因为外盘的关系，外盘晚上收一根大的实体K线，则内盘第二天几乎是必然以跳空的方式开盘，这就是以时间换取了空间，但它却受制于时间规律：本该用一天走完的行情，却以跳空的方式在短时间内把幅度走完了，则后面只能以小幅度空间来还回前面的短时间所产生的大空间。 时空互换的具体表现时空互换的具体表现，如图1至图3。 图1 美豆日线图 图2 A1209合约日线图 图3 A1209合约5分钟图 12月27日夜间美豆主力合约大幅上涨3.16%，第二天内盘主力合约跳空高开39个点。 相对于外盘的涨幅来说，这个开盘的幅度偏小。但对于内盘自身来说这个幅度仍然是大了，内盘本不该在这么短的时间涨出这个幅度，但是受外盘的影响却不得不高开，这就是以时间换取了空间。 但是却受制于时间规律，在开盘后即全天走出了震荡格局，至收盘时价格却比开盘价低了3个点。 开盘之后至收盘的走势就是用小小的空间换取了大量的时间，其实应该是还回了开盘跳空的幅度。 像这样的时空互换如何理解？ 首先需要对市场背景有个整体的认识：2011年下半年，美债过后的欧债危机已延续一段时间，所有的品种原油类、化工类、金属类、农产品类都已处于下跌后的反弹当中。 在这段时间里从基本面的情况来看，属农产品类的基本面情况较好，但从顶部跌下来是基本面让步于宏观面，并跟随了整体市场的方向。有句话叫做“覆巢之下，岂有完卵”，当整个金融市场都处于下跌之中，所有的商品都在下跌，即使豆类的基本面再好，也无法独善其身。 当时连豆的最低价已跌过4200以下，基本上就是在现货价附近了，而年底这段时间，宏观面与基本面的情况没有明显的利多也没有明显的利空，因而整个市场大体是处于一个震荡反弹行情。 由于豆类在这段时间偏强，所以在日线形态上走出了短期上涨的行情，但这种偏强仍是受制于整体的弱势，从根本上来说市场并没有真正地转为涨势。所以即使受外盘大涨的影响而高开，但高开后就无法继续强势了。 持仓量：期货市场的特有要素（1）国内期货市场中，持仓量指的是买入（或卖出）的头寸在未了结平仓前的总和，一般指的是买卖方向未平合约的总和，所以一般都是偶数。 （2）国外期货市场的持仓量是指所有交易商到当日收盘为止累计的未平仓合约的总数，是买盘或卖盘的单边总和，并不是双方之和，所以持仓量奇数和偶数都有。 （3）国内金融期货沪深300指数期货应用的是单边总和，所以持仓量奇数和偶数都有。 持仓量最大的是主力合约，这是基本常识。 但持仓量这一指标，在实战中研判也并不是一些技术普及书中所说的那么教条和简单。同样的放量增仓，在行情所处的位置不同所代表的意义是完全不同的。 具体来说，就日内行情而言，如果当日并不是处于行情发展的某个关键位置，则持仓的变化仅能供研判日内行情。 但某日如果是处于行情发展的一个关键位置，则持仓量的研判不仅仅对于日内行情有着重要的价值，对于是否选择隔夜持仓则有着更重要的意义。 持仓量的研判，越随着时间周期的延长，其作用越来越小，越要让步于宏观面、基本面，甚至于技术形态。 在平时大多数交易者使用的博易大师的软件里，分时图里持仓量是以一条曲线的形式，与成交量叠加在一起，分时图盘中的增仓与减仓一目了然。 但在K线图中持仓量是以柱状图显示，这样在视觉感受上和成交量相似，但持仓量的增与减看起来不太明显，这里有个小技巧，可以把持仓量的柱状图改为曲线形式。 先点击持仓量的柱状图，再用鼠标右键单击，然后选上“修改公式”，在指标编辑器里，把下面框内的后一个词删除掉，包括标点符号，仅仅留下“AMOUNT”，如图4所示。 图4 把持仓量由柱状图改为曲线图的步骤 图5是PTA的30分钟K线图，在持仓量这一栏内是软件初始设置，持仓量是以柱状图显示的，在经过修改之后，就成了图6所显示的曲线图了。 图5 以柱状图显示的持仓量 图6 以曲线图显示的持仓量 这两幅图表，在各项数据上是完全一致的，唯一的不同就是持仓量指标的显示方法。可以很明显地看出来，以曲线图显示的持仓变化，其增减情况一目了然。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>战期货</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[markdown1]]></title>
    <url>%2F2021%2F01%2F07%2Fmarkdown1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： \overline{R}]]></content>
  </entry>
  <entry>
    <title><![CDATA[2-我对金融市场运行规律的认识]]></title>
    <url>%2F2021%2F01%2F03%2F2-%E6%88%91%E5%AF%B9%E9%87%91%E8%9E%8D%E5%B8%82%E5%9C%BA%E8%BF%90%E8%A1%8C%E8%A7%84%E5%BE%8B%E7%9A%84%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 从本章开始我将介绍我的一整套投资体系，包括我对市场运行规律、对交易策略、对投资行为和投资者整体修炼的认识。 金融市场是混沌的混沌是什么？分形是什么？由于我的学术研究工作刚好就是关于混沌系统及其应用的，所以我对二者的数学定义和物理意义是很清楚的，不过我在这里不想追求学术上的严谨表述，只给读者一个通俗但较准确的介绍。 混沌通常是指确定性系统中出现的随机运动，即在一个确定性的动力学系统中（即一组微分方程组或迭代方程组，没有任何随机项，初值也是确定的），随着非线性作用的增强，系统所出现的随机性现象。混沌运动是介于确定性运动和随机性运动之间的一种稳定的中间状态，体现了确定性和随机性的统一。也就是说，从微观上看，混沌运动非常不稳定，具有很强的随机性，但从宏观上看，混沌运动又具有确定性的特征，比如数学方程是确定的，不带任何随机项，把混沌运动描绘出来，则整体形状是非常稳定的，以及其他一些统计特征也是确定的。可以这样理解，在混沌运动中随机性占主导地位，但又残留有少量确定性的特征。混沌运动最重要的性质是初值敏感性，即两个完全相同的混沌系统从几乎完全相同的初始条件开始演化，它们的轨道也很快变得完全不同，所谓“失之毫厘，差之千里”，媒体一般通俗地称之为“蝴蝶效应”。初值敏感性又导致长期行为不可预测性。由于混沌理论彻底粉碎了机械决定论，又加上混沌运动在自然界和人类社会广泛存在，是普遍规律而不是特例，因此混沌学被誉为是继相对论和量子力学之后的第三次物理学大革命。 分形是指外表极其丰富多姿或破碎杂乱，但其内部却有层次性、自相似性、递归性及仿射变换不变性等确定性特征的一类现象或体系。分形最令人惊奇的特性之一是其维数不是整数的，比如1.5维，2.8维等。大自然中的事物绝大多数以分形的外观存在，比如气象、云彩、山脉、树木、河流、海岸线、动物的血管、神经系统等，随处可见。若把混沌运动描绘出来，则其整体形状的横断面一定是分形的，由于有这种联系，学术界普遍接受分形就是混沌的几何表现这种说法，虽然尚未有严格的数学证明。 金融市场是混沌的吗？对这个问题已经研究了几十年了。埃得加·E·彼得斯是美国知名基金经理，他在这方面做得很好，已经出版了几本著作，其中《资本市场的混沌与秩序》，《分形市场分析-将混沌理论应用到投资与经济理论上》两本被翻译到国内，以下的内容就引自这两本书。 在混沌理论中，对一个过程的刻划有一个统计特征量，称为赫斯特指数H，当H=0.5，则表明这个过程是一个独立随机过程，就是说当前这一时刻的取值是随机的，并且和前后时刻的数据毫无关系；当0&lt;=H&lt;0.5，则这一过程具有反持续性，就是说它比独立随机过程更快地翻转自身；当0.5&lt;H&lt;=1.0，则表明这一过程具有长期记忆效应，也即今天发生的事情对今后会产生持续性的影响，而过去发生的事对今天也有残留影响。这种长期记忆效应，正是这类过程会产生趋势的原因，也对应于混沌的初值敏感性（因为对初值不敏感，则要么演变成确定性过程，要么演变成纯随机过程）。 令人十分惊奇的是，对于自然界的现象，其H指数大都介于0.7到0.8之间，几乎找不到H=0.5的情况，这正说明自然界的事物大多是混沌和分形的。 彼得斯用大量证据证明了金融市场的价格走势，其H指数也是介于0.7到0.8之间，因此金融市场是典型的混沌系统。彼得斯还据此提出了分形市场假说。这些工作从一个侧面也表明了，用纯粹随机性的正态分布来描述市场的正统的有效市场理论是不符合事实的（而行为金融学则从实验方面给有效市场理论以致命一击）。 既然金融市场是混沌的，那么用混沌算法产生的数据来模拟市场数据，就是最好的人工模拟了。图2-1是我用混沌算法产生的K线图，可以看出它和真实的市场数据完全相似。 图2-1 用混沌算法产生的模拟市场数据的K线图 过去，囿于科学发展水平，一线投资者对于正统学院派所鼓吹的随机游走理论虽然感到荒唐，却也无力彻底驳倒，因而备感困惑，甚至一些大师级人物也在其著作中表示了这种困惑。现在，真相大白了。图2-2是真实金融市场（SP500）产生的头肩顶，其赫斯特指数H=0.78。图2-3为用纯粹随机过程产生的头肩顶，其赫斯特指数H=0.5。我可以清楚地告诉读者，二者看起来很相象，其实有本质区别，形似而神不似！导致金融市场出现趋势和形态的背后原因是长期记忆效应及随机性的游程，而导致纯粹随机过程出现假趋势和形态则仅仅是游程在做怪（关于游程我下面还要详谈），所以H指数就差很远了。然而，因为在真实金融市场中也是随机性占主导地位，所以二者肉眼看起来有相似之处，也并不令人奇怪。 图2-2 SP500指数产生的头肩顶，其赫斯特指数H=0.78 图2-3 纯粹随机过程产生的头肩顶，其赫斯特指数H=0.5 金融市场是混沌的，还导致另一个重要结论：金融市场存在非周期循环，因为不稳定周期轨道正是混沌运动的骨架，所以市场存在循环不意外，只是这种循环的周期不是精确的，只存在一个大概的平均值。 对于我们实战派来说，金融市场是混沌的，告诉我们几个至关重要的结论： （1）市场是随机性占主导地位，但又残留有确定性的规律，我们的任务就是要找到并利用这些规律。 （2）市场趋势是因长期记忆效应而产生的内禀性质，我们一定要善加利用。 （3）市场存在非周期循环，我们要找出这种循环的平均周期，并不需要知道精确的时间，只要心中大概有个数即可，因为到时候一切还得以实际走势为准。 （4）因为市场充满了随机性，所以我们并不需要对每一个走势都要问个为什么，有时候纯粹是因为随机性而没有别的原因，我们只需要牢牢把握住走势即可。 （5）还是因为市场充满了随机性，意外随时都可能发生，所以仓位永远不可太满。 （6）所有的技术指标都有很大的局限性，因为技术指标就是企图给混沌运动的微观行为建立模型，而如何给微观的混沌运动建模，至今在学术界都是个未解的难题。 青泽认为，科学企图用细线条、定量和精确的语言来把握市场，因而备感困惑、尴尬和无奈，而哲学用粗线条、定性和模糊的语言，却能很好地把握市场。这种结论我认为在很大程度上是对的。从学术上来说，对于周期性的波动可以用三角函数描述，对于随机性的白噪声可以用高斯过程描述，可是对于在微观上如何描述“混沌波”，至今还写不出一个解析表达式来，束手无策！如果要建模，那就得建成一个宏观的、整体的动力学系统，而对于微观的“混沌波”还是没法描述。从实战的角度来说，很多趋势非常明显的行情，用肉眼一眼就看出来了，可是用电脑愣是认不出来，这是因为要想让电脑识别趋势，首先要对趋势进行描述，也就是对趋势建模，可是欲对趋势精确建模，实质上就是要对“混沌波”精确建模，其难度可想而知了。这就是我在花了大力气开发电脑自动交易系统后，现在做长线时却偏爱用人工交易的原因。 金融市场的特征时间尺度是多少？这个问题在数学上是荒唐的，因为混沌系统无任何特征尺度，可是在物理学上却是有意义的，现实的混沌系统毕竟和理想的混沌系统有差别。比如一棵树是分形的，可是如果我们用毫米的尺度来量它，就是说假定我们的眼睛每次只能看一毫米那么远，那么我们能看清楚一棵树的整体形状吗？我认为很难。反过来，若用10米的尺度来量它，就是说凡是小于10米的细节我们都看不见了，则也不能准确地把握树的形状。显然，比较合理的尺度是米、分米。金融市场的特征时间尺度，我认为是月（至少对外汇以外的交易品种），就是说市场的有意义的走势变化，是以月为时间单位的，市场振荡几个月，然后又走出明显单边趋势几个月，然后再振荡若干个月。当然这只是我的实战体会，并无严格数学证明。这就是说，我们考察市场，要以月为时间单位，至少也要以周为时间单位，这样才能把握整体局势，因此，等待市场机会，则不得不整月整月地坐等了，而耐心就成了投资者必须具备的首要素质。如果所使用的时间尺度远小于市场的特征尺度，比如日、小时、分、秒，则投资者会被淹没在随机噪声的汪洋大海之中，因为在这个尺度上确定性的因素已经残留到几乎等于零了。 为什么说耐心是一种智慧？因为从微观看，市场走势充满了随机性，每天的涨涨跌跌，和每小时、每分钟、每秒钟的涨涨跌跌，这些涨涨跌跌并没有太多的规律可言，操作时间太短，就得跟这些随机性做很难赢的搏斗，就算勉强找出某些规律性的东西，为了等候信号出现，必须斩头除尾，这样所得就甚少了；另一方面，虽然从细节上看走势充满了随机性，可是从粗线条上看，走势却又具有明显的方向性！这真是一种很奇怪的现象！我把它称为“随机性上涨”或“随机性下跌”。 关于艾略特波浪理论我有一个未经证实的猜测。在混沌理论中，随着非线性作用的增强，系统从确定性运动逐步向随机性运动转化，在这个过程中，各个不同模式的确定性运动（专业术语称为KAM环面）的转化难易程度是不同的，最难转化的甚至最后可能残留着不转化的模式（称为贵重KAM环面），它们的某个参数都是最前面的那几个斐波那契神奇数字！斐波那契神奇数字在自然界也是广泛存在，而波浪理论也很依赖于这些数字。所以我猜测波浪理论与混沌可能有某种未知的联系。不过我在实战中不喜欢用此理论，反例太多了。 既然金融市场是混沌的，而随机性又在混沌中占据主导地位，那么对概率性过程的准确理解就对实战有重要意义。下面对涉及概率的两个问题进行辨析。 （1）游程 游程是指在随机过程中相同结果连续出现的次数。游程是广为被人忽视的一种现象。例如连续抛100次硬币，在未抛之前，读者可以先在脑海中想象100次结果，在纸上写下来，然后真正去抛，你会发现你主观想象的结果和真正抛出来的结果相差甚远，差别就是连续正面或连续反面的次数比你想象的要多得多！下面是我亲自抛的100次结果（1表示正面，0表示反面）：121100111100 1110100101 0111111101 0001100110 10011011110110000010 0100100011 0111000100 0111110011 0101100000 游程统计如下：1游程20次，2游程16次，3游程6次，4游程2次，5游程3次，7游程1次。这就是说，硬币的一面只连续出现了一次或两次就反转的次数只有36次，而连续出现三四次才反转的情形非常常见，连续出现五六次的也时不时碰到，连续出现七八次的也不算罕见。这说明什么？说明即使是纯粹的随机过程也会出现“趋势”和“形态”，一个正的5游程再跟一个反的2游程，再接一个正的4游程，不就是一个“趋势”吗？形态的形成也是类似。 游程还是所谓的“运气”的本质所在。俗语“祸不单行”， “屋漏偏逢连绵雨”，“人一背运就是连喝水都喳着”，说的就是碰上了一个坏的游程。迷信的人则把接二连三的倒霉事归结为冥冥中有股神秘的力量在控制着自己的“命运”。赌徒和经常打牌的人对“手气”都有切身体会，四个水平相近的人一起打牌，其中一对却是一整晚都摸到臭牌，因为经过充分洗牌后的发牌是一个随机过程，再加上样本容量严重不足，一个大的坏游程就足以整晚都搞垮一对牌手了。同样是这几个人，过了几天再一起打牌，情况也许就完全不一样了。 游程不但影响着行情走势，而且对交易策略也有重大影响。试想，即使你的交易系统有50%的胜率，那么你连亏五六次也时不时碰到，连亏七八次也不罕见。更何况很多性能良好的交易系统，其胜率并没有达到50%。如果你不明白游程这个概念，你会信心尽失，如果你不能保证自己在看错时小亏，那么你很快就会爆仓！ 游程，这个既不能预测又不能控制的随机现象，是交易员的一个真正的杀手。 由于游程既不能预测又不能控制，所以当我们连亏几次时，惟一的办法就是轻仓，或者干脆暂停操作，以等待这个坏游程过去。 （2）小样本问题与大数定律 所谓大数定律，意思是说，当一个随机试验重复足够多时，某一个结果出现的频率应逐渐接近于它的概率。大凡学过概率论的人，这种观念往往根深蒂固，殊不知，人们往往对重复多少次才算“大数”毫无概念，误以为生活中碰到的事都符合“大数”的要求。恰恰相反，虽然没有严格的数学证明，但我认为，对具体某一个人而言，他一生中几乎所有碰到的事，都只是小样本事件，也就是重复次数远远没有达到“大数”的要求，因此概率规律离他远得很，偶然性在发挥着巨大的淫威。有的人“好命”，有的人“歹命”，就是这个原因。君不见，有的人出生在官宦人家，这就注定他这一生大多数事情都是很顺利的，对于普通民众，即使终生努力打拼，多数也只能搏个事业小成；还有的人，本来生活得好好的，忽然一场大病，从此人生完全改观；还有婚姻嫁娶，婚前千挑万拣，婚后有多少人还不是离婚收场或苦苦度日，这里面有多少分量不是出于偶然性呢？ 具体到抛硬币这件事上，大数定律是说正反两面出现的机会一样多，但多少才算“大数”，我看要上千次才算，一百次是不够的。而且正反两面机会一样多是一个非常“宏观”的结论，它并不要求在“微观”上也是处处正反两面次数一样多，所以它容许大游程的存在。 在交易上，很多人所使用某个具体交易策略进行的交易，其次数往往远不足以评价这一策略是否真的有效，因此其结论就非常主观了。进行历史数据测试，至少可以扩大样本容量，提高结论的可靠性，所以这是必不可少的一个环节。 行情框架理论考察一样事物，当我们感觉它如同一团乱麻，分不出孰轻孰重、孰主孰次的时候，往往也就是还不能对它很好把握的时候。当我们能够从总体到局部，从宏观到微观至少大体地划分出一个结构的时候，我们对它的轻重主次心中就有点数了，这就是我们开始能够把握它的转折点。 行情框架理论是我在实践中摸索出来的，关于期货市场行情走势的时间结构和空间结构的一套理论，其中时间结构部分是我独创出来的，空间结构部分则是由我在借鉴了前人的实践经验并结合自己的实践感悟总结而成。这套理论的目的并不是企图去预测行情走势将来如何演化，而是对目前已经走出来的行情走势做一个归类，给行情定性，从而针对不同性质的行情采取不同的交易策略。不企图去预测，而是强调跟踪，并且对跟踪出来的走势归类定性，这正是典型的面向交易员的理论。 时间框架期货市场的时间结构如何划分？我认为，趋势是行情走势的中心概念，因此对行情走势划分时间结构，本质上就是对不同性质的趋势作一个归纳分类，对每一类趋势的运行特点心里有数，以便从容应对。这套理论并不试图去穷尽行情的一切走势形态，如果能够描述大部分常见的走势形态，则对实际操作已经有很大帮助了。 下面从几个基本概念讲起。 振荡行情：指小幅箱体振荡，往往不值得参与。振荡行情很常见，例如图2-4是郑州PTA（精对苯二甲酸，一种化工原料）上市不久后（2007年1月底到3月底）的振荡行情，我曾在创上市新低的那天试探开仓做空，结果只下跌了三天就陷入振荡，我在开始振荡的第七个交易日平仓出来观望。 图2-4 郑州PTA上市后不久在2007年1月底到3月底的振荡行情 中级行情：指周线上很明显的连涨或连跌，往往持续8周左右，价格变动幅度大约在20%-40%，在农产品中最常见。中级行情的稀缺性和持续性都很明显，最典型的情况是，一个品种一年2波中级行情，运气好有3波，运气差就1波。例如，图2-5是大连豆油在2006年10月和11月的中级上涨行情。 图2-5 大连豆油在2006年10月和11月的中级上涨行情 超级行情：若行情一波一波地连涨（跌）七八个月，则是超级大牛（熊）市了，往往持续2-3年，价格变动幅度大约在1倍到3倍，多见于工业品和金融期货。超级行情的稀缺性和持续性更明显，每隔几年才一次。例如图2-6是伦敦铜在2003年到2006年上半年的超级大牛市行情，图2-7是原油在2004年到2006年8月的超级上涨行情。 图2-6 伦敦铜在2003年到2006年上半年的超级大牛市行情 图2-7 原油在2004年到2006年8月的超级上涨行情 鸡毛行情：指连周线都粗糙的缺乏持续性的振荡盘跌（或振荡盘升），类似于鸡毛飘来飘去地逐级下跌，没有力度，缓慢下跌，一阵微风吹来又显著快速反弹一阵，然后再继续下跌。因为没有力度，所以阻力位的作用往往明显。鸡毛行情是最常见的单边趋势，也最难把握，持续时间很长，往往大半年。鸡毛行情的常见性和持久性往往被人重视不够。例如，图2-8是郑州棉花在2006年2月到10月的一波鸡毛下跌，图2-9是大连豆粕在2005年6月到11月的鸡毛下跌。 图2-8 郑州棉花在2006年2月到10月的一波鸡毛下跌 图2-9 大连豆粕在2005年6月到11月的鸡毛下跌 一波一波，这实际上是对应于道氏理论中的一段主要趋势和一段次要趋势所构成的一个个“N”，我家乡有一句土话很形象地描述这一特性，但用文字我不知道该如何说，大意是类似于撬动一块很重的石头，一开始石头一动不动，接着有点松动了，在“嗨哟”、“嗨哟”几个来回后，每一个来回石头都往前挪一小点，最后大家一声断喝，石头“嘭”的一声被撬的老远！发动一波行情的过程和撬动一块大石头的过程是非常相似的。道氏理论是我欣赏并应用的惟一一个分析理论，我欣赏它仅仅是因为它简单实用。波涛的书 和斯波朗迪的书对道氏理论都有很好的解读，波涛的解读尤其精彩。然而，即便如此，我也觉得他们的解读过于复杂。从实战角度看，任何的理论、策略、方法都应该简单到无法再简单，故而对道氏理论我只取三条：①行情可以划分为主要趋势、次级趋势和日内杂波；②相关品种的走势要相互印证；③次级趋势和日内杂波可以被操纵，但主要趋势无法操纵。 由于中级行情、超级行情和鸡毛行情都可以被包含在“一波一波”中，所以这个概念无法用来给行情定性，但用来研判行情的突破方向和大体上处于哪个阶段却是非常有用的。 广义多头、空头陷阱：这是为了达到删繁就简的目的，而把几种相近的情况归纳起来，包括针对近期的头、底所成的多头、空头陷阱，也包括针对远期的头、底所成的多头、空头陷阱，还包括对近期、远期的顶、底所形成的阻力位所造成的价格回走（若价格走了较远距离后才碰到此顶、底，则阻力位有效的可能性极大），以及一波中级行情后期的激烈回抽，甚至包括主趋势明确时次级趋势拐弯处的多头、空头陷阱。广义多头、空头陷阱是一类常见的走势形态，具有较好的参考意义。如图2-10是CBOT豆粕在2007年3月初对2005年6月中旬形成的广义多头陷阱，对这种创了新高再回落的陷阱，其参考意义更大，也即斯波朗迪所说的“2B法则”。 图2-10 CBOT豆粕在2007年3月初对2005年6月中旬的广义多头陷阱 我把期货行情分成四类：振荡行情、中级行情、超级行情、鸡毛行情，实际上也就是把趋势分成这四类，它们组成了整个行情的主干，又可以统一用“一波一波”描述，广义多头陷阱和广义空头陷阱则组成了行情的端点，从底部、顶部整理区开始创新高、新低以后构成行情的中间阶段，次级趋势拐弯等构成行情的辅助转折点。在行情的主干，也就是中级行情、超级行情和鸡毛行情，我们要强调顺势而为， “市场永远是对的”，而在行情的端点，也即广义多头陷阱和广义空头陷阱，往往市场情绪物极必反，也就是到了大师所说的“市场经常是错误的”时候。 一般情况下，新兴市场的热门品种的上涨只有中级上涨行情和超级上涨行情两种方式，而下跌则有中级下跌行情和鸡毛盘跌两种方式，冷门品种的自主行情则是很温和缓慢的中级行情，而成熟市场（如美国）的大品种有时也有长期鸡毛上涨行情。图2-11是SP500在2004年底到2007年初的鸡毛上涨行情。不过即使在新兴的股票市场，比如国内股市，对个股来说鸡毛上涨也非常普遍。这是因为鸡毛上涨能让散户熬不住而充分换手，极大地抬高了散户平均持股成本，对于资金量大的主力投资机构来说，是属于稳打稳扎的做法，广受推崇。所以我经常觉得，如果单靠技术分析方法来操作，则股票比期货难度要大，因此做股票要更多地参考基本分析。对付鸡毛行情和超级行情，达瓦斯的“箱体理论”是个不错的技术方法，但是箱体上下轨确立的天数可能要从他所说的3天放缓到若干天。 图2-11 SP500在2004年底到2007年初的鸡毛上涨行情 中级、超级行情的形成，其条件很苛刻，一般不会容易形成，所以，一旦一波中级上涨行情结束，人气一涣散，那么接下来的很可能就是鸡毛下跌行情了！在其他情况下，只要情况不是非常明朗（明显的振荡行情除外），那么就可以当作鸡毛行情来做，这样做对的概率是很大的。 中级行情和超级行情的重大区别：中级行情持续时间短，一般2个月左右，人气旺，连涨连跌的持续性好，顺势追涨、追跌，短时间内见效快，而超级行情持续时间长，至少大半年，因为时间太长了，所以人气没那么旺，连涨连跌的持续性没那么好，经常是一步三回头，故对超级行情的追涨、追跌短时间内见效差。但是在超级行情的末期，它又很容易演变成以中级行情的方式狂奔，最后在疯狂中结束。 对期货的超级行情，耐心持仓是惟一选择。但对股市指数的超级行情，可以介入那些上涨趋势明显而最近又整理了若干天的个股或权证，然后持仓等待，因为不知道主力哪天才拉升，而拉升几天后则须平仓，再重新介入那些上涨趋势明显而最近整理了几天的品种（其实这样做很容易搞坏心态，耐心持仓股指期货或ETF权证是最好的选择）。 多头行情和空头行情的区别：一波中级上涨行情需要有明显的放量支持，而且气势很猛，上涨连续性很强，很少有大的回调，即走势很光滑（仅对新兴市场，对美国的成熟市场不适合）；一波中级下跌行情却不需要放量，但下跌连续性也强，走势也光滑；鸡毛下跌行情不需要放量，连续性不强，走势不光滑，常常进二退一，经常有较大回调，或长时间的振荡。 在顶部整理的时间往往不长（尤其是农产品），而在底部整理的时间往往很长，即所谓“尖顶宽底”。 通常从底部回升的第一波往往是中级行情，当这波中级上涨行情走到很极端的价位时，如果有一天突然跌停，再大幅振荡几天，那往往就是见顶了;这个顶往往就是此后至少几个月的最高点了！为什么这么说？因为一个品种一年一般只有2波中级行情（偶然运气好会有3波），所以一旦大幅振荡回落，不久又再次走出一波中级上涨行情的可能性是很小的，下一波中级上涨行情通常至少也得等好几个月，而在这期间价格一直都窄幅整理的可能性不大，所以最可能的情况是：从中级上涨的尖顶处大幅振荡回落后，再反弹构筑个时间较短的顶部整理区，然后再以鸡毛行情的方式跌两天涨一天地慢慢下跌几个月。这样的下跌会持续到什么时候呢？跌到前期较远价位处的某一个底部的支撑位附近为止，此时，价格大幅反弹，再箱体振荡整理，构筑时间较长的底部整理区，然后，要么直接上涨，要么下跌形成一个广义空头陷阱再涨，从而开始一个新的中级上涨行情。 一旦一波中级上涨行情见顶，我们就以这个顶为一个端点画一条下跌趋势线，一两个月内再涨上去的可能性不大，所以反弹时可以尝试做空。 反之，若一波中级上涨行情结束后，振荡几个月都不肯下跌，那么一旦创新高则形成一波新的中级上涨行情（对农产品），或一波超级上涨行情（对工业品和金融产品）。 一波中级下跌行情结束后，振荡大半年，则重新上涨或是走鸡毛下跌行情，得看突破方向。 我在这里对行情走势的可能演化做了一个框架性描述，有读者看了说不定会哑然失笑。的确，我也从来不认为任何试图对行情演化建立框架的理论有多大价值，因为这跟试图预测未来没多大区别。我在这里只不过是对我这几年来碰到的最典型的一些情形做一个描述罢了，也许明年、后年的行情就会以另一种完全不同的方式运行，天知道！所以这个演化框架并不重要。我要再次强调，行情框架理论的目标不是企图去预测行情走势将来如何演化，而是对目前已经走出来的行情走势做一个归类，判定它是振荡行情、中级行情、超级行情还是鸡毛行情，从而采取不同的交易策略，它所说的框架是指判断目前的走势是属于这四种行情中的哪一种，而不是说将来会演变成哪一种。把握好现在的行情才是最重要的，对于将来怎么样没必要去管。 当一波激烈的中级行情真正确立后，由于原来没有仓位而不敢追高、追低开仓，或有少量仓位而不敢加仓，都是源于对行情之恐惧，这是人性当中根深蒂固的一种恐惧！是人性的本能！其实这个问题可以这样从统计角度理解：一波中级行情最可能持续8周左右，在中间的第三、第四周的任何一天介人，则刚好买在最高点或卖在最概都只有大概1/20-1/40，这个概率非常小！风险回报率非常之高！ 因为一个品种通常一年才两波中级以上行情（偶然才有三波），所以一波行情结束不久就发动另一波行情的可能性很小，或者一个品种的行情结束就马上碰到另一个品种行情发动的机会也是很小的。每次当我们要开仓时，我们都要多问几次自己：真的这么快就又有机会了吗？一年才两波！所以每次做完一波行情，我们都要休息一段时间（连看盘都不要看）。如果我们舍不得休息，那就说明心里还是太贪，怕错过机会！因为中级行情的机会是很少的，即使每天沉迷在交易、看行情、看新闻评论、思考行情这些细节的事情上，中级行情的机会还是不会因此而增多！相反，我们会因此而浪费了时间和资金！ “过度关注”这个词很恰当（与过度交易对应），指过于频繁地看行情、看新闻、看评论，老惦记着它，搞得其他事都不能安心做（这也是过度交易的直接原因）。这是一种投资心态上的大毛病，造成时间和金钱的大浪费，以须适当地忘掉它！再怎么看，一年也还是只有两波中级行情！看得再多，它也不会因此增加！ 投资体系指一整套和自己个性适合的逐步稳定下来的投资理念、心态、策略、技术。中级行情和超级行情的稀缺性和持续性这两个统计规律，决定了：①投资体系的原则应该是“迅速止损，放足盈利”，也就是说，要做到“厚利少销”，而不是“薄利多销”。这是和做实业很不同的地方。“迅速止损”说明没抓到数量稀少的中级、超级行情，需要赶紧出来；“放足盈利”说明抓到了中级、超级行情，需要充分利用好其持续性。②投资成功主要是靠守株待免，而不是四面出击。正确的投资体系是在行情经常路过的地方挖好陷阱后被动地守株待兔，而不是主动地四面出击，“陷阱”就是指稳定的投资体系。还是因为稀缺性，机会本来就不多，四面出击抓到的肯定是大量假机会。 空间框架如何划分全球期货市场的空间结构？在我看来，只需要关注5个指数、8类独立品种，就可对全球期货市场在空间上有一个全局性的把握。 5个指数：指美元指数、CRB指数、原油指数、黄金指数（即黄金走势）和道琼斯指数，这些是我每天必看的指数。 美元指数对全球的商品和股票有着根本性的影响，一旦美元指数走出大的单边行情，毫无疑问将导致几乎所有的期货品种和股市走出翻天覆地的大行情，不过这种情况每隔几年才发生一次。如图2-12是美元指数从2002年到2005年的一波罕见的超级下跌行情，结果这几年几乎所有的股市、能源、金属、农产品都走出轰轰烈烈的大牛市。 CRB指数是由绝大部分商品期货组成的指数，其中能源和金属占大头，因为有时候股市没有大行情但商品期货有大涨跌，所以这个指数很重要。 而能源在工业品中占据最重要地位，还有很多其他商品来自或部分来自石油衍生品，甚至由于这几年生物能源概念的兴起，连农产品都对原油的走势敏感起来，所以必须牢牢把握好原油指数。 黄金作为保值的贵金属，其走势和一般的商品期货有较大区别，我感觉它颇带有一些汇率的特征，比如假突破很多，不过还是保留有一部分商品的特点，一般情况下，原油大涨则黄金必然大涨，而黄金一涨则铜、铝、铅、锌等基本金属也跟涨，同时澳元、英镑也会跟涨，所以把握好黄金走势对做金属和外汇很有好处。 至于道琼斯指数或SP500指数，无疑是全球股市的风向标，不可不察，其他股市的股指，比如日经指数、恒生指数，很多时候简直就是道琼斯指数的跟屁虫；股市涨跌，往往是经济体系中的某些行业起了大变化，必然涉及到相关的商品期货。 图2-12 美元指数从2002年到2005年的一波超级下跌行情 8类独立品种：我把全球所有的期货品种分成8大类，每一类走势都具有较大的独立性，而各类内部的品种则具有高度相关性。它们分别是：①粮油，包括大豆、豆油、豆粕、棕榈油、菜籽油、玉米、小麦；②调味品，主要指白糖③棉花；④金属，包括铜、铝、锌等；⑤能源，包括原油、燃油、PTA、塑料等；⑥林产品，如天胶；⑦股指，如恒生指数、国企股指数；⑧利率（国债）。 这里我没有把外汇期货包括进来，原因是外汇的走势和一般的期货、股票走势的差异太大了。生猪、猪腩、牛肉、咖啡、可可、橙汁、木材也没算进来，因为我觉得至少在目前我们还没有很大机会交易这些品种，所以我目前只关注这8类品种。如此一来，全球的期货在我眼中也不过近似于8个独立品种而已！相比于股票市场中的上千只个股，期货市场的品种真是容易把握多了！ 相关品种走势的相互验证和背离，是取自道氏理论的一个重要原则。当外盘、内盘、现货、同类内其他品种，这四方面的走势都印证一波行情时，就是该大胆放手去操作的时候。 热门品种与冷门品种：热门品种指介入资金多、走势活跃、涨跌幅度大、涨跌有力度的品种，而介入资金少、涨跌无力、走势沉闷的则是冷门品种。某一类独立品种中，往往只有一两个具体品种是热门品种，其余的都是冷门品种。比如国内粮油类的大豆、豆粕、豆油是热门品种，玉米和小麦是冷门品种，金属类的铜、锌是热门品种，铝是冷门品种。热门、冷门品种走势截然不同，热门品种可以连续追高、追低加仓，冷门品种则不能这样操作，当冷门品种某天走出大行情，则第二天往往不是继续往前走，反而往回退了。只要热门品种有行情，则应该避免介入冷门品种。冷门品种之所以冷门，其背后有深刻的基本面因素，或是品种太大，或是交割制度有不合理之处，这些基本面因素长期存在，所以冷门品种要想脱骨换胎变成热门品种，几乎是不可能的事。每次当市场主力资金对峙在冷门品种上，则简直是场灾难，因为冷门品种注定是扶不起来的阿斗，但资金集中在此，搞得其他热门品种的机会也少了，如2006年大量资金对峙在大连玉米上（图2-13），使得农产品市场各品种的走势都很沉闷。 图2-13 2006，2007年资金对特在大连玉米上，使得农产品市场很沉闷 自主行情与跟风行情：从走势独立性看，又可分为自主行情（独立性好）与跟风行情（独立性差）。热门品种一般为自主行情，偶然的情况下也会有跟风行情，往往出现在长假刚结束或有重大事件的时候，一般是跟风同一交易所的另一个不同类的热门品种，比如铜猛涨会导致燃油、天胶也涨，但热门品种的跟风行情时间很短，顶多几天，甚至只有一天，所以若原来打算平仓的话此时是好时机。图2-14是大连豆粕在2006年2月6日的一次跟风行情，只维持了两天，当时是春节长假后第一天，几乎所有的工业品都涨停，豆粕也被迫跟涨。冷门品种的跟风行情很常见，持续时间较长，每次当热门品种行情明显时，若冷门品种也同向涨跌，则为跟风行情，不值得参与。但当热门品种无明显趋势，而同类的冷门品种却走出趋势明显的涨跌，则为自主行情。比如大豆没有大的涨跌，小麦、玉米、棉花却趋势明显，或铜没有大的涨跌，铝却趋势明显，则往往是真实的自主行情，因为这些冷门品种大多是大商品，惯性很大，一旦走出自主行情往往持续较久，有可能连收很多周的阳线或阴线，所以很值得参与（并不是说冷门品种就一定不值得参与）。冷门品种的自主行情往往每天价格变动不多，但经常连续走两三个月，所以不能连续加仓（否则一个大回调导致风险收益不相称），还要注意若同类热门品种同向大涨跌，则会加速冷门品种的走势，反之，若同类热门品种反向大涨跌，则会导致冷门品种大回撤。冷门品种的上涨几乎都是跟风行情，但下跌却有可能是自主行情。在一波热门品种的中级上涨行情中，相关的冷门品种往往会被动地跟涨，但是一旦热门品种见顶，则这些冷门品种会下跌得更厉害！ 图2-14 大连豆粕在2006年2月6日的一次跟风行情，只维持了两天 各热门品种行情的最优、次优机会评估：有的品种虽然显露出将有一波行情的迹象，但却很可能处在行情的后期（从而有反复振荡的危险），或者刚走完一波中级行情回调不久（说明整理时间还不够，也会反复振荡），而另一些品种虽然还没突破，却有要突破的迹象，最要紧的是一旦突破就是一波中级行情的起始阶段，在这种情况下，我们宁肯等一段时间再去介入这个起始阶段的品种。 强者恒强弱者恒弱：股票、期货皆有强者恒强、弱者恒弱之规律。一般情况下，股票的弱者恒弱表现为别的股涨而它老不涨，而期货的弱者恒弱不但表现为其他品种涨它不涨，还表现为当涨得凶的品种开始凶猛下跌时，走得弱的品种却也还是弱势振荡，下跌也无力。故一旦形成强者、弱者之明显区分，则不管上涨做多还是下跌做空，大半年内不宜去碰弱者，而应该做强者。另一方面，一旦一个品种形成弱者，则有其深刻的基本面原因，一厢情愿地死等它重新活跃起来，而忽略其他强势品种，就像对一个正处在下跌趋势的品种一厢情愿地等待做多机会一样，是很愚蠢的！ 技术面和基本面的关系：对交易员来说，不是新闻、消息、政策、经济数据本身的含义有多重要，而是市场走势对它们的反应才最重要（反应相反时是最明确的信号），比如对一个利空政策，市场既可以理解为真正的利空，也可以理解为利空出尽或力度不够，反而会大涨。又如，如果美联储加息，美元却下跌，说明市场对加息幅度失望，市场解读此消息为利空，应该做空美元。对股票和期货，长期趋势一旦形成，一定是其背后多种基本面因素综合作用的结果，这些因素短期内不可能突然改变，所以趋势具有强大的惯性，如果某天有个不利于趋势方向的突发政策或事件出台，导致当天或第二天价格大幅回抽（反弹），则反而是建仓的良机，因为单个政策或事件能改变趋势的概率微乎其微。例如2006年10月9日上午11时左右朝鲜威镜北道地底深处的一声闷响，让朝鲜的核试验瞬间变成了现实，韩国股指当天大跌，结果几天后又涨回去了（图2-15），甚至连911那样的事件也不能改变商品期货的趋势！不过趋势的惯性对外汇市场似乎不适用，因为外汇大多是振荡行情，很少有连续几个月的长期趋势行情。几天甚至几个小时的“趋势”没什么惯性可言。所以每次当事件、消息、政策、经济数据出来的时候，就是观察市场的最佳时机，若市场走势当天就和字面意思相反，或第二天、或几天后才相反，则是非常好的研判信号。牛市中市场会夸大利多消息而忽略利空消息，熊市中市场会夸大利空消息而忽略利多消息，牛市中利空消息对市场只有短暂影响，熊市中利多消息对市场只有短暂影响，雨过天晴，市场就会回升到原来的轨道。趋势明显的市场会反过来干预舆论的报道偏好。 图2-15 2006年10月9日朝鲜核试验，韩国股指当天大跌，几天后又涨回去了 技术面和新闻的关系：由于中级行情具有很强的稀缺性和持续性，故其背后一定有很强的基本面的货物供求因素和资金供求因素在支撑，而这些因素不会在一两天内就改变， 日常的新闻并不能显著影响行情，所以平时并不需要每天都看新闻，只有在行情的后期或广义多空陷阱处，才需要密切留意新闻（平时反而要注意避免养成网络综合症，即每天都非看新闻不可，而且看完财经新闻看其他新闻，然后看评论，再看论坛及其他，大量的时间就这样浪费了）。 长假效应、拍卖效应、托市（收储）效应和减仓效应：长假效应指国内长假时，国外猛涨（跌），则当国内假期结束后，应尽快先平仓出来，因为行情可能很快就逆转，最快的第二天很可能就大幅回调，这样的情况已经多次发生了！拍卖效应指政府为调控价格而拍卖，对热门品种来说，拍卖行为本身就是看多信号，说明市场缺货，拍卖当天很可能期市就大涨，拍卖往往无法抑制涨势：但对冷门品种来说，价格本来就涨得很勉强，政府一拍卖，往往跌的多，抑制作用明显。托市效应指政府为托市而出台措施，比如收储入库，不过国内的政府部门往往怕涨不怕跌，等到他们出来托市，价格通常已经跌得惨不忍睹了，何况政府托市也只是不希望价格再下跌，而不是希望价格马上就涨起来，所以托市后价格往往是小幅阴跌或弱势振荡，一般情况下还没到做多的时候。减仓效应：当某日价格朝不利方向明显变动且2个主力合约都大幅减仓（近10%）时，便是己方主力弃盘之信号，价格次日继续回走的机会非常大！这种情况也屡见不鲜，不过似乎白糖是例外，因为白糖一天内达到10%的加仓减仓太频繁了。 投机大师索罗斯认为，在投资决策以前，应该先建立一个市场假设，作为理解市场运动的一个框架。他说： “请尝试给出一个未经精心构造的假设，它只会引导漫无目的的投资，相反，如果你精心地构造自己的假设，你将能始终不断地取得超出市场平均水平的成就—假使你的独到见地并非过分地偏离市场。” 青泽认为，从心理学的角度分析，投机者在观察市场的价格变化之前就应有一套系统的市场理论、框架、模型，这样的市场观察就是一种“自觉的注意”。投机者不再让市场价格变化主宰、左右自己的思维、情绪，而是以超然的态度审视市场运动，通过理论、模型观测市场、寻找市场交易机会。“自觉的注意”不是由市场价格涨跌对投机者本能的吸引而引起的，这样产生的注意是“自发注意”。大多数投机者往往在这方面陷入困境，一旦坐在显示屏前，就不由自主地被市场带着跑。“自觉的注意”恰恰是抑制了投机者的本能欲望、利益，而是强调关注投机者自身的主体操作过程。 应该说，我这套企图给期货市场划分时间结构和空间结构的行情框架理论，是符合前辈们的观点的，它也成了我整套投资体系的一块基石。 期货与股票、外汇及打工、创业之比较股票市场的空间结构和时间结构我个人认为，股票市场整体的空间结构和时间结构比期货市场复杂得多，因此把握起来的难度也大得多。按照我的分类，期货市场只有8大类，即使多关注一些品种，充其量也不过十几个而已。而股票市场动不动就上千只个股，这些股票又分成多种板块;影响股票价格的新政策、新题材、新潮流层出不穷;虚虚实实、真真假假的新闻、报表、公告、股评让人眼花缭乱;主力操纵股价的运作手法日新月异；价值派、成长派、技术派、跟庄派、公式派，各个投资流派你方唱罢我登场，让人不知跟哪一派才好;具体个股走势的大涨大跌、翻云覆雨，人为干预的痕迹太重，从技术分析上更难把握;股市几乎每天都有涨停的股票，要是能抓住一个多好啊！市场诱惑非常多。归根到底就是股票市场的样本容量太大了，大得不但要求投资者总体把握能力强，还要求在心态上抵制诱惑、耐得住寂寞，对投资者的定力有更高的要求。 股票市场的空间结构，大体上是股票指数一权重股一板块一各板块内部的绩优股、绩差股、重组股。当我们考察一个股市时，应首先看股指是否处于明显的上升趋势？若是，则要判断股指最可能处于趋势的哪个阶段？拉动股指的是权重股还是非权重股？这波行情重点炒作哪几个板块？各板块内部的龙头股是哪些？这些龙头股目前最可能处于趋势的哪些阶段？只要趋势不处于上涨末期，则应该追涨各板块的龙头股。当然，这只是一个原则性的分析思路，具体操作起来还是有相当难度，主要困难有两个，一是各板块之间会轮涨，一个板块涨几天就会调整，另一个板块又崛起，而这种轮涨的随机性非常强，要想知道这几天炒作什么板块，再过几天又炒作什么板块，几乎是不可能的事;二是具体个股快速大幅涨跌，人为操纵风格各异，有些股票价格创新高后一飞冲天，连续涨停，追都追不到，而更多的个股价格创新高后不久就大幅回调，等你被迫止损，不久它又重新上涨（即鸡毛上涨）。考虑到这些困难，我认为，对一般投资者而言，在指数的一波上涨行情中，认准一个重点炒作板块的龙头股，耐心持仓等待指数行情的尽头，能涨多少就是多少，这样做虽然极度寂寞，但却可能是最好的操作策略，因为无数经验表明，企图“踏淮节奏，板块轮妙”，最终将导致投资心态被破坏贻尽。 股票市场的时间结构，这个问题太复杂，我尚未完全搞清楚。股票指数作为一个大品种，其走势特点和商品期货还是很相似的，所以我认为，对商品期货所划分的振荡行情、中级行情、超级行情和鸡毛行情，对于股指是完全适用的，稍不同的是中级行情的典型时间可能大于8周。但是具体个股的走势特点和商品期货相似之处甚少，人为因素太重了，所以要划分出一个适用较广的时间结构有相当大的难度。现在我能做的只是判断一个笼统的个股趋势，然后定性股指的趋势，若股指是中级行情，则优先建仓创新高的龙头股，若股指为超级行情，则优先建仓上涨趋势明显然后又回调到趋势线附近的龙头股。至于平仓时机，一是判断股指行情是否结束，二是对个股留一个较宽的止盈范围。 经验告诉我，对具体个股，涨跌幅度大、人为因素重这两个特点决定了若单靠技术分析来操作，其有效性要远差于对期货品种的操作。所以对于个股，基本分析所起的作用比期货品种更大些。有时候股指一涨，个股也一涨一大片，单靠技术面都不知道买哪个好。随便买一个走势形态良好的，也许买了以后却发现别的股票猛涨而它却不涨了，这就是不考虑基本面所产生的分辨力不足。我现在在股市方面的修炼集中在两方面，一是加强对宏观政策和宏观经济形势的把握，二是加强对个股基本面的研究。但是我在股票操作上并不排斥技术分析，仍然强调趋势和止损。对于那些反对止损、主张越跌越买的流派，我认为他们在逻辑上有一个漏洞，那就是假定他们是永远不会犯错误的，难道基本分析就不会犯错误？否则，一次错误就足以致命了。 外汇市场的空间结构和时间结构关于外汇市场的空间结构，全球七大货币可以划分为相对独立的三大块：美加、欧洲和日本，这表现在美元兑加元汇率几乎不受欧洲和日本的影响，同时欧元兑美元和欧元兑加元具有联动性：欧洲内部的交叉汇率，比如英镑兑欧元，受美元、日元的影响也较小，同时欧元兑美元和英镑兑美元也具有一定的联动性;至于日元，一般情况下没有谁跟它联动，偶然澳元也会跟随它一阵子，相对更难操作。欧元兑美元永远是汇市的主要矛盾，做欧元只需要看欧洲、美国即可，其他国家的事务和货币对此无影响，是相对容易些的二元问题;而其他货币，比如日元，则不但受日本、美国影响，还得受欧洲影响，因为欧元和美元是跷跷板，故变成更难求解的三元问题，更难把握了！当然这种板块效应的作用远不如股市那么明显，更加占主导地位的是各个货币本身的情况。 我在实践中发现，虽然外汇市场是世界上最大的市场，但汇率似乎并不是一个独立变量，它更像一个受利率、商品和股市严重影响的因变量。 汇率对利率极其敏感，一旦市场对某个货币产生升降息的预期，相应汇率即刻闻风而动，很容易在离息口会议还有一个月就开始走出一波轰轰烈烈的超级行情来。等到真正宣布利率变动的那一天，行情往往已经走完了。所以有条件的话，要经常留意利率期货的走向，若没有条件，只好经常留意市场报道中是否提到利率预期了。 澳元、加元和英镑被业界称为“商品货币”，这是因为它们的走势经常和原油、黄金、基本金属等商品期货的走势表现出相关性。每当这些商品走出中级行情、超级行情时，这三个货币往往也走出甚至长达2个月的大行情来。图2-16是原油指数和英镑兑美元的走势比较，它们经常表现出较好的相关性，但若仔细检查，就会发现这种相关性在时间上较粗糙，最大时相差达到三天。图2-17是黄金和澳元兑美元的走势对比，显然，在时间、幅度上相关性都比英镑一原油好得多，行情发动的时间经常仅相差一天。 图2-16 原油和英镑的走势比较 图2-17 黄金和澳元的走势对比 日元被我杜撰为“股市货币”，因为美元兑日元和股市的走势相关性很强。由于日本经济长期不景气，日元利率很低（目前是0.5%），机构投资者大量借来日元换成其他货币投资于股市，所以日元成了很多领域的最终货币提供者，是全球流动性泛滥的罪魁祸首之一，同时它也成了埋在全球金融市场的一颗定时炸弹。股市一有风吹草动，投资者急忙平仓换回日元还债，大量平仓又造成股市进一步下跌，容易形成恶性循环。谁也不知道哪天这颗定时炸弹真的爆炸了。图2-18是SP500指数和美元兑日元的对比，我们看到它们经常有很好的相关性，有时时间精确到只相差一天。若看4小时线，则相关性更明显。这种相关性导致日元往往难以走出持续性较好的行情，成了操作难度最高的货币。顺便提一句，我发现欧元兑美元与SP500走势比较，在一段时间内是正相关，而在另一段时间内又变成负相关了，如此反复。 图2-18 SP500指数和美元兑日元的对比 注意：我在上面强调是“经常”有较好的相关性，而不是“每时每刻”都相关。对那些从不参与实战的研究者来说，他们仅仅从数学上计算个相关系数，然后就判断“相关系数不够理想，没有指导意义”。对实战者来说，能够找到经常相关的证据，就已经足够了。因为当它们走向一致时，就是在相互印证，可以大胆建仓;而当它们不一致时，这种背离同样是很有价值的信号，它说明另一个更强的因素在发挥着主导作用。例如，假若前一阵子原油和英镑一起上涨，现在，经过休整后，原油继续上涨，英镑却不涨了，则说明有更强大的利空因素在压着英镑，比如有报道说英镑可能要降息，这时我们要密切观察，在这种背离维持一段时间后，一旦英镑破位下跌，就要及时跟进。另外，对实战者来说，这种相关只需要“相位同步”就可以了，幅度无关紧要，也即只要节奏上在一至三天内印证，就有指导意义。因为每个人的长处不同，比如我判断商品的行情比较有经验，而另一个人可能判断股市比较擅长，通过自己擅长的相关品种来研判汇率走势，帮助非常大。 金融市场存在固定的因果关系吗？很多分析师写文章热衷于“找原因”，比如我刚刚看到一篇报道，标题为“人民币尾盘走高，受中间价调低推动再创历史新高”，这是典型的华尔街式的八股文。再随手拾两条： “日元收盘走高，受出口结算推动”， “英镑兑欧元跌至新低，受疲弱的美国数据影响”。在我看来，这些“原因”都很牵强，不值得重视：反之，秉持顽固的因果律的思维模式将为害不浅，因为金融市场只存在相关关系，不存在固定的因果关系，同一个因素在这种情形下是利多，到了另一种情形下却会变成利空，不可一概而论。例如，美国的次贷危机对美元一定是利空吗？不一定。如果危机导致美股缓跌，会引起降息预期增强，从而压低美元;但如果危机引起美股急跌，会使得人们惊慌地在全球范围内换回日元，从而拖累高息货币澳元、英镑等急跌，欧元也被波及，这些货币都跌了，作为翘翘板的美元反而涨了！这真是一种奇怪的辩证关系。其实要把握好它并不难，你只需要充分尊重市场走势，而不是事先给市场决定方向，这样就够了。市场就像一个几个月大的婴儿，它只按它自己的喜好走，不管你对它大叫大喊、大声训斥还是慢慢讲道理，它都不知道你说什么，你唯有顺着它的脾气做才得安生。 关于外汇市场的空间结构，另外一个非常有用的工具是各大货币的货币指数（具体参见第5章），货币指数比各个交叉汇率更能体现它本身的走势本质，用于综合研判走势有很大帮助，读者如果没有能直接读取这些货币指数的软件，也可以用通用的行情软件编个公式来计算这些指数。 外汇市场的时间结构，如果直接考察汇率现货的话，很容易如坠五里雾中，不得要领。但如果观察期权，则会发现原来还是有明显结构的。一般情况下，汇率先在一个箱体内振荡，然后创若干天的新高或新低，如果这个突破不是假突破，那么一轮中级行情开始了。在行情刚开始的一两天，汇率可能会大幅反扑，挣扎一至两次，然后就一直往前走，形成惯性，连走几天。当走到第四天、第五天或前方重要阻力位的时候，要小心行情可能会结束。反之，若行情走得不紧不慢，连走了五六天都没有跌破趋势线，则很有可能会演化成超级行情，一路大进小回地走两三个星期。和期货类似，中级行情人气旺，走势迅猛，持续时间短，而超级行情的走势会小范围地一步一回头，但持续时间长，到底能走多远得看运气。下跌行情经常是中级行情，而上涨行情则中级和超级的都可能。至于鸡毛行情，在外汇市场似乎偶然才见到。当然也经常碰到突破了箱体但却是个假突破，甚至假突破以后还有假突破，这样就会形成没有交易价值的宽幅振荡行情，所以仓位管理上一定要试探，不要急着加码。一般来说，为了尽可能避免假突破，不要只考察那几个汇率，要从股市、商品、利率、货币指数等几方面综合考虑。 外汇的日线、周线的创新高、新低没有期货那么有意义，经常是几天后很可能就折回去，但240分钟线的创近期新高、新低有一定意义，很可能在240分钟的时间尺度上走出一波行情来。有一个严重的问题是，日线、分时线、60分钟线上的顶、底的假突破非常之多，因此我们的止损单、限价单的价位一定要远离这些顶、底，宁可仓位轻点也要如此！外汇的假突破如此之多，以致于我曾经试过专做假突破的短线交易，也就是说，真正的突破我反而放弃不做了，专等假突破才进场，即使这样，还是时不时碰到“假的假突破”！外汇的日线的阻力位大多是有效的，当期货价格在前期阻力位附近久久徘徊不肯迅速回调时，往往是要突破的前兆，而外汇在前期日线阻力位附近久久徘徊则更多是要往回走。期货品种的趋势持续了一段时间有回调迹象时，我们要明白这只是回调，回调之后趋势还是要往前继续的，趋势不会轻易结束（这和一般人的本能看法相反），而外汇日线趋势走了一段时间有回调迹象，我们要明白这是真的要大幅往回走了（这和一般人的本能看法相同）！因为外汇就像一个钟摆，摆过来往往就要摆回去，背后原因是各国政府都希望汇率能维持在某一个区间。 期货和股票及外汇的比较1、从走势看，股票、期货容易形成单边趋势，趋势持续时间长，价位变动幅度大，而外汇的单边趋势大多持续时间短，偶然也有时间较长的超级行情。 2、从品种的标的物大小、交易量大小看，股票太小，价格会突然、猛烈、快速地变动，幅度大、速度快，持续性差，还容易被操纵：大多数期货品种大小适中，价格变动幅度大，但速度不快，持续性好，不容易被操纵，但有一些大品种的期货，由于标的物太大，或成交量太大，而导致不活跃，单边行情也少，例如国内的硬麦，或SP500 （成熟市场的很多金融期货都如此，而新兴市场的金融期货则活跃，单边行情多些，因为品种没那么大）：外汇是最大的交易品种，不太可能被操纵，在较短的时间尺度内也有持续性很好的单边行情。 3、股票、期货的走势一旦形成趋势，则持续时间长，价位变动大，它本身是多种因素综合作用的结果，所以并不会因为某一天突然发生的某一件事或公布的某个数据、政策就突然改变趋势，所以做中长线的人可以不必太留意每天的基本面信息；而外汇因为其单边趋势持续时间短，惯性没那么好，需要经常留意基本面信息，但仍然要以客观走势做为研判的主导因素。 4、与期货相比，股票的特点是个股机会多，难度大，人为因素重，走势中突发性的涨跌幅度大，走势没有期货那么光滑。股市一涨，国内商品期货市场就失血，因而走出中级上涨行情的机会更少，这成了事实上的规律。而外汇的长短线机会都很多，几乎每1-2周就会有一波较大行情。 5、一般来说，股票、期货、外汇都适合于中长线操作，而外汇的操作时间尺度更短。当然这些品种也适合某些高手做短线交易，但问题是，无论做股票、期货、外汇的短线交易，大多数人都逃不出时不时大亏一笔的宿命，这是人性的弱点所决定的。 6、最重要的一点，就是关于市场文化的问题。我认为，期货和外汇的市场文化都比较健康，绝大多文章都劝人冷静理智地交易，劝人静下心来慢慢地修炼。因此，如果一个人能坚持做10年期货或外汇，我相信他走向成功几乎是必然的，因为这种市场文化在推着他进步，如果他不进步早就被市场淘汰了。然而，国内股票市场的文化氛围仍然很不健康，鼓吹偷抢拐骗是最高智慧的文章还很多，让人热血沸腾的词语比比皆是，在这种环境下，即使一个人坚持做10年股票，我也不敢说他一定成功。 7、外汇期权的独特优势：①样本空间足够小，便于专注，很多银行只提供几个货币对的期权，看多了对走势都能背出来，时间一长甚至能产生直觉；②行情机会足够多，一般每个月都有2-3波大行情，幅度足够大，动辄以翻多少倍论；③期权是100%保证金交易，最大风险预知，不用担心追加保证金，心理压力小很多；④期权是通过放大价格变化幅度，而不是靠加大仓位来实现杠杆效应，因此交易起来更容易把握买卖价格；⑤期权和期货（保证金交易）相比，最独特的地方在于，当期权处于价外时只有时间价值，价格非常便宜，可是你一旦看对方向买了它，当它从价外变成价内时，升幅大得令人惊讶，放大倍数远非期货能比。 8、从技术分析的使用效果来看，对于中长线交易，交易对象的盘子越大，则技术分析的效果越好，期货、外汇、股指的盘子都足够大，但对于个股来说盘子小了点，导致单靠技术分析做个股的效果不够理想，此时还必须结合宏观经济热点及个股本身的基本面状况。 期货投资与打工、创业之比较所谓打工，我指的是在国营单位或私人企业谋个职位，领取固定薪水，并不包括那些已经进入到经营层面的“打工皇帝”。在工作中只要你有专业知识，然后认真工作，完成上司下达的任务，那么每个月按时领取工资，一般来说是没什么问题的，这里面的风险几乎为零。在职场上的随机性几乎都发生在入职和升职的时刻。由于制度壁垒的限制，即使你有才能，也不是你想入什么行业就是什么行业，想干什么工作就是什么工作，偶然性在发挥着巨大的作用。然而，一旦你运气不错，进入了一个好行业，即使你做得比同事差一点，你还是比其他行业的人过得好，风险还是很小。前段时间媒体报道在电力行业，一个抄表工都年薪10万元，就是一个极端的例子。相比之下，做金融投资，随时都有风险，账户里的钱在没取出来之前都不算数。你也具有很好的专业知识，你也很努力工作，可是收益却还是个未知数。对于绝大多数人来说，稳定的收入对于养家糊口有着巨大意义，即使是世界最顶级的对冲基金，每年不管盈亏也要收取2%的管理费来发薪水，也是出于现实考虑。所以我认为做投资的人除了投资收益外最好还有其他稳定的生活来源，否则心态很难调整。 然而，凡事有一利就有一弊，打工虽然平稳，收入却也几乎是封了顶的，绝大多数打工一族，即使学历高到博士，终其一生也就是养家糊口而已。要想不必一生为谋生奔波，要想实现财务自由，只有两条路，要么搞投资，要么搞创业（实业），我认识不少知识分子，年轻时老抱怨工资低，及至年纪大了几岁，就开始认命，认为自己命中注定就该过这种清贫的生活，言谈中始终流露出一种观念，那就是因为自己读了很多书，所以国家、企业或私人老板就应该出高薪把自己养起来，至于搞投资或创业，却又不敢去做或认为不值得做。这种观念属于典型的过时的计划经济时代的观念，那就是“读书打工论”，即“好好读书，将来找份好工作”， “好好读书，考一百分，将来国家会给你安排一份好工作”。现在这个时代变了，工字不出头，你不投资，别人投资，你不创业，别人创业，于是你就眼睁睁地看着别人发财。过高的学历对于发财致富也许反而是一种障碍。 所谓创业，是指开公司办实业，如制造、研发、服务、批发零售等。金融投资与实业投资有很多显著不同的地方，兹列举如下： （1）资金门槛问题。实业投资门槛高，即使极小的生意也动不动就要10万、8万元，稍好的机会没上百万元动不了。金融投资门槛低，股票、外汇几千元即可，期货三五万元也可上路。 （2）公平性问题。金融市场，尤其是期货和外汇市场，是相对比较公平的市场，所有投资者，不论资金大小，基本上是平等的，这对普通老百姓是好事。不过国内的股票市场离三公原则还远得很，这也反过来解释了为什么大资金往往不喜欢做期货和外汇，而独喜股票，因为他们做股票可以操纵，胜算大多了。而在实业中，不公平也是随处可见的。 （3）扬长避短问题。金融市场的相对公平性，反过来又导致很多人的优势无法体现出来。比如有的人生在官宦人家，他在势力范围内办实业，即使不用贪污受贿，都有很多人主动让他赚钱，所以他就不应该来做期货：还有些人，资金很大，做实业很有优势;还有的人，口才很好，或组织能力很强，或人缘特好，这些人来做期货都体现不出优势。至于那些喜欢独立思考，愿意不断学习和反省，同时社会活动方面无优势或能力差的人，来试试金融投资是很不错的。 （4）单次风险大小。做金融投资，只要控制得当，则单次风险可以很小，这样允许失败的次数多。而做实业投资，单次风险极大，一旦失败则失去大部分资金。一次生意失利亏掉毕生积蓄，这种例子并不罕见。 （5）风险时间百分比。做金融投资，今天赚了并不保证明天也一定赚，这波行情赚了也不保证下一波行情一定赚。虽然高手可以保证不大亏，但也不敢保证一定赚多少。所以金融投资中风险时间所占的百分比，虽然不到100%，但肯定是很高的。做实业投资，比如说开间工厂，如果能熬过头两年，那就说明已经找到稳定客户，至少以后几年是没多大风险了。所以总的来说，做实业风险时间所占百分比不高。 （6）竞争对手选择。做金融投资无法选择竞争对手，而做实业就可以选择，这是一个很大的优势。有个典故说，两个人被老虎追，猛跑，跑得慢的对跑得快的说：“你跑那么快干吗？再快也快不过老虎啊！”跑得快的说：“我不需要跑得比老虎快，我只需要跑得比你快，老虎吃了你，它就饱了，就不会吃我了。”假设一个岛上有两家超市，那么占优势的那家超市并不需要做得比全天下的超市都好，它只需要做得比另一家好即可，而另一家超市若感到竞争不过前者，则它可以选择搬到比它更差的竞争对手那里。这就是说，做实业投资的竞争是局部性的，所以只要求相对优势即可，但做金融投资的竞争是全局性的，成功的投资者要求具备人性方面的全局的、绝对的优势，你只有做得比绝大部分投资者都好，你才能赚钱，这个要求就高多了。（7）对人性弱点的约束问题。实业投资由于是肢体活动，可以建立各种规章制度，对人性的弱点进行有效约束，管理学上有句名言“世上没有懒惰的人，只有使人懒惰的制度”，说的就是制度的强大力量。可是金融投资几乎是纯心理活动，看不见、摸不着，一般人难以建立有效的制度来自我约束人性弱点，只有投资高手才能制定有效的心理规则并严格执行，大的投资公司则通过人员的分工合作来彼此制约，这样也能较好地约束人性弱点。 （8）业务量多寡的问题。在很多实业公司，平时没有接到订单时，每个月的开支是可以预先知道的，即无“成交量”时的风险是预知的，并且一般不会太大，一旦接到订单，只要认真努力做，则几乎是稳赚的，所以风险体现在接单之前。可是在金融投资，你也下了个单或接了个单（即开仓），你也很努力，可是并不一定就能赚钱，风险是体现在接单之后。所以，在实业投资一般是接单越多越好，可是从业者也明白，这些单是有客观频率的，不是你想接多少就有多少，故而想过度交易都没门。但在金融投资，尽管每张单不一定赚钱，但只要你愿意，却是每分钟、每秒钟都可以接单，过度交易就很容易发生了。 （9）是否可以兼职做。做实业投资，因为投资大，事情多，往往需要专门的时间、地点，故一般很难兼职做。可是做金融投资，如果做中长线，无需每天盯盘，无需专门地点，完全可以兼职做。等到积累若干年经验并走向成功后，再全职做，这样就有一个很好兼顾各方面的过渡期。 （10）资金增值问题。对实业投资，在公司很小的时候，一旦做对了则实现爆炸性增值是可能的，但对大公司，每年有百分之十几的净资产收益率就算不错了。对金融投资，一旦投资者整体修炼水平到位，则在短时间内把一笔小钱变成一笔大钱，是完全有可能的，甚至投资高手可以实现大资金长期指数式复利增长。故而，做好了金融投资也可以彻底改变一个人的命运。（11）做投资和做实业的共同之处。首先是都强调放足盈利，一旦做对了则要把市场（行情）吃透吃尽，决不轻易退出；但对于做投资所强调的迅速止损，在实业中则很难实现，所以做实业的单次风险就大。其次是都强调看清大势再下手，不争最先，不盲目创新，比赛的是谁活得长，“剩者为王”，网易的丁磊和腾讯的马化腾都反复强调此观点。第三是都强调不要四面出击，不要轻易投资，不要胡乱搞多元化（不要搞一大堆投资组合）。 所以对普通老百姓来说，金融投资的吸引力主要在于资金门槛低，大体公平，机会多，可以兼职，允许多次失败，一旦掌握了正确的投资理念和投资方法，可以实现资金指数式增长。然而要想实现稳定盈利，对投资者的整体修炼水平也是要求非常高的，只有极少数人能达到要求。 行情框架理论在股票市场中的应用也许有朋友看了前面的章节后认为我对股票的操作论述得太简洁、太抽象了，因此我在这里专门另辟一小节，以最近十年来股票市场的若干著名行情为例，具体谈谈我对股票的波段操作的认识。在时间上我由远到近，逐一论述对各个问题的处理方式。但由于历史原因，对过去的行情的基本面资料已经收集不全了，只好以技术面为主作讨论，虽然如此，我相信对读者的实际操盘还是有一定帮助的。 先从趋势谈起。按道氏理论的定义，上升趋势是指一系列更高的高点和低点，下跌趋势是指一系列更低的高点和低点。这个定义很巧妙，也很直观。但我自己还有一个不那么精确但更直观的定义，即，趋势是指大方向非常明显的走势。明显到什么程度？明显到一眼就看得出来，不需仔细观察，也不需要思考。逐步加仓介入这样的趋势行情，是最为理想的交易。由于顺势而为是一切中长线交易的一个基本原则，因此，判断大盘和个股的趋势走向就非常关键了。 如何判断大盘和个股的趋势？我建议使用下面三种方法： 1、看周线，凡连续涨跌两三周，则形成新趋势的可能性极大，必须及时逐步介入或迅速止损平仓。 2、把走势图打印出来，挂在房间一边的墙上，走到房间的另一边，如果从那边看来这张图是明显倾向于上升或下跌的，则是有明确的趋势了。离得远一点反而看得更真切。 3、找一个十岁以下的小孩来看走势图，小孩说涨就是涨，说跌就是跌，说振荡就是振荡。为什么？因为大人的思维已经被太多的复杂想法所束缚，以致于见山不是山，见水不是水，见了赤裸的皇帝还一本正经地说他穿着别人看不见的衣服。小孩则未受污染，保持着自然、朴素、直观、纯真、没有杂念、无所顾忌的思维方式，反而一眼就读懂这些非文字的符号。曾经有这么一个故事：一位著名的股票高手，某一天正在冥思苦想为什么他买的一只股票正在下跌，财务报表、筹码分布、主力动向、独家内参，这些统统都研究过了，而且都表明股价是要上涨的啊。困惑！困惑！这时他五岁的小女儿进来缠着他玩，他很不耐烦地说：“我正在思考问题呢！”谁知小女孩走过来瞥了一眼走势图，不屑地说：“不就是要向下吗？有什么好研究的。”这位高手听罢大吃一惊，恍然大悟，马上止损，还反手做空，最终大赚一笔。一个著名的投资高手，难道还不如他的几岁的小女儿?事情本不该如此，只不过大人的脑子里往往有个先入为主的想法，他认为这个股票要涨，于是拼命找出种种理由来支持要上涨的观点，都完全忽略了股票已处于下跌趋势这个事实。 再谈谈大盘（股指）和个股的关系。大盘犹如大河，个股犹如小河，大河有水小河满，大河没水小河干。当股指跌时，大部分个股都是跌的，但当股指涨时，却往往只有一小部分个股上涨。因此，对股指趋势的研判，就具有战略性的意义。当股指和个股都呈现明显上涨趋势时，就是在相互印证，应该大胆地逐步加到满仓。相反，当股指没有上涨趋势，只是区间振荡时，即使个股的走势再好，我们也要多一份警惕，加仓要多一份谨慎。至于当股指呈现明显下跌趋势时，不论个股的走势再怎么理想，我们也要赶紧出来，毕竟逆大盘上涨的个股，其连续性极差，随时都可能急跌。逆下跌的大势做多，则上涨是小概率事件，做对了也是可遇不可求，做错了则几乎是必然的。所以说，大盘是战略，个股是战术，只有站在战略性的高度把握好了大盘，个股的操作才会顺风顺水。任何时候买进个股都有一个大前提:股指不能处于下跌趋势。当股指连续下跌两三周时，则极有可能形成中级下跌行情，此时对于手中的持股，无论盈亏状况如何，都必须赶快出清，以免深套。 下面我们看看中国股市历史上的几波行情。 图2-19是上证指数在1999年5.19行情中的周线走势图。在1999年5月的时候，中国刚刚和两年来的亚洲金融危机擦肩而过，几个月前的华东大水的灾后重建也正在紧张施工，中央刚开始实施扩大内需的战略，西部大开发的战略决策也正在热烈讨论之中。另一方面，股市自1997年见顶， 1998年四五月份反弹后，就一路弱势振荡下行，但几次下探上证指数都未能跌破1050点的大底。同时，美国纳斯达克市场的科技股、网络股泡沫风头正盛，股指屡创新高。5月初，我国驻南斯拉夫大使馆被炸。就在一片令人绝望的氛围中，5月19日，行情突然爆发，以网络股为代表的高科技概念股一跃而起，上证指数自1047点发起进攻，以井喷的方式连续上涨，短短的一个半月，就上涨了68%，最高达到1756点。今天我们回头看这段历史，股指以中级行情的方式疯狂上涨，但持续时间不长，只有7周就见顶了。井喷上涨，人气虽然极旺，但力量也容易在短时间内用尽，故而总是不太长久。如果用今天成熟的手法，该如何把握这段行情？第一，当股指连续大涨两周，无论如何都要试探介入，以免错过行情；第二，当股指以连涨几天的方式收出一根周线的大阳线（只涨了一天的则要大打折扣），则也值得开始试探介入。 图2-19 上证指数在1999年5.19行情中的走势（周线） 图2-20是5.19行情的龙头股东方明珠（600832）的走势。既然股指以中级行情的方式迅速上涨，那么龙头股一般也是以中级上涨的方式疯狂拉升。东方明珠在1个月之内从15元上涨到40元，令人惊叹。擒贼先擒王，炒股就要炒龙头股，这是被历史反复证明的有效的经验。每一波行情过后，人们总是反复问: “怎样才能抓到龙头股？”按我现在的做法，这个问题应该这样处理：第一，在股指的行情发动之前，不要去猜测谁将是下一波行情的龙头股，更加不要因为这个猜测而预先开重仓，你永远猜不到的，主力似乎永远比你聪明，他们总是在你意想不到的地方发动猛攻；第二，并不需要预先知道谁是龙头股，只需要在股指连涨一两周的那段时间，留意看市场报道就可以了：第三，无论是股指还是龙头股的中级上涨行情，往往至少要持续五六周以上，所以错过刚开始那一两周，并没有什么好可惜的，关键是要敢于追涨，务必买到、抓牢龙头股；第四，何时平仓出局？具体做法可以五花八门，比如两三周都不再上涨就出局，或者跌破5周均线就平仓，总的原则是务求吃尽行情。 图2-20 东方明珠在5.19行情中的走势 图2-21是上证指数在2000年上半年的一波较大的行情和2001年上半年的一波较小的行情（周线）， 1999年的5.19行情没能维持太久，之后大幅回落，一直调整到2000年初，一波新的行情又爆发了。我们看这波行情，股指走得有点跟跟跄跄，甚至有点鸡毛上涨的味道，这在中国股市的历史上是罕见的。造成这种情况有两个原因，一是很多个股的主力是在5.19行情时急急忙忙杀进来抢筹建仓的，之后又被套好几个月，现在终于拉上去了，一些主力资金见好就收，但是，他们出局对股指冲击不大；二是美国纳斯达克科技股在2000年3月见顶后大幅回落，而国内这波行情的主力品种还是网络科技股，所以对国内股市的心理影响可想而知了。 图2-21 上证指数在2000年到2001年上半年的走势（周线） 图2-22是2000年行情的龙头股上海梅林（600073），我们看到它的走势比上一波的东方明珠更为疯狂，即使在龙头股中，连续开盘涨停也是不多见的。这就导致对它的操作难度更大，一开始买不到，等能买到时已身处高价了。尽管如此，历史经验告诉我们，还是要坚决买进，支撑我们信心的就是，作为龙头股往往至少要有五六周的上涨行情，我们要的是后面的行情。 图2-22 上海梅林在2000年行情中的走势 图2-23是上证指数自2001年开始一直到2005年长达5年的大熊市，以一波大型的鸡毛下跌的方式逐级下行，其间在2004年有一波较大的反弹，2002年、2003年各有一波较小的反弹，指数从最高2245点一直跌到最低998点。在中国经济仍在稳步发展的五年中，股市却出现了全球罕见的大熊市，表面上的导火线是财政部坚持要按市场价减持国有股，其实背后的真正原因是中国股市的制度安排不合理，比如股权分置，大小股东利益不一致，中小投资者利益不受保护，上市公司只是把股市当做圈钱场所，等等，这些独具“中国特色”的不合理之处正是中国股市发展的绊脚石。在这波熊市中，据说亏损超过50%的股民占了80%以上，很多人的本金亏损超过80%，相当多的个股价格，从二三十元经过一江春水向东流的漫漫熊途后，跌到只剩两三元。我本人有幸避开了这段熊市，但我所认识的许多股民朋友，对这段切肤之痛是致死也忘不了的。那种呼天天不应，叫地地不灵，在漫漫长夜里苦苦煎熬的感受，没经历过的人是无法体会到的。今天当我们回顾这段历史，任何一个理性的、面对现实的人都不得不承认，企图抄底是极其严重的错误，止损是保命的惟一法宝。不管基本面和政策怎么样，市场走势自有它自身的道理，面对下跌的趋势，冒死去抄底，就是对市场的不尊重，谁不尊重市场，市场就会惩罚谁;买进以后，面对天天下跌的市场却不愿止损，就是对市场走势的大不敬，谁蔑视市场，市场就会灭掉谁！那些整天在媒体上鼓吹抄底的人，那些整天在媒体上丑化止损的人，市场终会有一天教训他们。 图2-24是上证指数在2003年和2004年的两波反弹行情（周线）。我们看到2003年三四月份的那波行情，股指上涨的时间很短，幅度也小，但是在严格止损的前提下，也还是具有操作价值的。2003年底到2004年初的那波反弹有一定力度，以中级上涨的方式持续了十几周，若抓到龙头板块和龙头股的话，还是有很大的赢利机会。 图2-24 上证指数在2003年、2004年的两波反弹行情（周线） 图2-25是2003年的反弹行情的龙头股长安汽车（000625），典型的中级上涨行情，连涨8周才出现调整。我们看到，即使只是一轮反弹行情，其龙头股的走势也是相当凌厉的（在随后的2004年，我们看到长安汽车也下跌得相当凶猛，这再一次表明，不管上涨时媒体把其基本面宣传得多么美好，也不过是主力放出的烟幕弹罢了）。这说明，在股指的每一波上涨行情中，尽管一开始谁也不知道是反弹还是反转，也不知道能涨多高，但只要能牢牢抓住龙头股，则收益还是相当可观的。 图2-25长安汽车在2003年三四月份的中级上涨行情（周线） 在2003年11月到2004年4月的股指反弹行情中，出现了一个奇怪的现象，不知是否是主力运作失效，竟然找不到一个合适的个股作为一呼百应的龙头股，只好又拉起了老龙头上海梅林（600073）。如图2-26，上海梅林起先随着股指一路急跌，然后主力突然发力，股价大幅反弹，短期内翻了一番。然而，过气了的龙头是没有号召力的，上海梅林在股价翻番之后就软下去了。于是不久，主力们又拉起了另外一只股充当龙头，这就是南方汇通（000920），参见图2-27，南方汇通既不是著名大公司，又不是上海本地股，可见当时市场人气确是大不如前了，而且南方汇通的走势也确实没有表现出龙头应有的风范（不过若抓到它的话，涨幅还是相当不错的）。通常，在股指的一波中级上涨行情中，一个称职的龙头股会持续上涨到整个指数行情的一半到三分之二时才走软。剩下的行情中，市场热点会转移，主力会狂炒几个原来不那么知名的中盘、小盘股，造成“黑马狂奔”的现象，以掩护资金从前期大涨的个股中撤退。这几个被狂炒的“黑马”就充当了“后半期龙头”的角色，其作用类似于这里提到的南方汇通。从操作上说，要想抓住“后半期龙头”的难度大得多，因为股指在振荡，大多数个股也会随股指起伏，唯独那几匹黑马在狂奔，这就出现了股指和目标个股走势不共振的局面，要想从上涨后随时会回调的个股中找出不回调的黑马，难度很大。 图2-27 南方汇通在2003年11月到2004年4月的走势 图2-28是上证指数在2005年到2006年9月的股改初期的行情（周线），2005年初，中国股市经过近5年下跌，引发了一定的社会矛盾，股市本身成了一个社会问题、政治问题。如果不进行股市的制度改革，不但中国的金融行业永无进步，无法应对加入世贸组织所带来的挑战，万一股指跌破1 000点，更加可能引起社会动荡，从而酿成巨大的政治风险。另一方面，经过近两年的“全民大讨论”，对于改革股市的思路日渐成熟。在这种情况下，股权分置改革顶着压力强行试点、强力推广，最终取得巨大进展，整个股市发生了翻天覆地的变化。所谓股权分置，是指上市公司的一部分股份（社会公众股）上市流通，另一部分股份（国有股和法人股）暂不上市流通。股权分置是由于历史原因造成的极具“中国特色”的一种制度，它也成为中国股市种种弊端的源头，最终成了困扰我国股市发展的头号难前的2003年，伦敦金属交易所以铜为代表的有色金属就开始了一波轰轰烈烈的超级大牛市行情，伦敦铜从2003年的每吨1800美元，一路疯涨到2006年5月的每吨8500美元。股改行情和金属行情共振叠加，造就了有色金属股动辄翻几倍的狂牛神话。图2-29是驰宏锌错在2005年12月到2006年7月的中级上涨行情，确实令人咋舌。如果我们经常看板块指数，就不会错过这样的大行情。 图2-29驰宏锌错在2005年12月到2006年7月的上涨行情 图2-30展示了上证指数在2006， 2007年的超级上涨行情和2008年的一波中级下跌行情。考察持续了两年的超级大牛市，很明显它是由4波中级上涨行情所组成的，并没有出现太多的类似商品期货的超级上涨行情那样的一步一回头的慢牛现象，这说明股市的资金、人气比期市旺得多。组成超级行情的4波中级行情，分别是2005年底到2006年6月的上涨行情，重点炒作有色金属板块:2006年9月到2007年1月的上涨行情，重点炒作以工商银行（601398）为代表的银行股、金融股:2007年3月至5月30日的上涨行情，重点炒作那些不太出名的二线、三线股和垃圾股: 2007年7月至10月的上涨行情，重点炒作中国石化（600028）、中国平安（601318）等大盘权重蓝筹股。最后看看2008年1月至4月的中级下跌行情，重点杀跌对象也是以中国石油（601857）、中国平安（601318）为代表的大盘权重股。从这张图中我们可以看出，持续两年的超级大牛市已经结束了，按照超级行情每几年才出现一次的经验之谈，似乎短期内是不会再来一波超级行情的了。但是也不用悲观，历史经验告诉我们，股指的中级上涨行情还是不会少的，只要能抓住龙头股，中级行情照样很有赚头。 图2-31是工商银行（601398）在2006年10月底刚上市到12月底的一波中级上涨行情。当时，管理层刚刚批准要搞股指期货，媒体天天在描绘股指期货上市后的美好未来，此时中国石油（601857）还没上市，于是工商银行就成了最大的权重股，理所当然就被炒作股指期货概念的大资金炒上去了，股价也翻番了。工商银行的这波上涨行情，使人们有了一个新的认识，那就是，在过去被一般人所厌弃的大盘指标股，在股指期货时代，却有可能成为抢手的香饽饽。 图2-31工商银行在2006年10月底刚上市到12月底的中级上涨行情 在2007年3月到5月的时候，出现了一个怪现象。那就是天天被媒体吹捧为最值得进行价值投资的“绩优蓝筹股”，虽然风光无限，却不再上涨了。正当很多人以为股市波澜不惊的时候，有一天忽然被告知“工商银行成了两市价格最低的股票”，这才幡然醒悟，原来那些很少被媒体提起的二线股、三线股、垃圾股，个个被炒翻了天。错过一波行情，悔之晚矣！随便找个不知名的小盘股，都涨得令人诧异。图2-32所示的海王生物（000078）就是个随手捡来的例子，一路疯涨，股价翻了4倍，直到5月30日财政部突然上调印花税，才止住了上涨的势头。 图2-32海王生物在2007年1月到5月的上涨行情 怎样避免由于过份关注某些板块而错过了最热门板块的大行情?这个问题非常重要，我是这样解决这个问题的。前面已经提到，股票市场的空间结构，大体上是股指-权重股—板块指数—各板块内部的绩优股、绩差股、重组股。整个股市的上千只个股，若作最粗糙的分类，可以分为权重股和非权重股两大类。当股指走出明显的趋势行情的时候，一般我不会只看一个指数，而是同时看两三个指数，对比它们的强弱，就可以大体上判断出引导股指上涨的是权重股，还是非权重股，如果是非权重股，再去进一步查看板块指数。我一般同时看上证指数、沪深300指数和中小板指数，由于上证指数只是代表大盘权重股，沪深300指数则还兼顾一些二线绩优股，而中小板指数则代表二线、三线股中最活跃的成分，因此它们的涨跌幅度的区别，就反映了股市中不同板块的活跃程度。如果三个指数都处于上涨趋势，但是上证指数的日涨幅经常比沪深300指数、中小板指数大，则说明这波行情是主要炒作大盘权重股，反之，若上证指数的日涨幅经常比沪深300指数、中小板指数小，则说明市场是在炒作二线、三线股，此时需要进一步查看板块指数，找出最活跃的板块。如2008年1月到4月的这波中级下跌行情，看这三个指数的报价，就会经常发现上证指数的跌幅比后二者大，这就可以判断市场是重点杀跌权重股板块。 以上介绍的是仅仅通过涨跌幅的数据来大体判断，如果有时间，还可以进一步对比走势图。例如图2-33是中小板指数和上证指数的走势对比。如果说2007年上半年之前的对比不太明显的话，那么2007年7月到10月的这波上涨行情，上证指数的涨幅比中小板指数明显大很多，说明市场重点炒作权重股。同样的道理，可以看出在2007年12月到2008年1月中旬的这波反弹，是以炒作三线股、小盘股为主;而在2008年1月中旬到4月的这波下跌行情中，权重股跌得早、跌幅大，而三线股、小盘股则跌得晚、跌幅小。 我们再来看另一个对比，由于金融板块权重股云集，因此金融板块指数就近似代表了权重股的走势，而医药板块没什么大型公司，因此医药板块指数就代表着典型的二线、三线小盘股的行为。图2-34是这两个板块指数的对比。我们看到，在2007年5月30日上调印花税之前，二者的强弱对比何等鲜明！小盘股的涨势何等凌厉！而2007年下半年之后的走势对比，也可以得出和图2-33一样的结论。所以，平时一旦从三大股指的涨跌幅对比中嗅出端倪，则一定要勤于查看板块指数。 同样的道理，在2007年7月到10月的最后一波中级上涨行情中，如果我们注意到了三大股指的涨幅对比，就能知道这波行情重点炒作的是大盘权重股。这样我们就可以介入大盘股，从而避免了媒体所哀叹的“指数虚涨”、“二八现象”、“赚了指数不赚钱”。图2-35是中国石化（600028）在2007年的上涨行情（周线）。 图2-35中国石化在2007年的上涨行情（周线） 最后，让我们看看持续两年的大牛市结束后，我们所遭遇的第一波中级下跌行情的情况。这波行情从2008年1月中旬跌到4月，若从前期见顶的最高点算起，则上证指数从6124点一直跌到2990点，跌幅超过50% （参见图2-30），绝大多数个股都被腰斩，还有相当一部分个股跌幅大于60%，损失不可谓不惨重！所有没有经历过熊市的新股民都被吓得目瞪口呆。在全民狂热的阶段，因此其价值被严重高估了。刚一上市，很多理性的机构投资者就不断抛出，接盘的绝大部分是一些盲目的散户。今天我们回头看这个走势图，很明显是一个标准的下跌通道，按照顺势而为的原则，这样的股票是不能做多，只能做空的，如果有谁不慎做了多，也应该及时止损。可是有很多人并不接受顺势而为和止损的观念，他们声称是“价值投资者” （可是在我看来，真正的价值投资者是不会在这么高的价位去买入的，我只能称他们为“四不像”投资者），每一次下跌，他们都认为是到底了，是买入良机，要赶紧抄底，被套后又不止损，还要摊低成本，越跌越买，于是越买被套得越多，最终煎熬得头发都快白了。前段时间网上流传着一个笑话，说是抄底以为抄到了地板上，结果没想到下面还有地下室，到了地下室发现还有地窖，到了地窖没想到下面还有地壳，地壳下面还有地狱，到了地狱才发现原来地狱还有十八层！有一位财经界的老前辈（我估计他是以写文章为生的，账户盈亏对他无所谓），在中国石油上市前，他就坚信价格会达到50元，结果中国石油一上市就高达48元，似乎正好验证了他的看法，于是在其博客上号召广大股民买进。等到中国石油跌破40元时，他认为是主力资金在压低价格以便低位吸筹，广大散户应该坚持价值投资，逢低买进。等到中国石油跌破31元时，针对网友的指责，他仍在博客上坚持看多，主张越跌越买，还喊出了“保卫中石油”的口号。最终，苦熬几个月后，中国石油跌破了发行价16.7元，这位前辈的看多信心也终于崩溃了。不过他也算坦荡之人，在其博客上公开声称，中石油使他“很没面子”，他“愿意承担一切有关中石油的指责”，很有意思的是，他一发表这个认错声明，中国石油（以及整个股市）很快就止损回稳了，正应了那句老话“多头不死，跌势不止”，人无完人，孰能无过?看对看错本来是很平常的小事，可是如果要押上一大笔钱作为看错的陪葬品，那就没有必要了。看错了不要紧，止损呗！小亏一笔，保存实力以便抓住下一次机会。看错了，赶紧认错，这才叫尊重市场走势。所谓不尊重市场，就是说，对客观的市场走势视而不见，完全沉浸在自己的主观想法里，当行情明明几乎天天在跌，却一心想着找机会买进（也就是一心想着抄底），或者当行情明显几乎天天在涨，却顽固地看空，这样都会输得很惨的。和谁作对都行，但是千万不要和市场作对！市场远比你所想象的强大，市场远比你所想象的聪明，你不尊重市场，市场就会惩罚你，你若蔑视市场，市场就会灭掉你！ 图2-36中国石油刚上市就一路下跌的走势图 以上对中国股市近十年来的几次大行情作了讨论。由于我举的例子几乎都是龙头股，涨幅惊人，这样会不会给读者一个错误的印象，误以为炒股赚钱很容易？其实做股票，就像做期货、外汇一样，也是一件很艰难的事，成功者寥寥。具体难在哪里?本书的其他章节分别从不同角度反复进行了论述，这里不再重复了，我只想谈谈做股票独特的难处。 首先是上涨行情的多寡问题。除非碰上超级大牛市，否则一般来说，股指一年往往只有两波行情，从经验上看，每年的五六月份一般有一波业绩浪，股指涨幅比较大，下半年十一、十二月份又有一波，股指涨幅较小。其余的时间，股指都在振荡和下跌。当然你也可以说，只要股指不下跌，那么个股就总是有行情，这个不涨那个涨。话是这么说，事实上如果不是股指也在同时上涨的话，个股的上涨行情操作起来情况千变万化，难度大得多。也就是说，好做的时候不多。 其次，对于股指的中级上涨行情，一般都会有一个龙头板块和一个龙头股，这个龙头股由于人气极旺，往往也会以中级上涨的方式连续大幅拉升，只要够胆追高跳上车（是否有这个勇气，本身就是个困难），那么往后就很好做。但是，对于超级上涨行情中的第二波以后的行情，例如2007年的第二、第三波行情，市场虽然也存在一个主流板块，但却可能不再存在一个一呼百应的龙头股，而只存在几个有代表性的个股。问题是，对任何一只个股，只要它不是龙头股，则人气就没那么旺，以中级上涨的方式来拉升的可能性就要大打折扣，而是极可能以超级上涨甚至略带鸡毛上涨的方式来拉升，这就大大增加了操作难度。例如图2-37所示的中国平安（601318） 第三，当股指正处于上涨阶段时，那些不是龙头股的个股，它们的拉升方式也是名目繁多，各种可能都有，除了极少数以快速连续拉升的方式外，大多数个股是以鸡毛上涨的方式拉升。当股指处于振荡时，那些上涨的个股，情况完全类似，除极少数快速拉升外，大多数也是采用鸡毛上涨的方式步步为营。例如图2-38是华兰生物（002007）在2007年的鸡毛上涨行情（周线），图2-39是金螳螂（002081）在2007年的鸡毛上涨行情（周线）。我们看到上涨过程中的周线的持续性都如此之差，日线的持续性就更加让人望而生畏了（图2-40）。像这样一步三回头、四回头、五回头的拉升，对投资者的入市点位、止损点位的设置，以及持仓的耐心，都是极大的考验。对于鸡毛上涨的个股，如果仍然采取连续追高的方式买进，肯定会三番四次地撞得头破血流，这个时候，比较稳健的方式是，首先判断目标个股已经处于明显上升趋势，然后，等待它回调到趋势线附近，再逐步买进。我要再次指出，除了龙头股以外，对一般个股而言，这种鸡毛上涨的拉升方式是最常见的。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>从亏损到盈利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[3-我对交易策略的认识]]></title>
    <url>%2F2021%2F01%2F02%2F3-%E6%88%91%E5%AF%B9%E4%BA%A4%E6%98%93%E7%AD%96%E7%95%A5%E7%9A%84%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 交易策略的定义及分类所谓策略，也叫谋略，是指在动手做一件事之前，针对事情发展中各种可能出现的情况，事先规划好的主动应对方案。交易策略就是在交易之前，事先制定好的何时开仓、何时平仓、仓位控制的规则体系。开仓时机、平仓时机和仓位控制是交易策略的三大要素，缺一不可，否则就危及交易策略的完整性而使之不成为交易策略了。这实际上是一种系统化交易的思想，不管是人工交易还是电脑自动交易，都必须遵循这种正确的思维方式。 现在在投资界有几个相关的术语，很容易混淆，今辨析如下。 交易系统：这个概念本意是指能够发出具体的买入、卖出、开仓、平仓、手数等交易指令的一整套交易规则，真正的交易员和分析师对此都心照不宜。可是后来很多软件开发人员把给交易所和期货公司用的那套实现交易功能的大型软件也称为交易系统，还有些水平没到位的人把仅仅是技术指标的东西也叫做交易系统，所以现在这个词应用得颇为混乱。本书所提到的交易系统，和交易策略是相近的意思，但是交易策略的含义更广一些，比如同一个交易策略下可能有几个具体的、稍有不同的交易系统，也即交易策略更偏向于一般性、思想性一些。 交易模型：和交易系统的原始意思相同，所以这个词更准确。 技术指标：往往简称指标，是指能够绘出图形但不发出交易指令的某个数学公式，仅仅用于技术分析，和交易无直接关系。 性能指标：是指用于评价交易系统性能是否良好、优缺点如何的评价指标。 公式：泛指技术指标和交易模型。 交易信号：在技术指标上标出来的提示买卖的信号，比如箭头、文字等，也是属于技术分析的范畴。 交易指令：指电脑自动交易系统或人工交易所发出的委托单指令，属于交易范畴。 在我看来，交易策略可以分成纯客观、纯主观、粗线条客观细节处主观三大类。 纯客观的交易策略强调整个决策链中的每一步都要能够客观描述，具有完整性、客观性和惟一性。依据这类交易策略做成的交易系统往往体现为一组公式，然后编成电脑自动交易软件，这类交易系统适用于短、中、长线交易，并且方便进行历史数据测试及参数优化。然而，由于金融市场的混沌性，要想对趋势进行较精确的描述、建模是件极困难的事。而且并不是所有的纯客观交易策略都可以编成电脑自动交易程序，因为有些因素虽然客观但不容易量化，或不适合编成程序。 纯主观的交易策略，即在开仓时机、平仓时机和仓位控制方面完全是凭主观判断，是一种艺术型的投资风格。尽管每一步都是主观判断，可是成功的纯主观交易策略，其交易思想仍然类似于其他类型的成功的交易理念，其结果统计也符合通用的成功的交易策略的性能评价指标。高手凭直觉主观交易就能成功，是因为他对市场运行规律、对理念、心态、策略、技术的整体把握已经非常到位；而新手如果也企图凭直觉交易，则会陷入主观随意的情绪性交易而亏得一塌糊涂，这是因为他的天性并未扭转过来，他内心深处的“慢性病”并未治愈，所以他的直觉更多地只是错觉。这类交易系统也适于短、中、长线交易。纯主观的交易策略能否进行历史数据的测试？过去一直认为是不能的。然而，我发现有一个办法可以测试。在我开发的投资培训游戏中，当数据库中的训练样本足够大时，受训者的记忆效应将被完全抹除，这样，给定他一组历史数据，他就可以根据纯主观的交易策略，决定是买、卖还是观望，做出决策后再按一下空格键，又出来一个新的历史数据，这样一直测试下去，最后对交易结果进行统计评价（相对于传统的纯粹机器测试法，我把这种测试方法称为“人工测试法”）。 粗线条客观细节处主观的交易策略，是我最欣赏的一类交易策略，我目前也在使用，并认为它综合了纯客观和纯主观交易策略的优点。顾名思义，先找一个在粗线条上，比如在周线、双周线、月线上测试性能良好的纯客观交易策略，这样就把自己的交易策略建立在一个可靠的坚实的客观基础之上，然后，在充分理解这个交易策略的背后思想之后，再兼顾金融市场的混沌性和电脑程序的笨拙性，在细节地方充分发挥人的灵活性，这样就把机器的客观性和人的主观能动性充分结合起来了。我所使用的具体的交易系统一般都经过粗线条的客观测试和细节处的主观修正这两个步骤。显然这类策略只适用于中、长线交易，并且对交易员的整体的理念、心态的修炼要求比较高，否则在细节处的主观发挥就会变味。这类交易策略除了在粗线条上使用纯粹机器测试外，也可对最终策略使用人工测试法。 交易策略之关键要素及交易系统性能评价指标从实际操作的过程来说，任何交易策略必须包含开仓时机、平仓时机和仓位控制三大要素，缺了任意一个都不能称之为交易策略或交易系统。若再细分起来，则有开仓、持仓、止损、加仓、减仓、止盈、重新开仓、资金管理公式等等。经常听到某某人说他新发现了个什么秘诀，仔细一听却只是一个关于开仓时机的方法，对于平仓时机及仓位控制没任何描述，不禁哑然失笑。 从性能评价的角度来说，成功的交易策略（交易系统）包括六个方面的关键要素：可靠性（胜率）、利润和亏损的相对大小（风险回报率）、交易成本（佣金）、交易频率、账户规模、头寸调整模型。很多人往往只重视这六个因素中的某一个而忽视其他因素，因而导致投资理念上有重大缺陷。 下面结合其他指标来解释为什么这六个要素很关键。 图3-1是我开发的交易系统中所使用的性能评价指标，分别介绍如下： 图3-1 我开发的交易系统中的性能评价指标 N=测试的交易日天数/240（即一年按240个交易日计算） 年复利率为考虑所有因素后得到一个净结果的最终评价指标。如果有某种策略使得每个月的年复利率为正，不管具体数值多大或多小，则几年下来会滚动成一个惊人的数字。所以每个月的年复利率为正就成了投资的终极目标。 算术期望（期望收益）=（期末净资产-期初净资产）/总交易次数=净利润/总交易次数=平均单次盈利额×盈利几率（胜率）-平均单次亏损额×亏损几率-平均单次佣金 显然算术期望为正是一个交易系统有实际价值的首要条件，并且越大越好。从实际交易经验来看，对短线交易，平均单次盈利额和平均单次亏损额相差不太远，故要求胜率大于50%，且越大越好；但对长线交易而言，只要做到“迅速止损，放足盈利”，则平均单次盈利额和平均单次亏损额非常悬殊，故对胜率没有太高要求，一般达到30%-40%就可以接受。平均单次佣金对短线和长线都差不多，但长线交易次数少，故总的佣金很少，而短线若过度交易，则佣金会非常庞大。然而，短线的优势是交易机会频率高，一旦找到正算术期望的交易系统，则会导致年复利率非常之高。我就见过一个短线高手在10个月之内将账户上的资金翻了30倍，其中只有2个月是亏损的，这样的资金增值速度对长线来说是很困难的（不过做短线赚钱的人极其罕见，读者不可盲目模仿）。 此处附带讲讲短线和长线在交易原则上的一个重大区别：长线行情的持续性和稀缺性都很强，这就决定了长线交易必须追涨杀跌；而短线行情并不稀缺，但持续性很差，所以短线必须高抛低吸，而且短线交易在趋势不明显的时候做才更合适。另外，若考虑的时间尺度越大，则技术分析的效果越好，故而对中长线交易不需太重视基本面；但若时间尺度越小，则随机性的干扰越明显，故而对短线交易一定要高度重视基本面的作用，单靠纯粹的技术分析往往效果不佳,最明显的例子是外汇短线交易。我的这个观点刚好和市面上流行的观点相反。由于二者的理念刚好倒过来,所以能同时做好长线和短线的人是非常罕见的。新手往往既喜欢做短线,又喜欢追涨杀跌,焉有不败之理。我过去刚开始做股票和期货的时候,就犯了好几年这样的错误。 显然:几何期望反映的是平均每次交易净资产的增值的倍数,而算术期望反映的是平均每次交易净资产的增值的绝对数额。 由于几何期望是资产的倍数增值因子,而算术期望只是加减增值额,故几何期望比算术期望更加重要。二者有如下关系(设A为算术期望, G为几何期望, R,为单次收益率, s为(R+1)的标准差, G,为期初净资产): 这个关系表明,若每次收益太分散,则标准差s会变大,从而会抵消算术平均值的好处。我在本书第一章中指出,一个好的交易系统不但要有高的算术期望,还要求资产增值曲线平稳增长,实际上就是这里的s要小,这样G才大。 图3-2画出了G与平均单次收益率瓦的 图3-2 G与平均单次收益率凡的关系关系。 利润系数=所有盈利之和/所有亏损之和 由于利润系数这个评价指标不太好用,于是引入悲观利润率这个新指标: 悲观利润率是赋予亏损交易更多的权重，总交易次数越多，悲观利润率越接近利润系数。 悲观利润率在评价和比较不同的交易系统方面是个很好的指标。若一个交易系统的悲观利润率大于2.0，则表明此系统的性能很好，若大于2.5，则为优秀。 单位风险收益=算术期望/最小单笔亏损 撒普博士提出了“一元风险的期望收益” （R乘数），即期望收益除以初始止损额度，这个概念用于衡量风险收益比非常好，也很方便使用，但就是难以让电脑全自动计算，于是我把初始止损额度改为最小单笔亏损，杜撰了“单位风险收益”这个指标，这样一来电脑是会自动计算了，但结果常常比真正的收益风险比偏大，因为有些亏损小于初始止损额度。所以这个指标没有字面意思上那么重要。 月交易频率=总交易次数×20/总测试天数 月交易频率就是平均每月交易多少次。 胜率=盈利交易次数/总交易次数 胜率只有对短线交易才重要。 报酬率=（期末净资产-期初净资产）/期初净资产×100% 期初金额即期初账户净资产，期末金额即期末账户净资产。资产最高点、最低点，即账户在测试期间的最高、最低净资产，获利金额即所有盈利之和，亏损总额即所有亏损之和，净利总额即获利总额减去亏损总额，期初金额加上净利总额减去佣金即得期末余额。平均获利金额即获利总额除以获利笔数，平均亏损金额即亏损总额除以亏损笔数，平均每笔盈亏即净利总额减去佣金后除以交易笔数。其他指标的含义和字面意思相同。交易笔数即总交易次数，一般要大于20次，其统计结果才有可信度，图3-1中的这个例子交易笔数太少了。对于佣金，咋一看好像对交易结果的影响并不大，但事实上如果频繁交易，到月底一看账单会吓你一大跳!很多人做短线交易所得的盈利还不够交佣金，所以说佣金是个无形杀手。 单笔最高亏损和最大连续亏损次数，这两个指标对于资金管理（头寸调整）具有重要意义。 现在我们回头理解撒普博士所说的六个关键因素。从算术期望的数学公式可以看出，一组匹配恰当的胜率、利润亏损比及佣金，就会产生一个正的算术期望，这个正的算术期望是整个交易系统的基础。可是这个正算术期望只是一个统计结果，我们还要考虑它的构成，于是就发现每次收益越均匀越好，即几何期望越大越好。有了这个正的算术期望（最好还要有高的几何期望），则交易频率越高越好，它决定收益出现的时间密集度。而头寸调整模型，即资金管理模式，决定了收益出现的空间密集度。当单笔最高亏损和最大连续亏损次数越小，也即每次收益越均匀，几何期望越大，资产增长曲线越平稳，凹坑越小，则开平仓规则和资金管理模式越容易匹配良好，资金管理模式就越灵活，仓位加重后出现大亏的可能性越小。而合适的交易资本的规模，即账户资金的大小，则是前面这一切的前提条件。当资金量太小时，只能生硬地交易1手、2手，资金管理模式无从谈起，还往往导致一次止损就已经是损失过大了，比如5万元的资金账户去交易铜，或20万元的资金去交易HS300股指期货，那么一次止损的损失很可能已经远超5%了，故而很不恰当。 资金管理模式资金管理模式，我指的是仓位控制，或叫头寸管理，即什么时候开多大的仓位。一般人所说的止损幅度多大，或者该持有几个不相关的品种，我认为这些是属于风险控制或投资组合（分散化）的问题，并不属于资金管理模式的问题。资金管理模式专注于该开多少仓位的问题，有些做法是依据某个数学公式，另一些做法则不能写成简单的公式，故统称模式。如上节所述，资金管理模式决定收益出现的空间密集度，因此是一个事关交易成败并且能否把期货事业做大的决定性问题。 很多做股票出身的人往往喜欢简单地使用满仓、半仓、三分之一仓的做法，我认为这是不妥的，对于期货交易而言，无论是做长线还是短线，这样都是一次性开了太重的仓位了。 如果是做长线，因为持仓时间长，可以从容地试探，加码，再加码，具体多少仓位可以有一定的随意性，只要能满足轻仓的原则就可以了。但是，如果做短线，因为交易次数很多，资金滚动的复利效应很突出，仓位管理上的微小差别对将来都有显著性影响，因此最好严格使用经过充分论证的某个数学公式。 不论具体采用何种方法，我认为成功的资金管理模式都必须遵循两个原则，一是控制单次亏损额，一般以不超过总资产的5%为宜；二是要乘胜追击，而不是屡败屡战，即在盈利时增加仓位，而在亏损时减少仓位。当然乘胜追击时所增加的仓位也是逐步增加，而不能一次加太多。至于每次亏损则增加仓位这一“等价鞅”策略会带来两个致命的问题，首先，每个人的资金都是有限的，这个过程无法永远持续下去，其次，会产生报复性交易心理，不但仓位加重，进出也变得更频繁、更草率，甚至情绪失控，结果把一笔小亏损演变成一场灾难。赔钱时，最好的办法是赶紧止损离场，出去打打球或者回家睡一觉，下次再从小仓位重新开始。赔钱后的首要任务不是急着扳平，而是重建交易信心。 资金管理模式有没有一套经过严密论证的系统化的科学理论？很遗憾，在我所了解的范围内，没见过这样的理论。所以下面只能介绍一些我所知的经验性的做法。 模式1：每固定金额开仓1手合约。 例如，每5000元可用资金则买入1手白糖合约，或1手大豆，如果有10万元则买入20手白糖或20手大豆。这种模式的优点是简单明了，缺点也很严重，它把不同品种的风险同等对待，实际上1手白糖和1手大豆的风险并不相同，而每5000元买1手PTA的风险可能太大了，风险暴露过度。归根到底，此法对交易风险无明确的概念，因此我不建议大家使用此方法。 模式2：每固定金额交易一个品种。 比如一个账户有20万元，分成2份，每份10万元，事先定好杠杆比都为5倍，则每份交易额有50万元，分别交易沪铜和棉花，假定1手沪铜的价值为25万元（即5万元/吨），则可买2手沪铜，假定1手棉花的价值为7.5万元（即1.5万元/吨），则可买6手棉花。这种方法的优点是对持仓中的每个品种赋予相同的权重，杠杆比也很清晰，缺点是对每笔交易所承担的风险大小仍然没有一个事先明晰的概念。 模式3：每固定风险百分比交易一个不相关品种。比如一个账户有10万元，事先确定单笔风险为5%，即若止损的话损失的钱不能超过100000x5%=5000元，现在大豆报价每吨3000元，若买进的话事先确定止损点为2900元，即：亏100元就斩仓出来，那么应该开仓5000/100/10= 5 （手）；同时再做与大豆不相关的沪铝，假定报价为20 000元/吨，若做多的话事先确定止损点为19900，即止损幅度为100元，那么应开仓5000/100/5= 10（手）（显然大豆的止损宽松些，而沪铝的止损很紧）。这就是说，不管交易什么品种，最多只能亏5%。按照这种做法，你还可以再拿5000元风险额度去交易白糖，最终会导致满仓，甚至保证金不够用。这样做听起来好像很危险，其实只要你同时交易的是不相关的品种，而且给予宽松一些的止损幅度，则风险是完全可控的，并不容易招致经纪公司强行平仓，资金利用率也很高。只要你严格止损，那么风险是事先预知的、可控的。我个人很欣赏这种风险完全清晰的做法。 模式4：每固定波动性百分比交易一个不相关品种。 波动性是指期货品种的日常真实价格波动幅度。真实价格幅度是指以下三者的绝对值的最大值：①当天的最高点减去最低点，②当天的最高点减去前一天的收盘价， ③当天的最低点减去前一天的收盘价。这个模式的要点在于把每一头寸的波动值限制在总资本的一个固定百分比。比如一个账户有10万元资本，假定只允许资本的最大波动性为2%，则100000 ×2%= 2000元，再假定白糖的日常平均波动幅度为30元，则可开仓手数为2000/30/10=6手。如果账户还有剩余可用资金，可以交易不相关的其他品种。此模式同样存在满仓甚至保证金不足的问题。经过编程实际测试，这个模式的效果也很好，但比模式3更加激进。缺点是必须另外指定止损点，波动性大小并不是实际的止损风险。 模式5：凯利公式。 凯利公式原来是信息论中的一条公式，后来被引入到赌博论中，再后来被拉瑞·威廉姆斯应用于一次期货实盘大赛中，结果他在一年内将1万美元最高做到210万美元，之后又跌到70万美元，年底比赛结束时回升到110万美元，轰动全美。 设P为胜率， R为风险收益率，即R= （各次盈利之和/盈利次数） / （各次亏损之和/亏损次数）， F为账户资金的可用百分比，则：F=（（R+1）P-1）/R例如一个账户有10万元，所使用的交易系统胜率P-0.65， R=3，则F=0.53，可开仓之资金为100 000×x0.53=53000元，假定大豆每吨2500元，则可开仓手数为53 000/ （2500 × 10×0.08 （保证金比例））=26手。凯利公式为什么导致大起大落？后来拉夫·威斯在研究后指出”，这个公式本身要求每次盈利和亏损的大小是分别固定的，而期货交易显然不满足此条件。 模式6：琼斯的固定比例交易。 关于琼斯的固定比例交易，由于翻译进来的两本书都没有讲清楚，而我又没有英文版，因此对这个模式我也没彻底理解。大意是说，每当盈利达到账户资产的某个固定百分比，开仓时才能增加一份新合约。比如10万元的账户，假定按照现在的策略和价格可以买卖10手大豆，那么可以规定只有盈利达到账户的10%，即盈利1万元，开仓时才能增加到11手合约。 模式7：拉里·威廉姆斯公式。 拉里认为造成资产大起大落的真正原因不是胜率，而是来自亏损最大的那笔交易，并且强调此观念十分重要，因此必须把最大亏损纳入资金管理模式中。他提出的公式为：1开仓手数=账户余额×风险百分比/历史单手最大亏损 风险百分比是人为定出的，拉里建议一般不要超过15%，历史单手最大损失就是每次只开仓1手对历史数据进行测试时的最大亏损额。例如一个账户有10万元，风险百分比定为15%，所使用的交易系统的历史测试单手最大亏损为6000元，则开仓手数=100 000 15% /6000~2。拉里认为这条公式是通向财富王国的金钥匙，他已经用此赚了数百万美元。我的编程实践表明，此公式确实比较稳健。 模式8：拉夫·威斯的最优风险百分比公式。 在拉里·威廉姆斯公式中，风险百分比是根据经验人为地决定的，可是拉夫·威斯的研究表明，可以用一种方法找到客观的最优风险百分比。设风险百分比为， PLi为第1次交易的盈亏额（带正负号）， BL为历史最大单手亏损（为负）， M为总交易次数， G为几何期望，则：用电脑对f从0到1进行扫描，找出对应最大G的即为最优风险百分比。 开仓手数=账户余额×最优风险百分比/历史单手最大亏损 拉夫通过实例表明，对任何交易系统都存在一个客观的最优风险百分比fop，当交易次数很多时，f对fop的微小偏差都会引起最终收益的巨大变化。当实际应用的广小于fop，则未发挥系统的最大潜力，当实际/大于fop，则在暴露更大风险的同时实际收益反而下降，若实际/超出fop一定限度，即使是具有正算术期望的系统也会稳定地亏钱（读者用电脑对f从0到1扫描也能得出此结论，几何期望小于1即为亏损）。所以，对任何交易系统都不是仓位越重越好!一个具有微弱正算术期望的交易系统，若工作在fop，都会产生良好的收益，反之，一个具有巨大正算术期望的系统，若工作在糟糕的5，同样会产生糟糕的结果，所以fop是一个极端重要的概念。若已经有了一个具有正算术期望的交易系统，不去进一步寻找它的fop，而再花时间去寻找其他“更好的方法”，是一种常见的不正确的行为。 拉夫有一个研究结论很值得一提，至少对电脑自动交易系统而言，如果你想在某一时间段内获得最多的资产增值，或者想用最短的时间达到某个资产增值目标，那么在过程当中的资产大幅返折是不可避免的。所以，一般人通常的做法，比如开一个100万的账户，却只允许最多亏损10万，这是不正确的。正确的做法是，开一个不要太大的而且你能容忍85%~90%返折的账户，即哪怕有时几乎输光了你也能坦然接受，然后放开手脚严格按照数学去执行，而一旦达到目标资产，则严格按计划止赢，提出应提部分，不要保留。据说拉里·威廉姆斯也是每年年初都从小账户重新开始。这种做法有一定合理性，特别是账户一定要止赢，但是这种做法只适于电脑自动交易，若需要主观临时判断，则会造成对亏钱毫不心疼，对心态影响极坏。 拉夫还有一套资产组合理论，略为复杂，这里就不介绍了。 模式9：试探一加码法。 对于长线交易如何加仓？何时加减仓？加减多少仓位？有无仓位的计算公式？这些问题在公开的文献中很少有人探讨，偶有提到也只是笼统地说迅速止损，放足盈利，或说用倒金字塔加码，所以加仓的问题仍然是个未解的难题。就我本人的做法来说，我认为倒金字塔是不合理的，它把最大的一笔风险放在第一次交易上，根本未知水深水浅就投进最大一笔资金。合理的仓位管理应该是菱形的，先投少量资金试探，发现看对了行情时，才逐步加仓，判断主行情来了才投入大部队作战，随着主升（跌）浪的过去，加码的资金越来越少，甚至停止加码，每次没有浮动利润不允许加码，浮动利润没超出品种日常波动幅度也不允许加码。实战中我会逐步加至满仓，但在仓位过半后，若加仓后三天内行情不再往前走，则会砍掉新加的仓位，但在每次加仓的具体数目上，我仍有一定的主观随意性。如果每次加仓都严格按照上面的模式1至模式8来计算，则会如何？我认为这个做法很好，只要每次加仓都事先明确风险，并且严格止损，那就没问题。 图3-3是我前几年编程开发的一个交易系统加资金管理模式的历史数据测试结果，图中所示的是一种比较稳健的资金管理模式。当然对历史数据测试的一个突出问题是，当账户资金变大了也无法考虑市场容量问题。 坦率地讲，对于资金管理模式的诸多问题，比如长线的加仓问题，短线的不同性能的交易系统与不同的资金管理模式的匹配问题，等等，我都有模糊的地方，当然这些也是整个业界所面对的共同的难题。为安全起见，目前我只使用较保守的试探一加码模式。 投资与投机投资与投机，历来是充满争议的一个话题。古今中外，从经济学家、投资大师到普通市民，还没有一个人能够把二者严格区分开来，真是见仁见智，欲说还休。所以，投资与投机是个永恒的命题，关于它们的争论永远不会停息。在英文中，投机（speculating）的本意是指，在事实不够充分的情况下推测未来。既然是依据不充分的推测，当然充满风险。在英文中，这是个中性词，无所谓褒贬，但是在第一次翻译成中文的时候，也许翻译者对这种行为有偏见，就把它翻译成带有贬义的“投机”。 在金融领域，究竟应该怎么样定义投资与投机？由于说不清楚，很多大师的著作都回避了这个问题。价值投资之父本杰明·格雷厄姆在他那本著名的《证券分析》的第四章中，是这样说的”： 投资是指根据详尽的分析，本金安全和满意回报有保证的操作。不符合这一标准的操作就是投机。 我曾经反复阅读他在这一章中的论述，也许是我愚钝，恕我直言，我认为这句话是他经过长期研究，仍未能区分投资和投机之后，所讲的一句和稀泥的话。首先这句话模糊不清，怎样才叫“详尽的分析”？每个人的知识和判断力都是有限的，所能获取的资料也是有限的，谁都不可能百分之百地详尽，而一旦不详尽就可能有漏洞，一有漏洞则可能不自觉地陷入投机：怎样才叫“本金安全有保证”？世界上存在绝对安全的投资吗？没有。所以本金安全只能是一个相对安全罢了，既然是相对安全，就没办法“有保证”。格雷厄姆的得意弟子、当今世上最伟大的投资家巴菲特都时不时做亏本生意呢!怎样才叫“满意回报有保证”？多少才满意？有的人赚了5%就很满意了，有的人赚了100%还不满意，碰上失败的投资能保本就非常令人满意了。既然连本金安全都谈不上绝对有保证，那么满意回报也就谈不上一定有保证了。总之，关于投资的这个定义是模糊的、没法操作的。其次，让人觉得滑稽的是，关于投资的这个定义也完全可以用来作为投机的定义，也即”（理性的）投机是指根据详尽的分析，本金安全和满意回报有保证的操作”。因为理性投机决不是不劳而获，也是要花很多时间去收集资料（包括基本面的资料），然后进行艰苦而详尽的分析，同时理性投机允许甚至假定自己是经常出错的，所以强调止损，只要能把握好止损，则本金的安全是有相对保证的，还有，只要投机所采用的策略具有正的算术期望值，再加上合适的而不是过大的仓位控制后，则长期来看满意回报也是有保证的。呵呵，可笑吧!如此看来，连一代价值投资大师也区分不清何为投资、何为投机。 那么，关于投资和投机的区别，到底有没有一种被人们普遍接受的说法？还是有的，我认为下面这句话是最广为接受的投资是指通过买进某项资产，以获取这项资产所带来的收入作为收益的行为；投机是指通过买进卖出某项资产，以获取这项资产的差价作为收益的行为。 例如，如果买了股票就藏起来，只着眼于股息、分红作为收益，那么算是投资：但如果买了半年以后，发现股票价格翻了一番，就把它卖了以获得收益，这种行为就变成投机了。又如，如果买了个房子拿去出租，以租金作为收益，这种行为是投资；但看到房价涨了，觉得卖掉比出租划算，就卖了这种行为就是投机。 但是，被人们普遍接受的说法，并不意味着它就没有问题。在上面的对投资的定义中，只要“资产没变坏”，哪怕价格涨得再高，或者跌得再离谱，你都不能卖出，一旦卖出，你就由“高尚的投资者”变成“可耻的投机者”了。然而，在全世界你找得到“只要资产质量没变坏，就坚决不卖出”的投资者吗？我相信你找不到，连巴菲特都经常卖出。最近的一个例子是，巴菲特于2003年在香港以每股1港元多的价格大量买入中石油，再于2007年下半年以平均价12港元多的价格不断抛售，赚了大约6倍多。难道中石油的基本面变坏了吗？没有啊，中石油还是一个那么赚钱的企业，甚至在巴菲特卖出后股票价各还继续涨了很多呢。那为什么巴菲特要卖出？巴菲特的习惯是从来不公开买进卖出的理由，我猜测是他觉得价格太高了，卖掉更合算。如果按照上面的说法，岂不是巴菲特也成了投机者？如果连巴菲特都是投机者，那全世界还有谁不是投机者？ 在我看来，投资与投机是同一交易过程的不同侧面，是互相依存、无法截然分开的，无所谓谁对谁错、谁好谁坏。 过去，在计划经济时代，人们总是把投机同“投机取巧、投机倒把”等贬义词等同起来。现在，进入市场经济阶段以后，很多人慢慢就认识到，原来投机对于宏观经济是有积极作用的。投机对于宏观经济的积极意义至少体现在五个方面，一是促进市场信息流动，将许多被阻滞的信息迅速有效地传播开来，产生了极好的效益；二是中介买卖双方，沟通产销，调节供求关系，平抑物价波幅，促进市场流动性；三是促进社会资源合理流动，修正各生产要素由于时间差、空间差所产生的不匹配，有利于社会资源合理配置；四是有利于市场竞争，促进产销效率的提高；五是承担和规避风险，使得市场风险得以转移，得以化解。所以总的说来，投机是整个市场经济不可或缺的“润滑剂”。排斥投机只是某些人的无知，从来就没有一本严肃的经济学著作会去诋毁投机的积极作用。 现代期货市场是市场经济发展到一定阶段的高级产物，对于宏观经济的正常运作提供着规避风险和价格发现两大功能。规避风险也即“套期保值”，指生产商在实际生产经营过程中，为避免商品价格的过高起伏导致成本上升或利润下降，可在期货市场上买进或卖出与现货市场上数量相等但方向相反的产品，使两个市场的盈亏相互抵消，从而达到转移风险的目的。如果期货市场上只有套期保值者而没有投机者，则套期保值者根本就找不到交易对手，风险无法转移，期货市场就无法发挥规避风险的功能。而投机者大量介入后，在承担套期保值所转移过来的风险的同时，利用期货的价格波动，来赚取风险利润。其次，期货市场要想发挥价格发现的功能，也必须依靠大量的供求和充分的市场流动性来实现。如果没有投机者，只剩下几个套期保值者的话，肯定是供求不足，成交量形不成规模，市场流动性很小，后果就是价格大起大落，奇高奇低，无法形成反映供求关系的真实价格，导致宏观经济的价格信号陷入混乱。所以说，投机者对于宏观经济发展也是贡献良多的。最近几年，一些具有知识和良知的专家学者，不断呼吁加快建设期货市场的机构投资者，就是因为国内市场明显投机不足，阻碍了期货市场两大功能的充分发挥。 投机分为理性（良性）投机和恶性（非理性）投机。理性的投机对于国民经济是必要的和积极的，就类似天气里的刮风下雨，而恶性投机就像天气里的台风、热带风暴，对于国民经济有破坏作用，但是政府可以通过制定健全的法律制度来限制恶性投机的破坏程度。对于天气，我们欢迎和风细雨，我们也习惯于刮风下雨，但是，对于台风和热带风暴，不管我们喜欢不喜欢，每年它们还是要来几次，只要做好预防措施，还是可以降低损失的。同样的，在市场经济里，我们喜欢价格平稳，我们也习惯于价格有小波动，但是，不管你喜欢不喜欢，每隔几年，总是有这个或那个泡沫被吹起来，总是在这个或那个领域出现恶性投机。只要我们保持理性，即使不说远离泡沫，也要控制好仓位，做足预防措施，这样也总还是可以保全大部分资产的。下面再谈谈社会上对于投资和投机的种种误解。 在本杰明·格雷厄姆的那个年代，很多人认为买债券是投资，买股票则是投机，因为债券很安全，而股票风险极大。到了现在，几乎没有人再认为买股票是投机了，于是新的观点又出来，说什么“买股票是投资，买衍生品了还可以放上几年，等待解套，而买衍生品风险极大，被套了就亏了”。持这样观点的人，其立足点只有一个，那就是： “账面亏损不是真正的亏损；放上几年一定会解套的。”这样的立足点是很脆弱的，且不说你能不能熬满那几年，等到解套那一天，就算真的熬过来了，心态也被破坏殆尽，投资水平必定毫无进步，等于是浪费了几年的时间和机会。更何况很多人根本熬不了那么久，有一天信心崩溃了，就在底部割肉了，造成真正的巨亏。还有的股票，跌了几年就干脆退市了，投资者几乎血本无归。买卖金融衍生品是不是投资，我们只需要看巴菲特和其他大型机构投资者怎么做就知道了。最近几年，随着金属、能源和农产品的价格轮番上涨，国际上的大型、巨型的以保守、稳健为主的机构投资者，比如养老基金、保险基金，都纷纷进入商品期货市场，他们称之为“商品投资”。著名投资家罗杰斯更是呼吁投资者，不要买和商品相关的公司的股票，而是直接买入商品本身。难道这些大型机构都突然跑去摘“投机” ？难道著名投资家罗杰斯公开呼吁人们搞投机？再看巴菲特，他的一大爱好就是激进地买垃圾债券，历史上曾经数次因此而大获全胜。最近（2008年四五月份），次贷风暴还没完全结束，他又大口一张，吞下21亿美元的垃圾债券。垃圾债券之所以被称为垃圾，肯定是基本面和技术面都有问题的债券，巴菲特居然去玩它们，你说是投资还是投机？巴菲特还喜欢玩外汇，从2002年开始长期做空美元，总的情况是赚得盘满钵满，但在2005年美元反弹，他当年亏损近10亿美元，直到2008年他还在看空美元。巴菲特还玩期货、期权和掉期，在2006年的时候，他认为金属和能源价格涨得太恐怖了，于是大量抛售白银，大量买入黄豆、玉米、小麦、白糖等农产品，这一做法和罗杰斯不谋而合。在2008年第一季度的财报中，他披露，由于大量交易“信用违约掉期”和股指期权，造成暂时的账面亏损达16.9亿美元之巨。看看，巴菲特把衍生品几乎都玩遍了，按照某些人的观点，他应该成了彻头彻尾的投机者了。还有些人，出于某种目的，在国内把巴菲特宣传成一个只专注干股票投资的股神，误导不明就里的人们。 还有一种很流行的观点认为，根据基本面分析（指分析公司的产品销售状况、财务报表、管理团队等，或者分析国家宏观经济状况，或者农作物的种植、生长、天气状况，或者工业品的生产、消费状况，等等）买卖是投资，根据技术面分析买卖是投机。这种观点也很迷惑人。其实技术分析的核心是一套正确的交易策略，对于用于行情分析的具体理论，并不主张惟一性，因此，技术分析中的行情分析理论，具备包容性和开放性，连基本分析都可以包容进来。也就是说，技术分析并不排斥甚至也主张进行基本分析，当基本面因素和技术面走势相互印证时，是至为理想的交易机会。然而，当基本面因素和技术面走势相矛盾时，怎么办？技术分析主张此时有两种选择，一是放弃这次交易，二是以技术面走势为主，因为我们要承认，背后可能有还不为我们所知的其他基本面因素在发挥着作用。这就牵涉到一个问题，分析出错了怎么办？分析有遗漏怎么办？人非圣贤，谁能无错？不管用哪种方法分析都可能出错。技术分析本身包含有很好的容错机制，这就是止损，保命第一。然而，基本面分析有容错机制吗？万一基本面分析有差错、有遗漏，怎么办？也许我孤陋寡闻，至今我还没看到基本面分析的容错机制。另外，很多搞基本分析的人，对于技术分析是极端的排斥，这点让我难以理解。难道投资是一门纯粹的科学？存在着独一无二的真理？怎么样证明基本面分析是独一无二的、惟一正确的真理？ 还有一种观点，把投机等同于短线操作，或者干脆把技术分析等同于短线操作，这种观点很肤浅，不值一驳。其实，交易的时间尺度越大，则技术分析的效果越好。道氏理论更加声称，日内杂波是没有交易价值的。还有其他一些离奇古怪的说法，比如认为把资金投入到胜率小于50%的事件，就是投机。如此说来，风险投资（指投资于创业阶段的急需资金的小公司）都是投机了，因为历史统计表明，风险投资的胜率还没有大于50%。更有一种说法，认为买蓝筹股就是投资，买二线、三线股就是投机。这种说法也经不起推敲，蓝筹股的大企业固然有垄断优势、规模优势，但问题是其所占的市场份额也相当大了，要想更大一点就很困难，也就是失去成长性了。再说，很多大型蓝筹股也是由当年的小公司逐步发展而来的啊，比如万科（000002）是大家公认的一流大公司，在20世纪90年代初也是一家小公司啊，当年在房地产业中，无论规模还是业绩，它都不是最好的。那么在90年代买入万科股票究竟算是投资呢还是投机呢？ 说了那么多，结论还是一句话，要严格区分投资和投机是不可能的，没有必要钻这个牛角尖。 从交易策略的角度来说，投资也好，投机也罢，交易策略是允许相同的，最要紧的是满足两个条件，一是和自己的性格相适应，形成具有自己特色的盈利策略；二是满足前面第3.2小节所讲的六个关键要素，各次买卖结果统计起来要具有正的算术期望值，以及尽量大的几何期望值。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>从亏损到盈利</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十五章 行情反转的重要信号]]></title>
    <url>%2F2020%2F12%2F23%2F%E7%AC%AC%E5%8D%81%E4%BA%94%E7%AB%A0-%E8%A1%8C%E6%83%85%E5%8F%8D%E8%BD%AC%E7%9A%84%E9%87%8D%E8%A6%81%E4%BF%A1%E5%8F%B7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 行情反转的三个重要信号本节我想给大家介绍一下商品期货行情进入大的反转的三个重要标志，需要声明的是，我并不赞成摸顶抄底，因为根据我多年的经验，在市场进入顶部或者底部的时候往往非常折磨人，摸顶抄底必定会让你频繁止损出局，对于绝大多数交易者而言，我更加推荐右侧交易。 此外，我所介绍的市场反转的三个重要标志，一方面是我自身在期货市场中的亲身经历，而且也经过多次验证；另一方面是给期货交易者提供一种平仓离场的警示信号，并不是要你在这个位置摸顶抄底或进行反手操作。 标志一：价格处于高位或低位，基差得以修复后需谨慎。 前面我们介绍了商品期货的两大趋势，库存重建过程中的上涨与去库存过程中的下跌。无论是上涨或者下跌，由于预期的作用，导致了期货与现货上涨或下跌的幅度并不完全相同，所以在上涨或下跌的过程中基差会被拉大。 以库存重建过程中的上涨为例，大趋势是上涨的，无论是期货引领现货上涨，还是现货引领期货上涨，一旦基差被拉大，就会发生次级别的回调，即下跌的行情来进行基差修复，基差修复完成后，会开启新一轮的主趋势的上涨。所以，一个典型的趋势可以分解为两种情况：一种是主趋势库存周期的上涨或下跌，另一种就是次趋势的基差修复行情。 在一轮大趋势的情况下，上面的逻辑得到多次验证。无论是橡胶期货引领现货上涨，还是矿石现货引领期货上涨，莫不如此。可是我在这上面也吃过不少亏。因为，在趋势的初始阶段和延续阶段这样操作并没有什么大的问题，然而在趋势转折阶段却很容易亏钱。 以橡胶为例，在2016年，橡胶明显是期货引领现货上涨，开启了一轮大的上涨趋势，期货涨得比现货快一些，所以在期货上涨的过程中基差被拉大，接着就是期货下跌或者现货上涨来修复基差，基差得到修复之后，再次开启新一轮的上涨。然而，当橡胶指数在2016年末2017年初时达到22355点，现货快速上涨基本上又将基差修复了。 按照正常的逻辑，由于现货上涨来修复基差，这就为期货未来的继续上涨打开了空间，然而现实却是恰恰相反，橡胶开启了行情大反转，从22355点一度跌到了12490点。如图15-1所示。 图15-1 价格高位，基差修复，行情反转的例子 类似的情况我在棉花、矿石上也多次遇到过，后来我总结，工业品的库存周期是商品的一个主趋势，基差修复是一个次趋势，然而，在交易中也要对价格的相对高低保持警惕性，如果在高位或者低位发生了基差的修复，往往是行情的转折，而非行情的延续。 这个经验是我多次验证的来的，其背后的原因更多的是物极必返的道理以及交易者对高价位的恐惧和低价位的贪婪，所以价格处于高位或低位，同时基差得以修复后一定要谨慎，不要盲目继续去追行情，当然更不要盲目去反手。 标志二：价格处于高位或低位，日内频繁实现基差的升贴水转换时需谨慎。 通常情况下，商品在某个特定的大趋势下，一般无法实现基差的升贴水转换，只是基差的拉大与修复，因为商品依然处在某个特定的库存周期当中。然而，如果预期发生了变化，那么通常会出现两种情况，一是基差的升贴水转化，二是市场方向的转变。 例如，黑色系大部分品种都是逆向市场，所谓逆向市场就是远月价格低于近月价格，与此同时，黑色系的品种基本的都是期货贴水，所以每当期货向上修复贴水之后，都会开启新一轮的下跌。 2020年由于疫情的影响，螺纹钢5月合约在历史天量库存下，面临巨大的交割压力，所以多头主力资金纷纷从5月合约撤出。同时，市场预期随着疫情缓解，国家刺激政策出台，10月合约的需求会非常好，螺纹钢会表现出明显的去库现象，多头资金纷纷基于未来的预期，流入10月合约，从而导致过去一直是反向市场结构的螺纹钢，在疫情的影响下，短暂地变成了正向结构。 市场方向的转换大都是由于预期的一致性转变。如果市场方向发生转换之后，且能够长时间保持，说明市场行情发生逆转的可能性比较大。然而，很多交易者可能并不关注市场方向，只是关注自己当前所参与交易的合约，我在最初做期货的时候同样如此。 对于当下你所交易的合约，你需要时刻关注现货价格，你要了解基差的变化。通常情况下，基差都是修复，除非发生了市场预期的一致性转换，否则很难形成基差的升贴水转换，如果是你日频繁实现基差的升贴水转换，通常是行情进入末端，即将反转的时刻。 这一点我在2015年的股指期货上深刻体会，日内频繁的实现基差的升贴水转换，而那时候好多所谓的专家说上证指数要突破6000、8000甚至是10000点，在5000点的时候，股指期货就在日内频繁的出现基差的升贴水转换，我喝杯茶的时间账户的波动就有浮盈几十万变成浮亏几十万，实在拿不住单子了，出来了，结果果然后面就发生了行情的大逆转。 标志三：价格处于高位或低位，持仓量大幅下降需谨慎。 期货交易圈中有一句非常有趣的话：你开仓买入的每一笔单子，都是别人卖给你的，你们两人相视一笑，互道一声：笨蛋！这句话看似很有趣，其实有深刻的道理在里面。期货交易需要有对手盘，如果没有对手盘的话，你的单子便无法成交。读过《期货大作手风云录》的交易者都应该记得里面的一句话：多头不死，空头不止！这句话是很有道理的。 当多空双方对于某个商品方向产生了分歧时，多空都会加仓，此时，该合约的持仓量就会逐渐放大，在多空双方不断较量的过程中，持仓量持续放大。只要这个合约的持仓量没有出现非常明显的减少，你就可以大胆跟随多空获胜的一方进行开仓。 然而，这个品种的持仓量出现了继续下滑，与此同时，期货价格大幅上涨或下跌，那么说多空双方中的一方已经认输离场，导致持仓量大幅减少，与此同时，期货价格向反方向快速变化。我们以多头不死，空头不止这句话为例。 当多空双方发生激烈较量时，合约的持仓量不断加大，空头占主导优势，商品期货的价格重心不断下移，到了比较低的价位，持仓量大幅减少，期货价格进一步快速下跌，这说明多头已经认赔出局，斩仓离场，所以持仓量大幅下降，多头减仓就相当于空头加仓，所以期货价格会继续下跌。由于期货交易需要有对手盘，多头已死，空头获利巨大，需要兑现利润，这个时候就会出现空头平仓离场，此时，持仓量会进一步降低，而商品期货的价格快速上涨，容易出现空杀空的踩踏行情。 在期货市场中这种情况太常见了，举个例子，2016年的期货螺纹钢大战的时候，如果你仔细观察过，永安系列一直是螺纹钢的主力净多头，而期货投资者葛卫东看空螺纹，永安的产业客户做多螺纹的逻辑是供给侧改革的红利，葛卫东看空螺纹的逻辑是产业利润过大，双方都有各自的道理，于是展开了一场激烈的多空大战，螺纹持仓量大幅增加，盘面上多头占主导优势，螺纹期货价格不断上涨，双方加仓不断持续，后来，葛卫东意识到自己犯了错误，逐渐开始减仓离场，螺纹持仓量开始快速下降，而此时螺纹期货的价格也开始跟随下跌，因为多头获利巨大，也在趁机离场。 所以多空都加仓时，商品持仓量巨大，行情并未结束；当多空都减仓时，说明一方已经认输，另一方开始兑现利润，行情基本结束。如果你复盘去观察螺纹期货的历史走势，我相信你一定会发现这个规律的。 最后，需要注意一下基差的骗局，当价格或利润处于历史高位时，期货大幅度贴水，往往是假贴水，因为现货提前见顶；当价格或利润处于历史低位时，期货大幅升水，往往是价升水，因为现货已经提前见底。所以价格历史高位，期货贴水不是真贴水；价格历史低位，期货升水不是真升水。此时不可以再按按照基差的升贴水逻辑去做多或者做空。 根据主力持仓判断行情反转大部分交易者在每天期货收盘之后都会去关注一下相关品种的主力持仓情况，三大商品期货交易所在收盘之后都会进行公布，其他的一些资讯网站也会公布，但完全跟着这些主力资金的方向操作，你会发现自己经常慢半拍，被主力资金牵着鼻子走。 所以我个人认为，不能够完全按照主力资金的变化去追，而是要结合实际情况去进行客观地分析，不要把主力资金当做你期货交易的救世主，而是要结合主力资金的变化分析和总结客观的规律，然后按照客观规律去进行交易。 在关注主力合约多空持仓的时候，大多数人一般只看主力合约前20名的持仓结果是净多单还是净空单，从而判断主力的多空观点。一般情况下，对于反向市场的品种，现货市场供应偏紧，期货市场可交割的货物相对少一些，所以套保客户持仓也相对较少，多头基本上占据主动，所以前20名主力持仓一般都是净多单。如图15-2所示。 图15-2 大商所豆粕2001合约持仓情况 对于量化交易者来说，可以构成一个量化因子：净多单率，净多单率=（前20名多头持仓-前20名空头持仓）/前20名多头持仓。可以通过数据分析的方式来监测净多单率与主力合约价格变化之间的关系。 相反，对于正向市场的品种，现货市场供应过剩，期货市场可交割的货物相对多一些，所以套保客户持仓也相对较多，空头基本上占据主动，所以前20名主力持仓一般都是净空单。同样，量化交易者也可以把这个构成一个量化因子，净空单率=（前20名空头持仓-前20名多头持仓）/前20名空头持仓，从而分析净空单率与主力价格变化之间的关系。 此外，我们还经常关注主力合约第一大多头和第一大空头，当然有时候也可以看一下前3或者前5主力持仓情况，但是需要注意的是，无论是分析那个期货公司的持仓，都不能够只看他在这个品种这个合约上的持仓情况，因为这样是只见树木不见森林，我们不仅要看一下它在当前合约的持仓情况，也要看一下它在次主力合约的持仓情况，因为它可能并不是做单边的，而可能是做跨期的，从近月主力合约接货，然后转抛到次主力合约。 此外，不仅要看单品种持仓，也要看产业链上下游品种的持仓，从中观察一下它是做多产业利润还是做空产业利润。最后，还要关注一下板块持仓的情况，如工业品的持仓和农产品的持仓情况，来关注该机构的宏观对冲策略；有色、黑色、能化之间的持仓，来判断其对冲策略。如图15-3所示。 图15-3 从跨期和产业链角度去分析持仓 很多交易者存在这样的误区，当商品处于多头市场的时候，前20名多头持仓比前20名空头持仓大之差越大越好，或者说，上面构造的量化因子净多单率越大越好，在下跌的时候净空单率越大越好。 因为在价格上涨的时候，如果多头持仓远远大于空头持仓，说明多空力量相差悬殊，多头牢牢占据主动；在价格下跌的时候，如果空头持仓远远大于多头持仓，说明空头实力远远大于多头实力，空头牢牢占据主动。然而，我想告诉你的是，事实并非如此！ 单从净多单率和净空单率这一个指标是无法判断主力的真实行为，我所说的真实行为并不是过去已经发生的持仓结果，而是未来可能发生的持仓变化。因为当你已经看到的主力持仓在价格中已经反映出来了，意义不大，重要的是如何根据当下主力持仓以及当下的价格情况，来判断主力的未来行为。 多头不死，空头不止，反之亦然。当净多单率或者净空单率过大的时候，就会物极必反。具体而言，当多头主力持仓远超过空头主力持仓，即净多单率过大，说明多头的仓位十分拥挤，看涨的多头几乎全部进来了，场外的多头已经不多了，这意味着多头行情即将结束。 如果说这个时候价格还在高位，那么行情结束的概率非常高，下一步就是多头减仓而发生的多杀多踩踏行情。相反，当空头主力持仓远超过多头主力持仓，即净空单率过大，说明空头的仓位十分拥挤，看空的空头几乎全部进来了，场外的空头已经不多了，这意味着空头行情即将结束，如果此时价格还在低位，那么行情结束的概率非常高，下一步就是空头减仓而发生的空杀空踩踏行情。如图15-4所示。 图15-4 价格位置高度与持仓差过大可能引起行情反转 所以关于判断行情即将转折的方法，我个人的总结是： 净多单率高+价格高位→多头行情即将结束 净空单率高+价格低位→空头行情即将结束 上面介绍了计算净多单率和净空单率的方法，至于这个比率的高低，需要通过历史数据进行分析和观察。同样的道理，价格指标也可以用高低进行定位，以05合约为例，可以通过某个品种05合约的最高价格，05合约的最低价格以及当前价格来计算当前价格所处的历史位置：（当前价格-历史最低价格）/极差，极差=历史最高价格-历史最低价格。 当然，净多单率也可以采取相对比例法来计算净多单率的历史位置。这样的话指标就可以进行量化，通过仓差和价格两个维度判断后续行情可能发生的情况。 根据仓差和价格两个维度判断未来行情的变化之后，我们还需要找到方法去验证我们的判断。其实方法很简单，当多头行情开始结束，由于净多单率比较高，看多的基本上都进来了，看空的基本上都被打爆了，认输出局了，这个时候就会发生多杀多踩踏行情，即多头主动大幅减仓，仓差开始缩小，持仓量开始下降，这个时候我们又引入了第三个的判断指标：持仓量下降。 同样的道理，当空头行情结束时，由于净空单率比较高，看空的基本上都进来了，看多的基本上都被打爆了，认输出局，这个时候就会发生空杀空的踩踏行情，即空头主动大幅减仓，仓差开始缩小，持仓量开始下降。行情的结束充分说明了一个道理：期货交易就是对手盘交易，空头已死，多头方止；多头已死，空头方止！ 验证行情已经结束的方法，我个人的总结是： 净多单率下降+价格下跌+持仓量下降→多头行情已经结束 净空单率下降+价格上涨+持仓量下降→空头行情已经结束 另外，期货有限仓制度，随着距离交割日的不断临近，交易所对期货最大持仓的限制不断调整。所以，当前20名主力的多单比空单超出很多的时候，极有可能是多头超仓了，不得不进行减仓，这个时候就容易出现多头主动减仓带来的下跌行情。同理，如果前20名主力的空单比多单超出很多，就容易发生空头超仓引发的空头主动减仓带来的上涨行情。所以，多空仓差并不是越大越好，物极必反。如图15-5所示。 图15-5 限仓制度对行情带来的影响 最后，关于期货交易，不要把时间浪费在和别人之间进行多空争论上，也不要把时间浪费在寻找主力的观点上，而是把时间更多用于规律的观察、分析、总结和验证上，更多地用于自我修为上，因为当你对行情的理解和判断以及资金管理方面问题都不大的时候，最后你会发现交易中最大的敌人就是你自己，在这个时候你在交易中的理念、方法和技巧提高已经意义不大了，但是你个人修为上的提高，会给你的投资水平带来质的飞跃，所以交易者在交易中的自我管理也是非常重要的！ 根据盘面供求关系判断反转对于现货来说，供求决定价格，当商品供过于求时，价格下跌；当商品供不应求时，价格上涨；这是最简单的供求定律。 对于期货来说也是如此，但需要清楚的是什么是盘面的供给，什么是盘面的需求。期货的交易分为多开、多平、空开、空平，其中多开和空平都是有利于盘面价格上涨，属于盘面的需求方；空开和多平都是有利于盘面价格下跌，属于盘面的供应方。如图15-6所示。 图15-6 盘面的供应和需求 当盘面的供应大于需求时，盘面的价格会呈现下跌趋势；当盘面的需求大于供应时，盘面的价格会呈现上涨趋势；当盘面的供应和需求相当时，盘面往往处于震荡状态。 另外，只从价格是涨还是跌，我们所判断的盘面供应和需求只是历史情况，例如，当前价格是下跌趋势，我们可以判断出过去一段时间，价格的供应大于需求，即空开和多平的量大于多开和空平的量；但是未来行情会如何发展，我们单纯从价格一个指标却很难有所察觉，这个时候我们还需要观察另外一个指标，那就是成交量。 通常情况下，我们判断一个商品当下需求的好坏，主要是看现货市场成交是否放量，如果现货市场成交放量，说明当下的市场价格比较被认可，需求还是不错的；如果当前的价格下市场成交清淡，说明目前的市场价格不被市场认可。所以现货市场的成交量往往是判断供需的一个重要指标。 同样的道理，在期货盘面上我们也可以通过成交量来判断盘面的供需情况。当价格不断上涨时，说明当前盘面需求大于供应，与此同时，我们需要关注的是成交量情况，如果成交量不断放大，说明这个时候卖方的供应也在不断增加，往往价格处于较高位置，同时成交量放大时，说明大量卖方供应出现，例如多平和空开，就容易导致价格在高位反转。 相反，当盘面供应大于需求时，价格往往会一路下跌，当价格跌到某个区间时，成交量开始放大，说明在低价位的情况下，需求被刺激起来了，多开和空平增加，所以随着供应的增加，下面接货的买方越来越多，从而导致价格低位出现较大的成交量，在这种情况下，往往是价格处于低位，即将面临着反转。如图15-7所示。 图15-7 根据价量关系判断行情的顶部和底部区域 此外，除了价格水平的高低和成交量的高低之外，我们还需要关注一个重要的因素就是期货持仓量的高低。一个品种想要发生大的行情，都会伴随着较大的持仓量，在短时间内持仓量大幅增加。所以，大持仓往往容易塑造大行情。 具体来说，价格在历史低位时，持仓量较大往往容易导致行情反转上涨。由于期货的参与者有产业客户和投机客户，产业客户可以参与交割，投机客户持有的都是虚盘，当价格处于历史底部，持仓量创历史新高，这时候低价格使得产业受到损害，供应端主动减产停产，而低价格容易刺激需求，这就导致现货的库存开始慢慢偏紧。当期货持仓的量超过了现货市场中库存的量时，有大量空头无货可交割，不得不平仓离场。 所以价格低位，如果持仓创了历史新高时，往往会出现盘面交割货的量超过了现货市场中实际拥有的量，在这种情况下，多头的信心更足，而空头往往心里没底。因此，容易发生行情反转，从空头行情转变为多头行情。 空头行情反转为多头行情一般分为三个阶段，第一阶段，由于盘面持仓量巨大，超过现货市场库存所有量，空头选择主动减仓，盘面反弹上涨，空头减仓越多，盘面反弹力度越大；第二阶段，盘面的上涨吸引了更多的多头，多头买入热情高涨，推动价格进一步上涨；第三阶段，价格反弹到高位时，空头开始回补，多空双方展开最终较量，一旦多头获胜，将转入长期上涨行情，多空持仓都会减少，持仓量开始下降，价格稳步上涨，多头主导行情。如图15-8所示。 图15-8 行情空转多的三个阶段 当价格处于历史高位时，持仓量较大往往容易导致行情反转下跌。由于价格处于高位时，往往产业利润较高，这会刺激生产商不断加大供应，与此同时，高价格也会抑制需求，从而导致现货市场上的库存不断增加，开始过剩；大量有货无法在现货市场卖出的交易者，选择通过期货市场销售，在价格高位供应压力不断增加，到某一程度，买方的承接力度达到极限，价格开始反转下跌。 多头行情反转为空头行情一般也分为三个阶段，和上面的过程恰好相反，先是多头减仓下跌，然后空头增仓下跌，最后是多空再次激烈博弈，一旦空头获胜，那么多空双方都开始减仓，持仓量下降，空头主导行情。 所以，我们在判断价格是否即将发生反转时，需要将价格水平、持仓量、成交量三个重要指标结合起来判断，其核心就是供需逻辑，只不过把现货市场中的供需逻辑运用到了期货市场盘面价格而已。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十四章 跨品种套利的交易思路]]></title>
    <url>%2F2020%2F12%2F23%2F%E7%AC%AC%E5%8D%81%E5%9B%9B%E7%AB%A0-%E8%B7%A8%E5%93%81%E7%A7%8D%E5%A5%97%E5%88%A9%E7%9A%84%E4%BA%A4%E6%98%93%E6%80%9D%E8%B7%AF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 基于产业利润的套利逻辑西方经济学告诉我们，在完全竞争市场下，任何一个行业高利润不可持续，因为高利润吸引了更多生产者进入这个行业，从而生产出更多商品，供应会大幅增加，与此同时，高利润的背后往往是商品的高价格，而高价格天然地会抑制需求，在供应增加，需求受到抑制的情况下，商品的价格就会开始回落，随着商品价格的回落，产业利润会不断下降，从而恢复到合理的利润水平。如图14-1所示。 图14-1 高利润不可持续的原因 当然，需要注意的是，对于一些垄断或者政策扶植的产业，上述逻辑实现的周期可能更长一些。例如，在供给侧改革的影响下，钢厂高利润持续了近三年时间，在这种情况下做空钢厂利润就比较困难。有一类产业比较适合做空高利润，那就是门槛低、周期短的产业，例如蛋鸡养殖，门槛不高，蛋鸡生长周期较短，只要行业利润较高，养殖户纷纷冲进来了，供应马上就能恢复，把高利润给挤压下来。 同样的道理，在完全竞争市场情况下，任何一个行业的严重亏损也是不可持续的，由于产业利润亏损严重，从而导致行业内的一些生产商开始纷纷退出这个行业，使得行业生产出来的商品减少了，供应会大幅下降，与此同时，产业利润亏损的背后往往是低价格，而低价格天然地会刺激需求，在供应减少，需求受到刺激增加的情况下，商品的价格开始回升，随着商品价格的回升，产业利润会不断增加，最终恢复到合理的利润水平。如图14-2所示。 图14-2 长期亏损不可持续的原因 因此，基于产业利润的逻辑，我们可以选择做产业利润回归的套利，我们认为高利润不可持续，从而选择做空高利润；我们认为严重亏损也是不可持续，从而选择做多低利润。但是，想要做多或者做空产业利润，我们必须要搞清楚产业链的上下游关系，即哪些品种是原料，哪些品种是产品。做多产业利润就是做多产成品，同时做空原材料；做空产业利润就是做多原材料，同时做空产成品。 例如，最常见的就是大豆压榨产业利润的套利，原料是进口大豆，对应国内期货品种是豆二，产成品主要是豆粕和豆油。当压榨利润亏损比较严重的时候，我们可以考虑做多产业利润，即做多成品端的豆粕和豆油，同时做空原料端的豆二；反之，当压榨利润比较高的时候，我们可以考虑做空产业利润，即做空成品端的豆粕和豆油，同时做多原料端的豆二。 之前一些交易者选择做空豆一，这是错误的，因为豆一为国产非转基因大豆，豆二才是进口转基因大豆，而目前国内压榨产业的原料几乎全是进口转基因大豆，所以原料端应该用豆二进行对冲。 然而，由于豆二的持仓相对较少，而豆粕和豆油的持仓相对较大，所以一些做套利的资金并没有直接选择去参与豆二这个品种，而是直接选择豆油和豆粕两个品种进行参与。由于压榨企业的利润来源主要是豆粕，而非豆油，所以当油厂利润较差的时候，往往会选择挺粕价，而不是挺油价。 因此，对于套利资金来说，做多压榨利润也可以变相选择做空油粕比，即做多豆粕，同时做空豆油；反之，当油厂利润较高的时候，对于套利资金来说，可以选择做空豆粕，同时做多豆油，即做多油粕比。 农产品产业链上除了压榨套利之外，还有玉米和玉米淀粉的套利，显然玉米是原材料，玉米淀粉是产成品，同样的道理，当加工利润较高的时候，我们选择做空加工利润，即多玉米空玉米淀粉；当加工利润较低的时候，我们选择做多加工利润，即空玉米多玉米淀粉。不过由于行业的特殊性，目前玉米淀粉的加工基本上都是长期亏损的。 另外，我们还可以参与棉花和棉纱的套利，同样是当加工利润较高时，我们可以选择做多棉花，做空棉纱，来做空加工利润；反之，当加工利润较低时，我们可以选择做空棉花，做多棉纱，来做多加工利润。不过现在棉纱的持仓量相比棉花的持仓量来说实在是太小了，棉纱期货的流动性差一些，交易时滑点可能会大一些。 除了农产品之外，黑色系产业链的套利也是非常经典的，因为这个产业链上的品种大部分都是交易所上市的期货品种，所以在盘面上进行基于利润逻辑的套利也是相对方便的。对于焦化企业来说，原材料是焦煤，产成品是焦炭，当焦化利润较低的时候，我们可以考虑做多焦化利润，即多焦炭空焦煤；当焦化利润较高的时候，我们可以考虑做空焦化利润，即多焦煤空焦炭。当然，焦化利润的高低需要我们对双焦比值进行长期跟踪，和历史同期情况进行对比。 黑色系产业链上还有一个比较经典的套利是螺矿比套利，这是钢厂利润问题。钢厂高炉炼铁的主要原料是铁矿石，产品主要是螺纹钢，所以当钢厂利润较高时，我们可以考虑选择做空钢厂利润，即做多原材料铁矿石，同时做空产成品螺纹钢；反之，当钢厂利润较低时，我们可以考虑做多钢厂利润，即做空原材料铁矿石，同时做多产成品螺纹钢。所以螺矿比也是套利交易者经常跟踪的一个数据。 其实，严格来讲，如果做钢厂利润套利的话，其实是焦炭、铁矿石、螺纹钢三者之间进行套利，一般情况下，在粗略的计算钢厂利润时，可以利用下面的公式进行计算：当前期货盘面上钢厂的利润=螺纹钢价格-1.6x铁矿石价格-0.5x焦炭价格-1200元/吨，其中铁矿是原料成本，焦炭是燃料成本。做多钢厂利润时，做多螺纹钢，做空铁矿石和焦炭，做空钢厂利润时，做空螺纹钢，做多铁矿石和焦炭。 能化产业链当中，一个比较经典的产业利润套利是MTO利润套利，即聚烯烃利润的套利。原料是甲醇，产成品是聚丙烯，这两个也都是上市的期货品种，在计算MTO利润的时候，我们一般计算的是PP-3MA，因为理论上烯烃装置的利润=PP-3MA+加工费，当MTO利润亏损时，我们可以考虑做多MTO利润，即做多PP-3MA的价差，反之，当MTO利润较高时，我们可以考虑做空MTO利润，即做空PP-3MA的价差，PP和MA开仓手数的配比可以按照2:3去进行相应的匹配。 因此，产业利润套利是做跨品种套利当中最简单的逻辑之一，它只需要交易者了解产业链的上下游关系，上游原材料是什么，下游产成品是什么，以及当下的利润是处于高利润、亏损、还是正常利润状态。 产业利润套利的核心逻辑就是做产业利润的均值回归套利，但前提是需要找到利润出现均值回归的基本面逻辑以及相应的验证指标，而不能够盲目地去做利润回归。因为有时候产业结构发生变化，产业利润可能从上游向下游转移，从而导致下游长期高利润，这种情况下，再去盲目地做利润回归套利，就可能会遭遇趋势性风险。 需要注意的是，在整个经济下行周期当中，第一个阶段往往是去利润，即各个产业链上利润较高的品种下跌较多，把高利润打掉变成低利润甚至亏损，当高利润消失之后，就会进入第二个阶段，那就是去产量，上游纷纷停产，慢慢开始主动去库，如果价格依然继续下跌，那么就会进入第三个阶段，即去产能，行业内一些成本较高的落后产能承受不了长时间的亏损，最终退出行业，进行市场出清。如图14-3所示。 图14-3 经济下行周期的三个阶段及做空的风险度 需要注意的是，在经济下行周期的三个阶段中，做空去利润阶段的风险是最低的，其次是做空去产量，做空去产能阶段风险是最高的，因为随着市场出清，价格往往已经见底了，这个时候不宜再入场做空了。 基于伴生关系的套利逻辑有时候同一产业链上的品种之间存在伴生关系，所谓关系是指，产成品之间是从同一种原料加工而来，总是相伴而生，这类产品的价格往往存在此消彼长的关系，我们把这一类产品叫做伴生产品。 以大豆压榨产业链为例，进口大豆为原料，大豆压榨过程中同时产生豆油和豆粕，由于豆油和豆粕在大豆压榨过程中相伴而生，所以它们就属于伴生产品。伴生产品有一个重要的特性就是，一种商品走强，则另一种商品往往容易走弱。如图14-4所示。 图14-4 大豆压榨产业链图 以豆压榨产业链为例，当豆粕需求较好的时候，价格往往容易走强，这时候压榨企业为了满足下游对豆粕的需求而增加大豆压榨，从而产生豆粕，然而在产生豆粕的同时，导致豆油的供应被动增加，而豆油自身的需求并没有豆粕好，结果导致豆油库存进一步上升，价格进一步下跌。 所以，我们在做油粕比套利的时候，往往是以豆粕的需求为出发点，豆粕需求好的情况下，价格容易走强，同时压榨企业会提高压榨开工率，生产豆粕来满足需求，同时豆油供应被动增加，由于豆油需求相对稳定，从而使得豆油被动累库，价格下跌。如图14-5所示。可见，在豆粕需求好的时候，往往是做空油粕比的好机会，即做多豆粕，同时做空豆油。 图14-5 做空油粕比的主要逻辑 相反，当豆粕需求较差的时候，豆粕价格往往容易走弱，同时压榨企业为了挺豆粕的价格会降低压榨开工率，此时，豆油供应被动增加的局面有所缓解，而豆油的需求相对稳定，从而使得豆油库存开始得以下降，价格开始上涨。所以在豆粕需求不好的时候，往往是做多油粕比的好机会，即做空豆粕，同时做多豆油。 早些年间，对于压榨企业来说，豆油是主要产品，而豆粕是副产品，那个时候是对豆油的需求进入快速增长期，油粕比往往容易走高。然而，随着经济的发展，人们收入水平的提高，整个社会的饮食习惯开始发生变化，人们对豆油的需求相对减少，而对蛋白的需求不断增加，从而使得豆粕成为压榨企业的主要产品，豆油反而成了副产品，油粕比往往是容易走低。 其实从压榨企业的名称就可以看出社会饮食习惯的变化，早些年间压榨企业叫做油厂，因为那个时候豆油是主要产品，而现在压榨企业才叫做压榨企业，因为现在豆粕是主要产品。所以从整个社会发展的大趋势来看，逢高做空油粕比更符合社会的饮食习惯。 除了大豆压榨产业链，黑色系产成品之间也存在这种类似的关系，例如螺纹钢和热轧卷板，这两种产品之间存在铁水的竞争。当螺纹的利润较高时，而热卷的利润亏损时，钢厂的铁水更多流向螺纹，从而导致螺纹的供应增加，在需求不变的情况下，螺纹价格下跌，螺纹利润开始下降，而热卷的供应减少，在需求不变的情况下，热卷的价格上涨， 热卷利润开始回升，卷螺差开始发生变化。如图14-6所示。 如图14-6 做多卷螺差的逻辑 所以，当螺纹利润较高时，而热卷利润接近亏损的边缘时，这个时候比较适合做多卷螺差，即做多热卷做空螺纹。反之，当热卷利润较高时，而螺纹利润接近亏损的边缘时，这个时候比较适合做空卷螺差，即做空热卷做多螺纹。 其核心逻辑就是两种成品一个亏损一个盈利，铁水留向盈利的产品，从而导致盈利产品供应增加，亏损产品供应减少，两种成品的供求关系发生改变，从而使得价格发生强弱变化，进而使得卷螺差发生相应的修正。 不过，需要注意的是，如果两种商品都处于盈利状态，假设螺纹的利润高于热卷的利润，这个时候这种铁水竞争的逻辑往往不在成立，这是因为没有任何一种产品处于亏损的边缘，所以钢厂对高利润不敏感，生产两种成品都能赚钱，只是赚多赚少的问题，重要的是出货量，把这种账面利润通过销售变成实际利润。 所以，当两个成品都处于盈利状态，尤其是盈利状况不错时，我们不能做空高利润的，同时做多低利润的，因为钢厂对高利润不敏感，此时关键看两种商品各自的需求。 了解产业链产品之间的关系，对于我们选择跨品种套利具有重要的意义。主要应从产成品端去了解产品之间的伴生关系，其实从生产端或者原料端来看，不同的原料之间也存在类似的关系，以高炉炼铁为例，原料主要是铁矿石，燃料主要是焦炭，一般是生产1吨螺纹钢需要1.6吨铁矿石以及0.5吨焦炭。如图14-7所示。 图14-7 黑色系产业链简单示意图 当高炉开工率较高的时候，对矿石和焦炭的需求都会增加，这个时候原料之间的对冲核心逻辑是选择库存压力小的品种，如果矿石处于低库存状态，而焦炭处于高库存状态，那么我们可以选择做多铁矿石，同时做空焦炭。反之，如果矿石处于高库存状态，而焦炭处于低库存状态，我们可以选择做多焦炭，同时做空铁矿石，从而实现原料之间的套利。 与之类似的还有聚酯产业链的PTA和乙二醇，这两个品种是生产聚酯的原料，当下游需求增加的时候，我们可以选择做多低库存的品种，同时做空高库存的品种，其实当需求下降的时候，我们依然可以选择做多低库存的品种，同时做空高库存的品种，这种套利组合可以长时间持有。如图14-8所示。 图14-8 聚酯产业链简单示意图 2019年，PTA的库存处于较低水平，而乙二醇的港口库存处于较高水平，所以无论下游需求增加还是减少，PTA的价格都相对强于乙二醇，因为PTA是低库存状态，而乙二醇是高库存状态，所以我们选择做多PTA，同时做空MEG。 这种同一个产业链上的伴生产品或者伴生原料之间的套利往往风险更小一些，因为其相关性更大一些。在原料端主要比较哪个原料是低库存的，哪个原料是高库存的，原料端套利的逻辑是做多低库存的品种，同时做空高库存的品种；成品端的逻辑是做多需求好的品种，做空需求差的品种。 基于替代关系的套利逻辑基于宏观对冲的套利逻辑我们在选择跨品种对冲组合的时候，需要分析影响这两个品种的因素都有哪些，对冲掉共同的影响因素，然后留下不同的因素，我们做的就是不同因素的对冲。最常见的一种宏观对冲就是工业品和农产品之间的对冲，或者说是PPI和CPI的对冲。 因为工业品的金融属性更强一些，受整个宏观经济、货币政策的影响更大一些，而农产品的商品属性更强一些，受整个宏观经济、货币政策的影响小一些，需求相对比较稳定。所以在进行不同品种的配置时，往往在经济下行的时候，选择多农产品空工业品的配置，在经济上行的时候，选择多工业品空农产品的配置。如图14-12所示。 图14-12 多农产品空工业品的交易思路 除此之外，工业品当中不同的板块之间也是可以进行对冲的，例如黑色系和有色金属板块之间的对冲，黑色系和有色金属都是对宏观和政策比较敏感的品种，但是不同的是，有色金属的期货品种属于标准化的、全球性的期货品种，除了国内上期所的有色金属商品期货之外，世界上较为最具影响力的就是伦敦金属交易所，所以内外价差不会差太大，相互之间有一个参考的标的，否则价差过大就会出现跨市场套利机会。 但是黑色系不同，黑色系的品种属于国内所特有的品种，国外基本上没有相关的品种，除了新加坡有个铁矿石普氏指数之外，其他的诸如动力煤、焦煤、焦炭、螺纹钢、热轧卷板这些期货品种，国外基本上是没有的，所以不存在跨式套利资金的驱动把内外价差控制在合理范围之内的情况。 所以，当经济下行时，有色金属板块的品种，往往在宏观向下的影响下而不断下跌，相反，黑色系的品种则由于国家的逆周期调节，往往受益于政府基建投资，反而预期存在政策利好。所以这个时候，很多交易者会选择工业品内部当中的，多黑色系空有色金属的宏观对冲组合。 另外，目前世界上主要的能源有两种，一种是煤炭，一种是原油。理论上来说，煤油比的高低代表着两种能源的性价比，如果说市场预期煤炭的性价比更高一些，从而会导致市场对煤炭的需求增加，以煤炭为原料生产出来的品种价格往往由于成本推动而走高，例如黑色系的品种；相反，以原油为原料生产出来的品种往往由于成本坍塌而走弱，例如能化板块的品种。 所以对于看多煤炭，看空原油的交易者，往往会选择多黑色系，空能化品种的宏观对冲组合；对于看空煤炭，看多原油的交易者，往往会选择多能化品种，空黑色系品种的宏观对冲组合。 下面，我想在介绍一种完全不同的对冲思路，以能化品种为例。通过分析，我认为影响能化品种价格的基准共有三个：原油基准、宏观基准、产业基准。当我们选择两个能化品种进行对冲时，首先应该想办法过滤掉原油基准对价格的影响，因为不同能化品种对原油价格波动的敏感性是不同的。如图14-13所示。 图14-13 能化品种的定价基准 我们可以对原油、燃料油、沥青、PTA、乙二醇、甲醇、塑料、聚丙烯、PVC等能化品种进行相关性研究，从而得出不同能化品种与原油相关性的排序，在选择对冲品种的时候，我们最好选择与原油相关性临近的两个品种，因为它们对原油价格的波动敏感性基本差不多，从而对冲掉原油价格对我们的对冲组合的影响。 其次，我们再想办法对冲掉宏观的因素，能化品种的宏观属性基本上都差不多，它不像黑色系对国家的相关政策有着较强的预期，所以关于宏观部分的对冲，我们可以选择波动性匹配。 虽然同为能化品种，但是不同的能化品种波动性是不同的，有的能化品种波动性特别大，例如PTA、甲醇、PP等，而有一些能化品种的波动性比较小，例如塑料、PVC等，所以我们在选择对冲组合的时候，尽量选择一些波动性相当的品种进行对冲，否则一个品种波动性特别大，而另一个品种波动性特别小，就会增加我持仓过程中的压力，同时降低我们的持仓信心。 最后，当我们把影响能化品种价格的原油基准、宏观基准都对冲掉之后，剩下的只是产业基准不同了，这里的产业基准，我们可以理解为库存、基差、利润等基本面因素，然后就是我们所说的做多低库存、期货贴水、低利润的品种，同时做空高库存、期货升水、高利润的品种进行对冲。这种对冲的思路就是把影响价格的因素进行拆解，然后想办法把一些不好把握并且难以把握的因素进行对冲，留下容易把握的因素去交易。 当然，由于跨品种对冲交易往往都不是非标准化的套利组合，有时候还可能是跨交易所的品种，所以我们在进行合约数量匹配的时候，一般遵循两种常规的原则，对于跨期套利而言，我们一般遵从数量匹配的原则，即按照1：1进行匹配，开1手多单就开1手空单；对于跨品种套利而言，我们一般是遵从货值匹配的原则，即多头头寸的货值=空头头寸的货值。如图14-14所示。 图14-14 套利开仓的手数配比 货值的计算方式也比较简单，假设多头品种的价格为a，空头品种的价格为b，多头品种的合约乘数为m，空头品种的合约乘数为n，多头合约的开仓数量为x，空头合约的开仓数量为y。那么多头合约的货值=amx，空头合约的货值=bny，根据货值匹配的原则，amx=bny，我们因此可以计算出x/y=bn/am，这就是多空开仓的手数之比。然后根据我们账户的资金情况，可以进行同比例的放大。 基于期限结构的套利逻辑]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十三章 跨期套利的核心逻辑]]></title>
    <url>%2F2020%2F12%2F23%2F%E7%AC%AC%E5%8D%81%E4%B8%89%E7%AB%A0-%E8%B7%A8%E6%9C%9F%E5%A5%97%E5%88%A9%E7%9A%84%E6%A0%B8%E5%BF%83%E9%80%BB%E8%BE%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 如何理解正套与反套跨期套利常见的四种逻辑基于”库存+基差+利润”的跨期策略跨期套利如何看着基差来做月差期限结构与库存仓单验证的跨期策略]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十二章 关于交割制度应该注意哪些事]]></title>
    <url>%2F2020%2F12%2F23%2F%E7%AC%AC%E5%8D%81%E4%BA%8C%E7%AB%A0-%E5%85%B3%E4%BA%8E%E4%BA%A4%E5%89%B2%E5%88%B6%E5%BA%A6%E5%BA%94%E8%AF%A5%E6%B3%A8%E6%84%8F%E5%93%AA%E4%BA%9B%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 仓单有效期的重要性标准品与替代品的升贴水情况基准交割仓库所在地]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一章 基于“仓单+基差”的交易逻辑]]></title>
    <url>%2F2020%2F12%2F23%2F%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E2%80%9C%E4%BB%93%E5%8D%95-%E5%9F%BA%E5%B7%AE%E2%80%9D%E7%9A%84%E4%BA%A4%E6%98%93%E9%80%BB%E8%BE%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是虚实盘比期货交易的参与者有投机者、套利者、套保者，产业资金基本上以期现套利或者卖出套保为主，金融资金基本上以投机或者以跨期套利、跨品种套利为主。期货合约的持仓当中，包含了各种类型的资金，这些资金参与期货交易的目的也各不相同。 任何一个期货合约从上市到最终交割退市，在不同的阶段，主导行情的逻辑是不同的，在合约刚上市不久，往往是以投机资金主导行情，此时期货合约受预期的影响比较大，任何预期的波动在投机资金的作用下，都会被放大，从而容易出现暴涨暴跌的情况。 相反，随着期货合约距离交割月的不断临近，投机资金开始逐渐移仓到远月合约，而产业资金逐步介入近月合约，所以近月主力合约逐步开始被产业资金所主导，商品期货的金融属性开始逐渐退去，商品属性开始逐渐显现。这个时候期货合约往往会遵循产业逻辑，波动会小一些，趋势性会更强一些。 到最后，所有投机资金离场，产业资金进入交割月，国内大商所和郑商所的品种，投机散户是无法持仓进入交割月的，而上期所允许散户持仓进入交割月，但是持仓数量必须是最低可交割数量的整数倍，并且保证金还会大幅提高。所以在一个商品期货合约从上市到最终交割退市的过程中，持仓量会出现先增加后减少的特点。综上，主力合约在不同阶段的行情驱动逻辑如图11-1所示. 图11-1 主力合约在不同阶段的行情驱动逻辑 由于期货市场本身是为现货市场服务的，期货的交割能够促进期现价差的最终修复，然而并不是所有交易者的持仓都是为了去进行交割的。我们把用于交割的持仓称之为实盘，实盘持仓对应的数量可以通过期货交易所的公布的仓单日报查询。 期货合约总的持仓量减去可以交割的实盘持仓之后，剩下的就是虚盘，这部分持仓是没有货进行交割的。严格来说虚实盘比就是虚盘持仓与实盘持仓之间的比值，但在实际过程中，我们往往利用主力合约持仓量除以2得到单边持仓量作为虚盘的量，仓单数量折成盘面手数作为实盘的量，用二者之比来计算虚实比。 这个比值越大，说明了货越少，而资金越多，在钱比货多的情况下，价格容易上涨；这个比值越小，则说明了货比较多，而资金相对较少，在货比钱多的情况下，价格容易下跌。如图11-2所示。 图11-2 虚实比的计算方式以及使用技巧 没有固定的比值说虚实比多大就一定逼仓或者一定不逼仓，一方面取决于虚实比的大小，另一方面是取决于距离交割到期日的远近。如果以横轴为距离交割月的远近，纵轴为虚实比，基本上都是一个虚实比逐步减小的曲线。如图11-3所示。 图11-3 虚实比的变化图（以螺纹10合约为例） Contango结构下的虚实比曲线一般是凹型的，back结构下的虚实比曲线一般是凸型的。所以contango结构下一般容易出现空头交货，而多头接货意愿不足，期货大跌；back结构下一般容易出现多头接货，而空头货源不足，期货大涨。 并不存在一个具体的比值能够确定是否发生逼仓，但是我们可以借助虚实比曲线的特征来判断发生逼仓的可能性。移仓早的一般都是凹型的，不太可能逼仓，一般就是遵循交割逻辑；移仓晚的一般都是凸形的，极有可能逼仓。 基于”仓单+基差”的交易方法当我们理解了虚实盘比的概念之后，我们同样可以利用仓单或者虚实盘比去构造一个交易框架。在我的交易过程中，始终贯彻一个原则，那就是：期货升水尽量不做多，期货贴水尽量不做空。永远把基差当做我们交易的一个重要的安全边际，此外，我们再具有了安全边际的基础之上，通过寻找其他相关指标来提升我们对行情方向判断的胜率。 期货市场上经常出现一种现象叫做逼仓，通常我们所说的逼仓是指多逼空，由于期货市场上的多头是买货的一方，而空头是交货的一方，当市场上资金量巨大的时候，就会导致期货合约的持仓量不断放大，即买方的力量十分强大，而卖方的力量主要体现在实盘仓单的量。 当虚实盘比非常大的时候，说明市场上的钱多货少，想买货的多头非常多，而能够交货的空头非常少，最终空头苦于无货可交割的困境，不得不平仓离场，从而导致盘面因为空头减仓大涨。这就是典型的多逼空现象，这种现象在期货市场上经常会发生。 所以，对于普通的投机散户来说，尽量不要去卖空你所没有的东西。事实证明，大多数投机者赚钱还是依靠逢低做多的更多一些。无论是做多棉花的林广袤，做多矿石的傅海棠，基本上都是以逢低做多赚了大钱。 当期货处于贴水状态的时候，在仓单非常少或者虚实盘比特别大的情况下，如果现货启动上涨，往往会爆发大行情，像RB1801合约的逼仓上涨，TA1809合约的逼仓上涨，基本上满足三个共同的特点：第一，期货贴水于现货；第二，仓单较少，虚实盘比巨大；第三，现货坚挺上涨。如图11-4所示。 图11-4 多逼空时常伴随的三种现象 因此，我们可以利用基差和虚实盘比两个维度来得到一个交易策略： 期货深贴水+虚实盘比大→单边做多 相反，除了多逼空之外，期货市场上还有一种比较常见的现象，就是卖出套保，有时候卖出套保的意愿比较强烈，就会造成一种空逼多的情况。如果市场上期货合约持仓量比较少，而仓单的量比较大，即虚实盘比非常小，说明货相对较多，钱相对较少，在这种情况下，空头交割的意愿就会非常强烈，而多头接货的意愿就会相对较弱，从而导致盘面上接货意愿较差的多头率先离场，盘面上因为多头减仓下跌。 例如最近年以来的油脂、橡胶、棉花基本上都是这个特点，据我观察出现空逼多的时候一般也是满足三个特点：第一，期货升水于现货；第二，巨量仓单，虚实盘比巨大；第三，现货疲软下跌。如图11-5所示。 图11-5 空逼多时常伴随的三个现象 因此，我们可以利用基差和虚实盘比两个维度来得到另一个交易策略： 期货高升水+虚实盘比小→单边做空 其实，本质上来说”基差+仓单”交易逻辑与”基差+库存”交易逻辑有些类似，因为从数据的角度来说，仓单是库存的子集，库存比仓单更难反应整个商品的供需情况，而仓单比库存更能反应盘面上多空双方交割意愿和实力的情况。 由于厂库信用仓单政策的推出，很多时候仓单生成的比较快，不像之前仓单生成比较慢，可能还有库容的限制，所以卖方早早就把仓单注册好了，体现在交易所的仓单日报当中。而现在往往是在临近进入交割月甚至是进入交割月之后才生成仓单，这个时候我们用”基差+库存”的交易逻辑比”基差+仓单”的交易逻辑更好一些。 最后，我们从交易方向、增减仓两个角度，来总结和对比一下”库存+基差”交易逻辑与”仓单+基差”交易逻辑的异同： 交易方向： 深贴水+低库存→单边做多，高升水+高库存→单边做空 深贴水+虚实盘比大→单边做多，高升水+虚实盘比小→单边做空 增减仓操作： 深贴水+低库存累库→多单减仓，高升水+高库存去库→空单减仓 深贴水+仓单增加→多单减仓，高升水+仓单减少→空单减仓 基于”期限结构+仓单验证”的交易逻辑单点信息是没有价值的，把不同信息进行排列组合，才能够发挥不同信息的最大价值。所以我们在构思自己的交易策略时，尽量不要依靠单独一条信息或者单个指标去构造，因为这样得来的结果往往可靠性较差，相反，我们需要把不同纬度的信息进行整合，然后去归纳一个交易框架，这样反而可靠性会大大提高。 单纯基于基差来进行交易显然不如把基差和库存结合起来做交易判断的胜率高，更不如把基差、库存和利润三者结合起来做交易判断的胜率高。同样的道理，我们在利用仓单作为指标来判断交易方向时，也不能够只通过仓单一个指标，也需要把其他指标结合起来。 前面我们介绍了期限结构，我们可以把期限结构和仓单结合起来，从而形成我们的交易策略。之所以选择期限结构，主要是因为期限结构本身能够反映基差、库存等几方面的共性特征，例如back结构往往意味着期货贴水、库存较低、仓单较少，contango结构往往意味着期货升水、库存较高、仓单较多。 但事实情况是否如此呢，我们可以通过仓单来验证一下。当期限结构与仓单情况共振时，我们参与交易的胜率就会更好一些，因此，我们可以得到下面的交易法则： back结构+少量仓单→跨期正套 contango结构+巨量仓单→跨期反套 本质上，这个交易方法也是“库存+基差+利润”交易框架的一个变形，只是库存数据往往需要通过付费的方式从一些资讯网站获取，一些交易者可能不愿意为信息付费，所以退而求其次，只能用交易所免费公布的仓单数据来辅助我们做出交易判断。 因为仓单属于库存的一部分，通常情况下，少量仓单往往暗示着库存较低，而巨量仓单往往暗示着库存较高，与此同时，少量仓单往往还暗示着现货市场销售较好，巨量仓单还暗示着现货市场销售较差。 当然，这里我们主要介绍了利用期限结构+仓单验证的方法来做跨期套利，这取决于交易者的风险偏好，单边做多和跨期正套对于近月主力合约来说，交易的方向是一致的，都是做多，只是单边做多的风险更大一些，而跨期正套的风险更小一些；同样，单边做空和跨期反套对于近月主力合约来说，交易的方向是一致的，都是做空，只是单边做空的风险更大一些，而跨期反套的风险更小一些。 另外，在使用期限结构+仓单验证的跨期交易策略时，需要注意的是：第一，跨期正套的风险要小于跨期反套。第二，交易过程中尽量以正套为主，反套为辅。如图11-6所示。 图11-6 期限结构+仓单验证做跨期套利需要注意的两点 为什么说正套风险要小于反套呢？主要是因为在交易过程中，我们会遇到各种意外事件的冲击，从而对你最初的交易逻辑产生影响，一般情况下，这些意外冲击，无论是因为天气、矿难、罢工、政策，往往都会对近月合约的供应造成比较大的预期影响，近月合约容易走强，此时做反套就容易亏损，而做正套则是锦上添花。 除此之外，在利用期限结构+仓单验证的交易策略做跨期反套的时候，尽量选择仓单到期无法转抛的合约，这样的话，因为这部分仓单即将失去金融属性，空头交货意愿往往比较强，而多头接货的意愿就比较差，所以近月临近交割的合约往往就非常弱，甚至最终贴水交割，近远月价差就容易拉大，反套获利的概率更大一些，盈利也可能更多一些。但是如果遇到事件冲击，也可能会对这种高胜率的反套造成影响。 例如，OI1905-OI1909反套，由于郑商所规定，上一年度菜籽油的仓单要在5月底集中注销，无法继续转抛到后面的其他月份，而2019年OI1905合约对应的仓单又是历史同期非常高的位置，期限结构也是contango结构，一切看来都是非常完美的反套机会。 最初盘面确实是在走反套的逻辑，然而2019年三月我国停止了对加拿大菜籽和菜油的进口，一下子导致盘面开始走正套逻辑，期限结构也从contango结构变成了back结构，反套从盈利状态变成亏损状态，所以任何定式的套利逻辑都不如事件驱动对套利逻辑的影响大。 期货交易中的两个安全边际什么是期货交易中的安全边际？我认为最核心的一点就是：如果基于此做对了，那么我们会获利颇丰；相反，基于此做错了，我们的损失会比较小。根据我对安全边际的理解，我认为期货交易中存在两种安全边际：一种是从基差角度去寻找交易的安全边际，另一种是从虚实盘比的角度去寻找安全边际。期货交易中的两个安全边际如图11-7所示。 图11-7 期货交易中的两个安全边际 1.从基差的角度寻找安全边际 从基差的角度来讲，对于近月临近交割的主力合约，期货贴水的品种不宜做空，期货升水的品种不宜做多，这就是交易的安全边际。举例来说，假设螺纹现货价格是4000元/吨，现在期货主力合约价格是3700元/吨，市场完全有效，交割时基差进行修复，期货价格与现货价格相等。 在这种情况下，如果你选择做空期货主力合约，假设你做对了，最终是以现货下跌的方式来完成基差修复，假设最终期现价格都是3600元/吨，现货从4000元/吨跌到了3600元/吨，现货下跌了400元/吨，而期货从3700元/吨跌到3600元/吨，期货跌了100元/吨。由于你判断对了，并且通过做空期货每吨赚了100元的价差。 但如果你判断错误，最终是以期货上涨的方式来完成基差的修复，假设最终期现价格都是4100元/吨，现货从4000元/吨涨到了4100元/吨，现货上涨100元/吨，而期货从3700元/吨上涨到4100元/吨，期货上涨了400元/吨。由于你判断错误，并且选择了做空，所以你最终每吨亏损400元的价差。 所以，从上面的比较结果来看，在期货贴水的情况下，尤其是对于近月临近交割的合约，如果你选择做空的话，是没有安全边际的，因为你做对了赚钱少，做错了亏钱多，这并不是一种明智的交易方法，所以从基差角度来讲，近月合约临近交割，期货贴水不做空！相反，这种情况下更适合做多，因为做多的情况下与做空恰好相反，做错了的情况下，损失较小，做对了的情况下，盈利较大，盈亏比非常大。 同样的道理，从基差的角度来讲，对于近月临近交割的主力合约，期货升水的品种不宜做多，这就是交易的安全边际。举例来说，假设螺纹现货价格是3700元/吨，现在期货主力合约的价格是4000元/吨，市场完全有效，交割时基差进行修复，期货价格与现货价格相等。 在这种情况下，如果你选择做多期货主力合约，假设你做对了，最终是以现货上涨的方式来完成基差修复，假设最终期现价格都是4100元/吨，现货从3700元/吨涨到了4100元/吨，现货上涨了400元/吨，而期货从4000元/吨涨到了4100元/吨，期货涨了100元/吨。由于你判断对了，并且通过做多期货每吨赚了100元的价差。 但如果你判断错误，最终是以期货下跌的方式来完成基差的修复，假设最终期现价格都是3600元/吨，现货从3700元/吨下跌到3600元/吨，现货跌了100元/吨，而期货从4000元/吨下跌到3600元/吨，期货下跌了4000元/吨。由于你判断错误，并且选择了做多，所以你最终每吨亏损400元的价差。如图11-8所示。 图11-8 升水做空，贴水做多，具有安全边际 所以，从上面的比较结果来看，期货升水的情况下，尤其是对于近月临近交割的合约，如果你选择做多的话，是没有安全边际的，因为你做对了赚钱少，做错了亏钱多，这显然不是很明智的选择，所以从基差角度来讲，近月合约临近交割，期货升水不做多！相反，这种情况下更适合做空，因为做空的情况与做多恰好相反，做错了损失小，做对了盈利大，盈亏比十分理想。 通过基差的角度以及做多与做空的选择，对于近月临近交割的主力合约，我们可以找到如下两条安全边际： 近月合约临近交割，期货升水不做多。 近月合约临近交割，期货贴水不做空。 2.从虚实盘比角度寻找安全边际 从虚实盘比的角度来讲，对于近月临近交割的主力合约，虚实盘比大的品种不宜做空，这也是交易的安全边际。虚实盘比大说明钱多但是货少，这个时候就容易出现逼仓行情，即多逼空，在这种情况下，空头往往会损失惨重，在发生逼仓的情况下，期现最终有可能不会修复，而可能是期货升水交割，即期货价格大幅高于现货价格。 假设螺纹现货现在是4000元/吨，期现平水，期货主力合约也是4000元/吨，临近交割，仓单非常少，而主力合约持仓量非常大，即虚实盘比非常大，这个时候如果你去做空期货主力合约，假设做对了，期现都跌到了3900元/吨，你通过做空交易赚了100元/吨。但如果你做错了，发生了逼仓行情，结果可能是现货涨到4500元/吨，期货涨到了4700元/吨，你就会亏损700元/吨。显然做对了赚钱少，做错了亏钱多，这不是一个好的选择。 历史上发生过好多次逼仓事件，基本上都是在期货贴水，虚实盘比较大的情况下发生的，所以只要你能够遵循我所总结的这两条安全边际，基本上你就不会在逼仓行情中遭遇重大损失，相反，你还可以利用逼仓行情来大赚一笔，当然，我还是希望交易者能够记住这一点：近月合约，临近交割，虚实盘比较大，坚决不做空！ 同样的道理，对于近月临近交割的主力合约，虚实盘比小的品种不宜做多，这也是交易的安全边际。虚实盘比小说明的问题是钱少但是货多，这个时候就容易出现交仓行情，即空逼多，在这种情况下，多头往往会损失惨重，在发生交仓的情况下，期现最终有可能不修复，而可能是期货贴水交割，即期货价格大幅低于现货价格。 假设橡胶现货现在是13000元/吨，期现平水，期货主力合约也是13000元/吨，临近交割，仓单非常多，而主力合约持仓量并不大，即虚实盘比较小，这个时候如果你去做多期货主力合约，假设你做对了，期现都涨到13200元/吨，你通过做多交易赚了200元/吨。但如果你做错了，发生了交仓行情，结果可能是现货跌到12800元/吨，期货跌到了12000元/吨，你就会亏损1000元/吨。显然做对了赚钱少，做错了亏钱多，不是很好的选择。 历史上也经常发生交仓事件，也就是我们所说的空逼多，基本上都是在商品供求过剩的情况下，产业客户选择了卖出套保，市场上交货的非常多，而在供求过剩的情况下，愿意接货的资金比较少，所以期货价格大幅下跌。所以，近月合约临近交割，虚实盘比较小，坚决不做多！ 通过虚实盘比的角度以及交货与接货的意愿情况，对于近月临近交割的主力合约，我们可以找到如下两条安全边际： 近月合约临近交割，虚实盘比大不做空。 近月合约临近交割，虚实盘比小不做多。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十章 仓单在交易中的重要性]]></title>
    <url>%2F2020%2F12%2F18%2F%E7%AC%AC%E5%8D%81%E7%AB%A0-%E4%BB%93%E5%8D%95%E5%9C%A8%E4%BA%A4%E6%98%93%E4%B8%AD%E7%9A%84%E9%87%8D%E8%A6%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 注册仓单与有效预报仓单与期货升贴水的关系注册仓单与库存的关系仓单强制注销的意义]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第九章 基于“估值+驱动”的交易逻辑]]></title>
    <url>%2F2020%2F12%2F18%2F%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E2%80%9C%E4%BC%B0%E5%80%BC-%E9%A9%B1%E5%8A%A8%E2%80%9D%E7%9A%84%E4%BA%A4%E6%98%93%E9%80%BB%E8%BE%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 如何寻找估值指标估值+驱动的投研方法主要采取二维四象的方式对商品进行分类，在这个二维四象图中，横轴是驱动，纵轴是估值，每个品种根据自身估值与驱动的情况，落入不同的象限当中，从而选择不同的交易策略。永安期货常用的估值+驱动投研框架如图9-1所示。 图9-1 永安期货常用的估值+驱动投研框架 如何理解估值+驱动的逻辑呢？你可以把估值想象成势能，把驱动想象成动能。我们学过物理的人都知道，一般势能高的时候，动能比较低，相反，势能低的时候，动能比较高，如果没有热量损失的话，根据能量守恒定律，动能和势能之间可以互相转化。 以螺纹钢为例，高利润或者高价格就是从估值角度去看，它就是势能；高产量却低库存说明需求很好，你可以把这种需求理解为动能，当动能无法转化为势能时，接下来就是势能转化为动能的过程，估值发生了变化，驱动向反方向发生了变化。 理解了估值和驱动的逻辑之后，接下来就要明白如何进行估值以及如何寻找驱动，这是这种方法的一个难点。 先来简单谈一下估值，不仅要对现货进行估值，也要对期货进行估值。对现货估值的方法有很多，有人认为高价格代表现货高估，我认为这是不可取的，随着货币超发，通货膨胀增加，高价格并不一定代表商品被高估了；也有人认为用高利润代表现货高估，我认为这个勉强可用，高利润通常代表了商品被高估了。但是从更精确的角度来讲，高利润率才是最合适的，如图9-2所示。 图9-2 现货估值几个常用的指标 此外，我们还需要期货进行估值，通常情况下我们利用基差来判断期货相对于现货来说，是低估还是高估，这个也是勉强可以的，更严格来说，应该使用基差率，除了基差率之外，我们还可以计算一下盘面利润来判断期货估值的高低。这样的话能够把不同价位的品种合理地分配到估值+驱动的四个象限当中。期货估值几个常用指标如图9-3所示。 图9-3 期货估值几个常用指标 为了方便不同品种之间进行比较，通常情况下，我们可以使用利润率指标来进行绝对估值，使用基差率指标来进行相对估值。从估值角度来说，我们应该做多低估品种，做空高估品种。 如何构造驱动指标谈一下驱动，一切的驱动因素皆源自于基本面，而基本面最核心的就是供需平衡表，而供需平衡表中最重要的一个指标就是库存消费比。库存消费比较高，说明驱动向下；库存消费比较低，说明驱动向上。所以需要制定商品的月度供需平衡表，来实时追踪库存消费比的变化情况。 但是对于大多数个人交易者来说，想要自己制作商品的供需平衡表几乎是不可能，因为他们根本没有办法获得那么多的供需、库存、进出口、消费等数据，这也是我为什么更多的介绍“库存+基差+利润”这种分析框架。另外，对于消费相对稳定的品种来说，库存基本上是可以取代库存消费比的，对于消费变化较大的品种来说，库存消费比是更加准确的指标。 当然，除了库存消费比这个指标之外，开工率也是一个非常不错的指标，企业自身高开工率对价格的驱动作用向下，企业自身低开工率对价格的驱动向上。当然，在使用开工率进行判断时，最好能够结合产能利用率，因为如果产能利用率低的话，即使开工率高也不一定会产生大量供给，驱动不一定向下；相反，如果产能利用率高的话，即使开工率低也有可能产生大量供给，驱动可能会向下。 所以，关于驱动相关的指标，我们可以从库存消费比、库存、开工率、产能利用率等相关数据去寻找。如图9-4所示。 图9-4 关于驱动因素几个常用的指标 为了方便不同品种之间驱动强弱的比较，我们通常利用库存消费比这个指标对所有商品进行驱动分析，然后针对不同行业的品种，结合产业自身特点，选择开工率、产能利用率等指标辅助分析驱动作用。从驱动的角度来说，做多驱动向上的品种，做空驱动向下的品种。 如何量化”估值+驱动”交易逻辑我们继续来想象一下估值+驱动的二维四象图，横轴是估值，纵轴是驱动，那么第一象限就是高估值且驱动向上的品种，第二象限就是低估值且驱动向上的品种，第三象限就是低估值且驱动向下的品种，第四象限就是高估值且驱动向下的品种。 当估值与驱动指向一致的时候，我们采取单边交易策略；当估值与驱动不一致的时候，我们采取套利或对冲交易策略。我们对不同象限的品种可以采取这样的策略搭配： 第一象限：高估值驱动向上→套利或对冲 第二象限：低估值驱动向上→单边做多 第三象限：低估值驱动向下→套利或对冲 第四象限：高估值驱动向下→单边做空 需要注意的是，对于高估值驱动向上的品种如果选择做跨期套利，通常适合做正套；低估值驱动向下的品种如果选择做跨期套利，通常适合做反套，尤其是结合仓单有效期的规定来做反套。 如何进一步去细化？ 如果两个品种都落在同一个象限，在我们只能选择做一个品种的情况下，应该选哪一个呢？显然，我们只注重了分类，却没有注重量化，我们还需要给二维四象的坐标轴赋予一定的刻度，这样的话，当两个品种落在同一个象限时，我们就能够很容易做出选择。 估值分为严重低估（-3）、正常低估（-2）、略微低估（-1）、略微高估（1）、正常高估（2）、严重高估（3）这6种情况，驱动分为强烈驱动向下（-3）、正常驱动向下（-2）、略微驱动向下（-1）、略微驱动向上（1）、正常驱动向上（2）、强烈驱动向上（3）。这样一来，整个二维四象图就都有了刻度坐标，同时对估值和驱动的程度进行量化，如图9-1所示。 图9-1 估值和驱动的量化标准 我们在分析估值的时候使用利润率、基差率，在分析驱动的时候使用库存消费比、开工率、产能利用率，这些数值都可以进一步被量化。 以估值为例，首先我们需要对现货进行估值，使用利润率指标，针对不同的利润率情况，其在二维四象图中的取值范围是-3到3，然后我们对期货进行估值，使用基差率指标，其在二维四象中的估值范围也是-3到3。 如果我们在分析现货的绝对估值和对期货的相对估值采取等权重的方式对待的话，那么最终这个品种的估值结构就是，利润率估值与基差率估值的算术平均数。一个品种从利润率角度对现货估值为2.54，从基差率角度对期货进行估值为-0.54，那么这个品种的最终估值就是（2.54-0.54）/2=1.00。 对驱动的处理方式也是如此。但是这里面有一个非常重要也是最难得一点就是，如何把一个百分比转化成象限图中对应的坐标值。可能很多人在这一步不知所措，其实很简单。 以利润率为例，你需要把这个品种历史的利润率情况做出来，形成一个利润率分布图，最差的利润率情况对应是-3，最好的利润率情况对应3，然后利用数学中的插值法，对任何一个利润率你都能够得到一个准确的估值，而这个估值结果就是符合我们要求的象限图的值。 这样一来，我们就可以通过估值和驱动矩阵，将不同的品种放在同一个标准内进行比较，从中选择适合做多或者做空的品种，选择适合去做对冲的品种，每一个品种的估值和驱动指标都是可以计算出来的，并在坐标轴中对应的位置显示，如图9-5所示。 图9-5 估值驱动矩阵及其量化评级 但是这也存在一个问题，就是利润率分布图是否服从均匀分布或者正态分布，这就需要采取其他方法，例如剔除异常值，或者采用其他更加复杂的统计和计量方法去处理。对大多数个人交易者来说，想要把“估值+驱动”这种逻辑做得非常细，难度还是比较大的。 不过没关系，我们可以根据前面介绍的库存+基差+利润交易逻辑，对这个矩阵进行简化变形，还可以把二维矩阵变成三维矩阵。 “估值+驱动”交易逻辑的变形]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章 对商品期货如何做价值投资]]></title>
    <url>%2F2020%2F12%2F18%2F%E7%AC%AC%E5%85%AB%E7%AB%A0-%E5%AF%B9%E5%95%86%E5%93%81%E6%9C%9F%E8%B4%A7%E5%A6%82%E4%BD%95%E5%81%9A%E4%BB%B7%E5%80%BC%E6%8A%95%E8%B5%84%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是真正的价值投资什么是价值投资？低价买入就是价值投资吗？从结果来讲，只亏时间不亏钱的才是价值投资。价和值是两个字，价是价格，值是值多少钱。价值投资的代表人物是巴菲特，他也是喜欢逢低买入上市公司，尤其是那些价格明显低于净资产的上市公司，净资产就是公司的值，股价就是价，这个时候巴菲特和芒格只需判断一件事情，这个公司会不会倒闭，只要不会，那可以，就买入做多，长期持有。 价低于值的部分就是安全边际，然后长期持有，以时间为朋友，只要公司不倒闭，股价恢复到净资产水平，巴菲特就赚钱了，而正常情况下公司的股价应该高于净资产，所以随着公司业绩的改善，股价进一步上涨，价值投资赚得就更多。 我认为在国内商品期货比大多数上市公司都具备价值投资的潜力。既然是做价值投资，那么首先要找到价值的锚在哪里。对于商品期货来说，它的价比较简单就是现货价格和期货价格，对于交易者来说，买入的是期货价格；它的值是生产成本，当期货价格明显低于生产成本，这就是交易的安全边际。如图8-1所示。 图8-1 关于商品价值与安全边际的理解 然后也是长期持有，只要你比生产商更能忍受亏损，你就是最终的胜者。当价格回到成本线你也会赚很多，正常情况下价格应该高于成本线，这时候你会赚更多。这和巴菲特的价值投资如出一辙。 但是商品期货和上市公司不同，商品期货每个合约都有到期日，需要在进入交割月之前进行换月，如果远月合约是价格更低还好一些，简单地滚动换月就可以了，如果是远月价格更高，那么每次换月都会亏一部分钱。 所以对于价格处于低位，尤其是利润亏损了的品种，如果它是back结构，可以采取这种方式做多，甚至可以定投，只要你比生产企业能够忍受亏损，你只要能控制好资金管理不爆仓，你就一定是最后的赢家。如果是contango结构，有对应的商品期权的话，可以采取做多期货同时买入认沽期权的方式，用期权的收益来弥补换月的损失。如图8-2所示。 图8-2 不同期限结构下的价值投资策略 另外，能化品种不适用这个思路，因为能化品种的装置一般都会有多个产品，并不是单一产品，所以并不会因为单一品种利润亏损而停产，而是要考虑整个装置的综合利润情况，只要整个装置综合利润是赚钱的，即使是单品种亏损，那么装置还会继续开工，供应还会继续增加，价格依然会受到压制。 当然，商品的价值投资和股票不同，因为商品期货每个合约都有到期日，交易者在特定日期之前必须要平仓，然后旧合约退市，新合约上市。在这种情况下，价值投资可以分为两种，一种是针对于单个期货合约进行价值投资，另一种是对这个品种进行价值投资。 对主力合约如何做价值投资如果你把期货当做投机来做，那么你按照技术分析去做趋势追踪交易都可以，也有技术分析做得不错的。但如果你把期货当投资来做，尤其是当做价值投资来做，你的核心理念就是价格围绕着价值在波动，你可以在期货盘面时刻看到价格，但是价值是什么你一定要搞清楚。我个人认为，成本可以理解为商品的价值，而成本有两种，一种是生产成本，另一种是仓单成本，生产成本反映了这个商品的价值，仓单成本反映了这个合约的价值。如图8-3所示。 图8-3 价值投资的两种锚定方式 像我经常说的基于低库存+深贴水+低利润大胆可以做多近月合约，本质上就是做盘面期货价格与现货仓单价值的偏离，在有限的时间内，根据低库存+深贴水+低利润，我判断短期这个合约的价值不会发生大的贬值，而价格目前偏离价值较大，做多就是做价格向价值的修复，其核心的理念还是价格围绕着价值波动，只不过做基差修复行情做的是期货价格围绕着合约价值的波动。 同样的道理，如果某个品种低库存+深贴水+利润亏损，那么可以大胆做多，用傅海棠的理论，供不应求且亏损，这种商品必涨，可以重仓做多。利润亏损说明当前的价格已经偏离了商品的价值，低库存要么是反应了市场供不应求，要么说明已经去库尾声，只要需求稍微一启动，价格就容易起来，至少恢复到生产成本那里，即价格向价值靠拢。如图8-4所示。 图8-4 单个期货合约的价值投资逻辑 当然，深贴水的好处就是让时间成为你的朋友，即使在你持仓的合约不涨的情况下，你可以继续移仓，不会发生移仓损失，还有可能获得移仓收益。一旦需求启动，现货走强，就是一波强势的现货带动期货上涨的行情，甚至可能持续几年。 所以，我个人强烈建议，如果要搞基本面分析，不需要过于复杂，因为市场上影响价格的变量因素实在是太多太多了，即使你把所有的变量因子都找到了，你依然无法判断价格的波动，但是你可以确定的是价值，一个是合约的价值，一个是商品的价值，而价格是围绕价值波动的，对于合约来说，这个价格围绕价值波动的周期可能较短，也就是4个月，因为主力合约一般集中在1、5、9，间隔是4个月；对于商品来说，这个价格围绕价值波动的周期可能更长一些。 市场上大多数的研报都在罗列变量，为了判断价格的波动，在我看来那些都不重要，真正重要的只有三点：第一，这个合约或者商品的价值究竟是多少；第二，价格与价值的偏离程度有多大；第三，这个合约或者这个商品有没有值得参与的安全边际。 我个人其实不太注重产能、产量、开工率等这些数据，这些数据往往引导预期，影响的是价格，而不一定真的会对价值产生多大的影响。以螺纹为例，很多人根据这些数据做空螺纹，表面上看是有基本面作为依据的，在我看来，它很不成体系，就是赌一个预期，其实就是在利用各种变量去猜价格会如何变化。 而我认为真正的基本面交易并非去抓住每一次涨跌，而是有自己的逻辑、框架和策略，你的策略不可能适用于所有行情，用行情来匹配你的策略，而不是用你的策略去试探各种行情。螺纹仓单价格在4200元/吨以上，期货价格在3800元/吨左右，价值是4200元/吨，价格是3800元/吨，很多人喜欢做空，各种理由，不能说这些理由没有道理，确实有逻辑依据，但是这些都是零散的东西，不成体系，不能构成你的策略。 对于我来说，当价格严重低于价值时，我一般不会选择去做空。当然，这并不代表价格不会继续下跌，继续以螺纹为例，尤其是5、6月份南方雨季影响建材需求、甚至限产不及预期产量增加等等，盘面价格一直跌，当然现货价格也可能跟着下跌。对于这种价格的下跌，可能不是上述交易策略要赚的钱。我更希望它下跌，期货从贴水400点变成贴水800点，价格与价值偏离程度更大，具备了足够的安全边际。 与此同时，进入7、8月份，距离交割月也不断临近，就是一个做价格向价值修复的一个行情，这个是我的策略该赚的钱。所以价格涨跌与我无关，我不去试图用各种变量去判断，只是关注价格围绕价值的波动。大部分交易者都是去猜价格，而没有真正成型的策略。 当然，上面有些发散，核心的是几句话：第一，你要知道商品的两个成本，一个是生产成本，一个是仓单成本；第二，并不是所有行情都要去做，市场上有做不完的行情，并不是都参与了才能赚到钱，而是参与了恰当的行情才能赚到钱，所以行情要匹配你的策略，而不是用你的策略去匹配各种行情。 对单个商品如何做价值投资需要注意的是，投资价值并不等于价值投资。我以螺纹为例，假设rb1901现在4000，但是由于库存历史低位，期货贴水400点，加上环保限产政策的影响，现货十分坚挺，因此，我认为rb1901在4000元/吨这个价位上是有投资价值的，所以我选择做多rb1901，但是我这笔交易并不是价值投资。因为当下螺纹的价格远远在成本线之上，利润相对较高，所以在这个价位上螺纹并不适合做价值投资。 真正的价值投资指的是，商品的价格处于成本线之下，价格处于历史较低水平，在这种情况下买入并持有才是真正的价值投资。我们继续以螺纹为例，当螺纹跌到1600元/吨的时候，企业亏损严重，你买入做多就是做的价值投资，这与你在4000元/吨的价位上，利润相对较高时，买入做多是完全不同的。这两笔交易都是因为有投资价值才做多的，但前者做的是价值投资，而后者不是。 很多人自诩为价值投资交易者，但实际上他做的只是一笔笔普普通通的具有投资价值的交易而已，并非真正的价值投资。所以，如果你想做一名价值投资者，就一定要理解什么是真正的价值投资。价值投资与投资价值的区别如图8-5所示。 图8-5 价值投资不同于投资价值 或许，你之前已经理解了投资价值与价值投资的区别，于是当你发现某个商品的利润处于亏损状态，就毫不犹豫地建立多头头寸，结果亏得一塌糊涂，古往今来，低价格抄底被市场消灭的交易者不计其数，其中也不乏业内的一些资深交易者。你思考过为什么吗？ 继续以螺纹为例，假设现在螺纹跌到了3000元/吨，然后利润亏损，请问你会做多吗？如果你简单地认为，螺纹利润亏损，长期不可持续，于是你选择入场做多，那么你可能同样亏损非常严重，为什么？难道“长期亏损不可持续”这个常识是错误的吗？并不是！因为你现在做多并非真正的价值投资，只不过当前螺纹钢的价格进入了价值投资观察区域。 我们知道，螺纹钢的主要原料是铁矿石和焦炭，现在只是钢厂利润亏损，如果上游矿山和焦化厂依然有一定的利润，那么在下游亏损的情况下，上游矿山和焦化厂未来还会继续降价，一旦原材料降价，螺纹钢即使在利润亏损的情况下，依然还会继续下跌。所以我们不能只看单个品种的成本，而是要看整个产业链的情况。 换句话说，我们真正要关注的是商品的终极成本，所谓终极成本是指整个产业链都不赚钱的情况下，商品的成本。也就是说，当矿山、焦化厂都不赚钱甚至亏损的时候，这个时候螺纹的生产成本才是终极成本。如图8-6所示。 图8-6 价格跌破商品的终极成本时适合做多 当螺纹期货的价格低于螺纹的终极成本，这才是具有了价值投资的机会。因为在这种情况下，整个产业链都亏损了，产业链的任何一个环节商品的价格都已经降无可降了，所以这个时候你去逢低做多，才是真正的价值投资。 如果你没有意识到这一点，而只是看到了螺纹钢这一个品种亏损，就开始做多了，那不是真正的价值投资，你往往还会继续遭受巨大的损失。这就是很多人做价值投资依然亏钱的一个重要原因。 如何以定投的方式做商品期货很多人喜欢基金定投，我个人认为，与其如此，倒不如把自己当做成一个基金经理，自己进行股票或者期货的定投，我们以商品期货定投为例，首先假设你最初投资了1万元，基金的份额是1万份，基金的净值是1元，这个时候你发现某个商品价格跌破终极成本，你打算长期买入做多，最初资金使用率是30%。你打算每个月定投一次，定投的原则是每次定投都维持最初30%的资金使用率。 假设价格还在继续下跌，现在你的账户权益只剩下了0.9万元，基金份额保持不变，还是1万份，那么基金的净值就从1元变成了0.9元，账户的资金使用率会超过30%，假设为33%。这个时候你打算做这个月的定投，你需要确定定投的金额。定投的金额就等于买1手该商品的保证金，再除以最初的账户资金使用率30%。该商品的保证金就等于当前商品期货合约的价格乘以合约乘数再乘以保证金比例。 确定了需要定投的金额之后，我们的账户权益会发生变化，基金份额也会发生变化，但是基金净值并不会随着我们资金的增加而发生改变。所以，当我们增加了定投金额之后，我们需要金额基金份额的调整，用定投金额除以当前的基金净值，从而得到了增加的份额，再加上之前的份额就得到了总的基金份额。这里，为了方便计算，我把上面介绍的这些，列几个简单的公式： 1）定投金额=合约保证金/30% 2）合约保证金=期货合约价格x合约乘数x保证金比例 3）最新账户权益=当下权益+定投金额 4）最新基金份额=当下份额+定投金额/当下净值 你可以自己做个excel表格，记录日期、账户权益、基金份额、基金净值，可以做个折线图，实际上就是你自己的基金定投产品的曲线。如图8-7所示。当然，你还可以在这个表格中增加，期货价格、持仓数量、合约乘数、保证金比例、资金使用率、定投金额，这样的话，你可以利用表格中的相关数据，轻松计算出每次需要定投的金额是多少。 图8-7 记录账户权益、份额折算以及基金净值曲线 之所选择定投，是我们认为这个商品是有价值的，凡事有价值的东西，在价格低于其价值的时候就可以选择定投。在我看来，在国内做基金定投我很难去判断这个基金是被低估了还是被高估了。 但是上市公司的价值是否被低估或高估你可以判断出来，商品期货的价值是被高估了还是被低估了你也可以判断出来。所以你要选择去找到你认为有价值并且你能够判断其价值的标的去进行定投，而不要把钱定投给那些公募基金，因为他们能做的，你同样可以做到。 我个人认为，商品是有价值的，是值得定投的。上市公司还有可能退市，风险其实比商品更高一些，当然，如果你对上市公司进行定投也可以，尽量避免去定投那些商誉高的、财务费用高的、业务范围乱七八糟的公司。商品的价值在于哪里，我个人认为是利润率，价格的绝对高低有时候不一定准确，利润率的情况往往能说明问题。 很多人在做商品期货的时候，看到价格低了，容易进去抄底，这种情况下，商品一般供过于求，库存非常高，把价格压得很低，商品的利润率很低，甚至亏损。很多人认为长期亏损不可持续，所以就入场做多这个商品。 逻辑是没有问题的，但问题是任何一个产品都不是凭空造出来的，都有产业链的上下游，单纯是自己这个环节利润较差或者亏损了，并不是最佳的定投时机，因为如果上游利润比较好的话，中下游这个环节利润亏损的压力会向上传导，导致上游价格下跌，利润收窄，从而把中下游环节的利润空间打开，中下游有了利润，就依然存在了价格继续下跌的可能性。 所以研究利润，不仅要注意本环节的利润情况，更重要的是关注上游各环节的利润情况，如果整个上游利润率都很低，本环节利润率也很低，这样整个产业链上游都没办法再降价了，这种情况下本环节的生产成本才是终极成本，如果价格跌破了这个成本，是值得开始进行定投的，安全边际会高很多。 商品定投和股票定投不一样的地方在于，股票没有到期日，不需要移仓换月，而商品期货每个合约都有退市日期，所以需要进行移仓换月。在移仓换月的过程中，从而会产生移仓收益或损失，账户的资金使用率会发生变化。移仓后的账户资金使用率为：新合约价格x合约乘数x保证金比例x持仓数量/账户权益。 如果是商品是Contango结构，做多移仓的话，会有移仓损失，你的账户资金使用率会有所上升；如果是Back结构，做多移仓的话，会有移仓收益，你的账户资金使用率不会有所上升，甚至有可能下降。所以从市场结构来说，做定投的期货品种最好是Back结构。 关于定投品种的问题，不同的商品属性是不同的，对于多年生的品种，去做定投不太合适，因为它的周期太长，可能导致你长期定投没有效果。最好去定投那种周期短的品种，而不要去选择那些生长周期太长的品种，从而减少交易的时间成本。 例如，一年生农产品，基本上都是一年一个行情，今年如果是上涨的话，基本上全年都是涨势，如果今年是跌的话，基本上全年都是跌势。但明年再种的时候，可能就是完全不一样的行情了。 相反，像橡胶、棕榈这种周期比较长的品种，一旦进入丰产周期，时间太长，你需要定投的时间也可能特别长。所以找一些周期短的农产品和工业品进行定投可能更加好一些。 关于定投的频率和时机问题，这里我们假设是每个月定投一次，至于是每周一次，还是每月一次，还是半月一次，取决于交易者自身的资金状况。另外，这里我们默认假设最初定投1手，根据交易者自身资金状况，也可以是5手、10手等等。关于定投的时机问题，价格比上一次定投更低的情况下去定投好一些，因为需要投入的资金更少一些。 关于是否赎回的问题，基金除了可以申购，也可以赎回。很多时候，我们去低位长期做多某个品种时，价格从低位反弹了起来，那你的持仓是否要平仓呢？比如下有成本支撑，上有高库存压制，在成本支撑的作用下反弹了，受到了高库存的压制，可能长期在低位这里震荡，当涨起来的时候，你是无视，还是先平仓呢？ 这个因人而异，有的人无法容忍盈利回撤，有的人是先浮盈1.2亿后浮亏1500万，最终平仓的时候盈利4.5亿。我个人认为，在不缺资金的情况下，认为价格未来会比现在更高，那就可以继续持有，未来赚取更多的收益。 以上我们简单介绍了商品定投需要注意的几个方面，包括交易逻辑、品种选择、移仓换月、频率时机、赎回等等，如图8-8所示。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章 基于“库存+基差+利润” 的交易逻辑]]></title>
    <url>%2F2020%2F12%2F18%2F%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E2%80%9C%E5%BA%93%E5%AD%98-%E5%9F%BA%E5%B7%AE-%E5%88%A9%E6%B6%A6%E2%80%9D-%E7%9A%84%E4%BA%A4%E6%98%93%E9%80%BB%E8%BE%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 基于基差的交易逻辑基差是期货交易者最关心的一个指标，因为通过基差，交易者可以知道现货价格和期货价格哪个更高。交易的本质就是低买高卖，所以当期货价格高于现货价格，即期货升水的时候，选择做空是比较不错的选择；相反，当期货价格低于现货价格时，即期货贴水的时候，选择做多是比较不错的选择。 所以，单纯从基差一个角度去寻找交易策略，我们可以得到如下的结论： 期货升水→做空为宜 期货贴水→做多为宜 正如我们在前面所介绍的，顺基差交易可以给我们提供客观的赔率优势，如图7-1所示。但问题是，基差不代表一切，并不代表期货升水，价格就不会上涨了，期货贴水，价格就不会下跌了。因为影响价格的因素有很多，基差只是帮我们找到一个相对有利的交易方向，它并不能够确保我们较高的交易胜率，所以我们还需要寻找其他相关指标与基差配合来使用。 图7-1 顺基差交易的操作方法及优势 例如，当市场预期较为乐观的时候，即使期货升水，也会出现期货引领现货价格上涨的情况，例如2017年的橡胶期货，一直是期货升水现货，结果是期货价格上涨把升水幅度拉大，如图7-2所示。然后现货跟涨，进行基差修复，所以这种情况下单纯依靠基差来做空，显然就会遭受巨大的损失。 图7-2 2016-2017年沪胶主力升水上涨 再比如，当市场预期较为悲观的时候，即使期货贴水，也会出现期货引领现货价格下跌的情况，例如2018年的螺纹期货，一直是期货贴水现货。当时RB1801合约追随现货上涨，最终发生了逼仓行情， 而RB1805合约并不跟涨，反而下跌，结果期货价格下跌把贴水幅度拉大，然后现货跟跌，进行基差修复，如图7-3所示。所以这种情况下单纯依靠基差来做多，也会遭受巨大的损失。 图7-3 螺纹期货贴水情况下的大幅下跌 显然，单纯依靠基差一个指标去做交易决策，并不是十分有效，我们还需要增加其他重要的指标与之配合使用，根据个人的交易经验，我认为库存和利润这两个信号再结合基差做出交易决策，胜率往往比较高，盈亏比也十分理想。 基于”库存+基差”的交易逻辑期货深度贴水的时候，未来基差修复的方向有两种可能，一种是期货上涨向现货修复，另一种是现货下跌向期货进行修复，如图7-4所示。所以我们需要做的事情是判断基差的修复方向。 图7-4 基差修复的两种方式 由于期货不仅具有商品属性，同时具有金融属性，很难直接判断出来期货价格的变动，所以我们选择研究现货价格的变动，根据现货价格未来变动的情况以及基差修复的要求，倒推出来未来期货价格变化的方向。 商品现货的价格由供求关系决定，供不应求则价格上涨，供过于求则价格下跌，所以我们还需要判断商品的供求关系。供求关系相互作用的结果体现在库存上，供大于求的情况下，库存通常较高，供不应求的情况下，库存通常较低。所以我们发现低库存则价格容易上涨，高库存则现货价格容易下跌。 当期货深度贴水时，说明期货的价格低于现货的价格；如果商品的库存比较低，说明现货市场上供不应求，未来现货价格易涨难跌；由于交割时基差修复的需要，最终期货价格应该等于现货价格，所以我们可以推测出，在这种情况下，未来期货上涨向现货修复的概率比较大，同时具有不错的赔率优势。 当期货高度升水时，说明期货的价格高于现货的价格；如果商品的库存比较高，说明现货市场上供过于求，未来现货价格易跌难涨；由于交割时基差修复的需要，最终期货价格应该等于现货价格，所以我们可以推测出，在这种情况下，未来期货下跌向现货修复的概率比较大，同时具有不错的赔率优势。 所以从库存和基差两个角度来讲，我们可以得到这样一个基本的策略（见图7-5）： 低库存+深贴水→逢低做多 高库存+高升水→逢高做空 图7-5 库存+基差交易逻辑的胜率及赔率优势 基于”库存+基差+利润”的交易方法前面两期节目所介绍的交易逻辑并不能够保证让你永远赚钱，因为市场上经常出现期货深度贴水，而且现货低库存，结果期货和现货大幅下跌的情况。出现这种情况的根本原因在于，现货的高利润不可持续，市场预期现货见顶，所以在低库存且深贴水的情况下，期货引领现货下跌。 市场上经常出现期货大幅升水，而且现货高库存，结果期货和现货大幅上涨的情况。出现这种情况的根本原因在于，现货利润较低甚至亏损，低利润和亏损是不可持续的，市场预期现货价格见底，所以在高库存且高升水的情况下，期货引领现货上涨。 所以为了让上述的策略更加完备，我们还需要引入一个利润指标来辅助判断，从“库存+基差+利润”三个角度来说，我们可以进一步优化上述两个策略： 低库存+深贴水+低利润→逢低做多 高库存+高升水+高利润→逢高做空 当库存、基差和利润三个指标同时满足我们的条件时，我们的策略就是单边做多或者单边做空，如图7-6所示。但是，你会发现，有时候三个指标之间互相矛盾，这个时候我们需要调整策略，从单边改为跨期套利。 图7-6 库存+基差+利润交易策略的胜率及赔率优势 如果说期货深度贴水，而且现货低库存，但是现货高利润，在这种情况下，从库存角度倾向于做多，从利润角度倾向于做空，库存和利润两个判断胜率的指标矛盾，这时候如果采取单边策略去参与行情的话，往往会遭遇价格的剧烈波动，频繁止损，所以这种情况下可以将单边做多策略改为跨期正套。 正套的逻辑是这样的，近月做现货逻辑，远月做预期逻辑，近月合约面临基差修复的要求，所以基差修复是主要矛盾，远月合约由于暂时没有基差修复的要求，所以预期作用是主要矛盾，当现实和预期矛盾越大的时候，这种方向市场上的正套价差会越拉越大，风险小于单边，收益有可能比单边策略还要高。 例如，RB1801和RB1805合约的跨期正套，当时价格结构是：现货价格高于RB1801，RB1801的价格高于RB1805；从库存角度来讲，处于历史同期较低水平；但是从利润角度来讲，现货处于高利润状态，即低库存+深贴水+高利润的组合。当时近月RB1801合约跟随现货上涨，体现了现货逻辑，而远月RB1805合约预期悲观下跌，体现了预期逻辑，结果RB1801-RB1805价差大幅走高，如图7-7所示。 图7-7 螺纹15价差的历史走势 相反，如果期货高度升水，而且现货高库存，但是现货利润很低甚至亏损，在这种情况下，从库存角度倾向于做空，从利润角度倾向于做多，库存和利润两个判断胜率的指标矛盾，这时候如果采取单边策略去参与行情的话，往往也会遭遇价格的剧烈波动，频繁止损，所以这种情况下可以把单边做空策略改为跨期反套。 反套的逻辑和上面正套的逻辑类似，近月合约核心矛盾是基差修复，远月合约的核心矛盾是预期作用。这种跨期策略同样是风险小于单边，收益有可能比单边还要高。如图7-8所示。 图7-8 库存+基差+利润交易逻辑的策略分类 所以，当库存指标和利润指标发生矛盾时，为了降低交易中的风险，我们需要对交易策略进行调整，将单边交易策略改为跨期交易策略： 低库存+深贴水+高利润→跨期正套 高库存+高升水+低利润→跨期反套 “库存+基差+利润”交易逻辑的注意事项01 基差的升贴水转换 基差不仅仅只有基差修复一个特点，基差还会发生升贴水转换，基差本身是市场对基本面的认可程度，当基差发生升贴水转换之后，往往意味着整个市场结构发生了重大变化，所以基差也是市场行情的一个领先指标。 比如，当某个商品处于正向市场的结构当中，这是典型的现货熊市特征，说明当下供需宽松，基本面比较差，所以期货升水于现货是正常的，近月合约的价格高于现货的价格，远月合约的价格高于近月合约的价格，此时，基差为负数，基差较弱。 当你发现各个合约的基差从负值开始变为正值，这意味着市场结构从正向市场变为反向市场，这是典型的现货牛市特征，说明当下供需开始逐渐偏紧，基本面开始好转，所以期货贴水于现货是正常的。 市场各个合约都发生了基差的升贴水转换，往往意味着市场进行了牛熊转换，如图7-9所示。当价格处于相对高位或者低位时，如果发生了基差的升贴水转换或者期限结构的转变，往往意味着现货市场的供需基本面发生了变化，这也暗示了市场有可能发生牛熊转换。 图7-9 基差升贴水转换或者期限结构转换与牛熊转换的关系 反向市场是典型的牛市特征，在牛市的情况下，适合买入做多，通常情况下会出现较为激烈的上涨，即使你买入的近月合约没有出现大幅上涨也没关系，你可以选择移仓到下一个主力合约，由于远月合约价格更低，所以你不会有任何移仓损失。 相反，当你发现各个合约的基差从正值开始变为负值，而且近月合约基差的绝对值小于远月合约基差的绝对值时，这意味着市场结构从反向市场变为正向市场，这是典型的熊市特征，说明当下基本面变差。所以期货升水于现货是正常的。 通常在熊市状况下，适合卖出做空，当市场由牛市变为熊市时一般会出现较为激烈的下跌。如果你卖出的近月合约没有出现大幅下跌，你再移仓到下一个主力合约时，由于远月合约价格更高，虽然你有了一个更好的做空价格，但是你会遭受一定的移仓损失。所以在这种情况下，不建议采取长期持有然后滚动换月的操作方式，尤其是对于换月成本比较高的品种。 所以你会发现，基差不仅可以给你提供参与基差修复行情的机会以及配套的策略，它还可以给你指示市场的牛熊结构，在牛市的情况下，你可以采取长期持有做多的策略。当然，我在这里并没有详细介绍库存和利润的变化情况，其实随着基差发生了升贴水转换之后，库存和利润必定也会发生相应的变化，因为基本面的情况已经发生了变化。 以负基差向正基差转换为例，负基差通常对应的是现货高库存，利润较差，现货市场供需宽松。当负基差逐步向正基差转换时，通常会对应着库存从高位开始去化，利润从低位开始修复，现货市场成交开始回暖。如图7-10所示。 图7-10 基差变化与库存和利润变化的关系 02 季节性与上下游问题 关于“库存+基差+利润”交易逻辑，还有一个需要注意的方面就是季节性问题。例如，我们在比较库存高低时，有两种比较方式，一种是观察库存同比的变化，另一种是观察库存环比的变化。 但一些商品往往存在季节性问题，有的是因为供应端产量有明显的淡旺季之分，有的是因为需求端消费量有明显的淡旺季之分，从而导致商品的库存存在某种季节性规律，最终在价格上得以体现。 因此，我们在比较库存或者利润数据时，如果选择环比的话，那么就会存在季节性问题。所以我们在使用库存和利润这类指标时，往往选择根据同比来判断高低，根据环比来判断趋势。如图7-11所示。 图7-11 同比和环比的使用目的 此外，除了关注产业链本环节的库存、基差、利润等数据之外，我们还需要对整个产业链上下游的品种进行库存、利润等基本面数据的分析。 因为任何一个品种都不是独立存在的，它只是产业链中的一环，产业链上下游会进行库存和利润的传导。从库存角度来讲，如果下游产品库存高企，那么上游的品种可能也会慢慢出现累库的情况，从而降价销售，价格就容易走低；从利润角度来讲，如果下游的产品利润亏损严重，那么上游产品的需求受到抑制，出货不畅，就容易出现降价走量的情况，价格容易下跌。 简单来说，下游的库存状况和我们所研究品种的库存方向是一致的，下游的利润状况与我们所研究的品种利润方向是相反的。因为下游库存较高时，采购就会减少，上游就会累库，变成高库存；下游库存较低时，有补库需求，上有库存就会减少，变成低库存。下游利润较高时，能够接受更高的价格，利于上游利润的增加，可以认为上游利润处于比较低的状态；下游利润较低时，无法接受更高的价格，容易导致上游利润减少，可以认为上游利润已经处于比较高的状态。 所以不要孤立和静态地去分析任何一个商品，我们不仅要学会通过同比和环比对品种进行分析，同时也要学会从产业链上下游角度进行对比分析。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六章 驱动力与信号验证]]></title>
    <url>%2F2020%2F12%2F18%2F%E7%AC%AC%E5%85%AD%E7%AB%A0-%E9%A9%B1%E5%8A%A8%E5%8A%9B%E4%B8%8E%E4%BF%A1%E5%8F%B7%E9%AA%8C%E8%AF%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 期货分析的三种方法对于交易者而言，无论是对于单边期货交易，还是总结自己的交易框架，都需要经过三种分析过程：理论分析、逻辑分析、实证分析，如图6-1所示。只有地不断去完善理论、理清逻辑，再通过事实进行验证，我们在交易才会有所进步和提高，交易久了才能够总结出适合自己的交易框架。 图6-1 期货分析常用的三种方法 01 理论分析 我认为无论是做基本面交易，还是做技术分析交易，都离不开理论分析。对于基本面交易者来说，如果采取自上而下的分析方法，需要用到宏观分析、产业分析、品种分析，各种宏观的经济理论、微观经济理论、供求理论、库存周期等等，所以基本面分析离不开各种经济金融相关的理论。当然，技术分析也不例外，无论是缠论、波浪理论、均线理论、价量理论等，交易者在进行技术分析的时候，都是遵循各自的技术理论。 所以，无论是做基本面研究，还是做技术分析研究，交易者首先要具备一定的理论基础。大多数交易者常犯的一个错误就是，自己对其交易的方法背后的原理或理论根本就不了解，就盲目使用了。只有对基本的理论了解并认可，你才能在交易中更好地将这种理论与实际相结合，否则很难灵活运用。所以，交易者需要加强最基本的理论分析，从相关理论方面去充实和提高自己，而这恰恰是许多交易者所忽略的，由于急于赚快钱，会尝试各种方法，也不去研究方法本身，这是不可取的。 02 逻辑分析 只有理论还不够，还必须具备逻辑分析能力，简单来说就是根据已经掌握的理论，以及结合当下的客观数据或现象进行合理的逻辑推演，否则只有理论，缺乏逻辑分析能力，同样无法做好期货分析，更别提期货交易。 当我们在阅读期货公司的研报时，总是会被各种数据和图表搞得眼花缭乱，但逻辑分析不仅仅是列举各种现象、数据或者图表，关键是要理解这些数据以及图表背后的因果关系，通过数据得到原因，根据原因以及你所挖掘的因果关系来合理推演预期的结果，这才是逻辑分析。 当然，技术分析也是如此，很多时候技术分析的理论看似很美好，但是在实战交易过程中，想要运用好也是非常困难的，因为盘面比理论更加复杂，想要做好盘面的技术分析，首先技术分析的理论需要非常扎实，其次对盘面的解读需要有着非常强的逻辑，能够对趋势、关键位置、相关的信号、止损位置、胜率、盈亏比等都有着较为清晰的逻辑分析。 03 实证分析 最后，无论是基本面分析还是技术分析，都需要经过实证检验，尤其是在你想要总结出自己固定的交易框架时，更需要用实证来检验。科学的本质在于可证伪性，科学的交易方法同样如此，如果你的交易框架不能被证实或者证伪，那么这种交易方法本身都是不科学的。 交易本身就是概率游戏，如果有一些所谓的必胜法，无论怎样都没有办法证伪，这种交易方法基本上都是骗人的。科学的交易方法，对错分明，交易中对错很正常，需要总结成功的经验和失败的教训，然后不断去完善自己对理论的理解，去修正自己的逻辑，然后才能有所提高。 所以，无论是我们总结自己的交易框架，或者是我们对于单次行情的分析，最终结果都是要有清晰地结论，最终是可以被证实或者被证伪的。因此，我希望交易者在期货交易过程中，能够运用好这三种基本的分析手段：理论分析、逻辑分析和实证分析。 此外，在交易过程中，我们经常会遇到各种意外事件，对于事件分析，要做到三点：定性分析、定量分析和历史回顾，如图6-2所示。 图6-2 事件分析的三个要点 定性分析就是要能够判断出此次事件对价格的影响是利多还是利空，当然，这需要依赖一定的理论分析和逻辑分析。对事件定性是基础的要求，如果事件定性错误，那么之后所做的努力都是白费的。 虽然定性分析很重要，但也有很多人认为对事件定性分析没有意义，对事件进行定量分析才有价值。例如，当发生了某个事件冲击，从定性的角度来说，对价格带来利空，但是对价格影响有多大呢？因为此次事件的影响，某种商品价格已经跌了300元/吨，那么价格的下跌是否已经反映了事件的利空影响呢？ 定性分析显然无法解决这个问题，而交易者这个时候也无法确定是应该继续做空，还是应该去逢低做多。相反，定量分析能够解决这个问题，通过定量分析，你可能得出此次事件对价格的影响是200元/吨，现在超跌了，那么你可能就会选择做多；也有可能通过定量分析，你认为此次事件对价格的影响是600元/吨，现在才跌了300元/吨，那么你可能选择继续做空，如图6-3所示。 除此之外，我们还可以回顾历史事件，看一下历史上发生类似的事件时，对价格的影响是利多还是利空，从定量的角度去看一下对价格影响的量是多少。再将此次事件与历史事件进行对比，得出合理的判断。所谓的历史回顾，本质上就类似于上述所说的实证分析。 所以分析的根本思路就是理论分析、逻辑分析和实证分析，然后从交易的角度来说，可以分为定性分析、定量分析与历史回顾。掌握这几种分析方法与分析思路，基本上可以让你拥有一个独立的思想，从而不至于被市场上的虚假消息所迷惑，也不至于被一些水平参差不齐的研报所蒙骗。 驱动力与信号验证的理念在期货交易中，我们需要占据客观优势，即赔率上的优势，同时我们也需要通过主观判断来提高交易的胜率。无论我们用什么方法去判断胜率，其结果都是一个概率。对于基本面交易者来说，我们经常听到的一句话就是：大胆假设、小心求证。根据相关的理论、逻辑与数据，合理推演未来商品基本面可能会发生的情况。 为了充分利用数据与逻辑推理，我们需要找到验证我们逻辑的核心驱动力，以及支撑这种驱动力的相关指标。因此，基本面分析的基本方法是，通过逻辑推理，找到核心的驱动力，同时利用相关指标进行验证。对我们的逻辑进行证实或者证伪。 其实，一个好的分析报告，不仅要让自己明白前提条件是什么、逻辑推演是什么以及最终的结论是什么，更重要的是要让自己知道验证前提是什么。只有在你的前提条件得到验证，你的逻辑推演才是合理的，如果你的前提条件都被证伪了，那么你的交易逻辑也就不合理了。 例如，我们想要做多期货还是做空期货，核心的就是需要判断未来现货价格是上涨还是下跌，因此驱动力是判断未来现货价格的变化。判断的基本逻辑是供求决定价格，供求相互作用的结果体现在库存上，库存较高，我们可以理解为供过于求，库存较低，我们可以理解为供不应求。所以，我们找到了验证驱动力的一个信号，那就是库存。 然后，我们在继续进行推理，比库存更早一些的信号是什么，显然是供给和需求。那么供给和需求又取决于什么呢？答案是利润。对于生产者而言，在高利润的驱使下，短期会加大生产的开工率，长期则可能会选择扩大产能，而产量等于有效产能与开工率共同的乘积，所以上游生产利润、加工利润或者进口利润较高时，都会导致供应增加，所以供应可以作为库存的一个验证指标，而上游利润又可以作为供应的一个验证指标。 同样的道理，对于下游企业来说，在高利润的驱使下，短期也会加大生产的开工率，长期有可能存在产能投放的预期，从而导致下游的产量增加，下游增产会增加对上游的需求。所以需求也是库存的一个验证指标，而下游利润又可以作为需求的一个验证指标。 这样一来，我们就可以打造一个完整的逻辑闭环，如图6-4所示，同时具有明确的观察信号，我们只需要观察和验证这些信号，从而来对我们的逻辑进行证实或者证伪：利润—&gt;开工率和产能—&gt;供给和需求—&gt;库存—&gt;现货价格—&gt;期货交易。 图6-4 驱动力与信号验证的交易逻辑 对于任何一个行业，任何一个品种都可以按照上述逻辑去进行分析，只是不同产业的指标名称可能存在一些差别，但本质上都是一样的。所以，我们在分析逻辑时需要采取逆向思维，先是找到核心的驱动力，然后再去寻找验证驱动力的各种前置指标，同时我们根据最终的数据来验证我们的指标，同时判断我们的逻辑是否得到验证。 先存疑后验证的信息解读方式期货市场与股票市场有些不同，可能在期货市场上并没有那么多内幕消息，所以在消息的获取上，对所有交易者相对公平一些，只是在获得信息的时效性上稍微有一些差别，这也是没有办法的，毕竟大机构确实在信息获取上比散户有一些优势，但好在不会存在机构知道而散户不知道的信息。当你在期货市场中交易久了，你会发现，这个市场最可怕的不是你不知道信息，而是信息泛滥。 期货市场上存在太多信息，这些信息很多是虚假信息，有的是把历史信息当做最新信息来发布，有的甚至是无中生有的信息。所以对于交易者来说，不再是急需寻找各种信息，最重要的是学会识别和分析信息，对信息进行过滤。很多交易者对市场出现的信息不进行任何思考和求证，就盲目当做是真实的消息，从而仓促地做出了交易决策，这样的交易者大概就是市场中所谓的“韭菜”。 当市场中出现了某种信息或某些数据时，在我们未经求证之前，务必保持存疑态度。求证的方式有两种，一种是交叉验证，一种是逻辑验证，如图6-5所示。所谓交叉验证是指，寻找不同的信息发布来源来对数据或信息进行交叉验证，看一下不同的信息发布源的信息是否相互矛盾。 图6-5 信息验证的两种方式 例如，我们想了解一下黑色系钢材的库存情况，突然我的钢铁网给出了一个数据，我们不能不假思索地就以这个数据为准去做交易决策，我们要做的第一件事情就是进行数据求证，我们可以比较一下西本新干线、银谷网、找钢指数、唐宋钢铁等同类型平台发布的该数据，看一下数据或信息是相互验证的还是相互矛盾的。 求证的另一种方式是逻辑验证，有时候对于某个信息或者数据，我们可能没有其他信息来源进行对比，这个时候我们可以运用逻辑分析去思考一下，这个信息或者数据是否可靠。可以参考时寒冰先生的利益分析法，首先分析一下主要的利益主体有哪些，然后分析一下各个利益主体的诉求是什么，再次分析一下各个利益主体实现其利益的渠道有哪些，最后分析一下利益主体中趋势左右者的成本和收益，从而得出相应的结论。 当然，对于我们没有办法去进行交叉验证或逻辑验证的信息和数据，我们尽量回避，继续保持怀疑，不参与这类的行情。 除此之外，我们对市场信息的解读往往分为两种方式，一种是定性分析，另一种是定量分析。定性分析比较容易理解，就是分析某个消息对价格的影响是利多还是利空，只要懂得相应的经济学常识一般都能够做出合理判断，因为这类消息无非是影响供应端或者需求端，根据供求对价格影响的规律，比较好判断信息对价格的影响。 但是定量分析最大的问题在于，市场中的信息往往并不是孤立的，有时候可能多个信息同时发生，而这些信息有利多的因素，也有利空的因素，这个时候哪个因素对市场的影响更大，这是大多数分析者比较难以判断的问题，也是定性分析的难点。在交易中，定性分析如果分析错了，那么整个交易方向都会做反了。 然而，仅仅对信息进行定性分析，往往难以发挥信息的价值，甚至一些交易者认为没有定量分析的信息是没有任何价值的。因为比如市场上发生了某个利空消息，结果导致相关期货品种的价格下跌了100元/吨，那么问题来了，现在是入场做多，还是入场做空。换句话说，市场下跌了100元/吨之后，是否把已经把这个利空消息price in了。这就是定量分析需要解决的问题。 如果我们通过定量分析发现，这个消息应该导致价格下跌300元/吨，结果现在只下跌了100元/吨，此时我们可以继续入场做空；相反，如果我们通过定量分析，发现这个消息应该导致价格下跌50元/吨，结果现在却下跌了100元/吨，此时你可能会考虑入场做多。 但是，定量分析是比较困难的，还是接着上面的思路，通过计量经济学的方法，就是构造一个p=f（A，B，C，D，E，F）的函数，假设其中的变量D就是某个国际政治事件的影响，通过复杂的计量模型进行回归分析，得到原油价格p与D之间的关系，有一个系数。 在其他条件不变的情况下，D的变化对p的影响就是这个系数，但问题是，每次发生相同的政治事件时，其他的变量A、B、C、E、F都和之前的不一样的，所以没办法保证“在其他条件不变的情况下”，即控制变量法的思维在复杂的现实社会中几乎不可能实现，所以通过这个思路来企图量化某个政治事件对价格的影响，实在是难之又难。计量经济学中有一种方法叫做event study，专门进行事件研究，这种作为理论研究是可以的，但是作为现实应用，难度较大。 此外，定量分析还有一种更加简单的方法，不走计量的思路，而是走传统的微观经济学思路。 举个简单的例子，例如伊朗封锁霍尔木兹海峡，预期在6月份封锁15天，首先，你要做一个全球原油的月度平衡表，了解原油的6月全球供需情况，然后计算霍尔木兹海峡每天游轮运输原油的量，15天封锁影响多少桶原油的供应，然后计算原油的供给弹性是多少，根据减少的供应量以及供给弹性来预测原油价格的变化。 当然，伊朗这边封锁了，其他地方可能增产，所以你还需要对你预期的平衡表进行事后的修正。这是利用供需平衡与弹性来分析发生供应或需求缺口的情况下，价格的变化。 对于交易中的一些问题，要么你想尽一切办法弄懂它，然后利用它，要么你想尽一切办法规避它。如果你对它感兴趣，并且你认为你可以搞懂它，那你就投入时间和精力不断去研究它，在研究的过程中，你也会感到快乐。如果你对它不感兴趣，或者认为你没办法搞懂它，那你就想尽一切办法规避它给你的交易带来的影响。 了解一个品种，要去研究它的过去，了解它的现在，分析它的未来。在研究的时候，不能够天马行空，要有依据，所以最好要有理论分析，然后是逻辑分析，因为你是做交易的，不是搞研究的，所以最后还要搞实证分析，拿着行情来复盘一下。关于对商品基本面的研究，我个人有两点小小的建议： 1）研究过去→了解现在→分析未来； 2）理论分析→逻辑分析→实证分析。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章 期货交易中的正确思维]]></title>
    <url>%2F2020%2F12%2F18%2F%E7%AC%AC%E4%BA%94%E7%AB%A0-%E6%9C%9F%E8%B4%A7%E4%BA%A4%E6%98%93%E4%B8%AD%E7%9A%84%E6%AD%A3%E7%A1%AE%E6%80%9D%E7%BB%B4%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么上涨的时候我们有时候选择做多铁矿石，而不去选择做多螺纹钢呢？ 基本面分析是通过演绎法的方式去判断市场走势，技术分析法是通过归纳法的方式去判断市场的走势。怎么理解？ 胜率层面的优势和赔率层面的优势有什么区别？ 交易者应该学习的是如何做好资金管理。怎么理解？ 做胜率的交易具有脆弱性，做赔率的交易具有反脆弱性。为什么？ 期货交易的核心是概率思维期货交易是一个需要不断学习和积累的过程，一个20年交易经历的期货老手和一个2个月交易经历的期货新手水平绝对是不一样的。然而，这并不要是说交易的经历越久，交易者的水平就越高。很多交易者以一种错误的思维方式在进行期货交易，即使他们有多年的交易经历，但也鲜有交易经验，他们不懂得观察、思考和总结，只是凭感觉做出交易决策，而这并不是真正的期货投资，而是一种变相赌博！ 期货交易的核心是概率思维，简单来说，就是在积极参与大概率事件的同时，努力防范小概率事件，如图5-1所示。任何交易者开仓的时候都认为自己的开仓方向将会是行情发展的大概率事件，缺乏概率思维的交易者有两个典型的表现：重仓和不止损，因为他们没有做到防范小概率事件。所以，一个交易者无论之前在期货市场中赚了多少钱，只要缺少这种概率思维，一次黑天鹅事件，期货市场就可以让他爆仓出局。 图5-1 参与大概率事件，同时防范小概率事件 既然我们知道了在交易中时刻保持概率思维，那么接下来的问题就是，我们如何去寻找大概率事件以及如何去防范小概率事件。在寻找大概率事件时，有的交易者采取了技术分析法，有的交易者采取了基本面分析法，也有的交易者利用基本面和技术面共振的方法。 长时间以来，基本面派和技术面派经常水火不容，互相攻击，其实任何方法并没有好坏之分，其判断结果都不是百分之百准确，而只是一种概率。在防范小概率事件时，大多数交易者的想法比较一致，那就是资金管理。然而，比资金管理更加重要的是自我管理，因为绝大多数主观交易者的一致性非常差。 参与大概率事件其实分为两个过程，首先我们需要发现什么是大概率事件，其次我们需要确定何时参与大概率事件。本质上前者考验的是交易者的商品选择能力，而后者考验的是交易者的择时能力。 众所周知，商品有同涨同跌的属性，既然如此，那为什么上涨的时候我们有时候选择做多铁矿石，而不去选择做多螺纹钢呢？这是因为，我们根据基本面分析认为铁矿石的上涨空间比螺纹钢的上涨空间更大一些。既然我们根据基本面分析判断商品后期会上涨，为什么我们不选择入场呢？这是因为，基本面分析的作用在于品种的选择，入场时机的选择需要技术面给出明显的进场信号。 很多交易者把基本面分析和技术分析的作用给混淆了，所以操作时比较混乱。其实，基本面的分析主要作用就是品种选择与方向判断，而技术分析的作用主要是进出场时机的选择。很多技术分析者不认可基本面分析者，他们有人认为基本面分析都是马后炮，也有人认为散户不可能了解基本面。 其实，基本面分析是通过演绎法的方式去判断市场走势，技术分析法是通过归纳法的方式去判断市场的走势，前者基于严格的逻辑推理，后者基于历史会重演等假设，但交易并非一门科学，所以基本面分析法并不总是有效；同时，历史并不会简单重演，所以技术分析法也并不总是有效。因此，两种分析方法的判断结果都只是一种概率，如图5-2所示。 图5-2 利用基本面分析和技术分析来提高主观胜率 精明的交易者时刻保持着概率思维，他们通过基本面分析法找到了大概率事件，利用技术分析给出的明显信号来参与大概率事件。与此同时，为了防范小概率事件，他们懂得做好资金管理。为了表示对于概率思维的尊重，当他们找到自认为的大概率事件时，并不是急于入场，而是耐心等待，等待着技术分析给出强烈的进场信号。 让自己的交易处于平衡状态期货交易中最重要的是什么？有人说是方法，有人说是技术，也有人说是心态，各有道理。我个人认为，交易中最重要的是资金管理。无论是方法或者技术，都只是帮助你提高交易胜率层面的优势，而无法帮助你提高赔率层面的优势。 相信很多交易者都听说过关于美国魔术师的故事，有一位美国魔术师放弃任何判断，采用看似荒唐的抛硬币的方法来决定交易的方向，硬币数字朝上时选择做多，硬币图案朝上时选择做空，结果一年下来这位神奇魔术师的交易结果令人震惊，收益实现了翻倍。如果说方法或技巧很重要，那么这位魔术师的案例则是一个很好的反例，因为他用了一种看似荒唐滑稽的抛硬币的方法就实现了非常好的盈利效果。 所以，交易中最重要的并不是什么方法或者技巧，然而大多数交易者认为存在所谓必胜甚至常胜的方法或者技巧，一直迷失在苦苦寻找交易圣杯的道路上。其实，交易中无非两个核心的因素，一个是胜率，一个是赔率，这位魔术师的方式显然是放弃了胜率，抛硬币猜多空的胜率理论上在50%，然而他最终可以实现收益翻倍，说明这位神奇的魔术师一定是一位资金管理大师，因为他的交易具有赔率优势。 我认为，交易者应该学习的是如何做好资金管理，然而，这恰恰是大多数散户交易者所忽略的地方。散户交易者的交易特点是赌，要么重仓押多，要么重仓押空，就像是无头苍蝇一样乱撞，而大资金的交易方法则截然相反，交易中基本上注重多空平衡。我们可以通过席位四象图这个工具来看一下盈利的大资金在长期交易中是如何保持平衡的。 如图5-3所示，这是奇货可查网站中的席位四象图，它由四个维度构成，横轴是多空维度，越靠右说明席位的持仓越偏多，越靠左说明席位的持仓越偏空；纵轴是盈亏维度，越往上说明席位赚钱越多，越往下说明席位亏钱越多；气泡大小是保证金维度，气泡越大说明席位占用的保证金越多，气泡越小说明席位占用的保证金越少；右边还有一列时间维度，我们可以选择任意一个时间，看一下各个席位多空配置的情况以及盈亏的情况。 图5-3 席位四象图 以最右列的时间轴为例，我们最开始点击上方的2019-06-17，然后找到这一列最下边的播放按钮，从而可以动态观察所有席位在这段时间之内的多空配置变化以及盈亏情况的变化，整个界面会出现一个动态的气泡到处移动的过程，如果你仔细观察的话，你会发现这里面存在一个交易的秘密，那就是平衡。 我们在图5-3中可以显而易见看到一个大而且高的气泡，你会发现那就是永安期货的席位，气泡大说明它所使用的保证金比较多，位置高说明它盈利比较多，但其实，它并不是一开始就盈利这么多，而是经过一段时间之后才爬到那么高的位置，在这段时间之内，你会发现永安期货的持仓和其他一些席位的持仓存在很大不同。 很多时候我们可能只关注它气泡大小和位置高低，却忽略了它的多空维度。在整个过程中，你会发现永安期货的多空持仓基本上是均衡的，一直在纵轴附近移动，不会大幅偏离纵轴，多头行情来的时候，它的多单盈利超过空单亏损，位置上移；空头行情来的时候，它的空单盈利超过多单亏损，位置还是上移。 不光是永安期货，一些盈利比较强的头部席位基本上也是如此，多空持仓基本均衡，一直不会大幅偏离纵轴；反之，一些盈利比较弱的尾部席位，它们的持仓十分极端，大幅偏离纵轴，一会儿最靠右，一会儿最靠左，随着时间的推移，位置越来越靠下。 其实，对于大多数散户来说，他们的交易方式是赌博，而对于大多数机构来说，他们的交易方式是构造平衡。对于散户来说，一会儿赌多，一会儿赌空，胆子大的不止损死扛，胆子小的频繁止损被割肉。对于机构来说，基本上不存在止损，而是通过构造平衡来对冲风险。 以永安期货为例，在聚酯产业链中（见图5-4）。它持有大量PTA的多单，同时采取做空MEG来进行对冲；PTA和MEG都是聚酯产业链上游的原料，因此两个品种对应的下游需求是一致的，但是上游生产方式、生产工艺以及产业集中度不同，导致两个品种在供应端差异较大。因此，在对PTA和MEG进行对冲时，更多的是看两个品种的产能投放以及开工情况。 图5-4 聚酯产业链 类似的操作方式在永安这个席位的持仓多处可见，以MTO产业链为例，如图5-5所示，永安持有大量PP多单，同时做空MA进行对冲，也做空L进行对冲，尽管从聚酯产业链或者MTO装置原料和成品的对冲来看，似乎不是那么完全匹配，但是整体的能化板块上多空保证金基本上是配置较为均衡，在黑色系等其他版块也是如此，这样均衡的资金配置，无论行情是多头还是空头，抗风险能力都比较强，不像那些尾部席位，多空偏离巨大，抗风险能力较弱。 图5-5 MTO产业链 所以，对于交易者来说，要想成为期货市场上的“寿星”，你的持仓要寻求平衡，多头头寸的货值要和空头头寸的货值近乎平衡，这是资金的平衡。还可以进一步细化到板块内部的平衡，能化板块的平衡、黑色板块的平衡、有色板块的平衡、农产品板块的平衡，甚至还可以继续细化到产业链内部的平衡。 靠赌确实能赚快钱，也能赚大钱，但是盈亏同源，也能亏快钱，亏大钱。平衡未必能赚快钱，但也能赚大钱。交易中快是风险，大并不是风险。大钱并不一定由快钱加周转率而来，快钱未必能够积累成大钱。大钱是目的，快钱只是一种手段，当这种手段无法达到你的目的时，可以换另一种手段，平衡其实更多的是一种慢钱到大钱的手段。 国外交易者经常说得一句话是：Trade to live，don’t live to trade!当你的持仓不平衡的时候，你的心也难以平静下来，做什么事情都容易受到自己持仓的影响，生怕一个意外事件给你带来巨大损失。 当你的持仓不平衡的时候，你的家庭生活可能也是不平衡的，在本来值得开心的时候，由于持仓不平衡带来巨大亏损，作为交易者的你怎么能开心起来。这就会导致家庭生活中的情感不对称问题，当家人分享喜悦给你的时候，希望获得你的同理心和认可，而你由于持仓亏损巨大，没有表现出相同的喜悦，慢慢家庭关系以及家庭生活也会变得紧张和不平衡。 不仅如此，你做其他的事情也会因为持仓的不平衡而心不在焉，除了时刻盯住电脑屏幕或者手机屏幕之外，你找不到任何能够让放心的时候，那不是你在炒期货，而是期货在炒你，这样的交易是本末倒置的，交易的目的是为了更好的生活，而生活的目的不是为了交易！ 因此，如图5-6所示，一个交易者想要做好交易，至少要做到三方面的平衡：资金多空持仓均衡、板块品种多空配置均衡、生活与交易均衡。 图6 Trade to live，don’t live to trade! 事前风控的理念与操作方法凡事预则立，不预则废。期货交易也是如此。在开仓之前，我们需要做两手准备，如果我们判断正确了，该怎么办？如果我们判断错误了，又该怎么办？把两种情况都考虑清楚，然后制定合理的交易计划，交易中严格按照交易计划进行，这就是交易者常说的：计划你的交易，交易你的计划。 当然，这里不是详细介绍如何去制定一份交易计划，而是建议交易者要树立事前风控的交易理念，事前风控，事中执行，事后总结。我所接触的一些交易者，开仓之前并没有完全想清楚自己的止损区间或者止盈区间，目标并不明确。 这类交易者往往容易犯这样的错误：当持仓处于盈利状态时，由于缺乏盈利目标，不知道什么时候止盈，结果行情调整的时候，浮盈变成浮亏，又不懂得止损，结果行情越调越深，浮亏严重，最终自己因为承受能力不足而止损了。 如果按照这样的情况交易下去，那是永远也赚不到钱的，因为这从逻辑上就是一个死循环，如图5-7所示。盈利的时候，你永远不知道什么时候该止盈，行情不可能永远朝着一个方向发展，一旦行情掉头你就有可能亏损，然后你也没有明确的止损目标，结果浮亏越来越大，最终巨大的浮亏开始挑战你的心里承受能力，直到把你的心理防线给击垮，最终不得已而止损。所以这种没有目标和计划性的交易，最终结果必定是亏损离场。 图5-7 交易中的死循环 在交易之前，我们必须要有目标以及应对方式。如果你的判断正确，账户开始产生浮盈，最好采取移动止损的方式，不断上移止损线，这样即使最终触发止损了，离场的时候也能够确保不亏钱甚至盈利。盈利的时候，相对好处理一些，交易者的心态也比较放松一些。相反，当账户发生浮亏的时候，交易者心态上往往会面临较大的压力，所以必须提前想好应对措施。 如果是做带止损的交易的话，最好是根据入场位置以及最近的支撑位或阻力位设置止损位置，当价格突破支撑位或阻力位之后，就认为这笔交易失败了，以止损的方式退出交易。交易有容错率的，是允许失败的，不能为了避免失败而死扛。 如果是做不带止损的交易的话，最好提前想好是采取跨期对冲还是跨品种对冲的方式进行持仓，如果是跨期对冲的方式吗，必须提前想好近远月多空的逻辑，不能够盲目地去进行跨期对冲，必须保证我们跨期对冲的两条交易是符合逻辑的。当然，我们也可以考虑选择跨品种对冲，跨品种对冲相对于跨期对冲来说，一方面会占用更多的保证金，除非是标准化的套利组合，另一方面风险高于跨期对冲，但有时候预期收益也是高于跨期对冲的。 当市场再次朝着我们预期的方向发展时，我们可以把跨期对冲或者跨品种对冲的那一条交易平掉，从跨期或者跨品种对冲再次变为单边头寸，从而来缓解由于行情对我们不利而导致账户资金大幅减少的尴尬局面。总而言之，当账户浮亏到一定的阈值时，我们必须按照交易计划进行跨期或跨品种对冲，当行情再次对我们有利时，我们需要平掉对冲的品种。 忠于客观，利用主观在这里，我们需要着重介绍三组核心的理念：主观与客观、赔率与胜率、现实与预期，如图5-8所示。这三组词很简单，往往被大家所忽视。但简单不等于容易，想做好以上这几点还是挺难的。 图5-8 需要注意的三组核心理念 1、主观与客观 首先，要分清楚交易中哪些是主观的，哪些是客观的。我们的基本面分析和技术分析都是主观的，从主观方面判断未来行情发展的方向，只不过主观判断的方法或者手段不同而已。 既然是主观的东西，那就存在争议，因为见仁见智。所以基本面分析者之间存在争议，基本面分析者和技术分析者之间存在争议，技术分析者之间也可能存在争议。其实，争来争去，没有任何意义，不过是概率而已。 其次，如果你的交易中没有发现客观的理由并坚持客观的理由，交易大概率会是亏钱的。 根据我的观察，很多交易者往往过分重视自己主观判断的概率，而忽视一些客观的因素。但他们不知道自己的判断是存在较大主观的，我也很主观，但是我在主观的同时，会注重客观并坚持客观优势。 那我们来思考一下，交易中什么是客观的，什么是主观的？ 2、赔率与胜率 赔率是客观的，或者说盈亏比是客观的。所以，我一直建议大家顺基差交易，顺期限结构交易，就是为了让大家占据客观优势。 顺基差交易：深贴水做多，高升水做空。 顺期限结构交易：back结构做多，contango结构做空。 我举一个简单的例子，如图5-9所示。某个品种现货4000元/吨，期货3700元/吨，现在期货贴水，最终期现要修复，但问题是修复方式有两种，一种是期货上涨修复基差，另一种是现货下跌修复基差。 图5-9 顺基差交易所带来的客观赔率优势 其实，我们无论是利用基本面分析还是利用技术分析，都是为了判断基差修复的方向，都是主观判断。现在，我们不去判断修复方向，我们假设期货上涨修复和现货下跌修复的概率是一样的，都是50%。 顺基差交易，在深贴水的情况下，我们应该做多期货，如果做对了，最终期货上涨来修复，假设最终收在了4100元/吨，我们赚400元/吨；如果做错了，最终现货下跌来修复，假设收在了3600元/吨，我们亏了100元/吨。你会发现，顺基差交易的赔率是4:1，但如果你逆基差交易去做的话，赔率是1:4。 赔率4:1，胜率50%，长此以往交易下来，你会赚很多钱。事实上，我总结过自己的交易，发现37%的胜率，3:1以上的赔率，盈利非常不错的。但是大多数人都忽视客观的赔率，执念主观的胜率。 很多人往往忽视基差或者期限结构给我们提供的客观赔率，而是发挥自己的聪明才智，通过基本面分析也好，技术分析也好，去证明自己比别人聪明，判断未来的方向，就是为了提高胜率。 当然，我自己也这样做过，当我通过顺基差交易找到了客观上的赔率优势之后，我继续思考，如何才能提高主观上的胜率优势。所以才有了库存和利润两个判断胜率的指标。 期货贴水，从赔率上讲适合做多，如果从胜率上讲，它确实应该做多就更好了。所以除了基差之外，我想找指标来帮助我提高胜率。如果想要期货上涨来修复基差，那么现货至少要坚挺，现货想要坚挺，那么现货市场上供求关系要偏紧，供求偏紧的结果就是库存偏紧，所以低库存的情况下，我主观判断期货上涨修复基差的概率较大，这是主观胜率。 因此，这才有了最初的基差+库存的交易逻辑： 深贴水（高赔率）+低库存（高胜率）→做多 高升水（高赔率）+高库存（高胜率）→做空 永远需要记住的一点就是，赔率是客观的，胜率是我们主观判断的，无论你用什么方法，在我看来，胜率都是主观的，所谓的合理的逻辑推演也是主观的。主观的东西，都是概率，既然是概率，就存在尾部风险。 表面上看，基于库存+基差的逻辑去交易已经非常好了，高赔率+高胜率，但实际上在交易过程中，我发现我认为的高胜率，有时候并不高，后来我发现，关于胜率的判断，用库存一个指标是不够的，后来又加入了利润这个指标。 当库存和利润两个指标共振的时候，我们去做单边；当库存和利润矛盾的时候，我们去做对冲，如图5-10所示。 深贴水（高赔率）+低库存+低利润（高胜率）→做多 高升水（高赔率）+高库存+高利润（高胜率）→做空 图5-10 库存+基差+利润的交易策略 所以，你会发现，交易的核心都是围绕着赔率和胜率展开的，寻找相关的指标，同时区分哪些是主观的，哪些是客观的，坚持客观的东西，然后再去看主观的东西。 其实，我经常提到的两个交易思路都是遵循客观为主、主观为辅的思想： 1）库存+基差+利润； 2）期限结构+库存/仓单验证。 3、现实与预期 在我看来，当下现实是客观的，未来预期是主观的。客观的东西永远比主观的东西可靠。所以，我一直认为，追求主观胜率的交易者不如追求客观赔率的交易者，当然炒单和高频交易者可能并不同意我的观点；做主观预期的交易者不如做客观现实的交易者。 我关注永安这个席位很久了，我发现它的交易模式是：第一，顺基差交易或者顺期限结构交易；第二，注重当下客观；第三，注重持仓平衡。 back结构下的品种，常规思路是做多具有赔率优势，但是很多人放弃赔率优势，选择去做空，因为按照他们的逻辑推演，未来价格是要下跌的。但问题是你这个主观判断的胜率长期均值是多少呢？假设你判断胜率是80%，按照上面的例子，逆基差交易，给你1:4的赔率，我可以肯定的告诉你，按这个赔率和盈亏比，你照样会亏钱。 为什么会这样？因为期限结构近月的一端反映的是现实，远月的一端反映的是预期。客观的期限结构和基差给了你实实在在的赔率优势，你放弃了，你选择相信自己的判断，逆期限结构和基差去做预期，做你主观的判断。 但问题是，期货贴水的幅度是否已经把你的主观预期price in了？或者price in多少？我相信很多人难以去量化出来。或许你的主观判断没错，但问题是盘面的贴水已经把你的逻辑price in了，而你却不知道。（price in是指价格已经把潜在的消息提前反映出来了） 所以，我的建议是，你可以有主观预期，无论是需求端悲观的预期，还是供应端产能投放的预期，在back结构下如果你要做空，需要注意两点： 第一，基差修复或者back结构走平，这个时候你做空的赔率在上升，做多的赔率在下降，如果你主观上认为自己判断的胜率较高，你可以去做空。也就是我常说的，黑色系价格高位，期现接近平水，大胆做空。 第二，你预期未来会下跌，但有句话说，不见兔子不撒鹰，在back结构下，你只有实实在在看到现货崩盘了，你再去做空，而不是主观判断未来要跌，期货贴水很大，现货没动，你就杀进去了。 此外，如果你自认为判断胜率非常高，达到了95%甚至99%，在期货深贴水的情况下，你可以去做空。但是用塔勒布的观点来看，做胜率的交易具有脆弱性，做赔率的交易具有反脆弱性。 另外，如果说永安席位背后代表的是smart money，你会发现，他们的交易是多么务实，多么注重当下或者说眼前的供需平衡表，未来的预期过于主观，谁能说得准呢，这里面存在太多的变数。 对于smart money来说，做得就是当下的供需平衡表，至于基于预期推理出来的未来供需平衡表，傻瓜才去做呢，因为在未来预期被逐步验证的过程中，smart money有足够的时间去调整头寸，再次变为依据当下客观的现实去配置头寸。 大多数散户交易者，分不清楚期货市场中哪些消息是真实的，哪些消息是假的，容易被各种所谓的预期给忽悠。务实一些，关注当下，把握你能把握住的东西，然后利用你无法把握或者主观的东西。 最后，再次强调一下客观和主观的区分： 赔率（客观）vs 胜率（主观） 现实（客观）vs 预期（主观） 顺基差（客观）vs 逆基差（主观） 顺期限结构（客观）vs 逆期限结构（主观） 另外，我并不是说总是按照客观来做，不去做主观，因为主观的东西随着时间可能变成客观，但是做主观的时候要不见兔子不撒鹰，逆基差交易时，你要看到现货崩盘才去做；逆期限结构交易时，你要看到期限结构斜率发生变化时才去做；在做主观交易时，尽量在赔率上升的时候做，不要在赔率太低的时候做。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章 产业链分析主要看什么]]></title>
    <url>%2F2020%2F12%2F18%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E4%BA%A7%E4%B8%9A%E9%93%BE%E5%88%86%E6%9E%90%E4%B8%BB%E8%A6%81%E7%9C%8B%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 库存消费怎么计算？ 供需平衡分析是基础我们都知道供求决定价格，价格影响供求。所以想要了解未来价格变化的方向，首先要搞懂商品的供求情况，而供需平衡表则是分析供需平衡必不可少的一个工具。供需平衡表主要有三大部分：总供应量、总需求量、期末库存，从计算角度来讲，总供应量-总需求量=期末库存，期末库存越高，说明供求过剩越严重，期末库存越小，说明供不应求越严重。 总供应量又可以细分为期初库存、当年产量、进口量几个部分，用公式可以表示为：期初库存+当年产量+进口量=总供应量，其中期初库存就等于上一年末或者月末的期末库存，取决于我们做的是年度供需平衡表还是月度供需平衡表。总需求量又可以细分为消费量和出口量两部分，用公式表示为：消费量+出口量=总需求量。年度供需平衡表如图4-1所示。 表4-1 年度供需平衡表的简单示意图 我们一般用期末库存的高低来反映供求平衡的状态，但单纯看一个期末库存的高低有时候可能会引起误导，例如，当我们发现某个商品的期末库存较高时，并不一定说明供求过剩很严重，也有可能是这个商品每年的消耗量巨大，期末库存相对于年度需求量来说非常小。 所以为了能够更好地评价商品的供需情况，我们往往采用库存消费比来衡量供求之间的关系，库存消费比越高，说明供求过剩越严重，库存消费比越低，说明供不应求的情况越严重。库存消费比的计算方式是，期末库存除以上一年度或者月度的总需求量。 在构造商品的供需平衡表时，一般会同时构建两个供需平衡表，一个是年度的供需平衡表，来判断一下某个商品全年的供需平衡情况，是供求宽松，还是供求偏紧；另一个是月度的供需平衡表，主要用于判断商品供需平衡的节奏变化。如图4-1所示。 图4-1 年度供需平衡表与月度供需平衡表的作用 月度供需平衡表的主要作用是从月度总产能、检修计划、开工率等角度来计算一个合理的当月产量，再结合历史上的当月进口情况，预估一下本月的进口情况，再将上月的月末库存作为本月的期初库存，从而得到本月的总供应量。与此同时还要统计下游本月的消费量，主要根据下游的月度总产能、检修计划、开工率来计算一个合理的当月消费量，再根据历史上当月的出口情况，预估一个本月的出口情况，从而得到本月的总需求量。 有了总供给量和总需求量，我们就可以计算出月末的库存，以及当月的库存消费比，从而构建一个月度的供需平衡表。有了月度供需平衡表，我们就可以掌握商品更短周期的价格波动。但问题是，由于我们这里用到了预估，所以这就需要分情况讨论，乐观情况、中性情况、悲观情况，作出三种不同情况下的供需平衡表，然后事后对供需平衡表进行进一步的修正。如图4-2所示。 图4-2 供需平衡表的情景分析 所以，我们所做的月度供需平衡表并非是完全准确的，它只是给我们的交易作为一个简单的参考，我们还需要根据事后真实的数据对供需平衡表中的数据进行修正，在修正后的数据基础之上，再对未来的供需平衡进行新的预估。 供需平衡表看似简单，但是真正做起来并不容易，对于散户交易者来说，几乎是不可能完成供需平衡表的，一般情况下只有机构交易者或者分析师才有足够的数据以及科学的方法来构造商品的供需平衡表。对于大多数散户来说，在无法构造供需平衡表的情况下，利用库存这个指标作为一个简单的判断也是可以的，这是一种退而求其次的判断方法。 如果交易者对如何建立商品的供需平衡表比较感兴趣，那么可以参考我写的一个简单介绍： 首先，商品的供需平衡表思路很简单，但实际上操作比较复杂，最终呈现的结果很简单，但你要把这个表中的数据完全填充好了，需要做大量的工作，所以操作上并不简单，而是相当复杂。 其次，从供需平衡表的项目来说，总供给包括期产量、进口量，总需求包括消费量、出口量，总供给减去总需求，就是当期的供需缺口。然后我们在看库存，分为两种库存，一种是上一年度或者月度的结转库存，叫做期初库存，期初库存加上当期的供需缺口，得到的就是期末库存，本期的期末库存又是下一期的期初库存。然后，我们一般都会计算一下库存消费比，用一个指标来看一下供求过剩或紧缺的程度。 接下来，我们需要对供需平衡表里的每一项进行数据的搜集、整理和处理。期初库存是比较容易获得的，一般都有第三方数据库给你统计好了，可以直接录入。 然后，你需要去预估逐月的产量，分工业品和农产品，工业品每个月的产量等于当月产能乘以当月开工率，它的产量可能比较连续，但问题是，你要统计全口径的装置，还有统计各个装置的运行情况，以及检修情况，每检修一天都会造成产量的减少，还有预期产能投放，可能到了某个月之后，整个行业的产能会发生变化。产量预测表如表4-2所示。 表4-2 产量预测表 从计算角度来说，你要知道每个月的总产能，开工率情况，从而计算出总的产量，然后看一下当月装置检修情况以及检修天数，从而计算损失的产量，总产量减去损失产量得到当月的预期产量。这里面还有个问题是你对开工率的预测，利润的不同，库存的不同，都会影响开工率，你想预测准确还是很难的。 上面是工业品的计算方法，对于农产品来说，通过种植面积、单产来预测产量，种植面积需要不断调整，比如USDA报告就经常对美豆种植面积进行调整。单产的影响因素就更多了，温度、水分、种植进度、灾害等，仅仅产量一个因素就能让你折腾半天。 接下来是进口量，进口量比较简单，直接查海关数据就可以了，基本比较稳定，当然你也可以跟踪买船的情况，来预测进口量，然后用海关数据进行修正，出口量也是如此。它的变化基本上都相对稳定。我们预测了产量、进口量，那么总供给就得到了。 然后我们再看消费量。有的品种下游消费十分分散，如果挨个统计费时费力，下游比较集中的品种可能还好统计一些。你还要搞清楚不同下游产品和这个上游原料之间的生产配比关系，需求端比供应端更难处理。有一个简单的方法，可以找几个下游典型的产品，然后根据他们对原料的需求占比来预估整个需求量。 举个简单的例子，下游有A、B两个主要产品，A占了这个原料需求的70%，B占了这个原料需求的20%，生产1单位A需要3单位原料，生产1单位B需要2单位原料，我们知道了A的产量为m，B的产量为n，那么生产A消耗原料就是3m，生产B消耗原料就是2n，那么3m+2n占了整个原料需求的90%，我们可以倒推出当月原料的需求量。 那么问题来了，想要知道当月A、B的产量，就又回到了产量预测上来，产能、开工率、预期产能投放、装置检修计划等等，又是一个浩大的工程。当我们得到了需求量和出口量之后，总需求总算是搞定啦。 这样一来，整个供需平衡表的数据基本上都能够填满了，最后一个库存消费比，就是用当期总需求除以期末库存。库存消费比越低说明供求越紧张，库存消费比越高，说明供求越宽松。库存消费比变化与行情涨跌的关系如图4-3所示。 图4-3 库存消费比变化与行情涨跌的关系 需要注意的是，我们得到的这个供需平衡表并不准确，我们要在每个月在实际数据出来之后，对我们预估的供需平衡表进行修正。在修正之后的基础之上，重新对供需平衡表进行预估。 另外，关于开工率的问题，可能受到库存、利润的影响而发生变化，在进行分析的时候，我们一般采用情景分析法，分为三种情况，乐观情况下的开工率、中性情况下的开工率、悲观情况下的开工率，不同开工率下对应不同的产量，从而得到三个不同的供需平衡表。 当然，这里面还有其他一些细节问题，我不多说了。做供需平衡表，不是一个简单的事情，比较繁琐，需要有足够的数据，耐心，你还得有一定的方法，而且它未必有效。相比较而言，我个人认为库存+基差+利润的交易逻辑才是真正简单有效的。 库存与利润在产业链中的分布利润是任何一个行业的生命线，某个环节处于高利润阶段往往会导致该环节加大供应，短期在高利润的驱使下会导致开工率的上升，长期在高利润的驱使下可能导致产能投放，随着短期开工率的提高以及长期产能的投放，供应端的压力会越来越大，从利润传导到开工率和预期产能投放，从而改变产量，供应端开始发生边际变化，这是第一个效应。 另外，由于该环节处于高利润状态，高利润往往对应着产品的高价格，而高价格会抑制需求，随着利润的上涨，商品价格不断走高，对需求的抑制作用就会越来越强，从而导致需求开始变差，需求端开始发生边际变化，这是第二个效应。 当整个产业链某个环节发生利润变化时，会驱动供需两端发生变化，从而使产业链的结构发生相应的转变，产业结构发生转变之后，价格就会寻求新的均衡。因此，对整个行业进行分析，我认为最重要的就是去分析产业利润在产业链上下游的传导，以及在此过程中开工率、预期产能投放的变化。相关传导过程如图4-4所示。 图4-4 产业利润是行业分析的一个核心 可见，利润是任何一个行业的生命线，行业研究以利润传导为核心，根据利润在产业链中的传导跟踪产能与开工率的变化，进而推算产业结构供需平衡的变化，同时将各环节的库存作为监控指标。 除了利润之外，还有一个指标我们需要格外关注的是库存。我们都知道，供求决定价格，但供求相互作用的结果体现在库存数据上。正常情况下，高利润会驱动企业加大生产，短期提高开工率，长期增加产能投放，从而增加产量，与此同时，需求端在上游高利润的影响下受到影响，需求不断下降，所以理论上库存会不断累积。 当上游企业在高利润的驱使下，把手中的资金转化为更加值钱的库存时，由于库存又无法快速出售回笼资金，慢慢就会遭遇现金流的压力，就会迫使企业不得不去库存，降低价格，薄利多销，把手中的库存快速转化为资金。所以哪个环节库存较高，哪个环节就会面临较大的现金流压力，就会面临主动去库的问题，把库存转化为资金。如图4-5所示。 图4-5 库存价值与企业行为之间的关系 如果上游企业存在高库存的压力，那么上游可能会主动降价，高利润会逐步收窄，价格逐步下降；如果下游企业成品存在高库存的压力，那么下游企业对上游原材料的需求就会降低，久而久之，上游被迫也会慢慢降低原料的价格。相反，如果下游企业成品库存较低，那么未来就会存在补库预期，这个时候上游企业基本上不太可能选择降价，一般情况下会提价。 所以，对于整个产业进行分析时，首先要观察产业利润在整个产业链之间的传导，当下利润主要位于产业链的哪个环节；其次，高利润会驱使开工率和预期产能投放发生相应的变化，我们需要去跟踪开工率以及预期产能投放进度情况。 最后，供需相互作用的结果体现在库存上，我们最终还需要监控产业链各个环节的库存情况。从而把握整个产业链当下的格局以及主要矛盾在哪里，所以利润和库存是两个终极指标，开工率以及产能变化是需要跟踪的中间指标。 另外，关于库存，需要注意的是产业链不同环节库存的变化，例如，当下游需求较差的时候，社会库存不断下降，而厂库库存却在不断累积，由于社会库存下降超过厂库的增加，因此总库存也是下降的。 在这种情况下，我们不能够因为看到总库存下降，就盲目认为需求不错，而是需要结合产业链上下游的库存变化去判断需求情况以及上下游的心态。在这种情况下，往往说明市场需求并不好，或者预期市场需求较差，所以贸易商采取主动去库的策略，社会库存不断下降。 与此同时，由于生产有利润，所以上游生产商依然在不断生产，可以选择在期货盘面卖出套保，锁定利润，因此生产商产量不断增加，下游去库采购延缓，所以厂库库存不断增加，在这种情况下，价格往往容易承压下跌，如图4-6所示。 图4-6 根据产业链上下游库存变化的不同来判断需求 因此，我们无论是研究库存还是研究利润，不能只看单一环节的情况，而是需要结合产业链上下游一起进行判断，因为产业链各个环节并不是孤立的，而是会相互传导的，我们需要找到产业的问题在哪个环节，未来这个环节的出路在哪里，这是产业链分析的重中之重。 上中下游侧重点是什么对于任何一个品种，我们不能孤立地只看产业链的本环节，也需要关注产业链的上下游环节，从而把握产业的整体情况。上游主要是负责生产和供应，下游主要是负责消费和需求，中游起到了承上启下的作用。 正常情况下，对于产业链的任何一个环节，我们都需要了解其库存、基差、利润、产能、开工率等情况，这是最基本面要素。如图4-7所示。 图4-7 基本面分析需要跟踪的基本指标 假设我们交易的期货品种是处于中游，上游有生产商，下游有需求商，这个时候对于产业链本环节，我们需要关注库存、基差、利润、产能、开工率这几个重要指标。 对于上游的生产商，我们需要注意产业的集中度的情况。集中度不同，产业定价的逻辑也不相同，完全竞争定价、寡头定价以及垄断定价都是不同的，所以对于上游生产商，我们需要了解其集中度情况，然后判断上游是完全竞争市场、寡头市场还是垄断市场。 对于完全竞争市场，高利润是不合理的，往往也是不可持续的；对于寡头市场，高利润也是相对不合理的，因为寡头具有不稳定性的特征，所以高利润的持续时间可能会长一些，但最终还是会回归正常利润；对于垄断市场来说，高利润就是合理的，而且持续时间非常长。 另外，上游主要是生产商，除了关注集中度情况之外，我们还需要关注产能、开工率和库存情况，如图4-8所示，这三个指标是相对重要的，产能和开工率决定新增产量，而库存是历史存量，综合起来就是上游的总供应。 图4-8 上游企业需要关注的重点 对于下游的需求商来说，我们需要关注企业的现金流情况，因为下游主要提供需求，现金流情况的好坏往往影响下游需求，从而减少下游对本环节商品的采购数量。此外，除了需要关注下游的现金流情况之外，还需要关注下游的库存情况，如果下游库存较低，就存在补库需求，增加对本环节产品的采购；反之，如果下游库存较高，就会抑制对本环节产品的需求。对下游企业需要关注的重点如图4-9所示。 图4-9 下游企业需要关注的重点 如果想要研究得更加深入的话，可以细分到上下游的各个典型企业，例如下游企业的情况，除了上面提到的现金流情况、库存情况，还可以包括融资能力、相关发展计划等。 因此，总结一下整个产业链上、中、下游需要关注的重点，常规关注的几个点：库存、基差、利润、产能、开工率。上游需要着重关注的点：集中度、产能、开工率、库存，下游需要着重关注的点：现金流、库存、产能、开工率。 工业品与农产品的分析重点工业品和农产品相比存在较大的不同，工业品的金融属性更强一些，所以受到宏观经济以及货币政策的影响较大，与此同时，工业品的供应周期相对较短并且能够连续供应，而需求端则受经济环境影响较大，所以工业品主要关注宏观经济、货币政策以及下游需求。如图4-10所示。 图4-10 工业品需要关注的重点 与之相反，农产品的金融属性相对较弱一些，对宏观经济以及货币政策并不是很敏感，相反对国家的一些产业政策更加敏感，例如收抛储政策、关税政策等。此外，农产品的需求弹性较小，需求端相对比较稳定，而供应端往往容易受到天气以及自然灾害的影响，从而产生供需缺口，所以农产品主要关注产业、关税政策以及供应端的情况。如图4-11所示。 图4-11 农产品需要关注的重点 因此，在期货领域当中，经常有一些交易者提到“工业品看需求，农产品看供给”这样的交易理念，这其中也是有一定道理的。 另外，需要注意的是，我们在进行基本面分析时，最常使用的一个分析工具就是供需平衡表，供需平衡表当中我们比较关注的一个指标就是库存消费比，因为这个指标最能够反应一个商品的供给和需求的相互作用情况，根据库存消费比可以判断出供给和需求之间的关系。 但是对于一些不太擅长去做供需平衡表的交易者，我们建议退而求其次，选择使用库存来代替库存消费比，严格来说这是不准确的，因为从公式来看，库存消费比=库存/当期消费，直接使用库存来替代库存消费比显然并不准确。 如果某个品种消费相对稳定，那么我们就可以简单地利用库存来替代消费比，因为在消费稳定的情况下，库存消费比的变化和库存的变化是一致的。所以，对于需求弹性较小或者需求相对稳定的品种来说，我们是可以退而求其次，直接利用库存来代替库存消费比去判断供需情况的。 根据工业品和农产品的属性，工业品需求弹性较大，供应相对稳定；而农产品供给弹性较大，需求相对稳定。所以，大部分工业品单纯看库存的变化不如参考库存消费比准确，因为过去100万吨的库存和现在100万吨的库存没办法比较，可能过去年消费200万吨，而现在年消费400万吨，需求弹性太大，因此，工业品单纯看库存来判断供需容易发生判断失误。 相反，农产品需求端基本上稳定一些，每年就消费那么多植物油，这个时候我们可以近似地利用库存来代替库存消费比去判断商品的供需关系。所以农产品比工业品更适合利用库存进行判断。 另外，需要注意一点的是，农产品内部结构当中也存在不同，有的农产品需求增速较小，而有的农产品需求增速较大，所以同样是农产品，有的农产品只看库存准确性高一些，而有的农产品只看库存准确性低一些。 以油粕为例，过去几年豆油的需求增速比较稳定，基本上每年在2-3%，而随着人们收入不断提升，居民对动物蛋白的需求不断增加，蛋白需求每年以5-6%的增速增长。相比之下，油脂的需求比豆粕的需求更加稳定一些，所以单纯看库存指标来判断各自供需的话，油脂比豆粕准确一些。 最后，对于工业品来说，一些细小的指标也需要关注，例如预期产能投放、开工率、检修计划、进口利润等；对于农产品来说，也有一些数据需要跟踪，例如种植意向、种植面积、天气、灾害、收割进度、USDA报告、MPOB报告等等。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章 如何理解商品的周期]]></title>
    <url>%2F2020%2F12%2F17%2F%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3%E5%95%86%E5%93%81%E7%9A%84%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 工业品的库存周期有很多交易者都自诩为趋势交易者，可是每当我问他们什么是趋势时，他们要么张口结舌，要么就是在走势图中画趋势线给我看。可是当我追问他们：趋势已经走出来了，每个人都能够看到，可趋势什么时候开始，是否会继续延续呢？基本上没有人能够回答出来。为什么会这样呢？因为大多数交易者本身对趋势的理解并不深刻。 作为交易者，我们交易的标的是商品期货，而商品本身存在库存周期。这个周期简单来说分为两个阶段：库存重建过程中的价格上涨阶段和去库存过程中的价格下跌阶段，如图3-1所示。这才是趋势的本质，而K线图中从大周期来看必定是按照这个趋势去发展，体现的是趋势的表象。 图3-1 商品的趋势本质是库存周期 简单来说，我们通过库存周期来判断趋势，通过K线图来验证趋势。大多数交易者都把过多的精力放在交易图表上，他们所理解的趋势只是趋势的表象，试图通过在K线图中画趋势线的方法来判断趋势的形成与结束，其实他们并没有抓住趋势的本质。 为什么会出现库存重建过程中的上涨与去库存过程中的下跌呢？这是因为，当市场价格开始下跌时，资金是矛盾的主要方面，经销商将商品资源转化为资金，而终端用户则延缓资金采购商品资源的进程，所以库存下降的同时，价格随之快速下跌。 相反，当市场价格上涨时，商品资源是市场的主要矛盾，经销商急于将资金转化为商品资源，而终端用户则将资金用来采购货源，从而形成库存量上升的同时，价格快速上涨。之所以说这才是商品期货趋势的精髓，是因为这种趋势的持续性较长，欺骗性较低，而K线图中所体现的趋势相对较短，波动较大，欺骗性较高，不容易把握。如图3-2所示。 图3-2 补库周期和去库周期的核心矛盾与价格变化 实际上完整的库存周期分为四个阶段：被动去库存过程中的价格上涨阶段、主动建库存过程中的价格上涨阶段、被动建库存过程中的价格下跌阶段、主动去库存过程中的价格下跌阶段。其中被动去库阶段和主动建库阶段被称之为补库周期或建库周期，而被动建库和主动去库被称为去库周期。 工业品的库存周期又被称之为基钦周期，这个周期有两大趋势，一是补库上涨趋势和去库下跌趋势，每个趋势又分为两个阶段，补库上涨趋势分为被动去库上涨和主动建库上涨阶段，去库下跌趋势分为被动建库下跌和主动去库下跌阶段。在每个阶段过程中，整个产业链从下游到上游不断传导，库存、利润、产能、开工率不断发生变化，如图3-3所示。 图3-3 整个库存周期过程中上中下游相关指标的变化 产业陷入低迷，供需都很薄弱，突然需求开始启动，采购增加，这个时候需求从终端用户需要向零售商、经销商、厂商的传导，存在一定时滞，这个时候需求的增加，带来了现货价格的上涨，而厂商没有扩大生产，经销商也没有主动补库存，这个时候库存是在消耗下降的。所以在被动去库阶段，下游需求增加，中游和上游库存下降，价格开始上涨。 当经销商和厂商发现下游需求起来的时候，会逐渐扩大生产，同时提高产品价格，经销商也会积极建库存，下游需求端预期未来价格会继续上涨，所以会加速采购，需求增加，供需两端发力，价格继续上涨，库存同时累积，这就是库存重建过程中的上涨，此时整个产业链都开始把手中的资金转化为即将升值的库存，因此需求增加，中下游库存开始上涨，价格进一步上涨。 当商品价格过高，市场上库存也很高，需求端由于前期备货充足，开始减少采购，需求下降，价格下跌，而传导时滞的存在，导致厂商还在加大生产，经销商也在备货，这个时候库存还在继续累积，这个阶段下游需求下降，上游供给增加，整个产业链库存都在累积，价格下跌，这是被动建库阶段。 当经销商和厂商发现，下游需求不足时，为了及时将手中的货源转化为资金，避免成为接盘侠，就会降价出售，此时，需求端预期后续价格会继续下降，采购延缓，需要多少采购多少，因为后面再采购成本更低，所以这个时候商品价格不断下降，库存不断下降，就是去库存过程中的下跌。 至此，我们对趋势的理解从K线图中转移到了商品的库存周期当中。K线图中的趋势表象往往会欺骗交易者，而商品的库存周期却无法掩盖商品未来的趋势，只有抓住趋势的精髓才是交易者持仓的勇气所在！ 农产品的蛛网周期工业品的库存周期是从需求端出发的，工业品主要看需求，供应端可以根据需求端的变化来进行调整；农产品虽然也有库存周期，但是需求端相对稳定，变量较大的主要是供应端，一种作物以年度的产量以及之前年度结余的库存来满足当年的需求，在分析农产品的库存变化时，最常用的就是经济学中的蛛网模型。 蛛网模型的一个基本假设就是，今年的产量取决于前一年的价格，从而得到一个供应曲线，今年的需求量取决于当年的价格，从而得到一个需求曲线。在供给和需求的作用下，得到一个均衡价格，这个价格又会影响到下一年的产量，由于供给曲线和需求曲线的弹性存在差异，从而会出现三种形式的蛛网模型，一种是发散型蛛网、一种是封闭型蛛网、一种是收敛型蛛网。如图3-4所示。 图3-4 三种形式的蛛网模型 当供给曲线的弹性大于需求曲线的弹性时，即供给曲线斜率的绝对值大于需求曲线斜率的绝对值时，在市场受到外力的冲击之后，原有的均衡状态就会被打破，从而使得均衡点发生偏离，实际价格和实际产量的波动幅度会越来越大，从而偏离均衡点越来越远。属于这种类型的农产品，一般遭遇供给冲击之后，价格往往会暴涨，价格上涨的幅度可能远大于产量减少的幅度。如图3-5所示。 图3-5 发散型蛛网模型 当供给曲线的弹性和需求曲线的弹性相等时，即供给曲线斜率的绝对值等于需求曲线斜率的绝对值时，当市场受到外力的冲击之后，原有的均衡状态就会被打破，从而使得均衡点发生偏离，实际价格和实际产量也会发生变化，但与发散型蛛网不同的是，此时实际产量和实际价格适中按照相同幅度围绕着均衡点上下波动，不会不断偏离均衡点，也不会不断靠近均衡点。如图3-6所示。 图3-6 封闭型蛛网模型 当供给曲线的弹性小于需求曲线的弹性时，即供给曲线斜率的绝对值小于需求曲线斜率的绝对值时，在市场受到外力的冲击之后，原有的均衡状态就会被打破，从而使得均衡点发生偏离，实际价格和实际产量的波动幅度会越来越小，从而向均衡点不断靠拢。如图3-7所示。 图3-7 收敛型蛛网模型 当然，也有对蛛网模型有不同意见的，比较著名的是傅海棠老师，从期货交易的角度来讲，他是比较成功的，因为他以较小的资金在期货市场中赚取了几十亿元。因为农民出身，傅海棠老师对农产品有着较为深入的研究。 他认为农民对于农产品是比较有感情的，农产品价格较低的时候，第一年一般亏不到农民这里，而是贸易商发生亏损，农产品连续第二年低价的时候，农民可能会亏钱，但是农民对农作物是有感情的，当年亏钱了并不会导致农民马上改种其他农作物，而很多农民基于对农作物的感情，会选择再种一年看看，说不定来年价格就好了，结果农产品连续第三年价格较低的时候，农民继续亏钱，这次农民可能就亏怕了，开始改种其他的农产品。 所以如果按照蛛网模型，农产品就会每年都有一波行情，要么上涨行情，要么下跌行情，但实际上农产品发生大行情的时候并没有那么频繁，一般是三到四年一波大行情。 生长特性导致的供应周期商品的周期有的是从人性出发的，通过经济模型得到一个周期的解释，例如工业品的库存周期，农产品的蛛网模型。也有一些周期是从天气变化出发的，通过资金、情绪等层面的投机炒作而得到的一个周期的解释，例如厄尔尼诺和拉尼娜现象对农产品产量的影响。还有一些周期则是基于商品自身生产规律导致的其产量或者供应量的周期性变化。 其中最为典型的就是国内的白糖，国内白糖有两种，一种是以甘蔗为原料制成的甘蔗糖，另一种是以甜菜为原料制成的甜菜糖，其中甘蔗糖占了绝大部分。而国内种植的甘蔗主要以宿根蔗为主，由于纬度和气候的原因，国内宿根蔗的生长周期一般是3年，因为随着宿根蔗年份的增加，其糖分会不断下降，所以一般到了第三年都会砍了重新种植，宿根蔗的3年生长周期，导致了国内白糖产量的3年增产和3年减产周期，价格上也是平均3年牛市和3年熊市。如图3-8所示。 图3-8白糖的6年周期规律 另外，鸡蛋价格也存在类似的周期，其根本原因在于利润驱使下的补栏与蛋鸡生长周期。在蛋鸡养殖利润较差的情况下，就会导致养殖户的养殖积极性下降，补栏开始降低，从而导致蛋鸡的存栏量下降，存栏量的下降导致鸡蛋的供应减少，在供需的作用下，鸡蛋价格开始上涨，从而使得蛋鸡养殖利润开始变好，在养殖利润较好的情况下，养殖户的养殖积极性就比较高，补栏开始增加，从而导致蛋鸡的存栏开始上升，存栏量上升的结果导致鸡蛋的供应增加，在供需的作用下，鸡蛋价格开始下跌，结果利润再次变差。如图3-9所示。 图3-9 蛋鸡养殖周期 鸡蛋价格基本上也是3年左右的一个周期，主要原因在于利润对养殖户补栏行为的影响，养殖户补栏之后，蛋鸡从出壳到产蛋大约120天，产蛋以后大约300天以后产蛋能力就开始下降，蛋鸡的完整的生命周期大约在520天左右，基本上是一年半的时间，一个主动补库周期加上一个主动去库周期大约在3年左右。与蛋价周期类似的还有猪肉价格周期，原理都是一样的。 此外，需要注意的是，这些周期是在市场经济下自然发生的交替性的周期规律，但有时候会因为国家的一些政策原因，导致周期拉长或者缩短，即政策因素可能会改善或者打破周期规律，所以要时刻关注国家对于相关行业领域的政策。 例如，白糖我们采取的配额和关税保护措施，使得国内白糖价格高于国际原糖，国内糖价定价权主要在于广西，一旦我国关税保护措施开始放松，那么国内白糖的价格就容易和国际接轨，而不一定继续遵循宿根蔗的3年生长周期规律。 天气因素导致的行情周期有些农产品的周期是由于天气导致的，天气的周期性变化与地球的转动速度变化有关，因此，每当这类机会出现时，我们需要去把握。下面以豆粕为例，来简单介绍一下天气因素导致的行情周期，同时简单介绍一下这种周期产生的原因（见图3-10）。 豆粕的4年周期宿命 图3-10 豆粕的4年周期行情 关键词：4年周期、认识周期、分析周期、应用周期。 霍华德.马克思在《周期》中提到周期的三大规律：第一规律：不走直线必走曲线；第二规律：不会相同只会相似；第三规律：少走中间多走极端。他认为，周期毫无疑问是投资中最重要的事情，所以投资者需要学会认识周期、分析周期和应用周期。 大多数交易者都知道糖价周期、猪肉价周期、蛋价周期，但是还有一些可能被我们所忽视的其他周期，例如豆粕的4年周期。从豆粕指数来看，从豆粕2000年上市以来，每个4年就会出现一个价格高点，2004年-2008年-2012年-2016年都一直遵循着这个周期，这是我们对豆粕4年周期最粗浅的认识。 接下来，我们需要去分析一下豆粕的4年周期，当然，我们可能很难把过去的每一年都进行复盘，从中找到周期的规律，所以这里只是简单的对价格高点发生的那一年的行情进行一个简单的回顾，让我们一起看一下，当年都发上了什么事情，从而导致价格的暴涨暴跌。 当然，正如霍华德.马克思所说的，在周期存续期间发⽣的这些事件，不应该只被看作⼀个事件接着⼀个事件地发⽣，⽽应该被看作⼀个事 件引发下⼀个事件，因果关系远远重于先后顺序，只有这样才能够更好地理解周期。只有更好地理解周期，才能更好地应用周期，记住我们所处周期的位置，它会深刻影响我们的获胜机会。 2004年豆粕行情回顾（见图3-11） 图3-11 2004年豆粕行情回顾 关键词：禽流感、紧缩政策、需求不足、毒大豆事件。 1）2004年1季度：强势上涨。 2004年1季度国内豆粕大涨，主要得益于禽流感得到控制，国家开始从税收和补贴角度来扶持养殖行业，豆粕的需求增加，导致一些观望的企业因为库存不足，开始大量采购豆粕，一时间豆粕需求大增，刺激了价格上涨。再加上CBOT大豆价格上涨，进口成本进一步增加，国内油厂也开始纷纷涨价，所以豆粕价格进一步大涨，一季度豆粕指数直接突破3700点。 2）2004年2季度：强势下跌。 2004年2季度国内豆粕大跌，主要在于国家紧缩政策的影响以及对禽流感的低估。尽管国家对家禽养殖进行了扶持，但禽流感度需求造成的影响开始逐步显现，需求端表现不佳，与此同时，国家为了抑制投资过热，采取了宏观调控措施，结果一些企业的资金链比较紧张，开始了大量抛售，从而导致豆粕价格暴跌，走出了一个倒V型反转。 3）2004年3季度：震荡下跌。 2004年3季度国内豆粕震荡下跌，尽管在南美毒大豆事件的影响下，预期国内大豆供应会有所减少，盘面上一度走出一波的反弹行情，但无奈在国家紧缩的宏观调控下以及禽流感的影响下，整体需求不容乐观，市场投机做多的热情也不是很强烈，价格略微反弹之后依然出现了震荡下跌。 4）2004年4季度：偏弱震荡。 2004年4季度国内豆粕偏弱震荡，由于美豆增产，所以价格上涨无力，但由于国外大豆价格下跌，豆农惜售，所以在这种情况下，国内豆粕价格上涨乏力，下跌缺乏空间，一直处于价格低位偏弱震荡状态。2004年之前天气和灾害的炒作似乎并不明显，尽管大豆锈病有可能导致南美大豆减产，但盘面上并没有发生剧烈的反应。 2008年豆粕行情回顾（见图3-12） 图3-12 2008年豆粕行情回顾 关键词：天气因素、生物柴油、奥运会、金融危机。 1）2008年1季度：区间震荡。 2008年1季度豆粕先涨后跌，整体处于区间震荡状态。此时我们国家经济整体向好，整体有一定的通胀趋势，年初的上涨部分原因是因为南方暴雪引发雪灾，整个交通不便，从而引发物价上涨，国际上对生物柴油的炒作，导致外盘大豆价格上涨，内盘豆粕也随之价格上涨。随着价格炒到将近3800点，资金的风险偏好开始上升，价格开始高位回落。国家也采取政策打压物价上涨，例如降低关税、抛出储备期货、控制贷款发放等，所以豆粕价格从高位下跌。 2）2008年2季度：强势上涨。 2008年2季度豆粕价格又迎来了一次大爆发，最直接的原因是美国大豆主产区在6月份遭受了大洪水，导致大豆重播以及收获时间推迟，进而增加了霜冻的可能性，所以市场预期将严重影响未来的单产。在此期间，USDA供需报告不断发相关利好，美国大豆大幅走高，创下了历史新高，而国内豆粕的行情再次被点燃，资金做多的热情非常强烈，期货盘面冲破了4300点。 3）2008年3季度：震荡下跌。 2008年3季度豆粕开启了下跌之路，一方面国内豆粕价格走高，技术上形成了双顶的形态，另一方面全球金融危机爆发，原油暴跌，从147美元/桶跌到35美元/桶，全球都蔓延在悲观的情绪当中，各种商品价格基本上都大幅下跌，市场开始走出来宏观行情，豆粕在天气炒作之后，也跟着全球大宗市场开始回调。 4）2008年4季度：强势下跌。 2008年4季度豆粕继续大幅下跌，主要还是受全球性金融危机的影响，整个市场弥漫着悲观的气息，市场的投机信心严重不足，做多的热情受到了打压，与此同时，国内外大豆价格连续破位下跌。覆巢之下安有完卵，豆粕连续出现一字跌停，价格加速下跌。 2012年豆粕行情回顾（见图3-13） 图3-13 2012年豆粕行情回顾 关键词：天气因素、北美大旱、宏观直下、洗船频发。 1）2012年1季度：强势上涨。 2012年1季度豆粕大涨，其根本的原因是南美大豆遭遇了干旱，市场预期南美大豆减产，外盘美豆价格也因此而不断上涨，再加上国内猪禽养殖需求旺盛，对饲料的需求比较稳定，在此背景下，需求端无忧，供应端由于南美干旱预期减产，所以现货价格不断上涨，期货盘面也是一路温和上涨，价格重心不断上移，逼近3500点大关。 2）2012年2季度：震荡回调。 2012年2季度豆粕震荡回调，一方面是由于南美进口大豆开始到港，而国内港口库存处于较高位置，供应端压力较大，另一方面全球宏观形势比较差，国际上欧债危机爆发，一些国家进行大选加剧了全球的不稳定性，国内螺纹也是一路向下。因为悲观的宏观预期，以及进口大豆到港带来的库存压力，盘面开始了从高位进行回调。 3）2012年3季度：再次大涨。 2012年3季度豆粕价格再次暴涨，根本原因在于拉尼娜导致美国遭遇了56年以来罕见的大旱，年初的南美干旱，再加上北美罕见的大旱，市场对全球大豆产量减产的预期更加强烈，外盘价格不断上涨，内盘豆粕价格也因此创下了年内新高，期货突破了4200点。较高的豆粕价格带来了丰富的榨利，导致许多油厂高价点豆，为后期豆粕的下跌埋下了隐患。 4）2012年4季度：大幅回调。 2012年4季度豆粕开始了下跌之路，在高榨利的驱使下，许多企业高价点豆，市场预期进口到港大豆增加，供应端压力不断显现，而需求端开始逐渐降温，所以资金的热情开始退却，由于之前进口大豆点价成本过高，再加上国内豆粕价格迅速下跌，从而导致许多压榨企业不堪重负，洗船现象频频发生。另外，USDA报告也对减产预期开始进行修复，所以四季度整个豆粕从高位不断回落。 2016年豆粕行情回顾（见图3-14） 图3-14 2016年豆粕行情回顾 关键词：天气因素、超限新规、到港延误、环保整顿。 1）2016年1季度：震荡下跌。 2016年1季度豆粕价格整体处于震荡下跌状态，之所以出现震荡下跌，最主要的原因是终端养殖业产能缩减，当时生猪存栏量同比大幅下跌，存栏量处于低位，饲料需求低迷，成交较低，所以现货价格不断下跌，再加上进口大豆数量的回升，从供应端进一步给豆粕价格施压，所以整个一季度，豆粕价格一路向下。 2）2016年2季度：强势上涨。 2016年2季度豆粕迎来了彻底的大爆发，最根本的原因是受到厄尔尼诺天气炒作，南美大豆预期减产，再加上USDA5月和6月报告也是利多支撑，所以美豆价格不断上涨，在此背景下，压榨企业开始涨价，豆粕价格不断上涨，现货价格一度涨到3400元/吨，有的地区都超过了3500元/吨。 3）2016年3季度：大幅回调。 2016年3季度豆粕从高位开始回调，国内南方地区迎来了暴雨，一些地区受灾严重，水产养殖以及猪禽饲料需求都受到较大影响，豆粕现货价格见顶回落，此外，USDA报告开始逐渐出现利空，外盘价格也是相对偏弱，所以在内部需求不佳以及外盘偏弱的情况下，国内豆粕开启了大幅回调下跌之路。 4）2016年4季度：再次上涨。 2016年4季度豆粕价格开启了回调之后的二次上涨。由于运营货车超载超限新规的实行，导致了物流成本上升，以及进口大豆到港延误，再加上南方广东地区环保整顿油厂，从而导致供应端再次偏紧，豆粕货源变得紧张，因此豆粕再次开启了上涨，不过此次上涨的力度远远小于二季度。 在2004年之前，天气的炒作并不明显，但我们可以发现，从2004年之后，但凡豆粕大涨的年份，都会有天气配合。2008年2季度美豆主产区遭遇了洪水，2012年1季度南美干旱导致大豆减产，3季度北美遭遇56年不遇大旱导致大豆减产，2016年2季度受厄尔尼诺影响南美大豆减产。尽管每次发生大涨行情时，各个事件会依次发生，但事件各不相相同，唯一相同的就是天气因素，所以关于豆粕的这种价格周期的背后，我们认为是天气炒作在作祟。 巧合的是，厄尔尼诺现象平均大约每4年发生1次，拉尼娜常发生于厄尔尼诺之后，但也不是每次都这样。厄尔尼诺与拉尼娜相互转变需要大约4年的时间。所以无论是平均4年发生1次的厄尔尼诺现象，还是平均4年与厄尔尼诺现象相互转变的拉尼娜现象，都与豆粕的每4年出现1次价格高点相吻合。 2008年厄尔尼诺现象，2012年拉尼娜现象，2016年厄尔尼诺现象。所以豆粕4年的价格周期都伴随着天气因素，而这种天气炒作不是厄尔尼诺现象就是拉尼娜现象，而厄尔尼诺现象或拉尼娜现象，是不以人的意志为转移的，它与地球自转有关，会相对周期性的发生。 所以，按照这种规律来看，2008年厄尔尼诺现象→2012年拉尼娜现象→2016年厄尔尼诺现象→2020年拉尼娜现象？所以2019年厄尔尼诺现象有可能转正常，在9月份结束，2020年春天开始爆发拉尼娜现象，此时正值南美大豆生长时期，高温干旱天气可能会导致南美大豆减产。2020年有可能上半年异常燥热，而冬季异常寒冷。 既然厄尔尼诺和拉尼娜现象对农产品的影响这么大，那怎么才能判断是否发生厄尔尼诺或者拉尼娜现象呢？其实，这个很简单，虽然我们并不是气象学家，但对于气象学界的常用工具，我们会用就可以了。 为了监测热带太平洋地区海面水温的变化，气象学界构造了各种指数，通过这些指数的变化来预测发生厄尔尼诺和拉尼娜现象的概率，其中最为著名的就是NINO SST INDEX（尼诺SST指数）。 它把赤道附近的热带太平洋地区根据相应的经纬度（S代表南纬，N代表北纬，E代表东经，W代表西经）进行划分，一共分成了4个区域 l Nino 1+2（0-10S，90W-80W） l Nino 3（5N-5S，150W-90W） l Nino 4（5N-5S，160E-150W） l Nino 3.4（5N-5S，170W-120W） 各个划分的区域如图3-15所示，Nino 1+2这个区域是Nino SST指数当中最小的区域，也是最靠东的区域，它与南美海岸线对应，这个指数往往被当地居民认为最先可能发生厄尔尼诺现象，但问题是这个指数是所有Nino SST指数当中方差最大的一个。 图3-15 Nino SST指数 Nino 3这个区域过去曾是监测和预测厄尔尼诺现象的重要区域，但是后来研究人员发现海洋大气相互作用的关键区域位于西部，所以Nino 3.4在定义厄尔尼诺和拉尼娜现象时备受青睐。 Nino 3.4 这个区域发生异常时需要格外注意，它通常使用5个月的移动平均值，当Nino 3.4 SST超过0.4摄氏度持续6个月或更长时间时，就被定义为厄尔尼诺现象，反之，当Nino 3.4 SST低于-0.4摄氏度持续6个月或更长时间时，就被定义为拉尼娜现象。 Nino 4指数用于捕获赤道太平洋地区中部的SST异常，这个区域的方差往往比其他Nino区域要小。 在上述指数当中，我们观察的比较多的是Nino 1+2，Nino 3，Nino 3.4，Nino 4这4个区域的异常情况。我们可以在Tropical Tidbits这个网站上进行观察，这个网站有各种气象分析工具。 我们可以选择Ocean Analysis来看一下SST Anomaly Time Series，默认就是Nino 3.4区域的时间序列，还可以切换到Nino 1+2，Nino 3，Nino 4等几个区域的时间序列，从而来判断厄尔尼诺与拉尼娜现象的变化和发展情况。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章 期限结构暗示了什么]]></title>
    <url>%2F2020%2F12%2F17%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E6%9C%9F%E9%99%90%E7%BB%93%E6%9E%84%E6%9A%97%E7%A4%BA%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是期限结构？ 什么是期限结构期限结构包含了两层含义，一是期货与现货的价差关系，期货价格高于现货价格，称之为期货升水于现货，或者现货贴水于期货；二是期货合约之间的价差关系，远月合约的价格高于近月合约的价格，称之为远月升水于近月，或者近月贴水于远月。由现货价格、近月价格、远月价格所构成的价差结构，我们称之为期限结构。 最常见的两种期限结构是contango结构和backwardation结构（简称back结构）。在contango结构下，现货的价格低于期货的价格，近月合约的价格低于远月合约的价格，从而形成近低远高的结构；在back结构下，现货的价格高于期货的价格，近月合约的价格高于远月合约的价格，从而形成近高远低的结构，如图2-1所示。 图2-1 contango结构（左）和back结构（右） 期限结构反应了什么一些交易者认为，contango结构下远月合约的价格越来越高，说明市场未来都是看涨的，所以就选择入场做多，这种观点是片面的。事实上，有经验的交易者会发现，在contango结构下，期货是升水于现货的，而且一般情况下这种商品都是库存过剩，同时伴随着大量的仓单生成，所以往往是适合逢高做空的品种。例如，2019年期货市场上的橡胶、油脂等产品都呈现出这种结构，这类品种也是经历了长期的熊市，价格已经跌到历史比较低的位置。 期限结构靠近现货的一端反应了当下现货市场上的供求关系，远月的一端更多的是反映了对未来的预期。contango结构从近月角度来说，价格是非常低的，说明当下现货市场供应过剩，所以现货价格低，越靠近现货价格的一端，期货合约的价格就越低。 从远月角度来说，有两种传统的解释方式，一种是持有成本理论，一种是预期理论。由于当下现货市场供应过剩，库存较大，所以远月合约的持有成本会增加，因此远月价格要高于近月价格；另外，由于供应过剩，价格较低，容易刺激需求，所以市场预期过剩的库存会不断下降，未来供求关系会发生改善，不再是供应过剩，所以远月价格更高一些。 因此，从现实和预期两个角度进行理解，我们可以把contango结构理解为悲观的现实和乐观的预期，如图2-2所示。 图2-2 contango结构：悲观的现实和乐观的预期 相反，也有一些交易者认为，back结构下远月合约的价格越来越低，说明市场对未来的预期是看跌的，所以就选择入场做空，这种观点也是片面的，事实上，这种市场结构往往是现货牛市，是利于做多的期限结构，以螺纹为例，从供给侧改革以来，一直保持着这种期限结构，在螺纹钢这波长期牛市的过程中，只要长期做多，不断移仓换月到远月，基本上都是能够赚大钱的。 我们依然利用现实和预期两个角度来理解一下back结构，由于现货市场上供不应求，买方愿意为当下购买该商品支付更高的溢价，所以现货价格高企，产业利润较高，在高利润的驱使下，生产商会加大生产，因此市场预期未来供应会增加，当下这种供不应求的情况会得到改善，所以在这种预期作用下，远月合约的价格较低。 因此，从现实和预期两个角度进行理解，我们可以把back结构理解为乐观的现实和悲观的预期，如图2-3所示。 图2-3 back结构：乐观的现实和悲观的预期 所以，在这里我们要澄清一个认知上的错误：contango结构并不是牛市结构，back结构并不是熊市结构，相反，contango结构本身反应了现货的熊市，而back结构本身反应了现货的牛市。我们交易中做多还是做空的选择主要取决于现货处于牛市还是熊市，现货的牛市还是熊市，则可以通过期限结构判断出来。 为什么说back结构反应了现货的牛市呢？当现货市场上出现了商品供不应求时，再加上贸易商囤货惜售，现货价格往往容易坚挺并上涨，下游买方为了满足即期现货需求而愿意支付更高的溢价，所以现货价格往往不断上涨，反映出现货牛市的特征。 所以在back结构下，往往会出现供不应求的情况，反映在库存上就是低库存，反映在现货价格上就是现货价格牛市，反应在基差上是期货处于贴水状态。所以这种情况下，并不适合做空，一方面现货牛市天然利于做多，另一方面期货贴水存在做多的安全边际。 根据个人的观察以及交易经验，我发现，期限结构为back的品种，往往存在以下特征：第一，期货贴水；第二，库存较低；第三，仓单较少；第四，利润偏高；如图2-4所示。对于这种期限结构的品种，往往更适合做多，大多数情况下是期货上涨向现货靠拢来修复基差。 图2-4 back结构所反映的基本面情况 为什么说contango结构反应了现货的熊市呢？当现货市场上商品供过于求时，再加上贸易商的抛货，现货价格往往容易松动并下跌，而下游买方往往买涨不买跌，不愿意为满足即期需求而支付更高的溢价，所以上游卖方只能把过剩的库存储存起来， 从而产生一定的持有成本，所以这些库存的成本更高一些。 在供需情况不发生改变的前提下，远月合约的价格理论上等于近月合约的价格加上持有成本，在盘面上会体现出远月价格越来越高的特征。所以这种情况下，并不适合做多，一方面现货熊市天然利于做空，另一方面期货升水存在做空的安全边际。 根据个人的交易经验和总结，我发现，期限结构可以更好的帮我们去理解商品的基本面情况，如图2-5所示。contango结构背后往往表明了几点：第一，期货升水；第二，库存较高；第三，仓单较多；第四，利润较低。对于这种期限结构的品种，往往更适合做空，大多数情况下都是期货下跌向现货靠拢来修复基差。 图2-5 contango结构所反映的基本面情况 此外，除了正常的供需和预期能够影响商品的期限结构之外，交易所的规则、相关政策调整以及意外事件的冲击等也会导致商品期限结构发生变化。 例如，交易所对于某个品种的交割品质进行修订，从而导致某个合约之后的商品交割范围变小了，使得期货合约从那个月份之后开始变得价格较高。 再比如，不同仓单期限往往也会对期限结构造成影响，仓单有效期长的品种往往容易呈现contango结构，而仓单有效期短的品种往往容易呈现back结构。 所以，我们在研究商品期限结构的时候，要知道为什么它会呈现出这种结构，是现货市场供需的力量，还是预期的力量，还是交割品质修改的原因，抑或受到了某种事件的冲击。 期限结构和商品价格的关系商品期货上涨有两种方式，一种是现货引领期货上涨，这种情况下商品的期限结构一般是back结构，现货较为强势，现货不断上涨，期货跟涨；另一种是期货引领现货上涨，这种情况下商品的期限结构一般是contango结构，期货比较强势，期货不断上涨，现货跟涨。 当现货市场上供需较为紧张，现货比较强势的时候，商品的期限结构是back结构，现货引领期货不断上涨，从价格低位上涨至价格高位，这个时候如果近月主力合约贴水幅度较大时，往往暗示着现货市场价格已经见顶了，市场预期以后的现货价格不太可能会比现在更高，所以期货不再跟随现货上涨，从而造成了期货盘面巨大贴水的假象。 所以在back结构下，随着期现联动上涨，价格从低位上涨至高位时，如果近月主力合约贴水幅度较大，往往是市场见顶即将反转的一个信号。随后，期货开始不再跟随现货上涨，而是先于现货开始下跌，从而带动现货一起跟着下跌。 因此，在back结构下，常规的交易思路是逢低做多；当价格（严格来说是利润）处于高位时，如果近月主力合约贴水较大，不应盲目去追高做多；当期限结构从back变为contango时，交易思路需转变为做空为主。如图2-6所示。 图2-6 back结构下常见的交易思路总结 当现货市场上供需较为宽松，现货比较弱势的时候，商品的期限结构是contango结构，现货引领期货下跌，从价格高位跌至价格低位，这个时候如果期货合约的升水幅度变小，contango结构开始变得扁平进而变成了back结构，说明现货市场上商品的供需关系发生了根本性的转折，往往是从供求过剩逐步变为供求开始偏紧，所以导致现货变强，期限结构发生转变。 所以，当价格见顶的时候，往往是back结构下价格处于较高的位置，而近月主力合约贴水幅度较大；而商品处于价格底部区间的时候，往往呈现出contango结构；当商品在价格高位由back结构变为contango结构，说明商品现货从牛市转入熊市，适合反弹逢高去做空；当商品在价格低位由contango结构变为back结构，说明商品现货从熊市转入牛市，适合下跌逢低做多。 因此，在contango结构下，常规的交易思路是逢高做空；当现货利润处于亏损时，如果期货合约升水，不宜盲目去追空；当期限结构从contango变为back时，交易思路需转变为做多为主。如图2-7所示。 图2-7 contango结构下常见的交易思路总结 利润同样具有期限结构除了可以利用现货价格与期货价格的关系得到价差的期限结构之外，我们还可以研究利润的期限结构，产业利润分为现货利润和盘面利润，现货利润是根据当下市场上的原材料和产成品的价格计算的利润，盘面利润是根据当前期货市场上的原材料和产成品的期货价格计算的利润。现货利润和盘面利润之间也存在不同形式的期限结构。 在这里，我们简单介绍几个黑色系品种的盘面利润计算方式（单位：元/吨），以便我们能够了解盘面利润是多少： 螺纹钢盘面利润=螺纹钢期货价格-1.6x铁矿期货价格-0.5x焦炭期货价格-1200 热卷盘面价格=热卷期货价格-1.6x铁矿期货价格-0.5x焦炭期货价格-1350 焦炭盘面价格=焦炭期货价格-1.3x焦煤期货价格-160 如果现货利润低于盘面利润，同时近月合约盘面利润低于远月合约盘面利润，那么这个品种产业利润的期限结构就是contango结构。相反，如果现货利润高于盘面利润，同时近月合约盘面利润高于远月合约盘面利润，那么这个品种产业利润的期限结构就是back结构。 无论是价差还是利润，一般情况下，只要呈现出contango结构，从交易的角度来说，最好还是逢高做空或者做反套；相反，只要呈现出back结构，从交易的角度来说，最好还是逢低做多或者做正套。尤其是当近月主力合约距离交割月比较近的时候，与此同时，近月主力合约升水或贴水幅度比较大，结合着相应的期限结构进行交易，成功率往往非常高。 期限结构与价格涨跌的进一步解读其实商品的期限结构不仅仅是两种情况，不是除了back结构，就是contango结构，也有U型，倒U型，甚至极端的还有V型，甚至倒V型的。对于大部分主力合约不连续的商品期货来说，主要以back和contango结构为主，对于像有色金属这类逐月换主力合约的品种，它的期限结构有时候可能会比较奇怪一些。 在进行商品基本面研究时，基本上都离不开供需平衡表的研究，以商品的月度供需平衡表为例，近月的供需平衡表往往更加贴近当下的现实，而远月的供需平衡表则往往根据产能投放与检修等情况进行预期和评估，从而得到一个完整的月度供需平衡表，再根据当月实际发生的供需情况不断进行调整。 因此，严格来说，期限结构的排列应该与市场预期的月度供需平衡表相对应，理论上，商品的期限结构应该反映市场公允的供需平衡表，更具体来说，可能反映的是当下以及未来预期每个月的库存消费比的变化情况。所以，从供需平衡表角度能够更好地理解期限结构。但对于大多数交易者来说，由于数据的匮乏，往往很难自己去做一个商品的供需平衡表。 另外，商品的期限结构往往也能来验证我们的供需平衡表是否正确。当一个商品呈现的是contango结构时，你看到一个机构做的供需平衡表结果是供需偏紧的，那你可能意识到，那家机构的供需平衡表可能搞错了。 需要注意的是，contango结构不代表商品价格就不会一路上涨，同样，back结构也有商品价格一路下跌的。contango结构下想要持续上涨，那要有足够的投机资金去接盘，否则价格一上涨，给产业客户提供了很好的套保机会，产业资金套保把价格打下来，没有持续资金介入，多头就容易溃败，但只要钱比货多，就有可能在投机资金强大的投机情绪下，contango结构不断上涨。 其实从资金博弈的角度来说，contango结构可以理解为，货比钱多，或者更严格的说，货比想买货的钱多；back结构可以理解为，货比钱少，或者更严格的说，货比想买货的钱少。投机情绪上来的时候，有可能导致想买货的钱增加，contango结构下的上涨就是如此；投机情绪下来的时候，有可能导致想买货的钱减少，back结构下的下跌就是如此。 所以并不是说，contango结构就一定不会连续上涨，back结构就一定不会连续下跌。除了产业资金，还有投机资金，投机资金有时候受消息、情绪、政策等影响，也会出现非产业现货逻辑的涨跌，即预期逻辑下的涨跌。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章 基差与升贴水]]></title>
    <url>%2F2020%2F12%2F17%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E5%9F%BA%E5%B7%AE%E4%B8%8E%E5%8D%87%E8%B4%B4%E6%B0%B4%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是基差？时间价差，品质价差和地域价差分别是什么意思？ 什么是正基差和负基差？基差走强是什么？基差走弱是什么？ 基差及其构成商品的现货价格反映了当前市场上买卖这种商品的价格，期货价格反映了未来某个时刻在现货市场上买卖这种商品的价格，由于它们之间存在了一定时间间隔，在这段时间内就会产生各种不确定性，所以期货价格往往在距离交割日较远的时候会偏离现货价格，这个偏离本质上就是预期溢价或者预期折价，而基差等于现货价格减去期货价格。 基差本质上反应了三个价差：时间价差、品质价差、地区价差，如图1-1所示。时间价差比较容易理解，就是未来距离当下这段时间内存在诸多不确定性，由于这种不确定性带来的预期溢价或折价，这就是时间价差。 图1-1 基差反映的三种价差 对于品质价差，一些交易者可能没有注意，交易所对上市的期货品种都会规定交割的标准品以及替代品，正常情况下，期货盘面应该反映的是标准品的价格，但是实际交割的商品可能是替代品，而替代品与标准品之间由于存在品质差别，所以交易所一般会设置升贴水，所以品质价差也是影响基差的一个因素。 地区价差也比较容易理解，由于基准交割仓库所在地与非基准交割仓库所在地的价格往往不同，哪个地区交割仓库交割的量更大，往往更能反应盘面的期货价格，这就是地区价差。 因此，严格来讲，我们在计算基差的时候，不能简单的使用现货价格减去期货价格，而是应该把现货价格折成盘面价格然后再减去期货价格。现货折盘面就是先要处理一下品质价差、区域价差等问题。 例如，在计算华东地区螺纹钢基差时，我们需要使用螺纹钢现货价格除以0.97，然后再减去期货价格，这是因为螺纹交割时是过磅交割，先要处理一下磅差问题；在计算华北地区螺纹钢基差时，我们需要使用螺纹钢现货价格除以0.97，然后加上90，最后减去期货价格，这是因为华北地区交割库存在贴水交割的问题。 再比如，我们在计算铁矿石的基差时就更加复杂了，首先需要把湿吨变为干吨，然后再计算品质价差，再减去期货价格。以金布巴粉为例，计算金布巴粉基差时，我们通常使用日照港现货价格除以0.93，然后加上20.5，再减去期货价格；再以PB粉为例，PB粉基差我们通常使用日照港现货价格除以0.92，然后加上9，最后减去期货价格。 诸如此类的细节问题，交易者都需要注意。在计算基差时，首先要确定参考哪个地区的现货价格，然后把现货价格折成盘面价格，最后减去期货价格，如图1-2所示。研究商品期货的基本面时，基差是最基础、最重要的一个指标。 图1-2 计算基差的三个步骤 当现货价格大于期货价格，我们称之为正基差或者现货升水；当现货价格小于期货价格，我们称之为负基差或者现货贴水。当现货价格开始强于期货价格，从而导致现货升水幅度越来越大或者贴水幅度越来越小时，我们称之为基差走强；反之，当现货价格开始弱于期货价格，从而导致现货升水幅度越来越小或贴水幅度越来越大时，我们称之为基差走弱。 基差的强弱变化对于产业客户的套保行为有着重要的影响，而期货市场本身是为现货服务的，所以我们想要了解产业客户的决策就需要理解基差的强弱变化。 什么是升贴水升贴水最初是外汇市场的常用术语，后来也被运用到基差交易当中。例如，豆粕现货市场的报价为m2001+50，其中m2001是指豆粕2001合约的期货价格，+50是指现货价格在m2001合约的价格基础之上加上50元/吨，即比m2001合约的价格高50个点，所以也称为期货贴水50个点。反之，如果豆粕现货市场的报价为m2001-50，那就说明现货价格比m2001合约的价格便宜50个点，所以期货升水50个点。 对于基差交易的品种，升贴水报价是常见的一种形式。例如，我们从国外进口转基因大豆时，不仅需要关注CBOT大豆的价格，还需要关注国外升贴水报价情况，例如南美贴水60，它是指盘面期货合约的价格贴水现货60，而现货的价格要在盘面基础上增加60，所以国外在进行升贴水报价的时候，贴水幅度越大，那么现货价格越高，如果贴水为负，说明现货价格低于盘面价格。 一般情况下，当期货价格较高时，或者盘面利润较高的时候，升贴水报价的幅度一般都是贴水比较低甚至是贴水为负，例如，当m2001的价格是2800元/吨的时候，报价可能是m2001+50，即期货贴水50。当m2001的价格是3000元/吨的时候，报价可能是m2001-80，即期货贴水80个点。 期货贴水幅度的变化往往反映了盘面利润的情况以及现货市场的成交情况，盘面利润较高，通常情况下会抑制现货市场的需求，因此现货市场成交不畅，往往期货贴水幅度收窄甚至为负；盘面利润较低，现货市场成交较好，往往期货贴水幅度开始增加。 点价与基差交易现在全球大宗商品的贸易基本上都是以基差交易为主，即m2001+50，这里的+50是期货贴水50个点，也可以理解为现货基差，但是m2001的价格每个交易日都会随着期货盘面不断发生变化，买卖双方最终合同的价格没有敲定，需要买方在合同规定的点价截止日期之前进行点价，从而来确定合同最终的成交价格。 例如，合同规定在2019年11月30日之前进行点价，买方在2019年11月20日点价，当日收盘价为2800元/吨，那么现货合同最终的成交价格就是2800+50=2850元/吨，从而把最终的销售价格确定了。基差交易下的点价模式有利于卖方规避风险。 以压榨产业为例，原料大豆是从国外进口的，需要与国外签订基差合同，接受国外的升贴水报价，到时候需要在芝加哥CBOT盘面进行点价，从而确定原料的进口成本，一旦压榨企业在芝加哥CBOT点价之后，同时提前进行远期锁汇，那么未来的进口成本就确定了。 与此同时，压榨企业在大商所盘面卖出豆粕和豆油，从而锁定这部分大豆压榨的收入，再根据期货盘面价格加上升贴水报价，形成基差合同，一旦有下游买方接受了基差合同，并在未来某一时刻进行点价，那么压榨企业就需要平掉空单，交付现货，把盘面利润进行兑现，现货毛利就等于盘面利润减去现货基差。 所以当盘面利润较高的时候，压榨企业为了早一些将利润兑现，往往把期货升贴水报的很低，以便让下游买方接受基差合同，并完成点价，只要买方一点价，压榨企业就可以平掉期货盘面的空单，把盘面利润兑现。所以，在大多数情况下，盘面利润与现货基差往往是负相关的，盘面利润较高，则现货基差较低；盘面利润较低，则现货基差往往较高，这里的现货基差就是期货贴水的幅度。 基差与交易方向在期货交易中，基差是一个非常重要的指标，最常见的交易思路是顺基差交易，即期货升水时做空，期货贴水时做多。 为什么我们在大多数时候要选择顺基差交易呢？这是因为，决定交易长期下来能否赚钱最核心的因素有两个：一是胜率，二是盈亏比。对于交易者来说，无论我们是采取基本面分析还是技术分析，更多的都是判断交易的胜率，而这种判断或多或少都存在一定的主观成分。 与胜率不同，盈亏比则相对客观。如图1-3所示，我们以螺纹钢为例，来看一下顺基差交易如何给我们的交易提供更好的盈亏比。 图1-3 顺基差交易的优势 假设，现在螺纹钢现货价格是4000元/吨，期货价格是3700元/吨，我们都知道未来期货需要进行交割，交割时基差需要修复，即期货价格等于现货价格。但基差修复的方向有两种，一种是期货上涨来修复基差，另一种是现货下跌来修复基差。我们通过基本面分析或者技术分析，更多的是主观判断基差修复的方向，从而提高交易的胜率。 这里，我们不做任何判断，我们假设期货上涨来修复基差和现货下跌来修复基差的概率是一样的，都是50%。这个时候，如果我们顺基差交易选择做多期货，如果我们做对了，最终期货和现货价格都是4100元/吨，那么我们可以赚400元/吨；如果我们做错了，最终期货和现货价格都是3600元/吨，那么我们亏损100元/吨。因此，这笔交易的盈亏比就是4:1。 相反，如果我们是逆基差选择做空期货合约的话，如果我们判断正确了，期货和现货价格最终都是3600元/吨，我们只能赚100元/吨，但如果我们错了，期货和现货价格最终都是4100元/吨，我们会亏400元/吨。这笔交易的盈亏比是1:4，即使你有80%的胜率，这么低的盈亏比长期交易下去也是必亏无疑。 同样的道理，我们假设期货现在是4000元/吨，现货是3700元/吨，如果我们顺基差交易，应该选择做空期货，假设期货下跌修复基差和现货上涨修复基差的概率相等，都是50%。如果我们做对了，期货和现货最终都是3600元/吨，我们可以赚400元/吨；如果我们做错了，期货和现货最终都是4100元/吨，我们亏损100元/吨。这笔交易的盈亏比是4:1。 相反，如果我们是逆基差交易选择做多期货合约的话，如果我们判断正确了，期货和现货最终都是4100元/吨，我们可以赚100元/吨，但我们判断错误时，期货和现货最终都是3600元/吨，我们就会亏损400元/吨，这笔交易的盈亏比是1:4。 对于理智的交易者来说，任何盈亏比小于1的交易，其实都不应该去参与的。除非你有接近100%的胜率，但期货交易本身就是概率交易，不存在100%的事情。长期交易盈亏比较低的方向，即使你有80%的胜率甚至90%的胜率，最终交易结果都可能是亏钱的。相反，交易3:1的盈亏比交易，你只需要30%以上的胜率，就可以赚很多钱。 所以，单纯从基差这个指标来看，我们可以得到一个重要的启示：顺基差交易可以给我们一个非常客观的高盈亏比，而很多交易者往往忽视客观的高盈亏比，却去追求主观判断下的高胜率。现实情况是，主观判断的胜率往往都很低。所以，交易要先注重客观上的优势，再结合主观上的优势，很多交易者往往本末倒置。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货多空逻辑</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fnext-boot%2F</url>
    <content type="text"><![CDATA[/* global NexT, CONFIG */ $(document).ready(function() { $(document).trigger('bootstrap:before'); /** * Register JS handlers by condition option. * Need to add config option in Front-End at 'layout/_partials/head.swig' file. */ CONFIG.fastclick && NexT.utils.isMobile() && window.FastClick.attach(document.body); CONFIG.lazyload && NexT.utils.lazyLoadPostsImages(); NexT.utils.registerESCKeyEvent(); CONFIG.back2top && NexT.utils.registerBackToTop(); // Mobile top menu bar. $('.site-nav-toggle button').on('click', function() { var $siteNav = $('.site-nav'); var ON_CLASS_NAME = 'site-nav-on'; var isSiteNavOn = $siteNav.hasClass(ON_CLASS_NAME); var animateAction = isSiteNavOn ? 'slideUp' : 'slideDown'; var animateCallback = isSiteNavOn ? 'removeClass' : 'addClass'; $siteNav.stop()[animateAction]('fast', function() { $siteNav[animateCallback](ON_CLASS_NAME); }); }); /** * Register JS handlers by condition option. * Need to add config option in Front-End at 'layout/_partials/head.swig' file. */ CONFIG.fancybox && NexT.utils.wrapImageWithFancyBox(); CONFIG.tabs && NexT.utils.registerTabsTag(); NexT.utils.embeddedVideoTransformer(); // Define Motion Sequence. NexT.motion.integrator .add(NexT.motion.middleWares.logo) .add(NexT.motion.middleWares.menu) .add(NexT.motion.middleWares.postList) .add(NexT.motion.middleWares.sidebar); $(document).trigger('motion:before'); // Bootstrap Motion. CONFIG.motion.enable && NexT.motion.integrator.bootstrap(); $(document).trigger('bootstrap:after'); });]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fpost-details%2F</url>
    <content type="text"><![CDATA[/* global NexT, CONFIG */ $(document).ready(function() { function initScrollSpy() { var tocSelector = '.post-toc'; var $tocElement = $(tocSelector); var activeCurrentSelector = '.active-current'; function removeCurrentActiveClass() { $(tocSelector + ' ' + activeCurrentSelector) .removeClass(activeCurrentSelector.substring(1)); } $tocElement .on('activate.bs.scrollspy', function() { var $currentActiveElement = $(tocSelector + ' .active').last(); removeCurrentActiveClass(); $currentActiveElement.addClass('active-current'); // Scrolling to center active TOC element if TOC content is taller then viewport. $tocElement.scrollTop($currentActiveElement.offset().top - $tocElement.offset().top + $tocElement.scrollTop() - ($tocElement.height() / 2)); }) .on('clear.bs.scrollspy', removeCurrentActiveClass); $('body').scrollspy({ target: tocSelector }); } initScrollSpy(); }); $(document).ready(function() { var html = $('html'); var TAB_ANIMATE_DURATION = 200; var hasVelocity = $.isFunction(html.velocity); $('.sidebar-nav li').on('click', function() { var item = $(this); var activeTabClassName = 'sidebar-nav-active'; var activePanelClassName = 'sidebar-panel-active'; if (item.hasClass(activeTabClassName)) { return; } var currentTarget = $('.' + activePanelClassName); var target = $('.' + item.data('target')); hasVelocity ? currentTarget.velocity('transition.slideUpOut', TAB_ANIMATE_DURATION, function() { target .velocity('stop') .velocity('transition.slideDownIn', TAB_ANIMATE_DURATION) .addClass(activePanelClassName); }) : currentTarget.animate({ opacity: 0 }, TAB_ANIMATE_DURATION, function() { currentTarget.hide(); target .stop() .css({'opacity': 0, 'display': 'block'}) .animate({ opacity: 1 }, TAB_ANIMATE_DURATION, function() { currentTarget.removeClass(activePanelClassName); target.addClass(activePanelClassName); }); }); item.siblings().removeClass(activeTabClassName); item.addClass(activeTabClassName); }); // TOC item animation navigate & prevent #item selector in adress bar. $('.post-toc a').on('click', function(e) { e.preventDefault(); var targetSelector = NexT.utils.escapeSelector(this.getAttribute('href')); var offset = $(targetSelector).offset().top; hasVelocity ? html.velocity('stop').velocity('scroll', { offset : offset + 'px', mobileHA: false }) : $('html, body').stop().animate({ scrollTop: offset }, 500); }); // Expand sidebar on post detail page by default, when post has a toc. var $tocContent = $('.post-toc-content'); var display = CONFIG.page.sidebar; if (typeof display !== 'boolean') { // There's no definition sidebar in the page front-matter var isSidebarCouldDisplay = CONFIG.sidebar.display === 'post' || CONFIG.sidebar.display === 'always'; var hasTOC = $tocContent.length > 0 && $tocContent.html().trim().length > 0; display = isSidebarCouldDisplay && hasTOC; } if (display) { CONFIG.motion.enable ? NexT.motion.middleWares.sidebar = function() { NexT.utils.displaySidebar(); } : NexT.utils.displaySidebar(); } });]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fscrollspy%2F</url>
    <content type="text"><![CDATA[/* ======================================================================== * Bootstrap: scrollspy.js v3.3.2 * http://getbootstrap.com/javascript/#scrollspy * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ /** * Customized by iissnan & Ivan.Nginx * * - Add a `clear.bs.scrollspy` event. * - Esacpe targets selector. * - Refactored with eslint-config-theme-next style. */ /* global NexT */ (function($) { 'use strict'; // SCROLLSPY CLASS DEFINITION // ========================== function ScrollSpy(element, options) { this.$body = $(document.body); this.$scrollElement = $(element).is(document.body) ? $(window) : $(element); this.options = $.extend({}, ScrollSpy.DEFAULTS, options); this.selector = (this.options.target || '') + ' .nav li > a'; this.offsets = []; this.targets = []; this.activeTarget = null; this.scrollHeight = 0; this.$scrollElement.on('scroll.bs.scrollspy', $.proxy(this.process, this)); this.refresh(); this.process(); } ScrollSpy.VERSION = '3.3.2'; ScrollSpy.DEFAULTS = { offset: 10 }; ScrollSpy.prototype.getScrollHeight = function() { return this.$scrollElement[0].scrollHeight || Math.max(this.$body[0].scrollHeight, document.documentElement.scrollHeight); }; ScrollSpy.prototype.refresh = function() { var that = this; var offsetMethod = 'offset'; var offsetBase = 0; this.offsets = []; this.targets = []; this.scrollHeight = this.getScrollHeight(); if (!$.isWindow(this.$scrollElement[0])) { offsetMethod = 'position'; offsetBase = this.$scrollElement.scrollTop(); } this.$body .find(this.selector) .map(function() { var $el = $(this); var href = $el.data('target') || $el.attr('href'); var $href = /^#./.test(href) && $(NexT.utils.escapeSelector(href)); // Need to escape selector. return ($href && $href.length && $href.is(':visible') && [[$href[offsetMethod]().top + offsetBase, href]]) || null; }) .sort(function(a, b) { return a[0] - b[0]; }) .each(function() { that.offsets.push(this[0]); that.targets.push(this[1]); }); }; ScrollSpy.prototype.process = function() { var scrollTop = this.$scrollElement.scrollTop() + this.options.offset; var scrollHeight = this.getScrollHeight(); var maxScroll = this.options.offset + scrollHeight - this.$scrollElement.height(); var offsets = this.offsets; var targets = this.targets; var activeTarget = this.activeTarget; var i; if (this.scrollHeight !== scrollHeight) { this.refresh(); } if (scrollTop >= maxScroll) { return activeTarget !== (i = targets[targets.length - 1]) && this.activate(i); } if (activeTarget && scrollTop < offsets[0]) { $(this.selector).trigger('clear.bs.scrollspy'); // Add a custom event. this.activeTarget = null; return this.clear(); } for (i = offsets.length; i--;) { activeTarget !== targets[i] && scrollTop >= offsets[i] && (!offsets[i + 1] || scrollTop]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fpisces%2F</url>
    <content type="text"><![CDATA[/* global NexT, CONFIG */ $(document).ready(function() { var sidebarInner = $('.sidebar-inner'); var sidebarOffset = CONFIG.sidebar.offset || 12; function getHeaderOffset() { return $('.header-inner').height() + sidebarOffset; } function getFooterOffset() { var footer = $('#footer'); var footerInner = $('.footer-inner'); var footerMargin = footer.outerHeight() - footerInner.outerHeight(); var footerOffset = footer.outerHeight() + footerMargin; return footerOffset; } function initAffix() { var headerOffset = getHeaderOffset(); var footerOffset = getFooterOffset(); var sidebarHeight = $('#sidebar').height() + NexT.utils.getSidebarb2tHeight(); var contentHeight = $('#content').height(); // Not affix if sidebar taller than content (to prevent bottom jumping). if (headerOffset + sidebarHeight < contentHeight) { sidebarInner.affix({ offset: { top : headerOffset - sidebarOffset, bottom: footerOffset } }); sidebarInner.affix('checkPosition'); } $('#sidebar').css({ 'margin-top': headerOffset, 'margin-left': 'auto' }); } function recalculateAffixPosition() { $(window).off('.affix'); sidebarInner.removeData('bs.affix').removeClass('affix affix-top affix-bottom'); initAffix(); } function resizeListener() { var mql = window.matchMedia('(min-width: 992px)'); mql.addListener(function(e) { if (e.matches) { recalculateAffixPosition(); } }); } initAffix(); resizeListener(); });]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Faffix%2F</url>
    <content type="text"><![CDATA[/* ======================================================================== * Bootstrap: affix.js v3.3.5 * http://getbootstrap.com/javascript/#affix * ======================================================================== * Copyright 2011-2015 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/master/LICENSE) * ======================================================================== */ /** * Customized by Ivan.Nginx * * - Refactored with eslint-config-theme-next style. */ (function($) { 'use strict'; // AFFIX CLASS DEFINITION // ====================== var Affix = function(element, options) { this.options = $.extend({}, Affix.DEFAULTS, options); this.$target = $(this.options.target) .on('scroll.bs.affix.data-api', $.proxy(this.checkPosition, this)) .on('click.bs.affix.data-api', $.proxy(this.checkPositionWithEventLoop, this)); this.$element = $(element); this.affixed = null; this.unpin = null; this.pinnedOffset = null; this.checkPosition(); }; Affix.VERSION = '3.3.5'; Affix.RESET = 'affix affix-top affix-bottom'; Affix.DEFAULTS = { offset: 0, target: window }; Affix.prototype.getState = function(scrollHeight, height, offsetTop, offsetBottom) { var scrollTop = this.$target.scrollTop(); var position = this.$element.offset(); var targetHeight = this.$target.height(); if (offsetTop != null && this.affixed === 'top') return scrollTop < offsetTop ? 'top' : false; if (this.affixed === 'bottom') { if (offsetTop != null) return scrollTop + this.unpin]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fmotion%2F</url>
    <content type="text"><![CDATA[/* global NexT, CONFIG */ $(document).ready(function() { NexT.motion = {}; var sidebarToggleLines = { lines: [], push : function(line) { this.lines.push(line); }, init: function() { this.lines.forEach(function(line) { line.init(); }); }, arrow: function() { this.lines.forEach(function(line) { line.arrow(); }); }, close: function() { this.lines.forEach(function(line) { line.close(); }); } }; function SidebarToggleLine(settings) { this.el = $(settings.el); this.status = $.extend({}, { init: { width : '100%', opacity: 1, left : 0, rotateZ: 0, top : 0 } }, settings.status); } SidebarToggleLine.prototype.init = function() { this.transform('init'); }; SidebarToggleLine.prototype.arrow = function() { this.transform('arrow'); }; SidebarToggleLine.prototype.close = function() { this.transform('close'); }; SidebarToggleLine.prototype.transform = function(status) { this.el.velocity('stop').velocity(this.status[status]); }; var sidebarToggleLine1st = new SidebarToggleLine({ el : '.sidebar-toggle-line-first', status: { arrow: {width: '50%', rotateZ: '-45deg', top: '2px'}, close: {width: '100%', rotateZ: '-45deg', top: '5px'} } }); var sidebarToggleLine2nd = new SidebarToggleLine({ el : '.sidebar-toggle-line-middle', status: { arrow: {width: '90%'}, close: {opacity: 0} } }); var sidebarToggleLine3rd = new SidebarToggleLine({ el : '.sidebar-toggle-line-last', status: { arrow: {width: '50%', rotateZ: '45deg', top: '-2px'}, close: {width: '100%', rotateZ: '45deg', top: '-5px'} } }); sidebarToggleLines.push(sidebarToggleLine1st); sidebarToggleLines.push(sidebarToggleLine2nd); sidebarToggleLines.push(sidebarToggleLine3rd); var SIDEBAR_WIDTH = CONFIG.sidebar.width ? CONFIG.sidebar.width : '320px'; var SIDEBAR_DISPLAY_DURATION = 200; var xPos, yPos; var sidebarToggleMotion = { toggleEl : $('.sidebar-toggle'), dimmerEl : $('#sidebar-dimmer'), sidebarEl : $('.sidebar'), isSidebarVisible: false, init : function() { this.toggleEl.on('click', this.clickHandler.bind(this)); this.dimmerEl.on('click', this.clickHandler.bind(this)); this.toggleEl.on('mouseenter', this.mouseEnterHandler.bind(this)); this.toggleEl.on('mouseleave', this.mouseLeaveHandler.bind(this)); this.sidebarEl.on('touchstart', this.touchstartHandler.bind(this)); this.sidebarEl.on('touchend', this.touchendHandler.bind(this)); this.sidebarEl.on('touchmove', function(e) { e.preventDefault(); }); $(document) .on('sidebar.isShowing', function() { NexT.utils.isDesktop() && $('body').velocity('stop').velocity( {paddingRight: SIDEBAR_WIDTH}, SIDEBAR_DISPLAY_DURATION ); }) .on('sidebar.isHiding', function() { }); }, clickHandler: function() { this.isSidebarVisible ? this.hideSidebar() : this.showSidebar(); this.isSidebarVisible = !this.isSidebarVisible; }, mouseEnterHandler: function() { if (this.isSidebarVisible) { return; } sidebarToggleLines.arrow(); }, mouseLeaveHandler: function() { if (this.isSidebarVisible) { return; } sidebarToggleLines.init(); }, touchstartHandler: function(e) { xPos = e.originalEvent.touches[0].clientX; yPos = e.originalEvent.touches[0].clientY; }, touchendHandler: function(e) { var _xPos = e.originalEvent.changedTouches[0].clientX; var _yPos = e.originalEvent.changedTouches[0].clientY; if (_xPos - xPos > 30 && Math.abs(_yPos - yPos) < 20) { this.clickHandler(); } }, showSidebar: function() { var self = this; sidebarToggleLines.close(); this.sidebarEl.velocity('stop').velocity({ width: SIDEBAR_WIDTH }, { display : 'block', duration: SIDEBAR_DISPLAY_DURATION, begin : function() { $('.sidebar .motion-element').not('.site-state').velocity( 'transition.slideRightIn', { stagger : 50, drag : true, complete: function() { self.sidebarEl.trigger('sidebar.motion.complete'); } } ); $('.site-state').velocity( 'transition.slideRightIn', { stagger : 50, drag : true, display : 'flex' } ); }, complete: function() { self.sidebarEl.addClass('sidebar-active'); self.sidebarEl.trigger('sidebar.didShow'); } }); this.sidebarEl.trigger('sidebar.isShowing'); }, hideSidebar: function() { NexT.utils.isDesktop() && $('body').velocity('stop').velocity({paddingRight: 0}); this.sidebarEl.find('.motion-element').velocity('stop').css('display', 'none'); this.sidebarEl.velocity('stop').velocity({width: 0}, {display: 'none'}); sidebarToggleLines.init(); this.sidebarEl.removeClass('sidebar-active'); this.sidebarEl.trigger('sidebar.isHiding'); // Prevent adding TOC to Overview if Overview was selected when close & open sidebar. if ($('.post-toc-wrap')) { if ($('.site-overview-wrap').css('display') === 'block') { $('.post-toc-wrap').removeClass('motion-element'); } else { $('.post-toc-wrap').addClass('motion-element'); } } } }; sidebarToggleMotion.init(); NexT.motion.integrator = { queue : [], cursor: -1, add : function(fn) { this.queue.push(fn); return this; }, next: function() { this.cursor++; var fn = this.queue[this.cursor]; $.isFunction(fn) && fn(NexT.motion.integrator); }, bootstrap: function() { this.next(); } }; NexT.motion.middleWares = { logo: function(integrator) { var sequence = []; var $brand = $('.brand'); var $image = $('.custom-logo-image'); var $title = $('.site-title'); var $subtitle = $('.site-subtitle'); var $logoLineTop = $('.logo-line-before i'); var $logoLineBottom = $('.logo-line-after i'); $brand.length > 0 && sequence.push({ e: $brand, p: {opacity: 1}, o: {duration: 200} }); /** * Check if $elements exist. * @param {jQuery|Array} $elements * @returns {boolean} */ function hasElement($elements) { $elements = Array.isArray($elements) ? $elements : [$elements]; return $elements.every(function($element) { return $element.length > 0; }); } function getMistLineSettings(element, translateX) { return { e: $(element), p: {translateX: translateX}, o: { duration : 500, sequenceQueue: false } }; } function pushImageToSequence() { sequence.push({ e: $image, p: {opacity: 1, top: 0}, o: {duration: 200} }); } NexT.utils.isMist() && hasElement([$logoLineTop, $logoLineBottom]) && sequence.push( getMistLineSettings($logoLineTop, '100%'), getMistLineSettings($logoLineBottom, '-100%') ); NexT.utils.isMuse() && hasElement($image) && pushImageToSequence(); hasElement($title) && sequence.push({ e: $title, p: {opacity: 1, top: 0}, o: {duration: 200} }); hasElement($subtitle) && sequence.push({ e: $subtitle, p: {opacity: 1, top: 0}, o: {duration: 200} }); (NexT.utils.isPisces() || NexT.utils.isGemini()) && hasElement($image) && pushImageToSequence(); if (CONFIG.motion.async) { integrator.next(); } if (sequence.length > 0) { sequence[sequence.length - 1].o.complete = function() { integrator.next(); }; /* eslint-disable */ $.Velocity.RunSequence(sequence); /* eslint-enable */ } else { integrator.next(); } }, menu: function(integrator) { if (CONFIG.motion.async) { integrator.next(); } $('.menu-item').velocity('transition.slideDownIn', { display : null, duration: 200, complete: function() { integrator.next(); } }); }, postList: function(integrator) { //var $post = $('.post'); var $postBlock = $('.post-block, .pagination, .comments'); var $postBlockTransition = CONFIG.motion.transition.post_block; var $postHeader = $('.post-header'); var $postHeaderTransition = CONFIG.motion.transition.post_header; var $postBody = $('.post-body'); var $postBodyTransition = CONFIG.motion.transition.post_body; var $collHeader = $('.collection-title, .archive-year'); var $collHeaderTransition = CONFIG.motion.transition.coll_header; var $sidebarAffix = $('.sidebar-inner'); var $sidebarAffixTransition = CONFIG.motion.transition.sidebar; var hasPost = $postBlock.length > 0; function postMotion() { var postMotionOptions = window.postMotionOptions || { stagger: 100, drag : true }; postMotionOptions.complete = function() { // After motion complete need to remove transform from sidebar to let affix work on Pisces | Gemini. if (CONFIG.motion.transition.sidebar && (NexT.utils.isPisces() || NexT.utils.isGemini())) { $sidebarAffix.css({ 'transform': 'initial' }); } integrator.next(); }; //$post.velocity('transition.slideDownIn', postMotionOptions); if (CONFIG.motion.transition.post_block) { $postBlock.velocity('transition.' + $postBlockTransition, postMotionOptions); } if (CONFIG.motion.transition.post_header) { $postHeader.velocity('transition.' + $postHeaderTransition, postMotionOptions); } if (CONFIG.motion.transition.post_body) { $postBody.velocity('transition.' + $postBodyTransition, postMotionOptions); } if (CONFIG.motion.transition.coll_header) { $collHeader.velocity('transition.' + $collHeaderTransition, postMotionOptions); } // Only for Pisces | Gemini. if (CONFIG.motion.transition.sidebar && (NexT.utils.isPisces() || NexT.utils.isGemini())) { $sidebarAffix.velocity('transition.' + $sidebarAffixTransition, postMotionOptions); } } hasPost ? postMotion() : integrator.next(); if (CONFIG.motion.async) { integrator.next(); } }, sidebar: function(integrator) { if (CONFIG.sidebar.display === 'always') { NexT.utils.displaySidebar(); } integrator.next(); } }; });]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Futils%2F</url>
    <content type="text"><![CDATA[/* global NexT, CONFIG */ NexT.utils = NexT.$u = { /** * Wrap images with fancybox support. */ wrapImageWithFancyBox: function() { $('.content img') .not(':hidden') .each(function() { var $image = $(this); var imageTitle = $image.attr('title') || $image.attr('alt'); var $imageWrapLink = $image.parent('a'); if ($imageWrapLink.length < 1) { var imageLink = $image.attr('data-original') || $image.attr('src'); $imageWrapLink = $image.wrap('').parent('a'); if ($image.is('.post-gallery img')) { $imageWrapLink.addClass('post-gallery-img'); $imageWrapLink.attr('data-fancybox', 'gallery').attr('rel', 'gallery'); } else if ($image.is('.group-picture img')) { $imageWrapLink.attr('data-fancybox', 'group').attr('rel', 'group'); } else { $imageWrapLink.attr('data-fancybox', 'default').attr('rel', 'default'); } } if (imageTitle) { $imageWrapLink.append('' + imageTitle + ''); // Make sure img title tag will show correctly in fancybox $imageWrapLink.attr('title', imageTitle).attr('data-caption', imageTitle); } }); $('.fancybox').fancybox({ loop: true, helpers: { overlay: { locked: false } } }); }, lazyLoadPostsImages: function() { $('#posts').find('img').lazyload({ //placeholder: '/images/loading.gif', effect : 'fadeIn', threshold: 0 }); }, /** * Tabs tag listener (without twitter bootstrap). */ registerTabsTag: function() { var tNav = '.tabs ul.nav-tabs '; // Binding `nav-tabs` & `tab-content` by real time permalink changing. $(function() { $(window).bind('hashchange', function() { var tHash = location.hash; if (tHash !== '' && !tHash.match(/%\S{2}/)) { $(tNav + 'li:has(a[href="' + tHash + '"])').addClass('active').siblings().removeClass('active'); $(tHash).addClass('active').siblings().removeClass('active'); } }).trigger('hashchange'); }); $(tNav + '.tab').on('click', function(href) { href.preventDefault(); // Prevent selected tab to select again. if (!$(this).hasClass('active')) { // Add & Remove active class on `nav-tabs` & `tab-content`. $(this).addClass('active').siblings().removeClass('active'); var tActive = $(this).find('a').attr('href'); $(tActive).addClass('active').siblings().removeClass('active'); // Clear location hash in browser if #permalink exists. if (location.hash !== '') { history.pushState('', document.title, window.location.pathname + window.location.search); } } }); }, registerESCKeyEvent: function() { $(document).on('keyup', function(event) { var shouldDismissSearchPopup = event.which === 27 && $('.search-popup').is(':visible'); if (shouldDismissSearchPopup) { $('.search-popup').hide(); $('.search-popup-overlay').remove(); $('body').css('overflow', ''); } }); }, registerBackToTop: function() { var THRESHOLD = 50; var $top = $('.back-to-top'); function initBackToTop() { $top.toggleClass('back-to-top-on', window.pageYOffset > THRESHOLD); var scrollTop = $(window).scrollTop(); var contentVisibilityHeight = NexT.utils.getContentVisibilityHeight(); var scrollPercent = scrollTop / contentVisibilityHeight; var scrollPercentRounded = Math.round(scrollPercent * 100); var scrollPercentMaxed = scrollPercentRounded > 100 ? 100 : scrollPercentRounded; $('#scrollpercent>span').html(scrollPercentMaxed); } // For init back to top in sidebar if page was scrolled after page refresh. $(window).on('load', function() { initBackToTop(); }); $(window).on('scroll', function() { initBackToTop(); }); $top.on('click', function() { $.isFunction($('html').velocity) ? $('body').velocity('scroll') : $('html, body').animate({ scrollTop: 0 }); }); }, /** * Transform embedded video to support responsive layout. * @see http://toddmotto.com/fluid-and-responsive-youtube-and-vimeo-videos-with-fluidvids-js/ */ embeddedVideoTransformer: function() { var $iframes = $('iframe'); // Supported Players. Extend this if you need more players. var SUPPORTED_PLAYERS = [ 'www.youtube.com', 'player.vimeo.com', 'player.youku.com', 'music.163.com', 'www.tudou.com' ]; var pattern = new RegExp(SUPPORTED_PLAYERS.join('|')); function getDimension($element) { return { width : $element.width(), height: $element.height() }; } function getAspectRadio(width, height) { return height / width * 100; } $iframes.each(function() { var iframe = this; var $iframe = $(this); var oldDimension = getDimension($iframe); var newDimension; if (this.src.search(pattern) > 0) { // Calculate the video ratio based on the iframe's w/h dimensions var videoRatio = getAspectRadio(oldDimension.width, oldDimension.height); // Replace the iframe's dimensions and position the iframe absolute // This is the trick to emulate the video ratio $iframe.width('100%').height('100%') .css({ position: 'absolute', top : '0', left : '0' }); // Wrap the iframe in a new which uses a dynamically fetched padding-top property // based on the video's w/h dimensions var wrap = document.createElement('div'); wrap.className = 'fluid-vids'; wrap.style.position = 'relative'; wrap.style.marginBottom = '20px'; wrap.style.width = '100%'; wrap.style.paddingTop = videoRatio + '%'; // Fix for appear inside tabs tag. (wrap.style.paddingTop === '') && (wrap.style.paddingTop = '50%'); // Add the iframe inside our newly created var iframeParent = iframe.parentNode; iframeParent.insertBefore(wrap, iframe); wrap.appendChild(iframe); // Additional adjustments for 163 Music if (this.src.search('music.163.com') > 0) { newDimension = getDimension($iframe); var shouldRecalculateAspect = newDimension.width > oldDimension.width || newDimension.height < oldDimension.height; // 163 Music Player has a fixed height, so we need to reset the aspect radio if (shouldRecalculateAspect) { wrap.style.paddingTop = getAspectRadio(newDimension.width, oldDimension.height) + '%'; } } } }); }, hasMobileUA: function() { var nav = window.navigator; var ua = nav.userAgent; var pa = /iPad|iPhone|Android|Opera Mini|BlackBerry|webOS|UCWEB|Blazer|PSP|IEMobile|Symbian/g; return pa.test(ua); }, isTablet: function() { return window.screen.width < 992 && window.screen.width > 767 && this.hasMobileUA(); }, isMobile: function() { return window.screen.width < 767 && this.hasMobileUA(); }, isDesktop: function() { return !this.isTablet() && !this.isMobile(); }, /** * Escape meta symbols in jQuery selectors. * * @param selector * @returns {string|void|XML|*} */ escapeSelector: function(selector) { return selector.replace(/[!"$%&'()*+,./:;?@[\\\]^`{|}~]/g, '\\$&'); }, displaySidebar: function() { if (!this.isDesktop() || this.isPisces() || this.isGemini()) { return; } $('.sidebar-toggle').trigger('click'); }, isMuse: function() { return CONFIG.scheme === 'Muse'; }, isMist: function() { return CONFIG.scheme === 'Mist'; }, isPisces: function() { return CONFIG.scheme === 'Pisces'; }, isGemini: function() { return CONFIG.scheme === 'Gemini'; }, getScrollbarWidth: function() { var $div = $('').addClass('scrollbar-measure').prependTo('body'); var div = $div[0]; var scrollbarWidth = div.offsetWidth - div.clientWidth; $div.remove(); return scrollbarWidth; }, getContentVisibilityHeight: function() { var docHeight = $('.container').height(); var winHeight = $(window).height(); var contentVisibilityHeight = docHeight > winHeight ? docHeight - winHeight : $(document).height() - winHeight; return contentVisibilityHeight; }, getSidebarb2tHeight: function() { var sidebarb2tHeight = (CONFIG.back2top && CONFIG.back2top_sidebar) ? $('.back-to-top').height() : 0; return sidebarb2tHeight; }, getSidebarSchemePadding: function() { var sidebarNavHeight = $('.sidebar-nav').css('display') === 'block' ? $('.sidebar-nav').outerHeight(true) : 0; var sidebarInner = $('.sidebar-inner'); var sidebarPadding = sidebarInner.innerWidth() - sidebarInner.width(); var sidebarOffset = CONFIG.sidebar.offset ? CONFIG.sidebar.offset : 12; var sidebarSchemePadding = this.isPisces() || this.isGemini() ? (sidebarPadding * 2) + sidebarNavHeight + sidebarOffset + this.getSidebarb2tHeight() : (sidebarPadding * 2) + (sidebarNavHeight / 2); return sidebarSchemePadding; } }; $(document).ready(function() { function wrapTable() { $('table').not('figure table').wrap(''); } /** * Init Sidebar & TOC inner dimensions on all pages and for all schemes. * Need for Sidebar/TOC inner scrolling if content taller then viewport. */ function updateSidebarHeight(height) { height = height || 'auto'; $('.site-overview, .post-toc').css('max-height', height); } function initSidebarDimension() { var updateSidebarHeightTimer; $(window).on('resize', function() { updateSidebarHeightTimer && clearTimeout(updateSidebarHeightTimer); updateSidebarHeightTimer = setTimeout(function() { var sidebarWrapperHeight = document.body.clientHeight - NexT.utils.getSidebarSchemePadding(); updateSidebarHeight(sidebarWrapperHeight); }, 0); }); // Initialize Sidebar & TOC Width. var scrollbarWidth = NexT.utils.getScrollbarWidth(); if ($('.site-overview-wrap').height() > (document.body.clientHeight - NexT.utils.getSidebarSchemePadding())) { $('.site-overview').css('width', 'calc(100% + ' + scrollbarWidth + 'px)'); } if ($('.post-toc-wrap').height() > (document.body.clientHeight - NexT.utils.getSidebarSchemePadding())) { $('.post-toc').css('width', 'calc(100% + ' + scrollbarWidth + 'px)'); } // Initialize Sidebar & TOC Height. updateSidebarHeight(document.body.clientHeight - NexT.utils.getSidebarSchemePadding()); } initSidebarDimension(); wrapTable(); });]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fvelocity.ui.min%2F</url>
    <content type="text"><![CDATA[/* VelocityJS.org UI Pack (5.0.4). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License. Portions copyright Daniel Eden, Christian Pucci. */ !function(t){"function"==typeof require&&"object"==typeof exports?module.exports=t():"function"==typeof define&&define.amd?define(["velocity"],t):t()}(function(){return function(t,a,e,r){function n(t,a){var e=[];return t&&a?($.each([t,a],function(t,a){var r=[];$.each(a,function(t,a){for(;a.toString().lengthparseFloat(e[1])):!1}if(!t.Velocity||!t.Velocity.Utilities)return void(a.console&&console.log("Velocity UI Pack: Velocity must be loaded first. Aborting."));var i=t.Velocity,$=i.Utilities,s=i.version,o={major:1,minor:1,patch:0};if(n(o,s)){var l="Velocity UI Pack: You need to update Velocity (jquery.velocity.js) to a newer version. Visit http://github.com/julianshapiro/velocity.";throw alert(l),new Error(l)}i.RegisterEffect=i.RegisterUI=function(t,a){function e(t,a,e,r){var n=0,s;$.each(t.nodeType?[t]:t,function(t,a){r&&(e+=t*r),s=a.parentNode,$.each(["height","paddingTop","paddingBottom","marginTop","marginBottom"],function(t,e){n+=parseFloat(i.CSS.getPropertyValue(a,e))})}),i.animate(s,{height:("In"===a?"+":"-")+"="+n},{queue:!1,easing:"ease-in-out",duration:e*("In"===a?.6:1)})}return i.Redirects[t]=function(n,s,o,l,c,u){function f(){s.display!==r&&"none"!==s.display||!/Out$/.test(t)||$.each(c.nodeType?[c]:c,function(t,a){i.CSS.setPropertyValue(a,"display","none")}),s.complete&&s.complete.call(c,c),u&&u.resolver(c||n)}var p=o===l-1;a.defaultDuration="function"==typeof a.defaultDuration?a.defaultDuration.call(c,c):parseFloat(a.defaultDuration);for(var d=0;d1&&($.each(a.reverse(),function(t,e){var r=a[t+1];if(r){var n=e.o||e.options,s=r.o||r.options,o=n&&n.sequenceQueue===!1?"begin":"complete",l=s&&s[o],c={};c[o]=function(){var t=r.e||r.elements,a=t.nodeType?[t]:t;l&&l.call(a,a),i(e)},r.o?r.o=$.extend({},s,c):r.options=$.extend({},s,c)}}),a.reverse()),i(a[0])}}(window.jQuery||window.Zepto||window,window,document)});]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fvelocity.min%2F</url>
    <content type="text"><![CDATA[/*! VelocityJS.org (1.2.2). (C) 2014 Julian Shapiro. MIT @license: en.wikipedia.org/wiki/MIT_License */ /*! VelocityJS.org jQuery Shim (1.0.1). (C) 2014 The jQuery Foundation. MIT @license: en.wikipedia.org/wiki/MIT_License. */ !function(e){function t(e){var t=e.length,r=$.type(e);return"function"===r||$.isWindow(e)?!1:1===e.nodeType&&t?!0:"array"===r||0===t||"number"==typeof t&&t>0&&t-1 in e}if(!e.jQuery){var $=function(e,t){return new $.fn.init(e,t)};$.isWindow=function(e){return null!=e&&e==e.window},$.type=function(e){return null==e?e+"":"object"==typeof e||"function"==typeof e?a[o.call(e)]||"object":typeof e},$.isArray=Array.isArray||function(e){return"array"===$.type(e)},$.isPlainObject=function(e){var t;if(!e||"object"!==$.type(e)||e.nodeType||$.isWindow(e))return!1;try{if(e.constructor&&!n.call(e,"constructor")&&!n.call(e.constructor.prototype,"isPrototypeOf"))return!1}catch(r){return!1}for(t in e);return void 0===t||n.call(e,t)},$.each=function(e,r,a){var n,o=0,i=e.length,s=t(e);if(a){if(s)for(;i>o&&(n=r.apply(e[o],a),n!==!1);o++);else for(o in e)if(n=r.apply(e[o],a),n===!1)break}else if(s)for(;i>o&&(n=r.call(e[o],o,e[o]),n!==!1);o++);else for(o in e)if(n=r.call(e[o],o,e[o]),n===!1)break;return e},$.data=function(e,t,a){if(void 0===a){var n=e[$.expando],o=n&&r[n];if(void 0===t)return o;if(o&&t in o)return o[t]}else if(void 0!==t){var n=e[$.expando]||(e[$.expando]=++$.uuid);return r[n]=r[n]||{},r[n][t]=a,a}},$.removeData=function(e,t){var a=e[$.expando],n=a&&r[a];n&&$.each(t,function(e,t){delete n[t]})},$.extend=function(){var e,t,r,a,n,o,i=arguments[0]||{},s=1,l=arguments.length,u=!1;for("boolean"==typeof i&&(u=i,i=arguments[s]||{},s++),"object"!=typeof i&&"function"!==$.type(i)&&(i={}),s===l&&(i=this,s--);l>s;s++)if(null!=(n=arguments[s]))for(a in n)e=i[a],r=n[a],i!==r&&(u&&r&&($.isPlainObject(r)||(t=$.isArray(r)))?(t?(t=!1,o=e&&$.isArray(e)?e:[]):o=e&&$.isPlainObject(e)?e:{},i[a]=$.extend(u,o,r)):void 0!==r&&(i[a]=r));return i},$.queue=function(e,r,a){function n(e,r){var a=r||[];return null!=e&&(t(Object(e))?!function(e,t){for(var r=+t.length,a=0,n=e.length;r>a;)e[n++]=t[a++];if(r!==r)for(;void 0!==t[a];)e[n++]=t[a++];return e.length=n,e}(a,"string"==typeof e?[e]:e):[].push.call(a,e)),a}if(e){r=(r||"fx")+"queue";var o=$.data(e,r);return a?(!o||$.isArray(a)?o=$.data(e,r,n(a)):o.push(a),o):o||[]}},$.dequeue=function(e,t){$.each(e.nodeType?[e]:e,function(e,r){t=t||"fx";var a=$.queue(r,t),n=a.shift();"inprogress"===n&&(n=a.shift()),n&&("fx"===t&&a.unshift("inprogress"),n.call(r,function(){$.dequeue(r,t)}))})},$.fn=$.prototype={init:function(e){if(e.nodeType)return this[0]=e,this;throw new Error("Not a DOM node.")},offset:function(){var t=this[0].getBoundingClientRect?this[0].getBoundingClientRect():{top:0,left:0};return{top:t.top+(e.pageYOffset||document.scrollTop||0)-(document.clientTop||0),left:t.left+(e.pageXOffset||document.scrollLeft||0)-(document.clientLeft||0)}},position:function(){function e(){for(var e=this.offsetParent||document;e&&"html"===!e.nodeType.toLowerCase&&"static"===e.style.position;)e=e.offsetParent;return e||document}var t=this[0],e=e.apply(t),r=this.offset(),a=/^(?:body|html)$/i.test(e.nodeName)?{top:0,left:0}:$(e).offset();return r.top-=parseFloat(t.style.marginTop)||0,r.left-=parseFloat(t.style.marginLeft)||0,e.style&&(a.top+=parseFloat(e.style.borderTopWidth)||0,a.left+=parseFloat(e.style.borderLeftWidth)||0),{top:r.top-a.top,left:r.left-a.left}}};var r={};$.expando="velocity"+(new Date).getTime(),$.uuid=0;for(var a={},n=a.hasOwnProperty,o=a.toString,i="Boolean Number String Function Array Date RegExp Object Error".split(" "),s=0;sn;++n){var o=u(r,e,a);if(0===o)return r;var i=l(r,e,a)-t;r-=i/o}return r}function p(){for(var t=0;b>t;++t)w[t]=l(t*x,e,a)}function f(t,r,n){var o,i,s=0;do i=r+(n-r)/2,o=l(i,e,a)-t,o>0?n=i:r=i;while(Math.abs(o)>h&&++s=y?c(t,s):0==l?s:f(t,r,r+x)}function g(){V=!0,(e!=r||a!=n)&&p()}var m=4,y=.001,h=1e-7,v=10,b=11,x=1/(b-1),S="Float32Array"in t;if(4!==arguments.length)return!1;for(var P=0;4>P;++P)if("number"!=typeof arguments[P]||isNaN(arguments[P])||!isFinite(arguments[P]))return!1;e=Math.min(e,1),a=Math.min(a,1),e=Math.max(e,0),a=Math.max(a,0);var w=S?new Float32Array(b):new Array(b),V=!1,C=function(t){return V||g(),e===r&&a===n?t:0===t?0:1===t?1:l(d(t),r,n)};C.getControlPoints=function(){return[{x:e,y:r},{x:a,y:n}]};var T="generateBezier("+[e,r,a,n]+")";return C.toString=function(){return T},C}function u(e,t){var r=e;return g.isString(e)?v.Easings[e]||(r=!1):r=g.isArray(e)&&1===e.length?s.apply(null,e):g.isArray(e)&&2===e.length?b.apply(null,e.concat([t])):g.isArray(e)&&4===e.length?l.apply(null,e):!1,r===!1&&(r=v.Easings[v.defaults.easing]?v.defaults.easing:h),r}function c(e){if(e){var t=(new Date).getTime(),r=v.State.calls.length;r>1e4&&(v.State.calls=n(v.State.calls));for(var o=0;r>o;o++)if(v.State.calls[o]){var s=v.State.calls[o],l=s[0],u=s[2],f=s[3],d=!!f,m=null;f||(f=v.State.calls[o][3]=t-16);for(var y=Math.min((t-f)/u.duration,1),h=0,b=l.length;b>h;h++){var S=l[h],w=S.element;if(i(w)){var V=!1;if(u.display!==a&&null!==u.display&&"none"!==u.display){if("flex"===u.display){var C=["-webkit-box","-moz-box","-ms-flexbox","-webkit-flex"];$.each(C,function(e,t){x.setPropertyValue(w,"display",t)})}x.setPropertyValue(w,"display",u.display)}u.visibility!==a&&"hidden"!==u.visibility&&x.setPropertyValue(w,"visibility",u.visibility);for(var T in S)if("element"!==T){var k=S[T],A,F=g.isString(k.easing)?v.Easings[k.easing]:k.easing;if(1===y)A=k.endValue;else{var E=k.endValue-k.startValue;if(A=k.startValue+E*F(y,u,E),!d&&A===k.currentValue)continue}if(k.currentValue=A,"tween"===T)m=A;else{if(x.Hooks.registered[T]){var j=x.Hooks.getRoot(T),H=i(w).rootPropertyValueCache[j];H&&(k.rootPropertyValue=H)}var N=x.setPropertyValue(w,T,k.currentValue+(0===parseFloat(A)?"":k.unitType),k.rootPropertyValue,k.scrollData);x.Hooks.registered[T]&&(i(w).rootPropertyValueCache[j]=x.Normalizations.registered[j]?x.Normalizations.registered[j]("extract",null,N[1]):N[1]),"transform"===N[0]&&(V=!0)}}u.mobileHA&&i(w).transformCache.translate3d===a&&(i(w).transformCache.translate3d="(0px, 0px, 0px)",V=!0),V&&x.flushTransformCache(w)}}u.display!==a&&"none"!==u.display&&(v.State.calls[o][2].display=!1),u.visibility!==a&&"hidden"!==u.visibility&&(v.State.calls[o][2].visibility=!1),u.progress&&u.progress.call(s[1],s[1],y,Math.max(0,f+u.duration-t),f,m),1===y&&p(o)}}v.State.isTicking&&P(c)}function p(e,t){if(!v.State.calls[e])return!1;for(var r=v.State.calls[e][0],n=v.State.calls[e][1],o=v.State.calls[e][2],s=v.State.calls[e][4],l=!1,u=0,c=r.length;c>u;u++){var p=r[u].element;if(t||o.loop||("none"===o.display&&x.setPropertyValue(p,"display",o.display),"hidden"===o.visibility&&x.setPropertyValue(p,"visibility",o.visibility)),o.loop!==!0&&($.queue(p)[1]===a||!/\.velocityQueueEntryFlag/i.test($.queue(p)[1]))&&i(p)){i(p).isAnimating=!1,i(p).rootPropertyValueCache={};var f=!1;$.each(x.Lists.transforms3D,function(e,t){var r=/^scale/.test(t)?1:0,n=i(p).transformCache[t];i(p).transformCache[t]!==a&&new RegExp("^\\("+r+"[^.]").test(n)&&(f=!0,delete i(p).transformCache[t])}),o.mobileHA&&(f=!0,delete i(p).transformCache.translate3d),f&&x.flushTransformCache(p),x.Values.removeClass(p,"velocity-animating")}if(!t&&o.complete&&!o.loop&&u===c-1)try{o.complete.call(n,n)}catch(d){setTimeout(function(){throw d},1)}s&&o.loop!==!0&&s(n),i(p)&&o.loop===!0&&!t&&($.each(i(p).tweensContainer,function(e,t){/^rotate/.test(e)&&360===parseFloat(t.endValue)&&(t.endValue=0,t.startValue=360),/^backgroundPosition/.test(e)&&100===parseFloat(t.endValue)&&"%"===t.unitType&&(t.endValue=0,t.startValue=100)}),v(p,"reverse",{loop:!0,delay:o.delay})),o.queue!==!1&&$.dequeue(p,o.queue)}v.State.calls[e]=!1;for(var g=0,m=v.State.calls.length;m>g;g++)if(v.State.calls[g]!==!1){l=!0;break}l===!1&&(v.State.isTicking=!1,delete v.State.calls,v.State.calls=[])}var f=function(){if(r.documentMode)return r.documentMode;for(var e=7;e>4;e--){var t=r.createElement("div");if(t.innerHTML="",t.getElementsByTagName("span").length)return t=null,e}return a}(),d=function(){var e=0;return t.webkitRequestAnimationFrame||t.mozRequestAnimationFrame||function(t){var r=(new Date).getTime(),a;return a=Math.max(0,16-(r-e)),e=r+a,setTimeout(function(){t(r+a)},a)}}(),g={isString:function(e){return"string"==typeof e},isArray:Array.isArray||function(e){return"[object Array]"===Object.prototype.toString.call(e)},isFunction:function(e){return"[object Function]"===Object.prototype.toString.call(e)},isNode:function(e){return e&&e.nodeType},isNodeList:function(e){return"object"==typeof e&&/^\[object (HTMLCollection|NodeList|Object)\]$/.test(Object.prototype.toString.call(e))&&e.length!==a&&(0===e.length||"object"==typeof e[0]&&e[0].nodeType>0)},isWrapped:function(e){return e&&(e.jquery||t.Zepto&&t.Zepto.zepto.isZ(e))},isSVG:function(e){return t.SVGElement&&e instanceof t.SVGElement},isEmptyObject:function(e){for(var t in e)return!1;return!0}},$,m=!1;if(e.fn&&e.fn.jquery?($=e,m=!0):$=t.Velocity.Utilities,8>=f&&!m)throw new Error("Velocity: IE8 and below require jQuery to be loaded before Velocity.");if(7>=f)return void(jQuery.fn.velocity=jQuery.fn.animate);var y=400,h="swing",v={State:{isMobile:/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),isAndroid:/Android/i.test(navigator.userAgent),isGingerbread:/Android 2\.3\.[3-7]/i.test(navigator.userAgent),isChrome:t.chrome,isFirefox:/Firefox/i.test(navigator.userAgent),prefixElement:r.createElement("div"),prefixMatches:{},scrollAnchor:null,scrollPropertyLeft:null,scrollPropertyTop:null,isTicking:!1,calls:[]},CSS:{},Utilities:$,Redirects:{},Easings:{},Promise:t.Promise,defaults:{queue:"",duration:y,easing:h,begin:a,complete:a,progress:a,display:a,visibility:a,loop:!1,delay:!1,mobileHA:!0,_cacheValues:!0},init:function(e){$.data(e,"velocity",{isSVG:g.isSVG(e),isAnimating:!1,computedStyle:null,tweensContainer:null,rootPropertyValueCache:{},transformCache:{}})},hook:null,mock:!1,version:{major:1,minor:2,patch:2},debug:!1};t.pageYOffset!==a?(v.State.scrollAnchor=t,v.State.scrollPropertyLeft="pageXOffset",v.State.scrollPropertyTop="pageYOffset"):(v.State.scrollAnchor=r.documentElement||r.body.parentNode||r.body,v.State.scrollPropertyLeft="scrollLeft",v.State.scrollPropertyTop="scrollTop");var b=function(){function e(e){return-e.tension*e.x-e.friction*e.v}function t(t,r,a){var n={x:t.x+a.dx*r,v:t.v+a.dv*r,tension:t.tension,friction:t.friction};return{dx:n.v,dv:e(n)}}function r(r,a){var n={dx:r.v,dv:e(r)},o=t(r,.5*a,n),i=t(r,.5*a,o),s=t(r,a,i),l=1/6*(n.dx+2*(o.dx+i.dx)+s.dx),u=1/6*(n.dv+2*(o.dv+i.dv)+s.dv);return r.x=r.x+l*a,r.v=r.v+u*a,r}return function a(e,t,n){var o={x:-1,v:0,tension:null,friction:null},i=[0],s=0,l=1e-4,u=.016,c,p,f;for(e=parseFloat(e)||500,t=parseFloat(t)||20,n=n||null,o.tension=e,o.friction=t,c=null!==n,c?(s=a(e,t),p=s/n*u):p=u;;)if(f=r(f||o,p),i.push(1+f.x),s+=16,!(Math.abs(f.x)>l&&Math.abs(f.v)>l))break;return c?function(e){return i[e*(i.length-1)|0]}:s}}();v.Easings={linear:function(e){return e},swing:function(e){return.5-Math.cos(e*Math.PI)/2},spring:function(e){return 1-Math.cos(4.5*e*Math.PI)*Math.exp(6*-e)}},$.each([["ease",[.25,.1,.25,1]],["ease-in",[.42,0,1,1]],["ease-out",[0,0,.58,1]],["ease-in-out",[.42,0,.58,1]],["easeInSine",[.47,0,.745,.715]],["easeOutSine",[.39,.575,.565,1]],["easeInOutSine",[.445,.05,.55,.95]],["easeInQuad",[.55,.085,.68,.53]],["easeOutQuad",[.25,.46,.45,.94]],["easeInOutQuad",[.455,.03,.515,.955]],["easeInCubic",[.55,.055,.675,.19]],["easeOutCubic",[.215,.61,.355,1]],["easeInOutCubic",[.645,.045,.355,1]],["easeInQuart",[.895,.03,.685,.22]],["easeOutQuart",[.165,.84,.44,1]],["easeInOutQuart",[.77,0,.175,1]],["easeInQuint",[.755,.05,.855,.06]],["easeOutQuint",[.23,1,.32,1]],["easeInOutQuint",[.86,0,.07,1]],["easeInExpo",[.95,.05,.795,.035]],["easeOutExpo",[.19,1,.22,1]],["easeInOutExpo",[1,0,0,1]],["easeInCirc",[.6,.04,.98,.335]],["easeOutCirc",[.075,.82,.165,1]],["easeInOutCirc",[.785,.135,.15,.86]]],function(e,t){v.Easings[t[0]]=l.apply(null,t[1])});var x=v.CSS={RegEx:{isHex:/^#([A-f\d]{3}){1,2}$/i,valueUnwrap:/^[A-z]+\((.*)\)$/i,wrappedValueAlreadyExtracted:/[0-9.]+ [0-9.]+ [0-9.]+( [0-9.]+)?/,valueSplit:/([A-z]+\(.+\))|(([A-z0-9#-.]+?)(?=\s|$))/gi},Lists:{colors:["fill","stroke","stopColor","color","backgroundColor","borderColor","borderTopColor","borderRightColor","borderBottomColor","borderLeftColor","outlineColor"],transformsBase:["translateX","translateY","scale","scaleX","scaleY","skewX","skewY","rotateZ"],transforms3D:["transformPerspective","translateZ","scaleZ","rotateX","rotateY"]},Hooks:{templates:{textShadow:["Color X Y Blur","black 0px 0px 0px"],boxShadow:["Color X Y Blur Spread","black 0px 0px 0px 0px"],clip:["Top Right Bottom Left","0px 0px 0px 0px"],backgroundPosition:["X Y","0% 0%"],transformOrigin:["X Y Z","50% 50% 0px"],perspectiveOrigin:["X Y","50% 50%"]},registered:{},register:function(){for(var e=0;e=f)switch(e){case"name":return"filter";case"extract":var a=r.toString().match(/alpha\(opacity=(.*)\)/i);return r=a?a[1]/100:1;case"inject":return t.style.zoom=1,parseFloat(r)>=1?"":"alpha(opacity="+parseInt(100*parseFloat(r),10)+")"}else switch(e){case"name":return"opacity";case"extract":return r;case"inject":return r}}},register:function(){9>=f||v.State.isGingerbread||(x.Lists.transformsBase=x.Lists.transformsBase.concat(x.Lists.transforms3D));for(var e=0;en&&(n=1),o=!/(\d)$/i.test(n);break;case"skew":o=!/(deg|\d)$/i.test(n);break;case"rotate":o=!/(deg|\d)$/i.test(n)}return o||(i(r).transformCache[t]="("+n+")"),i(r).transformCache[t]}}}();for(var e=0;e=f||3!==o.split(" ").length||(o+=" 1"),o;case"inject":return 8>=f?4===n.split(" ").length&&(n=n.split(/\s+/).slice(0,3).join(" ")):3===n.split(" ").length&&(n+=" 1"),(8>=f?"rgb":"rgba")+"("+n.replace(/\s+/g,",").replace(/\.(\d)+(?=,)/g,"")+")"}}}()}},Names:{camelCase:function(e){return e.replace(/-(\w)/g,function(e,t){return t.toUpperCase()})},SVGAttribute:function(e){var t="width|height|x|y|cx|cy|r|rx|ry|x1|x2|y1|y2";return(f||v.State.isAndroid&&!v.State.isChrome)&&(t+="|transform"),new RegExp("^("+t+")$","i").test(e)},prefixCheck:function(e){if(v.State.prefixMatches[e])return[v.State.prefixMatches[e],!0];for(var t=["","Webkit","Moz","ms","O"],r=0,a=t.length;a>r;r++){var n;if(n=0===r?e:t[r]+e.replace(/^\w/,function(e){return e.toUpperCase()}),g.isString(v.State.prefixElement.style[n]))return v.State.prefixMatches[e]=n,[n,!0]}return[e,!1]}},Values:{hexToRgb:function(e){var t=/^#?([a-f\d])([a-f\d])([a-f\d])$/i,r=/^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i,a;return e=e.replace(t,function(e,t,r,a){return t+t+r+r+a+a}),a=r.exec(e),a?[parseInt(a[1],16),parseInt(a[2],16),parseInt(a[3],16)]:[0,0,0]},isCSSNullValue:function(e){return 0==e||/^(none|auto|transparent|(rgba\(0, ?0, ?0, ?0\)))$/i.test(e)},getUnitType:function(e){return/^(rotate|skew)/i.test(e)?"deg":/(^(scale|scaleX|scaleY|scaleZ|alpha|flexGrow|flexHeight|zIndex|fontWeight)$)|((opacity|red|green|blue|alpha)$)/i.test(e)?"":"px"},getDisplayType:function(e){var t=e&&e.tagName.toString().toLowerCase();return/^(b|big|i|small|tt|abbr|acronym|cite|code|dfn|em|kbd|strong|samp|var|a|bdo|br|img|map|object|q|script|span|sub|sup|button|input|label|select|textarea)$/i.test(t)?"inline":/^(li)$/i.test(t)?"list-item":/^(tr)$/i.test(t)?"table-row":/^(table)$/i.test(t)?"table":/^(tbody)$/i.test(t)?"table-row-group":"block"},addClass:function(e,t){e.classList?e.classList.add(t):e.className+=(e.className.length?" ":"")+t},removeClass:function(e,t){e.classList?e.classList.remove(t):e.className=e.className.toString().replace(new RegExp("(^|\\s)"+t.split(" ").join("|")+"(\\s|$)","gi")," ")}},getPropertyValue:function(e,r,n,o){function s(e,r){function n(){u&&x.setPropertyValue(e,"display","none")}var l=0;if(8>=f)l=$.css(e,r);else{var u=!1;if(/^(width|height)$/.test(r)&&0===x.getPropertyValue(e,"display")&&(u=!0,x.setPropertyValue(e,"display",x.Values.getDisplayType(e))),!o){if("height"===r&&"border-box"!==x.getPropertyValue(e,"boxSizing").toString().toLowerCase()){var c=e.offsetHeight-(parseFloat(x.getPropertyValue(e,"borderTopWidth"))||0)-(parseFloat(x.getPropertyValue(e,"borderBottomWidth"))||0)-(parseFloat(x.getPropertyValue(e,"paddingTop"))||0)-(parseFloat(x.getPropertyValue(e,"paddingBottom"))||0);return n(),c}if("width"===r&&"border-box"!==x.getPropertyValue(e,"boxSizing").toString().toLowerCase()){var p=e.offsetWidth-(parseFloat(x.getPropertyValue(e,"borderLeftWidth"))||0)-(parseFloat(x.getPropertyValue(e,"borderRightWidth"))||0)-(parseFloat(x.getPropertyValue(e,"paddingLeft"))||0)-(parseFloat(x.getPropertyValue(e,"paddingRight"))||0);return n(),p}}var d;d=i(e)===a?t.getComputedStyle(e,null):i(e).computedStyle?i(e).computedStyle:i(e).computedStyle=t.getComputedStyle(e,null),"borderColor"===r&&(r="borderTopColor"),l=9===f&&"filter"===r?d.getPropertyValue(r):d[r],(""===l||null===l)&&(l=e.style[r]),n()}if("auto"===l&&/^(top|right|bottom|left)$/i.test(r)){var g=s(e,"position");("fixed"===g||"absolute"===g&&/top|left/i.test(r))&&(l=$(e).position()[r]+"px")}return l}var l;if(x.Hooks.registered[r]){var u=r,c=x.Hooks.getRoot(u);n===a&&(n=x.getPropertyValue(e,x.Names.prefixCheck(c)[0])),x.Normalizations.registered[c]&&(n=x.Normalizations.registered[c]("extract",e,n)),l=x.Hooks.extractValue(u,n)}else if(x.Normalizations.registered[r]){var p,d;p=x.Normalizations.registered[r]("name",e),"transform"!==p&&(d=s(e,x.Names.prefixCheck(p)[0]),x.Values.isCSSNullValue(d)&&x.Hooks.templates[r]&&(d=x.Hooks.templates[r][1])),l=x.Normalizations.registered[r]("extract",e,d)}if(!/^[\d-]/.test(l))if(i(e)&&i(e).isSVG&&x.Names.SVGAttribute(r))if(/^(height|width)$/i.test(r))try{l=e.getBBox()[r]}catch(g){l=0}else l=e.getAttribute(r);else l=s(e,x.Names.prefixCheck(r)[0]);return x.Values.isCSSNullValue(l)&&(l=0),v.debug>=2&&console.log("Get "+r+": "+l),l},setPropertyValue:function(e,r,a,n,o){var s=r;if("scroll"===r)o.container?o.container["scroll"+o.direction]=a:"Left"===o.direction?t.scrollTo(a,o.alternateValue):t.scrollTo(o.alternateValue,a);else if(x.Normalizations.registered[r]&&"transform"===x.Normalizations.registered[r]("name",e))x.Normalizations.registered[r]("inject",e,a),s="transform",a=i(e).transformCache[r];else{if(x.Hooks.registered[r]){var l=r,u=x.Hooks.getRoot(r);n=n||x.getPropertyValue(e,u),a=x.Hooks.injectValue(l,a,n),r=u}if(x.Normalizations.registered[r]&&(a=x.Normalizations.registered[r]("inject",e,a),r=x.Normalizations.registered[r]("name",e)),s=x.Names.prefixCheck(r)[0],8>=f)try{e.style[s]=a}catch(c){v.debug&&console.log("Browser does not support ["+a+"] for ["+s+"]")}else i(e)&&i(e).isSVG&&x.Names.SVGAttribute(r)?e.setAttribute(r,a):e.style[s]=a;v.debug>=2&&console.log("Set "+r+" ("+s+"): "+a)}return[s,a]},flushTransformCache:function(e){function t(t){return parseFloat(x.getPropertyValue(e,t))}var r="";if((f||v.State.isAndroid&&!v.State.isChrome)&&i(e).isSVG){var a={translate:[t("translateX"),t("translateY")],skewX:[t("skewX")],skewY:[t("skewY")],scale:1!==t("scale")?[t("scale"),t("scale")]:[t("scaleX"),t("scaleY")],rotate:[t("rotateZ"),0,0]};$.each(i(e).transformCache,function(e){/^translate/i.test(e)?e="translate":/^scale/i.test(e)?e="scale":/^rotate/i.test(e)&&(e="rotate"),a[e]&&(r+=e+"("+a[e].join(" ")+") ",delete a[e])})}else{var n,o;$.each(i(e).transformCache,function(t){return n=i(e).transformCache[t],"transformPerspective"===t?(o=n,!0):(9===f&&"rotateZ"===t&&(t="rotate"),void(r+=t+n+" "))}),o&&(r="perspective"+o+" "+r)}x.setPropertyValue(e,"transform",r)}};x.Hooks.register(),x.Normalizations.register(),v.hook=function(e,t,r){var n=a;return e=o(e),$.each(e,function(e,o){if(i(o)===a&&v.init(o),r===a)n===a&&(n=v.CSS.getPropertyValue(o,t));else{var s=v.CSS.setPropertyValue(o,t,r);"transform"===s[0]&&v.CSS.flushTransformCache(o),n=s}}),n};var S=function(){function e(){return l?T.promise||null:f}function n(){function e(e){function p(e,t){var r=a,i=a,s=a;return g.isArray(e)?(r=e[0],!g.isArray(e[1])&&/^[\d-]/.test(e[1])||g.isFunction(e[1])||x.RegEx.isHex.test(e[1])?s=e[1]:(g.isString(e[1])&&!x.RegEx.isHex.test(e[1])||g.isArray(e[1]))&&(i=t?e[1]:u(e[1],o.duration),e[2]!==a&&(s=e[2]))):r=e,t||(i=i||o.easing),g.isFunction(r)&&(r=r.call(n,w,P)),g.isFunction(s)&&(s=s.call(n,w,P)),[r||0,i,s]}function f(e,t){var r,a;return a=(t||"0").toString().toLowerCase().replace(/[%A-z]+$/,function(e){return r=e,""}),r||(r=x.Values.getUnitType(e)),[a,r]}function d(){var e={myParent:n.parentNode||r.body,position:x.getPropertyValue(n,"position"),fontSize:x.getPropertyValue(n,"fontSize")},a=e.position===N.lastPosition&&e.myParent===N.lastParent,o=e.fontSize===N.lastFontSize;N.lastParent=e.myParent,N.lastPosition=e.position,N.lastFontSize=e.fontSize;var s=100,l={};if(o&&a)l.emToPx=N.lastEmToPx,l.percentToPxWidth=N.lastPercentToPxWidth,l.percentToPxHeight=N.lastPercentToPxHeight;else{var u=i(n).isSVG?r.createElementNS("http://www.w3.org/2000/svg","rect"):r.createElement("div");v.init(u),e.myParent.appendChild(u),$.each(["overflow","overflowX","overflowY"],function(e,t){v.CSS.setPropertyValue(u,t,"hidden")}),v.CSS.setPropertyValue(u,"position",e.position),v.CSS.setPropertyValue(u,"fontSize",e.fontSize),v.CSS.setPropertyValue(u,"boxSizing","content-box"),$.each(["minWidth","maxWidth","width","minHeight","maxHeight","height"],function(e,t){v.CSS.setPropertyValue(u,t,s+"%")}),v.CSS.setPropertyValue(u,"paddingLeft",s+"em"),l.percentToPxWidth=N.lastPercentToPxWidth=(parseFloat(x.getPropertyValue(u,"width",null,!0))||1)/s,l.percentToPxHeight=N.lastPercentToPxHeight=(parseFloat(x.getPropertyValue(u,"height",null,!0))||1)/s,l.emToPx=N.lastEmToPx=(parseFloat(x.getPropertyValue(u,"paddingLeft"))||1)/s,e.myParent.removeChild(u)}return null===N.remToPx&&(N.remToPx=parseFloat(x.getPropertyValue(r.body,"fontSize"))||16),null===N.vwToPx&&(N.vwToPx=parseFloat(t.innerWidth)/100,N.vhToPx=parseFloat(t.innerHeight)/100),l.remToPx=N.remToPx,l.vwToPx=N.vwToPx,l.vhToPx=N.vhToPx,v.debug>=1&&console.log("Unit ratios: "+JSON.stringify(l),n),l}if(o.begin&&0===w)try{o.begin.call(m,m)}catch(y){setTimeout(function(){throw y},1)}if("scroll"===k){var S=/^x$/i.test(o.axis)?"Left":"Top",V=parseFloat(o.offset)||0,C,A,F;o.container?g.isWrapped(o.container)||g.isNode(o.container)?(o.container=o.container[0]||o.container,C=o.container["scroll"+S],F=C+$(n).position()[S.toLowerCase()]+V):o.container=null:(C=v.State.scrollAnchor[v.State["scrollProperty"+S]],A=v.State.scrollAnchor[v.State["scrollProperty"+("Left"===S?"Top":"Left")]],F=$(n).offset()[S.toLowerCase()]+V),s={scroll:{rootPropertyValue:!1,startValue:C,currentValue:C,endValue:F,unitType:"",easing:o.easing,scrollData:{container:o.container,direction:S,alternateValue:A}},element:n},v.debug&&console.log("tweensContainer (scroll): ",s.scroll,n)}else if("reverse"===k){if(!i(n).tweensContainer)return void $.dequeue(n,o.queue);"none"===i(n).opts.display&&(i(n).opts.display="auto"),"hidden"===i(n).opts.visibility&&(i(n).opts.visibility="visible"),i(n).opts.loop=!1,i(n).opts.begin=null,i(n).opts.complete=null,b.easing||delete o.easing,b.duration||delete o.duration,o=$.extend({},i(n).opts,o);var E=$.extend(!0,{},i(n).tweensContainer);for(var j in E)if("element"!==j){var H=E[j].startValue;E[j].startValue=E[j].currentValue=E[j].endValue,E[j].endValue=H,g.isEmptyObject(b)||(E[j].easing=o.easing),v.debug&&console.log("reverse tweensContainer ("+j+"): "+JSON.stringify(E[j]),n)}s=E}else if("start"===k){var E;i(n).tweensContainer&&i(n).isAnimating===!0&&(E=i(n).tweensContainer),$.each(h,function(e,t){if(RegExp("^"+x.Lists.colors.join("$|^")+"$").test(e)){var r=p(t,!0),n=r[0],o=r[1],i=r[2];if(x.RegEx.isHex.test(n)){for(var s=["Red","Green","Blue"],l=x.Values.hexToRgb(n),u=i?x.Values.hexToRgb(i):a,c=0;cO;O++){var z={delay:F.delay,progress:F.progress};O===R-1&&(z.display=F.display,z.visibility=F.visibility,z.complete=F.complete),S(m,"reverse",z)}return e()}};v=$.extend(S,v),v.animate=S;var P=t.requestAnimationFrame||d;return v.State.isMobile||r.hidden===a||r.addEventListener("visibilitychange",function(){r.hidden?(P=function(e){return setTimeout(function(){e(!0)},16)},c()):P=t.requestAnimationFrame||d}),e.Velocity=v,e!==t&&(e.fn.velocity=S,e.fn.velocity.defaults=v.defaults),$.each(["Down","Up"],function(e,t){v.Redirects["slide"+t]=function(e,r,n,o,i,s){var l=$.extend({},r),u=l.begin,c=l.complete,p={height:"",marginTop:"",marginBottom:"",paddingTop:"",paddingBottom:""},f={};l.display===a&&(l.display="Down"===t?"inline"===v.CSS.Values.getDisplayType(e)?"inline-block":"block":"none"),l.begin=function(){u&&u.call(i,i);for(var r in p){f[r]=e.style[r];var a=v.CSS.getPropertyValue(e,r);p[r]="Down"===t?[a,0]:[0,a]}f.overflow=e.style.overflow,e.style.overflow="hidden"},l.complete=function(){for(var t in f)e.style[t]=f[t];c&&c.call(i,i),s&&s.resolver(i)},v(e,p,l)}}),$.each(["In","Out"],function(e,t){v.Redirects["fade"+t]=function(e,r,n,o,i,s){var l=$.extend({},r),u={opacity:"In"===t?1:0},c=l.complete;l.complete=n!==o-1?l.begin=null:function(){c&&c.call(i,i),s&&s.resolver(i)},l.display===a&&(l.display="In"===t?"auto":"none"),v(this,u,l)}}),v}(window.jQuery||window.Zepto||window,window,document)});]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Findex%2F</url>
    <content type="text"><![CDATA[/*! jQuery v2.1.3 | (c) 2005, 2014 jQuery Foundation, Inc. | jquery.org/license */ !function(a,b){"object"==typeof module&&"object"==typeof module.exports?module.exports=a.document?b(a,!0):function(a){if(!a.document)throw new Error("jQuery requires a window with a document");return b(a)}:b(a)}("undefined"!=typeof window?window:this,function(a,b){var c=[],d=c.slice,e=c.concat,f=c.push,g=c.indexOf,h={},i=h.toString,j=h.hasOwnProperty,k={},l=a.document,m="2.1.3",n=function(a,b){return new n.fn.init(a,b)},o=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,p=/^-ms-/,q=/-([\da-z])/gi,r=function(a,b){return b.toUpperCase()};n.fn=n.prototype={jquery:m,constructor:n,selector:"",length:0,toArray:function(){return d.call(this)},get:function(a){return null!=a?0>a?this[a+this.length]:this[a]:d.call(this)},pushStack:function(a){var b=n.merge(this.constructor(),a);return b.prevObject=this,b.context=this.context,b},each:function(a,b){return n.each(this,a,b)},map:function(a){return this.pushStack(n.map(this,function(b,c){return a.call(b,c,b)}))},slice:function(){return this.pushStack(d.apply(this,arguments))},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},eq:function(a){var b=this.length,c=+a+(0>a?b:0);return this.pushStack(c>=0&&b>c?[this[c]]:[])},end:function(){return this.prevObject||this.constructor(null)},push:f,sort:c.sort,splice:c.splice},n.extend=n.fn.extend=function(){var a,b,c,d,e,f,g=arguments[0]||{},h=1,i=arguments.length,j=!1;for("boolean"==typeof g&&(j=g,g=arguments[h]||{},h++),"object"==typeof g||n.isFunction(g)||(g={}),h===i&&(g=this,h--);i>h;h++)if(null!=(a=arguments[h]))for(b in a)c=g[b],d=a[b],g!==d&&(j&&d&&(n.isPlainObject(d)||(e=n.isArray(d)))?(e?(e=!1,f=c&&n.isArray(c)?c:[]):f=c&&n.isPlainObject(c)?c:{},g[b]=n.extend(j,f,d)):void 0!==d&&(g[b]=d));return g},n.extend({expando:"jQuery"+(m+Math.random()).replace(/\D/g,""),isReady:!0,error:function(a){throw new Error(a)},noop:function(){},isFunction:function(a){return"function"===n.type(a)},isArray:Array.isArray,isWindow:function(a){return null!=a&&a===a.window},isNumeric:function(a){return!n.isArray(a)&&a-parseFloat(a)+1>=0},isPlainObject:function(a){return"object"!==n.type(a)||a.nodeType||n.isWindow(a)?!1:a.constructor&&!j.call(a.constructor.prototype,"isPrototypeOf")?!1:!0},isEmptyObject:function(a){var b;for(b in a)return!1;return!0},type:function(a){return null==a?a+"":"object"==typeof a||"function"==typeof a?h[i.call(a)]||"object":typeof a},globalEval:function(a){var b,c=eval;a=n.trim(a),a&&(1===a.indexOf("use strict")?(b=l.createElement("script"),b.text=a,l.head.appendChild(b).parentNode.removeChild(b)):c(a))},camelCase:function(a){return a.replace(p,"ms-").replace(q,r)},nodeName:function(a,b){return a.nodeName&&a.nodeName.toLowerCase()===b.toLowerCase()},each:function(a,b,c){var d,e=0,f=a.length,g=s(a);if(c){if(g){for(;f>e;e++)if(d=b.apply(a[e],c),d===!1)break}else for(e in a)if(d=b.apply(a[e],c),d===!1)break}else if(g){for(;f>e;e++)if(d=b.call(a[e],e,a[e]),d===!1)break}else for(e in a)if(d=b.call(a[e],e,a[e]),d===!1)break;return a},trim:function(a){return null==a?"":(a+"").replace(o,"")},makeArray:function(a,b){var c=b||[];return null!=a&&(s(Object(a))?n.merge(c,"string"==typeof a?[a]:a):f.call(c,a)),c},inArray:function(a,b,c){return null==b?-1:g.call(b,a,c)},merge:function(a,b){for(var c=+b.length,d=0,e=a.length;c>d;d++)a[e++]=b[d];return a.length=e,a},grep:function(a,b,c){for(var d,e=[],f=0,g=a.length,h=!c;g>f;f++)d=!b(a[f],f),d!==h&&e.push(a[f]);return e},map:function(a,b,c){var d,f=0,g=a.length,h=s(a),i=[];if(h)for(;g>f;f++)d=b(a[f],f,c),null!=d&&i.push(d);else for(f in a)d=b(a[f],f,c),null!=d&&i.push(d);return e.apply([],i)},guid:1,proxy:function(a,b){var c,e,f;return"string"==typeof b&&(c=a[b],b=a,a=c),n.isFunction(a)?(e=d.call(arguments,2),f=function(){return a.apply(b||this,e.concat(d.call(arguments)))},f.guid=a.guid=a.guid||n.guid++,f):void 0},now:Date.now,support:k}),n.each("Boolean Number String Function Array Date RegExp Object Error".split(" "),function(a,b){h["[object "+b+"]"]=b.toLowerCase()});function s(a){var b=a.length,c=n.type(a);return"function"===c||n.isWindow(a)?!1:1===a.nodeType&&b?!0:"array"===c||0===b||"number"==typeof b&&b>0&&b-1 in a}var t=function(a){var b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u="sizzle"+1*new Date,v=a.document,w=0,x=0,y=hb(),z=hb(),A=hb(),B=function(a,b){return a===b&&(l=!0),0},C=1]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Fmain%2F</url>
    <content type="text"><![CDATA[/* normalize.css v8.0.1 | MIT License | github.com/necolas/normalize.css */ html { line-height: 1.15; /* 1 */ -webkit-text-size-adjust: 100%; /* 2 */ } body { margin: 0; } main { display: block; } h1 { font-size: 2em; margin: 0.67em 0; } hr { box-sizing: content-box; /* 1 */ height: 0; /* 1 */ overflow: visible; /* 2 */ } pre { font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */ } a { background-color: transparent; } abbr[title] { border-bottom: none; /* 1 */ text-decoration: underline; /* 2 */ text-decoration: underline dotted; /* 2 */ } b, strong { font-weight: bolder; } code, kbd, samp { font-family: monospace, monospace; /* 1 */ font-size: 1em; /* 2 */ } small { font-size: 80%; } sub, sup { font-size: 75%; line-height: 0; position: relative; vertical-align: baseline; } sub { bottom: -0.25em; } sup { top: -0.5em; } img { border-style: none; } button, input, optgroup, select, textarea { font-family: inherit; /* 1 */ font-size: 100%; /* 1 */ line-height: 1.15; /* 1 */ margin: 0; /* 2 */ } button, input { /* 1 */ overflow: visible; } button, select { /* 1 */ text-transform: none; } button, [type="button"], [type="reset"], [type="submit"] { -webkit-appearance: button; } button::-moz-focus-inner, [type="button"]::-moz-focus-inner, [type="reset"]::-moz-focus-inner, [type="submit"]::-moz-focus-inner { border-style: none; padding: 0; } button:-moz-focusring, [type="button"]:-moz-focusring, [type="reset"]:-moz-focusring, [type="submit"]:-moz-focusring { outline: 1px dotted ButtonText; } fieldset { padding: 0.35em 0.75em 0.625em; } legend { box-sizing: border-box; /* 1 */ color: inherit; /* 2 */ display: table; /* 1 */ max-width: 100%; /* 1 */ padding: 0; /* 3 */ white-space: normal; /* 1 */ } progress { vertical-align: baseline; } textarea { overflow: auto; } [type="checkbox"], [type="radio"] { box-sizing: border-box; /* 1 */ padding: 0; /* 2 */ } [type="number"]::-webkit-inner-spin-button, [type="number"]::-webkit-outer-spin-button { height: auto; } [type="search"] { -webkit-appearance: textfield; /* 1 */ outline-offset: -2px; /* 2 */ } [type="search"]::-webkit-search-decoration { -webkit-appearance: none; } ::-webkit-file-upload-button { -webkit-appearance: button; /* 1 */ font: inherit; /* 2 */ } details { display: block; } summary { display: list-item; } template { display: none; } [hidden] { display: none; } ::selection { background: #262a30; color: #fff; } body { position: relative; font-family: 'Lato', "PingFang SC", "Microsoft YaHei", sans-serif; font-size: 14px; line-height: 2; color: #555; background: #f5f7f9; } @media (max-width: 991px) { body { padding-right: 0 !important; } } @media (min-width: 1200px) { body { font-size: 16px; } } h1, h2, h3, h4, h5, h6 { margin: 20px 0 15px; padding: 0; font-weight: bold; line-height: 1.5; font-family: 'Lato', "PingFang SC", "Microsoft YaHei", sans-serif; } h1 { font-size: 22px; } h1 code { font-size: 1em; } @media (max-width: 767px) { h1 { font-size: 18px; } h1 code { font-size: 1em; } } h2 { font-size: 20px; } h2 code { font-size: 1em; } @media (max-width: 767px) { h2 { font-size: 16px; } h2 code { font-size: 1em; } } h3 { font-size: 18px; } h3 code { font-size: 1em; } @media (max-width: 767px) { h3 { font-size: 14px; } h3 code { font-size: 1em; } } h4 { font-size: 16px; } h4 code { font-size: 1em; } @media (max-width: 767px) { h4 { font-size: 12px; } h4 code { font-size: 1em; } } h5 { font-size: 14px; } h5 code { font-size: 1em; } @media (max-width: 767px) { h5 { font-size: 10px; } h5 code { font-size: 1em; } } h6 { font-size: 12px; } h6 code { font-size: 1em; } @media (max-width: 767px) { h6 { font-size: 8px; } h6 code { font-size: 1em; } } p { margin: 0 0 20px 0; } a, span.exturl { overflow-wrap: break-word; word-wrap: break-word; background-color: transparent; color: #555; text-decoration: none; outline: none; border-bottom: 1px solid #999; cursor: pointer; } a:hover, span.exturl:hover { color: #222; border-bottom-color: #222; } video { max-width: 100%; display: block; margin-left: auto; margin-right: auto; } img { display: block; margin: auto; max-width: 100%; height: auto; } hr { margin: 40px 0; height: 3px; border: none; background-color: #ddd; background-image: repeating-linear-gradient(-45deg, #fff, #fff 4px, transparent 4px, transparent 8px); } blockquote { margin: 0; padding: 0 15px; color: #666; border-left: 4px solid #ddd; } blockquote cite::before { content: "-"; padding: 0 5px; } dt { font-weight: 700; } dd { margin: 0; padding: 0; } kbd { border: 1px solid #ccc; border-radius: 0.2em; box-shadow: 0.1em 0.1em 0.2em rgba(0,0,0,0.1); background-color: #f9f9f9; font-family: inherit; background-image: linear-gradient(top, #eee, #fff, #eee); padding: 0.1em 0.3em; white-space: nowrap; } .text-left { text-align: left; } .text-center { text-align: center; } .text-right { text-align: right; } .text-justify { text-align: justify; } .text-nowrap { white-space: nowrap; } .text-lowercase { text-transform: lowercase; } .text-uppercase { text-transform: uppercase; } .text-capitalize { text-transform: capitalize; } .center-block { display: block; margin-left: auto; margin-right: auto; } .clearfix:before, .clearfix:after { content: " "; display: table; } .clearfix:after { clear: both; } .pullquote { width: 45%; } .pullquote.left { float: left; margin-left: 5px; margin-right: 10px; } .pullquote.right { float: right; margin-left: 10px; margin-right: 5px; } .affix { position: fixed; } .translation { margin-top: -20px; font-size: 14px; color: #999; } .scrollbar-measure { width: 100px; height: 100px; overflow: scroll; position: absolute; top: -9999px; } .use-motion .motion-element { opacity: 0; } .table-container { margin: 20px 0; overflow: auto; -webkit-overflow-scrolling: touch; } table { width: 100%; border-collapse: collapse; border-spacing: 0; font-size: 14px; } table > tbody > tr:nth-of-type(odd) { background-color: #f9f9f9; } table > tbody > tr:hover { background-color: #f5f5f5; } caption, th, td { padding: 8px; text-align: left; vertical-align: middle; font-weight: normal; } th, td { border: 1px solid #ddd; border-bottom: 3px solid #ddd; } th { padding-bottom: 10px; font-weight: 700; } td { border-bottom-width: 1px; } html, body { height: 100%; } .container { position: relative; } .header-inner { margin: 0 auto; padding: 100px 0 70px; width: calc(100% - 20px); } @media (min-width: 1200px) { .container .header-inner { width: 1160px; } } @media (min-width: 1600px) { .container .header-inner { width: 73%; } } .main-inner { margin: 0 auto; width: calc(100% - 20px); } @media (min-width: 1200px) { .container .main-inner { width: 1160px; } } @media (min-width: 1600px) { .container .main-inner { width: 73%; } } .footer { padding: 20px 0; } .footer-inner { box-sizing: border-box; margin: 0px auto; width: calc(100% - 20px); } @media (min-width: 1200px) { .container .footer-inner { width: 1160px; } } @media (min-width: 1600px) { .container .footer-inner { width: 73%; } } pre, .highlight { overflow: auto; margin: 20px 0; padding: 0; font-size: 14px; color: #eaeaea; background: #000; line-height: 1.6; } pre, code { font-family: consolas, Menlo, "PingFang SC", "Microsoft YaHei", monospace; } code { overflow-wrap: break-word; word-wrap: break-word; padding: 2px 4px; color: #555; background: #eee; border-radius: 3px; font-size: 14px; } pre { padding: 10px; } pre code { padding: 0; color: #eaeaea; background: none; text-shadow: none; } .highlight { border-radius: 1px; } .highlight pre { border: none; margin: 0; padding: 10px 0; } .highlight table { margin: 0; width: auto; border: none; } .highlight td { border: none; padding: 0; } .highlight figcaption { font-size: 1em; color: #eaeaea; line-height: 1em; margin-bottom: 1em; margin: 0em; padding: 0.5em; background: #eee; border-bottom: 1px solid #e9e9e9; } .highlight figcaption:before, .highlight figcaption:after { content: " "; display: table; } .highlight figcaption:after { clear: both; } .highlight figcaption a { float: right; color: #eaeaea; } .highlight figcaption a:hover { border-bottom-color: #eaeaea; } .highlight .gutter pre { padding-left: 10px; padding-right: 10px; color: #666; text-align: right; background-color: #292929; } .highlight .code pre { width: 100%; padding-left: 10px; padding-right: 10px; background-color: #000; } .highlight .line { height: 20px; } .gutter { -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; } .gist table { width: auto; } .gist table td { border: none; } pre .deletion { background: #800000; } pre .addition { background: #008000; } pre .meta { color: #c397d8; } pre .comment { color: #969896; } pre .variable, pre .attribute, pre .tag, pre .name, pre .regexp, pre .ruby .constant, pre .xml .tag .title, pre .xml .pi, pre .xml .doctype, pre .html .doctype, pre .css .id, pre .css .class, pre .css .pseudo { color: #d54e53; } pre .number, pre .preprocessor, pre .built_in, pre .builtin-name, pre .literal, pre .params, pre .constant, pre .command { color: #e78c45; } pre .ruby .class .title, pre .css .rules .attribute, pre .string, pre .symbol, pre .value, pre .inheritance, pre .header, pre .ruby .symbol, pre .xml .cdata, pre .special, pre .formula { color: #b9ca4a; } pre .title, pre .css .hexcolor { color: #70c0b1; } pre .function, pre .python .decorator, pre .python .title, pre .ruby .function .title, pre .ruby .title .keyword, pre .perl .sub, pre .javascript .title, pre .coffeescript .title { color: #7aa6da; } pre .keyword, pre .javascript .function { color: #c397d8; } .posts-expand .post-body img.full-image { border: none; } .blockquote-center, .page-home .post-type-quote blockquote, .page-post-detail .post-type-quote blockquote { position: relative; margin: 40px 0; padding: 0; border-left: none; text-align: center; } .blockquote-center::before, .page-home .post-type-quote blockquote::before, .page-post-detail .post-type-quote blockquote::before, .blockquote-center::after, .page-home .post-type-quote blockquote::after, .page-post-detail .post-type-quote blockquote::after { position: absolute; content: ' '; display: block; width: 100%; height: 24px; opacity: 0.2; background-repeat: no-repeat; background-position: 0 -6px; background-size: 22px 22px; } .blockquote-center::before, .page-home .post-type-quote blockquote::before, .page-post-detail .post-type-quote blockquote::before { top: -20px; background-image: url("../images/quote-l.svg"); border-top: 1px solid #ccc; } .blockquote-center::after, .page-home .post-type-quote blockquote::after, .page-post-detail .post-type-quote blockquote::after { bottom: -20px; background-image: url("../images/quote-r.svg"); border-bottom: 1px solid #ccc; background-position: 100% 8px; } .blockquote-center p, .page-home .post-type-quote blockquote p, .page-post-detail .post-type-quote blockquote p, .blockquote-center div, .page-home .post-type-quote blockquote div, .page-post-detail .post-type-quote blockquote div { text-align: center; } .post .post-body .group-picture img { box-sizing: border-box; padding: 0 3px; border: none; } .post .group-picture-row { overflow: hidden; margin-top: 6px; } .post .group-picture-row:first-child { margin-top: 0; } .post .group-picture-column { float: left; } .page-post-detail .post-body .group-picture-column { float: none; margin-top: 10px; width: auto !important; } .page-post-detail .post-body .group-picture-column img { margin: 0 auto; } .page-archive .group-picture-container { overflow: hidden; } .page-archive .group-picture-row { float: left; } .page-archive .group-picture-row:first-child { margin-top: 6px; } .page-archive .group-picture-column { max-width: 150px; max-height: 150px; } .post-body .label { display: inline; padding: 0 2px; white-space: nowrap; } .post-body .label.default { background-color: #f0f0f0; } .post-body .label.primary { background-color: #efe6f7; } .post-body .label.info { background-color: #e5f2f8; } .post-body .label.success { background-color: #e7f4e9; } .post-body .label.warning { background-color: #fcf6e1; } .post-body .label.danger { background-color: #fae8eb; } .post-body .note { position: relative; padding: 15px; margin-bottom: 20px; border: 1px solid #eee; border-left-width: 5px; border-radius: 3px; } .post-body .note h2, .post-body .note h3, .post-body .note h4, .post-body .note h5, .post-body .note h6 { margin-top: 0; margin-bottom: 0; border-bottom: initial; padding-top: 0 !important; } .post-body .note p:first-child, .post-body .note ul:first-child, .post-body .note ol:first-child, .post-body .note table:first-child, .post-body .note pre:first-child, .post-body .note blockquote:first-child { margin-top: 0; } .post-body .note p:last-child, .post-body .note ul:last-child, .post-body .note ol:last-child, .post-body .note table:last-child, .post-body .note pre:last-child, .post-body .note blockquote:last-child { margin-bottom: 0; } .post-body .note.default { border-left-color: #777; } .post-body .note.default h2, .post-body .note.default h3, .post-body .note.default h4, .post-body .note.default h5, .post-body .note.default h6 { color: #777; } .post-body .note.primary { border-left-color: #6f42c1; } .post-body .note.primary h2, .post-body .note.primary h3, .post-body .note.primary h4, .post-body .note.primary h5, .post-body .note.primary h6 { color: #6f42c1; } .post-body .note.info { border-left-color: #428bca; } .post-body .note.info h2, .post-body .note.info h3, .post-body .note.info h4, .post-body .note.info h5, .post-body .note.info h6 { color: #428bca; } .post-body .note.success { border-left-color: #5cb85c; } .post-body .note.success h2, .post-body .note.success h3, .post-body .note.success h4, .post-body .note.success h5, .post-body .note.success h6 { color: #5cb85c; } .post-body .note.warning { border-left-color: #f0ad4e; } .post-body .note.warning h2, .post-body .note.warning h3, .post-body .note.warning h4, .post-body .note.warning h5, .post-body .note.warning h6 { color: #f0ad4e; } .post-body .note.danger { border-left-color: #d9534f; } .post-body .note.danger h2, .post-body .note.danger h3, .post-body .note.danger h4, .post-body .note.danger h5, .post-body .note.danger h6 { color: #d9534f; } .post-body .tabs { position: relative; display: block; margin-bottom: 20px; padding-top: 10px; } .post-body .tabs ul.nav-tabs { margin: 0; padding: 0; display: flex; margin-bottom: -1px; } @media (max-width: 413px) { .post-body .tabs ul.nav-tabs { display: block; margin-bottom: 5px; } } .post-body .tabs ul.nav-tabs li.tab { list-style-type: none !important; margin: 0 0.25em 0 0; border-top: 3px solid transparent; border-left: 1px solid transparent; border-right: 1px solid transparent; } @media (max-width: 413px) { .post-body .tabs ul.nav-tabs li.tab { margin: initial; border-top: 1px solid transparent; border-left: 3px solid transparent; border-right: 1px solid transparent; border-bottom: 1px solid transparent; } } .post-body .tabs ul.nav-tabs li.tab a { outline: 0; border-bottom: initial; display: block; line-height: 1.8em; padding: 0.25em 0.75em; transition-duration: 0.2s; transition-timing-function: ease-out; transition-delay: 0s; } .post-body .tabs ul.nav-tabs li.tab a i { width: 1.285714285714286em; } .post-body .tabs ul.nav-tabs li.tab.active { border-top: 3px solid #fc6423; border-left: 1px solid #ddd; border-right: 1px solid #ddd; background-color: #fff; } @media (max-width: 413px) { .post-body .tabs ul.nav-tabs li.tab.active { border-top: 1px solid #ddd; border-left: 3px solid #fc6423; border-right: 1px solid #ddd; border-bottom: 1px solid #ddd; } } .post-body .tabs ul.nav-tabs li.tab.active a { cursor: default; color: #555; } .post-body .tabs .tab-content { background-color: #fff; } .post-body .tabs .tab-content .tab-pane { border: 1px solid #ddd; padding: 20px 20px 0 20px; } .post-body .tabs .tab-content .tab-pane:not(.active) { display: none; } .post-body .tabs .tab-content .tab-pane.active { display: block; } .btn { display: inline-block; padding: 0 20px; font-size: 14px; color: #555; background: #fff; border: 2px solid #555; text-decoration: none; border-radius: 2px; transition-property: background-color; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; line-height: 2; } .btn:hover { border-color: #222; color: #fff; background: #222; } .btn +.btn { margin: 0 0 8px 8px; } .btn .fa-fw { width: 1.285714285714286em; text-align: left; } .btn-bar { display: block; width: 22px; height: 2px; background: #555; border-radius: 1px; } .btn-bar+.btn-bar { margin-top: 4px; } .pagination { margin: 120px 0 40px; text-align: center; border-top: 1px solid #eee; } .page-number-basic, .pagination .prev, .pagination .next, .pagination .page-number, .pagination .space { display: inline-block; position: relative; top: -1px; margin: 0 10px; padding: 0 11px; } @media (max-width: 767px) { .page-number-basic, .pagination .prev, .pagination .next, .pagination .page-number, .pagination .space { margin: 0 5px; } } .pagination .prev, .pagination .next, .pagination .page-number { border-bottom: 0; border-top: 1px solid #eee; transition-property: border-color; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; } .pagination .prev:hover, .pagination .next:hover, .pagination .page-number:hover { border-top-color: #222; } .pagination .space { padding: 0; margin: 0; } .pagination .prev { margin-left: 0; } .pagination .next { margin-right: 0; } .pagination .page-number.current { color: #fff; background: #ccc; border-top-color: #ccc; } @media (max-width: 767px) { .pagination { border-top: none; } .pagination .prev, .pagination .next, .pagination .page-number { margin-bottom: 10px; border-top: 0; border-bottom: 1px solid #eee; padding: 0 10px; } .pagination .prev:hover, .pagination .next:hover, .pagination .page-number:hover { border-bottom-color: #222; } } .comments { margin: 60px 20px 0; } .back-to-top { box-sizing: border-box; position: fixed; bottom: -100px; right: 30px; z-index: 1050; padding: 0 6px; width: initial; background: #222; font-size: 12px; opacity: 0.6; color: #fff; cursor: pointer; text-align: center; transition-property: bottom; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; } .back-to-top.back-to-top-on { bottom: 30px; } .back-to-top:hover { color: #fc6423; } .header { background: transparent; } .header-inner { position: relative; } .headband { height: 3px; background: #222; } .site-meta { margin: 0; text-align: center; } @media (max-width: 767px) { .site-meta { text-align: center; } } .brand { position: relative; display: inline-block; padding: 0 40px; color: #fff; background: #222; border-bottom: none; } .brand:hover { color: #fff; } .logo { display: inline-block; margin-right: 5px; line-height: 36px; vertical-align: top; } .site-title { display: inline-block; vertical-align: top; line-height: 36px; font-size: 20px; font-weight: normal; font-family: 'Lato', "PingFang SC", "Microsoft YaHei", sans-serif; } .site-subtitle { margin-top: 10px; font-size: 13px; color: #ddd; } .use-motion .brand { opacity: 0; } .use-motion .logo, .use-motion .site-title, .use-motion .site-subtitle, .use-motion .custom-logo-image { opacity: 0; position: relative; top: -10px; } .site-nav-toggle { display: none; position: absolute; top: 10px; left: 10px; } @media (max-width: 767px) { .site-nav-toggle { display: block; } } .site-nav-toggle button { margin-top: 2px; padding: 9px 10px; background: transparent; border: none; } @media (max-width: 767px) { .site-nav { display: none; margin: 0 -10px; padding: 0 10px; clear: both; border-top: 1px solid #ddd; } } @media (min-width: 768px) and (max-width: 991px) { .site-nav { display: block !important; } } @media (min-width: 992px) { .site-nav { display: block !important; } } .menu { margin-top: 20px; padding-left: 0; text-align: center; } .menu .menu-item { display: inline-block; margin: 0 10px; list-style: none; } @media (max-width: 767px) { .menu .menu-item { margin-top: 10px; } } .menu .menu-item a, .menu .menu-item span.exturl { display: block; font-size: 13px; line-height: inherit; border-bottom: 1px solid transparent; transition-property: border-color; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; } .menu .menu-item a:hover, .menu .menu-item span.exturl:hover { border-bottom-color: #222; } .menu .menu-item .fa { margin-right: 5px; } .use-motion .menu-item { opacity: 0; } .post-body { overflow-wrap: break-word; word-wrap: break-word; font-family: 'Lato', "PingFang SC", "Microsoft YaHei", sans-serif; } .post-body span.exturl .fa { font-size: 14px; margin-left: 4px; } .post-body .fancybox img { display: block !important; margin: 0 auto; cursor: pointer; cursor: zoom-in; } .post-body .image-caption, .post-body .figure .caption { margin: -20px auto 15px; text-align: center; font-size: 14px; color: #999; font-weight: bold; line-height: 1; } .post-sticky-flag { display: inline-block; font-size: 16px; transform: rotate(30deg); } .use-motion .post-block, .use-motion .pagination, .use-motion .comments { opacity: 0; } .use-motion .post-header { opacity: 0; } .use-motion .post-body { opacity: 0; } .use-motion .collection-title { opacity: 0; } .posts-expand { padding-top: 40px; } @media (max-width: 767px) { .posts-expand { margin: 0 20px; } .post-body pre .gutter pre { padding-right: 10px; } .post-body .highlight { margin-left: 0px; margin-right: 0px; padding: 0; } .post-body .highlight .gutter pre { padding-right: 10px; } } @media (min-width: 992px) { .posts-expand .post-body { text-align: justify; } } @media (max-width: 991px) { .posts-expand .post-body { text-align: justify; } } .posts-expand .post-body h2, .posts-expand .post-body h3, .posts-expand .post-body h4, .posts-expand .post-body h5, .posts-expand .post-body h6 { padding-top: 10px; } .posts-expand .post-body h2 .header-anchor, .posts-expand .post-body h3 .header-anchor, .posts-expand .post-body h4 .header-anchor, .posts-expand .post-body h5 .header-anchor, .posts-expand .post-body h6 .header-anchor { float: right; margin-left: 10px; color: #ccc; border-bottom-style: none; visibility: hidden; } .posts-expand .post-body h2 .header-anchor:hover, .posts-expand .post-body h3 .header-anchor:hover, .posts-expand .post-body h4 .header-anchor:hover, .posts-expand .post-body h5 .header-anchor:hover, .posts-expand .post-body h6 .header-anchor:hover { color: inherit; } .posts-expand .post-body h2:hover .header-anchor, .posts-expand .post-body h3:hover .header-anchor, .posts-expand .post-body h4:hover .header-anchor, .posts-expand .post-body h5:hover .header-anchor, .posts-expand .post-body h6:hover .header-anchor { visibility: visible; } .posts-expand .post-body img { box-sizing: border-box; margin: 0 auto 25px; padding: 3px; border: 1px solid #ddd; } @media (max-width: 767px) { .posts-collapse { margin: 0 20px; } .posts-collapse .post-title, .posts-collapse .post-meta { display: block; width: auto; text-align: left; } } .posts-collapse { position: relative; z-index: 1010; margin-left: 55px; } .posts-collapse::after { content: " "; position: absolute; top: 20px; left: 0; margin-left: -2px; width: 4px; height: 100%; background: #f5f5f5; z-index: -1; } @media (max-width: 767px) { .posts-collapse { margin: 0 20px; } } .posts-collapse .collection-title { position: relative; margin: 60px 0; } .posts-collapse .collection-title h1, .posts-collapse .collection-title h2 { margin-left: 20px; } .posts-collapse .collection-title small { color: #bbb; margin-left: 5px; } .posts-collapse .collection-title::before { content: " "; position: absolute; left: 0; top: 50%; margin-left: -4px; margin-top: -4px; width: 8px; height: 8px; background: #bbb; border-radius: 50%; } .posts-collapse .post { margin: 30px 0; } .posts-collapse .post-header { position: relative; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; transition-property: border; border-bottom: 1px dashed #ccc; } .posts-collapse .post-header::before { content: " "; position: absolute; left: 0; top: 12px; width: 6px; height: 6px; margin-left: -4px; background: #bbb; border-radius: 50%; border: 1px solid #fff; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; transition-property: background; } .posts-collapse .post-header:hover { border-bottom-color: #666; } .posts-collapse .post-header:hover::before { background: #222; } .posts-collapse .post-meta { position: absolute; font-size: 12px; left: 20px; top: 5px; } .posts-collapse .post-comments-count { display: none; } .posts-collapse .post-title { margin-left: 60px; font-size: 16px; font-weight: normal; line-height: inherit; } .posts-collapse .post-title::after { margin-left: 3px; opacity: 0.6; } .posts-collapse .post-title a, .posts-collapse .post-title span.exturl { color: #666; border-bottom: none; } .page-home .post-type-quote .post-header, .page-post-detail .post-type-quote .post-header, .page-home .post-type-quote .post-tags, .page-post-detail .post-type-quote .post-tags { display: none; } .posts-expand .post-title { overflow-wrap: break-word; word-wrap: break-word; text-align: center; font-weight: 400; } .posts-expand .post-title-link { display: inline-block; position: relative; color: #555; border-bottom: none; line-height: 1.2; vertical-align: top; } .posts-expand .post-title-link::before { content: ""; position: absolute; width: 100%; height: 2px; bottom: 0; left: 0; background-color: #000; visibility: hidden; transform: scaleX(0); transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; } .posts-expand .post-title-link:hover::before { visibility: visible; transform: scaleX(1); } .posts-expand .post-title-link .fa { font-size: 20px; margin-left: 5px; } .posts-expand .post-meta { margin: 3px 0 60px 0; color: #999; font-family: 'Lato', "PingFang SC", "Microsoft YaHei", sans-serif; font-size: 12px; text-align: center; } .posts-expand .post-meta .post-category-list { display: inline-block; margin: 0; padding: 3px; } .posts-expand .post-meta .post-category-list-link { color: #999; } .posts-expand .post-meta .post-description { font-size: 14px; margin-top: 2px; } .posts-expand .post-meta time { border-bottom: 1px dashed #999; cursor: help; } .post-meta-divider { margin: 0 0.5em; } .post-meta-item-icon { margin-right: 3px; } @media (min-width: 768px) and (max-width: 991px) { .post-meta-item-icon { display: inline-block; } } @media (max-width: 767px) { .post-meta-item-icon { display: inline-block; } } @media (min-width: 768px) and (max-width: 991px) { .post-meta-item-text { display: none; } } @media (max-width: 767px) { .post-meta-item-text { display: none; } } .post-button { margin-top: 40px; } .posts-expand .post-tags { margin-top: 40px; text-align: center; } .posts-expand .post-tags a { display: inline-block; margin-right: 10px; font-size: 13px; } .post-nav { display: table; margin-top: 15px; width: 100%; border-top: 1px solid #eee; } .post-nav-divider { display: table-cell; width: 10%; } .post-nav-item { display: table-cell; padding: 10px 0 0 0; width: 45%; vertical-align: top; } .post-nav-item a { position: relative; display: block; line-height: 25px; font-size: 14px; color: #555; border-bottom: none; } .post-nav-item a:hover { color: #222; border-bottom: none; } .post-nav-item a:active { top: 2px; } .post-nav-item .fa { font-size: 12px; margin-right: 5px; } .post-nav-next a { padding-left: 5px; } .post-nav-prev { text-align: right; } .post-nav-prev a { padding-right: 5px; } .post-nav-prev .fa { margin-left: 5px; } .posts-expand .post-eof { display: block; margin: 80px auto 60px; width: 8%; height: 1px; background: #ccc; text-align: center; } .post:last-child .post-eof.post-eof.post-eof { display: none; } .post-gallery { display: table; table-layout: fixed; width: 100%; border-collapse: separate; } .post-gallery-row { display: table-row; } .post-gallery .post-gallery-img { display: table-cell; text-align: center; vertical-align: middle; border: none; } .post-gallery .post-gallery-img img { max-width: 100%; max-height: 100%; border: none; } .fancybox-close, .fancybox-close:hover { border: none; } .rtl.post-body p, .rtl.post-body a, .rtl.post-body h1, .rtl.post-body h2, .rtl.post-body h3, .rtl.post-body h4, .rtl.post-body h5, .rtl.post-body h6, .rtl.post-body li, .rtl.post-body ul, .rtl.post-body ol { direction: rtl; font-family: UKIJ Ekran; } .rtl.post-title { font-family: UKIJ Ekran; } .sidebar { position: fixed; right: 0; top: 0; bottom: 0; width: 0; z-index: 1040; box-shadow: inset 0 2px 6px #000; background: #222; } .sidebar a, .sidebar span.exturl { color: #999; border-bottom-color: #555; } .sidebar a:hover, .sidebar span.exturl:hover { color: #eee; border-bottom-color: #eee; } @media (max-width: 991px) { .sidebar { display: none; } } .sidebar-inner { position: relative; padding: 20px 10px; color: #999; text-align: center; } .site-overview-wrap { overflow: hidden; } .site-overview { overflow-y: auto; overflow-x: hidden; } .cc-license { margin-top: 10px; text-align: center; } .cc-license .cc-opacity { opacity: 0.7; border-bottom: none; } .cc-license .cc-opacity:hover { opacity: 0.9; } .cc-license img { display: inline-block; } .sidebar-toggle { position: fixed; right: 30px; bottom: 45px; width: 14px; height: 14px; padding: 5px; background: #222; line-height: 0; z-index: 1050; cursor: pointer; } .sidebar-toggle:hover .sidebar-toggle-line { background: #fc6423; } @media (max-width: 991px) { .sidebar-toggle { display: none; } } .sidebar-toggle-line { position: relative; display: inline-block; vertical-align: top; height: 2px; width: 100%; background: #fff; margin-top: 3px; } .sidebar-toggle-line:first-child { margin-top: 0; } .site-author-image { display: block; margin: 0 auto; padding: 2px; max-width: 120px; height: auto; border: 1px solid #eee; opacity: 1; } .site-author-name { margin: 0; text-align: center; color: #222; font-weight: 600; } .site-description { margin-top: 0; text-align: center; font-size: 13px; color: #999; } .links-of-author { margin-top: 20px; } .links-of-author a, .links-of-author span.exturl { display: inline-block; vertical-align: middle; margin-right: 10px; margin-bottom: 10px; border-bottom-color: #555; font-size: 13px; } .links-of-author a:before, .links-of-author span.exturl:before { display: inline-block; vertical-align: middle; margin-right: 3px; content: " "; width: 4px; height: 4px; border-radius: 50%; background: #30ff6f; } .feed-link, .chat { margin-top: 10px; } .feed-link a, .chat a { display: inline-block; padding: 0 15px; color: #fc6423; border: 1px solid #fc6423 !important; border-radius: 4px; } .feed-link a i, .chat a i { color: #fc6423; font-size: 14px; } .feed-link a:hover, .chat a:hover { color: #fff; background: #fc6423; } .feed-link a:hover i, .chat a:hover i { color: #fff; } .links-of-blogroll { margin-top: 10px; font-size: 13px; } .links-of-blogroll-title { margin-top: 0; font-size: 14px; font-weight: 600; } .links-of-blogroll-list { margin: 0; padding: 0; list-style: none; } .links-of-blogroll-item { padding: 2px 10px; } .links-of-blogroll-item a, .links-of-blogroll-item span.exturl { max-width: 280px; box-sizing: border-box; display: inline-block; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .sidebar-nav { margin: 0 0 20px; padding-left: 0; } .sidebar-nav li { display: inline-block; cursor: pointer; border-bottom: 1px solid transparent; font-size: 14px; color: #555; } .sidebar-nav li:hover { color: #fc6423; } .page-post-detail .sidebar-nav-toc { padding: 0 5px; } .page-post-detail .sidebar-nav-overview { margin-left: 10px; } .sidebar-nav .sidebar-nav-active { color: #fc6423; border-bottom-color: #fc6423; } .sidebar-nav .sidebar-nav-active:hover { color: #fc6423; } .sidebar-panel { display: none; } .sidebar-panel-active { display: block; } .site-state { display: flex; justify-content: center; overflow: hidden; line-height: 1.4; white-space: nowrap; text-align: center; margin-top: 10px; } .site-state-item { padding: 0 15px; border-left: 1px solid #eee; } .site-state-item:first-child { border-left: none; } .site-state-item a { border-bottom: none; } .site-state-item-count { display: block; text-align: center; color: inherit; font-weight: 600; font-size: 16px; } .site-state-item-name { font-size: 13px; color: #999; } .post-toc-empty { font-size: 14px; color: #666; } .post-toc-wrap { overflow: hidden; } .post-toc { overflow: auto; } .post-toc ol { margin: 0; padding: 0 2px 5px 10px; text-align: left; list-style: none; font-size: 14px; } .post-toc ol > ol { padding-left: 0; } .post-toc ol a { transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; transition-property: all; color: #666; border-bottom-color: #ccc; } .post-toc ol a:hover { color: #000; border-bottom-color: #000; } .post-toc .nav-item { overflow: hidden; text-overflow: ellipsis; white-space: nowrap; line-height: 1.8; } .post-toc .nav .nav-child { display: none; } .post-toc .nav .active > .nav-child { display: block; } .post-toc .nav .active-current > .nav-child { display: block; } .post-toc .nav .active-current > .nav-child > .nav-item { display: block; } .post-toc .nav .active > a { color: #fc6423; border-bottom-color: #fc6423; } .post-toc .nav .active-current > a { color: #fc6423; } .post-toc .nav .active-current > a:hover { color: #fc6423; } .footer { font-size: 14px; color: #999; } .footer img { border: none; } .footer-inner { text-align: center; } .with-love { display: inline-block; margin: 0 5px; color: #808080; } .powered-by, .theme-info { display: inline-block; } @-moz-keyframes iconAnimate { 0%, 100% { transform: scale(1); } 10%, 30% { transform: scale(0.9); } 20%, 40%, 60%, 80% { transform: scale(1.1); } 50%, 70% { transform: scale(1.1); } } @-webkit-keyframes iconAnimate { 0%, 100% { transform: scale(1); } 10%, 30% { transform: scale(0.9); } 20%, 40%, 60%, 80% { transform: scale(1.1); } 50%, 70% { transform: scale(1.1); } } @-o-keyframes iconAnimate { 0%, 100% { transform: scale(1); } 10%, 30% { transform: scale(0.9); } 20%, 40%, 60%, 80% { transform: scale(1.1); } 50%, 70% { transform: scale(1.1); } } @keyframes iconAnimate { 0%, 100% { transform: scale(1); } 10%, 30% { transform: scale(0.9); } 20%, 40%, 60%, 80% { transform: scale(1.1); } 50%, 70% { transform: scale(1.1); } } .local-search-pop-overlay { position: fixed; width: 100%; height: 100%; top: 0; left: 0; z-index: 2080; background-color: rgba(0,0,0,0.3); } .local-search-popup { display: none; position: fixed; top: 10%; left: 50%; margin-left: -350px; width: 700px; height: 80%; padding: 0; background: #fff; color: #333; z-index: 9999; border-radius: 5px; } @media (max-width: 767px) { .local-search-popup { padding: 0; top: 0; left: 0; margin: 0; width: 100%; height: 100%; border-radius: 0; } } .local-search-popup ul.search-result-list { padding: 0; margin: 0 5px; } .local-search-popup p.search-result { border-bottom: 1px dashed #ccc; padding: 5px 0; } .local-search-popup a.search-result-title { font-weight: bold; font-size: 16px; } .local-search-popup .search-keyword { border-bottom: 1px dashed #f00; font-weight: bold; color: #f00; } .local-search-popup .local-search-header { padding: 5px; height: 36px; background: #f5f5f5; border-top-left-radius: 5px; border-top-right-radius: 5px; } .local-search-popup #local-search-result { overflow: auto; position: relative; padding: 5px 25px; height: calc(100% - 55px); } .local-search-popup .local-search-input-wrapper { display: inline-block; width: calc(100% - 90px); height: 36px; line-height: 36px; padding: 0 5px; } .local-search-popup .local-search-input-wrapper input { padding: 8px 0; height: 20px; display: block; width: 100%; outline: none; border: none; background: transparent; vertical-align: middle; } .local-search-popup .search-icon, .local-search-popup .popup-btn-close { display: inline-block; font-size: 18px; color: #999; height: 36px; width: 18px; padding-left: 10px; padding-right: 10px; } .local-search-popup .search-icon { float: left; } .local-search-popup .popup-btn-close { border-left: 1px solid #eee; float: right; cursor: pointer; } .local-search-popup #no-result { position: absolute; left: 50%; top: 50%; transform: translate(-50%, -50%); color: #ccc; } .copy-btn { display: inline-block; padding: 6px 12px; font-size: 13px; font-weight: 700; line-height: 20px; color: #333; white-space: nowrap; vertical-align: middle; cursor: pointer; background-color: #eee; background-image: linear-gradient(#fcfcfc, #eee); border: 1px solid #d5d5d5; border-radius: 3px; user-select: none; outline: 0; } .highlight-wrap .copy-btn { transition: opacity 0.3s ease-in-out; opacity: 0; padding: 2px 6px; position: absolute; right: 4px; top: 8px; } .highlight-wrap:hover .copy-btn, .highlight-wrap .copy-btn:focus { opacity: 1; } .highlight-wrap { position: relative; } .page-archive .archive-page-counter { position: relative; top: 3px; left: 20px; } @media (max-width: 767px) { .page-archive .archive-page-counter { top: 5px; } } .page-archive .posts-collapse .archive-move-on { position: absolute; top: 11px; left: 0; margin-left: -6px; width: 10px; height: 10px; opacity: 0.5; background: #555; border: 1px solid #fff; border-radius: 50%; } .page-archive .fa-external-link { font-size: 15px; margin-left: 5px; } .category-all-page .category-all-title { text-align: center; } .category-all-page .category-all { margin-top: 20px; } .category-all-page .category-list { margin: 0; padding: 0; list-style: none; } .category-all-page .category-list-item { margin: 5px 10px; } .category-all-page .category-list-count { color: #bbb; } .category-all-page .category-list-count:before { display: inline; content: " ("; } .category-all-page .category-list-count:after { display: inline; content: ") "; } .category-all-page .category-list-child { padding-left: 10px; } #event-list { padding-left: 30px; } #event-list hr { margin: 20px 0 45px 0 !important; background: #222; } #event-list hr:after { display: inline-block; content: 'NOW'; background: #222; color: #fff; font-weight: bold; text-align: right; padding: 0 5px; } #event-list li.event { margin: 20px 0px; background: #f9f9f9; padding-left: 10px; min-height: 40px; } #event-list li.event h2.event-summary { margin: 0; padding-bottom: 3px; } #event-list li.event h2.event-summary:before { display: inline-block; font-family: FontAwesome; font-size: 8px; content: '\f111'; vertical-align: middle; margin-right: 25px; color: #bbb; } #event-list li.event span.event-relative-time { display: inline-block; font-size: 12px; font-weight: 400; padding-left: 12px; color: #bbb; } #event-list li.event span.event-details { display: block; color: #bbb; margin-left: 56px; padding-top: 3px; padding-bottom: 6px; text-indent: -24px; line-height: 18px; } #event-list li.event span.event-details:before { text-indent: 0; display: inline-block; width: 14px; font-family: FontAwesome; text-align: center; margin-right: 9px; color: #bbb; } #event-list li.event span.event-details.event-location:before { content: '\f041'; } #event-list li.event span.event-details.event-duration:before { content: '\f017'; } #event-list li.event-past { background: #fcfcfc; padding: 15px 0 15px 10px; } #event-list li.event-past > * { opacity: 0.9; } #event-list li.event-past h2.event-summary { color: #bbb; } #event-list li.event-past h2.event-summary:before { color: #dfdfdf; } #event-list li.event-now { background: #222; color: #fff; padding: 15px 0 15px 10px; } #event-list li.event-now h2.event-summary:before { transform: scale(1.2); color: #fff; animation: dot-flash 1s alternate infinite ease-in-out; } #event-list li.event-now * { color: #fff !important; } #event-list li.event-future { background: #222; color: #fff; padding: 15px 0 15px 10px; } #event-list li.event-future h2.event-summary:before { transform: scale(1.2); color: #fff; animation: dot-flash 1s alternate infinite ease-in-out; } #event-list li.event-future * { color: #fff !important; } @-moz-keyframes dot-flash { from { opacity: 1; transform: scale(1.1); } to { opacity: 0; transform: scale(1); } } @-webkit-keyframes dot-flash { from { opacity: 1; transform: scale(1.1); } to { opacity: 0; transform: scale(1); } } @-o-keyframes dot-flash { from { opacity: 1; transform: scale(1.1); } to { opacity: 0; transform: scale(1); } } @keyframes dot-flash { from { opacity: 1; transform: scale(1.1); } to { opacity: 0; transform: scale(1); } } .page-post-detail .sidebar-toggle-line { background: #fc6423; } .page-post-detail .comments { overflow: hidden; } ul.breadcrumb { list-style: none; margin: 1em 0; padding: 0 2em; text-align: center; font-size: 12px; } ul.breadcrumb li { display: inline; } ul.breadcrumb li+li:before { padding: 0.5em; font-weight: normal; content: "/\00a0"; } ul.breadcrumb li+li:last-child { font-weight: bold; } .tag-cloud { text-align: center; } .tag-cloud a { display: inline-block; margin: 10px; } .tag-cloud a:hover { color: #222 !important; } .header { position: relative; margin: 0 auto; width: calc(100% - 20px); } @media (min-width: 1200px) { .header { width: 1160px; } } @media (min-width: 1600px) { .header { width: 73%; } } @media (max-width: 991px) { .header { width: auto; } } .header-inner { position: absolute; top: 0; overflow: hidden; padding: 0; width: 240px; background: #fff; box-shadow: initial; border-radius: initial; } @media (min-width: 1200px) { .container .header-inner { width: 240px; } } @media (max-width: 991px) { .header-inner { position: relative; width: auto; border-radius: initial; } } .main:before, .main:after { content: " "; display: table; } .main:after { clear: both; } @media (max-width: 991px) { .container .main-inner { width: auto; } } .content-wrap { float: right; box-sizing: border-box; padding: 40px; width: calc(100% - 252px); background: #fff; min-height: 700px; box-shadow: initial; border-radius: initial; } @media (min-width: 768px) and (max-width: 991px) { .content-wrap { width: 100%; padding: 20px; border-radius: initial; } } @media (max-width: 767px) { .content-wrap { width: 100%; padding: 20px; min-height: auto; border-radius: initial; } } .sidebar { position: static; float: left; margin-left: -100%; width: 240px; background: #f5f7f9; box-shadow: none; } @media (max-width: 991px) { .sidebar { display: none; } } .sidebar-toggle { display: none; } .footer-inner { padding-left: 260px; } @media (max-width: 991px) { .footer-inner { width: auto; padding-left: 0 !important; padding-right: 0 !important; } } .sidebar-position-right .header-inner { right: 0; } .sidebar-position-right .content-wrap { float: left; } .sidebar-position-right .sidebar { float: right; } .sidebar-position-right .footer-inner { padding-left: 0; padding-right: 260px; } .site-brand-wrapper { position: relative; } .site-meta { padding: 20px 0; color: #fff; background: #222; } @media (max-width: 991px) { .site-meta { box-shadow: 0 0 16px rgba(0,0,0,0.5); } } .brand { padding: 0; background: none; } .brand:hover { color: #fff; } .site-subtitle { margin: 10px 10px 0; font-weight: initial; } .custom-logo-image { margin-top: 20px; } @media (max-width: 991px) { .custom-logo-image { display: none; } } .site-search form { display: none; } .site-nav { border-top: none; } @media (min-width: 768px) and (max-width: 991px) { .site-nav { display: none !important; } } @media (min-width: 768px) and (max-width: 991px) { .site-nav-on { display: block !important; } } .menu-item-active a, .menu .menu-item a:hover, .menu .menu-item span.exturl:hover { background: #f9f9f9; border-bottom-color: #fff; } .menu-item-active a:after, .menu .menu-item a:hover:after, .menu .menu-item span.exturl:hover:after { content: " "; position: absolute; top: 50%; margin-top: -3px; right: 15px; width: 6px; height: 6px; border-radius: 50%; background-color: #bbb; } .menu .menu-item { display: block; margin: 0; } .menu .menu-item a, .menu .menu-item span.exturl { position: relative; box-sizing: border-box; padding: 5px 20px; text-align: left; line-height: inherit; transition-property: background-color; transition-duration: 0.2s; transition-timing-function: ease-in-out; transition-delay: 0s; } @media (hover: none) { .menu .menu-item a:hover, .menu .menu-item span.exturl:hover { background: none; } } .menu .menu-item .badge { display: inline-block; padding: 2px 5px; font-weight: 700; line-height: 1; color: #fff; text-align: center; white-space: nowrap; vertical-align: middle; background-color: #ccc; border-radius: 10px; float: right; margin: 0.35em 0 0 0; text-shadow: 1px 1px 0px rgba(0,0,0,0.1); } .menu .menu-item br { display: none; } .btn-bar { background-color: #fff; } .site-nav-toggle { left: 20px; top: 50%; transform: translateY(-50%); } @media (min-width: 768px) and (max-width: 991px) { .site-nav-toggle { display: block; } } .sub-menu { margin: 0; padding: 6px 0; background: #fff !important; border-bottom: 1px solid #ddd; } .sub-menu .menu-item { display: inline-block !important; } .sub-menu .menu-item a, .sub-menu .menu-item span.exturl { padding: initial !important; margin: 5px 10px; } .sub-menu .menu-item a:hover, .sub-menu .menu-item span.exturl:hover { background: initial !important; color: #fc6423; } .sub-menu .menu-item-active a { background: #fff !important; color: #fc6423; border-bottom-color: #fc6423; } .sub-menu .menu-item-active a:hover { background: #fff !important; border-bottom-color: #fc6423; } .sub-menu .menu-item-active a:after { content: initial; } .use-motion .sidebar .motion-element { opacity: 1; } .sidebar { right: auto; bottom: auto; -webkit-transform: none; } .sidebar a, .sidebar span.exturl { color: #555; } .sidebar a:hover, .sidebar span.exturl:hover { color: #222; border-bottom-color: #222; } .sidebar-inner { box-sizing: border-box; width: 240px; color: #555; background: #fff; box-shadow: initial; border-radius: initial; opacity: 0; } .sidebar-inner.affix { position: fixed; top: 12px; } .sidebar-inner.affix-bottom { position: absolute; } .site-overview { text-align: left; } .site-author:before, .site-author:after { content: " "; display: table; } .site-author:after { clear: both; } .site-state-item { padding: 0 10px; } .feed-link, .chat { border-top: 1px dotted #ccc; border-bottom: 1px dotted #ccc; text-align: center; } .feed-link a, .chat a { display: block; color: #fc6423; border: none; } .feed-link a:hover, .chat a:hover { background: none; color: #e34603; } .feed-link a:hover i, .chat a:hover i { color: #e34603; } .links-of-author { display: flex; flex-wrap: wrap; justify-content: center; } .links-of-author span.exturl { font-size: 13px; } .links-of-author-item { margin: 5px 0 0; width: 50%; } .links-of-author-item a, .links-of-author-item span.exturl { max-width: 216px; box-sizing: border-box; display: inline-block; margin-right: 0; margin-bottom: 0; padding: 0 5px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; } .links-of-author-item a:before, .links-of-author-item span.exturl:before { display: none; } .links-of-author-item a, .links-of-author-item span.exturl { border-bottom: none; text-decoration: underline; } .links-of-author-item a, .links-of-author-item span.exturl { display: block; text-decoration: none; } .links-of-author-item a:hover, .links-of-author-item span.exturl:hover { border-radius: 4px; background: #eee; } .links-of-author-item .fa { margin-right: 2px; font-size: 16px; } .links-of-author-item .fa-globe { font-size: 15px; } .links-of-blogroll { text-align: center; padding: 3px 0 0; } .links-of-blogroll-item { padding: 0; } .links-of-blogroll-inline:before, .links-of-blogroll-inline:after { content: " "; display: table; } .links-of-blogroll-inline:after { clear: both; } .links-of-blogroll-inline .links-of-blogroll-item { margin: 5px 0 0; width: 50%; display: inline-block; width: unset; } .links-of-blogroll-inline .links-of-blogroll-item a, .links-of-blogroll-inline .links-of-blogroll-item span.exturl { max-width: 216px; box-sizing: border-box; display: inline-block; margin-right: 0; margin-bottom: 0; padding: 0 5px; overflow: hidden; white-space: nowrap; text-overflow: ellipsis; }]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F2020%2F12%2F08%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F%E7%AC%AC3%E7%AB%A0%20Python%E7%9A%84%E5%9B%BE%E8%A1%A8%E7%BB%98%E5%88%B6%20_%20%E8%BD%A6%E6%96%8C%E7%9A%84%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2_files%2Ffont-awesome.min%2F</url>
    <content type="text"><![CDATA[/*! * Font Awesome 4.7.0 by @davegandy - http://fontawesome.io - @fontawesome * License - http://fontawesome.io/license (Font: SIL OFL 1.1, CSS: MIT License) */@font-face{font-family:'FontAwesome';src:url('../fonts/fontawesome-webfont.eot?v=4.7.0');src:url('../fonts/fontawesome-webfont.eot?#iefix&v=4.7.0') format('embedded-opentype'),url('../fonts/fontawesome-webfont.woff2?v=4.7.0') format('woff2'),url('../fonts/fontawesome-webfont.woff?v=4.7.0') format('woff'),url('../fonts/fontawesome-webfont.ttf?v=4.7.0') format('truetype'),url('../fonts/fontawesome-webfont.svg?v=4.7.0#fontawesomeregular') format('svg');font-weight:normal;font-style:normal}.fa{display:inline-block;font:normal normal normal 14px/1 FontAwesome;font-size:inherit;text-rendering:auto;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale}.fa-lg{font-size:1.33333333em;line-height:.75em;vertical-align:-15%}.fa-2x{font-size:2em}.fa-3x{font-size:3em}.fa-4x{font-size:4em}.fa-5x{font-size:5em}.fa-fw{width:1.28571429em;text-align:center}.fa-ul{padding-left:0;margin-left:2.14285714em;list-style-type:none}.fa-ul>li{position:relative}.fa-li{position:absolute;left:-2.14285714em;width:2.14285714em;top:.14285714em;text-align:center}.fa-li.fa-lg{left:-1.85714286em}.fa-border{padding:.2em .25em .15em;border:solid .08em #eee;border-radius:.1em}.fa-pull-left{float:left}.fa-pull-right{float:right}.fa.fa-pull-left{margin-right:.3em}.fa.fa-pull-right{margin-left:.3em}.pull-right{float:right}.pull-left{float:left}.fa.pull-left{margin-right:.3em}.fa.pull-right{margin-left:.3em}.fa-spin{-webkit-animation:fa-spin 2s infinite linear;animation:fa-spin 2s infinite linear}.fa-pulse{-webkit-animation:fa-spin 1s infinite steps(8);animation:fa-spin 1s infinite steps(8)}@-webkit-keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}@keyframes fa-spin{0%{-webkit-transform:rotate(0deg);transform:rotate(0deg)}100%{-webkit-transform:rotate(359deg);transform:rotate(359deg)}}.fa-rotate-90{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=1)";-webkit-transform:rotate(90deg);-ms-transform:rotate(90deg);transform:rotate(90deg)}.fa-rotate-180{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2)";-webkit-transform:rotate(180deg);-ms-transform:rotate(180deg);transform:rotate(180deg)}.fa-rotate-270{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=3)";-webkit-transform:rotate(270deg);-ms-transform:rotate(270deg);transform:rotate(270deg)}.fa-flip-horizontal{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=0, mirror=1)";-webkit-transform:scale(-1, 1);-ms-transform:scale(-1, 1);transform:scale(-1, 1)}.fa-flip-vertical{-ms-filter:"progid:DXImageTransform.Microsoft.BasicImage(rotation=2, mirror=1)";-webkit-transform:scale(1, -1);-ms-transform:scale(1, -1);transform:scale(1, -1)}:root .fa-rotate-90,:root .fa-rotate-180,:root .fa-rotate-270,:root .fa-flip-horizontal,:root .fa-flip-vertical{filter:none}.fa-stack{position:relative;display:inline-block;width:2em;height:2em;line-height:2em;vertical-align:middle}.fa-stack-1x,.fa-stack-2x{position:absolute;left:0;width:100%;text-align:center}.fa-stack-1x{line-height:inherit}.fa-stack-2x{font-size:2em}.fa-inverse{color:#fff}.fa-glass:before{content:"\f000"}.fa-music:before{content:"\f001"}.fa-search:before{content:"\f002"}.fa-envelope-o:before{content:"\f003"}.fa-heart:before{content:"\f004"}.fa-star:before{content:"\f005"}.fa-star-o:before{content:"\f006"}.fa-user:before{content:"\f007"}.fa-film:before{content:"\f008"}.fa-th-large:before{content:"\f009"}.fa-th:before{content:"\f00a"}.fa-th-list:before{content:"\f00b"}.fa-check:before{content:"\f00c"}.fa-remove:before,.fa-close:before,.fa-times:before{content:"\f00d"}.fa-search-plus:before{content:"\f00e"}.fa-search-minus:before{content:"\f010"}.fa-power-off:before{content:"\f011"}.fa-signal:before{content:"\f012"}.fa-gear:before,.fa-cog:before{content:"\f013"}.fa-trash-o:before{content:"\f014"}.fa-home:before{content:"\f015"}.fa-file-o:before{content:"\f016"}.fa-clock-o:before{content:"\f017"}.fa-road:before{content:"\f018"}.fa-download:before{content:"\f019"}.fa-arrow-circle-o-down:before{content:"\f01a"}.fa-arrow-circle-o-up:before{content:"\f01b"}.fa-inbox:before{content:"\f01c"}.fa-play-circle-o:before{content:"\f01d"}.fa-rotate-right:before,.fa-repeat:before{content:"\f01e"}.fa-refresh:before{content:"\f021"}.fa-list-alt:before{content:"\f022"}.fa-lock:before{content:"\f023"}.fa-flag:before{content:"\f024"}.fa-headphones:before{content:"\f025"}.fa-volume-off:before{content:"\f026"}.fa-volume-down:before{content:"\f027"}.fa-volume-up:before{content:"\f028"}.fa-qrcode:before{content:"\f029"}.fa-barcode:before{content:"\f02a"}.fa-tag:before{content:"\f02b"}.fa-tags:before{content:"\f02c"}.fa-book:before{content:"\f02d"}.fa-bookmark:before{content:"\f02e"}.fa-print:before{content:"\f02f"}.fa-camera:before{content:"\f030"}.fa-font:before{content:"\f031"}.fa-bold:before{content:"\f032"}.fa-italic:before{content:"\f033"}.fa-text-height:before{content:"\f034"}.fa-text-width:before{content:"\f035"}.fa-align-left:before{content:"\f036"}.fa-align-center:before{content:"\f037"}.fa-align-right:before{content:"\f038"}.fa-align-justify:before{content:"\f039"}.fa-list:before{content:"\f03a"}.fa-dedent:before,.fa-outdent:before{content:"\f03b"}.fa-indent:before{content:"\f03c"}.fa-video-camera:before{content:"\f03d"}.fa-photo:before,.fa-image:before,.fa-picture-o:before{content:"\f03e"}.fa-pencil:before{content:"\f040"}.fa-map-marker:before{content:"\f041"}.fa-adjust:before{content:"\f042"}.fa-tint:before{content:"\f043"}.fa-edit:before,.fa-pencil-square-o:before{content:"\f044"}.fa-share-square-o:before{content:"\f045"}.fa-check-square-o:before{content:"\f046"}.fa-arrows:before{content:"\f047"}.fa-step-backward:before{content:"\f048"}.fa-fast-backward:before{content:"\f049"}.fa-backward:before{content:"\f04a"}.fa-play:before{content:"\f04b"}.fa-pause:before{content:"\f04c"}.fa-stop:before{content:"\f04d"}.fa-forward:before{content:"\f04e"}.fa-fast-forward:before{content:"\f050"}.fa-step-forward:before{content:"\f051"}.fa-eject:before{content:"\f052"}.fa-chevron-left:before{content:"\f053"}.fa-chevron-right:before{content:"\f054"}.fa-plus-circle:before{content:"\f055"}.fa-minus-circle:before{content:"\f056"}.fa-times-circle:before{content:"\f057"}.fa-check-circle:before{content:"\f058"}.fa-question-circle:before{content:"\f059"}.fa-info-circle:before{content:"\f05a"}.fa-crosshairs:before{content:"\f05b"}.fa-times-circle-o:before{content:"\f05c"}.fa-check-circle-o:before{content:"\f05d"}.fa-ban:before{content:"\f05e"}.fa-arrow-left:before{content:"\f060"}.fa-arrow-right:before{content:"\f061"}.fa-arrow-up:before{content:"\f062"}.fa-arrow-down:before{content:"\f063"}.fa-mail-forward:before,.fa-share:before{content:"\f064"}.fa-expand:before{content:"\f065"}.fa-compress:before{content:"\f066"}.fa-plus:before{content:"\f067"}.fa-minus:before{content:"\f068"}.fa-asterisk:before{content:"\f069"}.fa-exclamation-circle:before{content:"\f06a"}.fa-gift:before{content:"\f06b"}.fa-leaf:before{content:"\f06c"}.fa-fire:before{content:"\f06d"}.fa-eye:before{content:"\f06e"}.fa-eye-slash:before{content:"\f070"}.fa-warning:before,.fa-exclamation-triangle:before{content:"\f071"}.fa-plane:before{content:"\f072"}.fa-calendar:before{content:"\f073"}.fa-random:before{content:"\f074"}.fa-comment:before{content:"\f075"}.fa-magnet:before{content:"\f076"}.fa-chevron-up:before{content:"\f077"}.fa-chevron-down:before{content:"\f078"}.fa-retweet:before{content:"\f079"}.fa-shopping-cart:before{content:"\f07a"}.fa-folder:before{content:"\f07b"}.fa-folder-open:before{content:"\f07c"}.fa-arrows-v:before{content:"\f07d"}.fa-arrows-h:before{content:"\f07e"}.fa-bar-chart-o:before,.fa-bar-chart:before{content:"\f080"}.fa-twitter-square:before{content:"\f081"}.fa-facebook-square:before{content:"\f082"}.fa-camera-retro:before{content:"\f083"}.fa-key:before{content:"\f084"}.fa-gears:before,.fa-cogs:before{content:"\f085"}.fa-comments:before{content:"\f086"}.fa-thumbs-o-up:before{content:"\f087"}.fa-thumbs-o-down:before{content:"\f088"}.fa-star-half:before{content:"\f089"}.fa-heart-o:before{content:"\f08a"}.fa-sign-out:before{content:"\f08b"}.fa-linkedin-square:before{content:"\f08c"}.fa-thumb-tack:before{content:"\f08d"}.fa-external-link:before{content:"\f08e"}.fa-sign-in:before{content:"\f090"}.fa-trophy:before{content:"\f091"}.fa-github-square:before{content:"\f092"}.fa-upload:before{content:"\f093"}.fa-lemon-o:before{content:"\f094"}.fa-phone:before{content:"\f095"}.fa-square-o:before{content:"\f096"}.fa-bookmark-o:before{content:"\f097"}.fa-phone-square:before{content:"\f098"}.fa-twitter:before{content:"\f099"}.fa-facebook-f:before,.fa-facebook:before{content:"\f09a"}.fa-github:before{content:"\f09b"}.fa-unlock:before{content:"\f09c"}.fa-credit-card:before{content:"\f09d"}.fa-feed:before,.fa-rss:before{content:"\f09e"}.fa-hdd-o:before{content:"\f0a0"}.fa-bullhorn:before{content:"\f0a1"}.fa-bell:before{content:"\f0f3"}.fa-certificate:before{content:"\f0a3"}.fa-hand-o-right:before{content:"\f0a4"}.fa-hand-o-left:before{content:"\f0a5"}.fa-hand-o-up:before{content:"\f0a6"}.fa-hand-o-down:before{content:"\f0a7"}.fa-arrow-circle-left:before{content:"\f0a8"}.fa-arrow-circle-right:before{content:"\f0a9"}.fa-arrow-circle-up:before{content:"\f0aa"}.fa-arrow-circle-down:before{content:"\f0ab"}.fa-globe:before{content:"\f0ac"}.fa-wrench:before{content:"\f0ad"}.fa-tasks:before{content:"\f0ae"}.fa-filter:before{content:"\f0b0"}.fa-briefcase:before{content:"\f0b1"}.fa-arrows-alt:before{content:"\f0b2"}.fa-group:before,.fa-users:before{content:"\f0c0"}.fa-chain:before,.fa-link:before{content:"\f0c1"}.fa-cloud:before{content:"\f0c2"}.fa-flask:before{content:"\f0c3"}.fa-cut:before,.fa-scissors:before{content:"\f0c4"}.fa-copy:before,.fa-files-o:before{content:"\f0c5"}.fa-paperclip:before{content:"\f0c6"}.fa-save:before,.fa-floppy-o:before{content:"\f0c7"}.fa-square:before{content:"\f0c8"}.fa-navicon:before,.fa-reorder:before,.fa-bars:before{content:"\f0c9"}.fa-list-ul:before{content:"\f0ca"}.fa-list-ol:before{content:"\f0cb"}.fa-strikethrough:before{content:"\f0cc"}.fa-underline:before{content:"\f0cd"}.fa-table:before{content:"\f0ce"}.fa-magic:before{content:"\f0d0"}.fa-truck:before{content:"\f0d1"}.fa-pinterest:before{content:"\f0d2"}.fa-pinterest-square:before{content:"\f0d3"}.fa-google-plus-square:before{content:"\f0d4"}.fa-google-plus:before{content:"\f0d5"}.fa-money:before{content:"\f0d6"}.fa-caret-down:before{content:"\f0d7"}.fa-caret-up:before{content:"\f0d8"}.fa-caret-left:before{content:"\f0d9"}.fa-caret-right:before{content:"\f0da"}.fa-columns:before{content:"\f0db"}.fa-unsorted:before,.fa-sort:before{content:"\f0dc"}.fa-sort-down:before,.fa-sort-desc:before{content:"\f0dd"}.fa-sort-up:before,.fa-sort-asc:before{content:"\f0de"}.fa-envelope:before{content:"\f0e0"}.fa-linkedin:before{content:"\f0e1"}.fa-rotate-left:before,.fa-undo:before{content:"\f0e2"}.fa-legal:before,.fa-gavel:before{content:"\f0e3"}.fa-dashboard:before,.fa-tachometer:before{content:"\f0e4"}.fa-comment-o:before{content:"\f0e5"}.fa-comments-o:before{content:"\f0e6"}.fa-flash:before,.fa-bolt:before{content:"\f0e7"}.fa-sitemap:before{content:"\f0e8"}.fa-umbrella:before{content:"\f0e9"}.fa-paste:before,.fa-clipboard:before{content:"\f0ea"}.fa-lightbulb-o:before{content:"\f0eb"}.fa-exchange:before{content:"\f0ec"}.fa-cloud-download:before{content:"\f0ed"}.fa-cloud-upload:before{content:"\f0ee"}.fa-user-md:before{content:"\f0f0"}.fa-stethoscope:before{content:"\f0f1"}.fa-suitcase:before{content:"\f0f2"}.fa-bell-o:before{content:"\f0a2"}.fa-coffee:before{content:"\f0f4"}.fa-cutlery:before{content:"\f0f5"}.fa-file-text-o:before{content:"\f0f6"}.fa-building-o:before{content:"\f0f7"}.fa-hospital-o:before{content:"\f0f8"}.fa-ambulance:before{content:"\f0f9"}.fa-medkit:before{content:"\f0fa"}.fa-fighter-jet:before{content:"\f0fb"}.fa-beer:before{content:"\f0fc"}.fa-h-square:before{content:"\f0fd"}.fa-plus-square:before{content:"\f0fe"}.fa-angle-double-left:before{content:"\f100"}.fa-angle-double-right:before{content:"\f101"}.fa-angle-double-up:before{content:"\f102"}.fa-angle-double-down:before{content:"\f103"}.fa-angle-left:before{content:"\f104"}.fa-angle-right:before{content:"\f105"}.fa-angle-up:before{content:"\f106"}.fa-angle-down:before{content:"\f107"}.fa-desktop:before{content:"\f108"}.fa-laptop:before{content:"\f109"}.fa-tablet:before{content:"\f10a"}.fa-mobile-phone:before,.fa-mobile:before{content:"\f10b"}.fa-circle-o:before{content:"\f10c"}.fa-quote-left:before{content:"\f10d"}.fa-quote-right:before{content:"\f10e"}.fa-spinner:before{content:"\f110"}.fa-circle:before{content:"\f111"}.fa-mail-reply:before,.fa-reply:before{content:"\f112"}.fa-github-alt:before{content:"\f113"}.fa-folder-o:before{content:"\f114"}.fa-folder-open-o:before{content:"\f115"}.fa-smile-o:before{content:"\f118"}.fa-frown-o:before{content:"\f119"}.fa-meh-o:before{content:"\f11a"}.fa-gamepad:before{content:"\f11b"}.fa-keyboard-o:before{content:"\f11c"}.fa-flag-o:before{content:"\f11d"}.fa-flag-checkered:before{content:"\f11e"}.fa-terminal:before{content:"\f120"}.fa-code:before{content:"\f121"}.fa-mail-reply-all:before,.fa-reply-all:before{content:"\f122"}.fa-star-half-empty:before,.fa-star-half-full:before,.fa-star-half-o:before{content:"\f123"}.fa-location-arrow:before{content:"\f124"}.fa-crop:before{content:"\f125"}.fa-code-fork:before{content:"\f126"}.fa-unlink:before,.fa-chain-broken:before{content:"\f127"}.fa-question:before{content:"\f128"}.fa-info:before{content:"\f129"}.fa-exclamation:before{content:"\f12a"}.fa-superscript:before{content:"\f12b"}.fa-subscript:before{content:"\f12c"}.fa-eraser:before{content:"\f12d"}.fa-puzzle-piece:before{content:"\f12e"}.fa-microphone:before{content:"\f130"}.fa-microphone-slash:before{content:"\f131"}.fa-shield:before{content:"\f132"}.fa-calendar-o:before{content:"\f133"}.fa-fire-extinguisher:before{content:"\f134"}.fa-rocket:before{content:"\f135"}.fa-maxcdn:before{content:"\f136"}.fa-chevron-circle-left:before{content:"\f137"}.fa-chevron-circle-right:before{content:"\f138"}.fa-chevron-circle-up:before{content:"\f139"}.fa-chevron-circle-down:before{content:"\f13a"}.fa-html5:before{content:"\f13b"}.fa-css3:before{content:"\f13c"}.fa-anchor:before{content:"\f13d"}.fa-unlock-alt:before{content:"\f13e"}.fa-bullseye:before{content:"\f140"}.fa-ellipsis-h:before{content:"\f141"}.fa-ellipsis-v:before{content:"\f142"}.fa-rss-square:before{content:"\f143"}.fa-play-circle:before{content:"\f144"}.fa-ticket:before{content:"\f145"}.fa-minus-square:before{content:"\f146"}.fa-minus-square-o:before{content:"\f147"}.fa-level-up:before{content:"\f148"}.fa-level-down:before{content:"\f149"}.fa-check-square:before{content:"\f14a"}.fa-pencil-square:before{content:"\f14b"}.fa-external-link-square:before{content:"\f14c"}.fa-share-square:before{content:"\f14d"}.fa-compass:before{content:"\f14e"}.fa-toggle-down:before,.fa-caret-square-o-down:before{content:"\f150"}.fa-toggle-up:before,.fa-caret-square-o-up:before{content:"\f151"}.fa-toggle-right:before,.fa-caret-square-o-right:before{content:"\f152"}.fa-euro:before,.fa-eur:before{content:"\f153"}.fa-gbp:before{content:"\f154"}.fa-dollar:before,.fa-usd:before{content:"\f155"}.fa-rupee:before,.fa-inr:before{content:"\f156"}.fa-cny:before,.fa-rmb:before,.fa-yen:before,.fa-jpy:before{content:"\f157"}.fa-ruble:before,.fa-rouble:before,.fa-rub:before{content:"\f158"}.fa-won:before,.fa-krw:before{content:"\f159"}.fa-bitcoin:before,.fa-btc:before{content:"\f15a"}.fa-file:before{content:"\f15b"}.fa-file-text:before{content:"\f15c"}.fa-sort-alpha-asc:before{content:"\f15d"}.fa-sort-alpha-desc:before{content:"\f15e"}.fa-sort-amount-asc:before{content:"\f160"}.fa-sort-amount-desc:before{content:"\f161"}.fa-sort-numeric-asc:before{content:"\f162"}.fa-sort-numeric-desc:before{content:"\f163"}.fa-thumbs-up:before{content:"\f164"}.fa-thumbs-down:before{content:"\f165"}.fa-youtube-square:before{content:"\f166"}.fa-youtube:before{content:"\f167"}.fa-xing:before{content:"\f168"}.fa-xing-square:before{content:"\f169"}.fa-youtube-play:before{content:"\f16a"}.fa-dropbox:before{content:"\f16b"}.fa-stack-overflow:before{content:"\f16c"}.fa-instagram:before{content:"\f16d"}.fa-flickr:before{content:"\f16e"}.fa-adn:before{content:"\f170"}.fa-bitbucket:before{content:"\f171"}.fa-bitbucket-square:before{content:"\f172"}.fa-tumblr:before{content:"\f173"}.fa-tumblr-square:before{content:"\f174"}.fa-long-arrow-down:before{content:"\f175"}.fa-long-arrow-up:before{content:"\f176"}.fa-long-arrow-left:before{content:"\f177"}.fa-long-arrow-right:before{content:"\f178"}.fa-apple:before{content:"\f179"}.fa-windows:before{content:"\f17a"}.fa-android:before{content:"\f17b"}.fa-linux:before{content:"\f17c"}.fa-dribbble:before{content:"\f17d"}.fa-skype:before{content:"\f17e"}.fa-foursquare:before{content:"\f180"}.fa-trello:before{content:"\f181"}.fa-female:before{content:"\f182"}.fa-male:before{content:"\f183"}.fa-gittip:before,.fa-gratipay:before{content:"\f184"}.fa-sun-o:before{content:"\f185"}.fa-moon-o:before{content:"\f186"}.fa-archive:before{content:"\f187"}.fa-bug:before{content:"\f188"}.fa-vk:before{content:"\f189"}.fa-weibo:before{content:"\f18a"}.fa-renren:before{content:"\f18b"}.fa-pagelines:before{content:"\f18c"}.fa-stack-exchange:before{content:"\f18d"}.fa-arrow-circle-o-right:before{content:"\f18e"}.fa-arrow-circle-o-left:before{content:"\f190"}.fa-toggle-left:before,.fa-caret-square-o-left:before{content:"\f191"}.fa-dot-circle-o:before{content:"\f192"}.fa-wheelchair:before{content:"\f193"}.fa-vimeo-square:before{content:"\f194"}.fa-turkish-lira:before,.fa-try:before{content:"\f195"}.fa-plus-square-o:before{content:"\f196"}.fa-space-shuttle:before{content:"\f197"}.fa-slack:before{content:"\f198"}.fa-envelope-square:before{content:"\f199"}.fa-wordpress:before{content:"\f19a"}.fa-openid:before{content:"\f19b"}.fa-institution:before,.fa-bank:before,.fa-university:before{content:"\f19c"}.fa-mortar-board:before,.fa-graduation-cap:before{content:"\f19d"}.fa-yahoo:before{content:"\f19e"}.fa-google:before{content:"\f1a0"}.fa-reddit:before{content:"\f1a1"}.fa-reddit-square:before{content:"\f1a2"}.fa-stumbleupon-circle:before{content:"\f1a3"}.fa-stumbleupon:before{content:"\f1a4"}.fa-delicious:before{content:"\f1a5"}.fa-digg:before{content:"\f1a6"}.fa-pied-piper-pp:before{content:"\f1a7"}.fa-pied-piper-alt:before{content:"\f1a8"}.fa-drupal:before{content:"\f1a9"}.fa-joomla:before{content:"\f1aa"}.fa-language:before{content:"\f1ab"}.fa-fax:before{content:"\f1ac"}.fa-building:before{content:"\f1ad"}.fa-child:before{content:"\f1ae"}.fa-paw:before{content:"\f1b0"}.fa-spoon:before{content:"\f1b1"}.fa-cube:before{content:"\f1b2"}.fa-cubes:before{content:"\f1b3"}.fa-behance:before{content:"\f1b4"}.fa-behance-square:before{content:"\f1b5"}.fa-steam:before{content:"\f1b6"}.fa-steam-square:before{content:"\f1b7"}.fa-recycle:before{content:"\f1b8"}.fa-automobile:before,.fa-car:before{content:"\f1b9"}.fa-cab:before,.fa-taxi:before{content:"\f1ba"}.fa-tree:before{content:"\f1bb"}.fa-spotify:before{content:"\f1bc"}.fa-deviantart:before{content:"\f1bd"}.fa-soundcloud:before{content:"\f1be"}.fa-database:before{content:"\f1c0"}.fa-file-pdf-o:before{content:"\f1c1"}.fa-file-word-o:before{content:"\f1c2"}.fa-file-excel-o:before{content:"\f1c3"}.fa-file-powerpoint-o:before{content:"\f1c4"}.fa-file-photo-o:before,.fa-file-picture-o:before,.fa-file-image-o:before{content:"\f1c5"}.fa-file-zip-o:before,.fa-file-archive-o:before{content:"\f1c6"}.fa-file-sound-o:before,.fa-file-audio-o:before{content:"\f1c7"}.fa-file-movie-o:before,.fa-file-video-o:before{content:"\f1c8"}.fa-file-code-o:before{content:"\f1c9"}.fa-vine:before{content:"\f1ca"}.fa-codepen:before{content:"\f1cb"}.fa-jsfiddle:before{content:"\f1cc"}.fa-life-bouy:before,.fa-life-buoy:before,.fa-life-saver:before,.fa-support:before,.fa-life-ring:before{content:"\f1cd"}.fa-circle-o-notch:before{content:"\f1ce"}.fa-ra:before,.fa-resistance:before,.fa-rebel:before{content:"\f1d0"}.fa-ge:before,.fa-empire:before{content:"\f1d1"}.fa-git-square:before{content:"\f1d2"}.fa-git:before{content:"\f1d3"}.fa-y-combinator-square:before,.fa-yc-square:before,.fa-hacker-news:before{content:"\f1d4"}.fa-tencent-weibo:before{content:"\f1d5"}.fa-qq:before{content:"\f1d6"}.fa-wechat:before,.fa-weixin:before{content:"\f1d7"}.fa-send:before,.fa-paper-plane:before{content:"\f1d8"}.fa-send-o:before,.fa-paper-plane-o:before{content:"\f1d9"}.fa-history:before{content:"\f1da"}.fa-circle-thin:before{content:"\f1db"}.fa-header:before{content:"\f1dc"}.fa-paragraph:before{content:"\f1dd"}.fa-sliders:before{content:"\f1de"}.fa-share-alt:before{content:"\f1e0"}.fa-share-alt-square:before{content:"\f1e1"}.fa-bomb:before{content:"\f1e2"}.fa-soccer-ball-o:before,.fa-futbol-o:before{content:"\f1e3"}.fa-tty:before{content:"\f1e4"}.fa-binoculars:before{content:"\f1e5"}.fa-plug:before{content:"\f1e6"}.fa-slideshare:before{content:"\f1e7"}.fa-twitch:before{content:"\f1e8"}.fa-yelp:before{content:"\f1e9"}.fa-newspaper-o:before{content:"\f1ea"}.fa-wifi:before{content:"\f1eb"}.fa-calculator:before{content:"\f1ec"}.fa-paypal:before{content:"\f1ed"}.fa-google-wallet:before{content:"\f1ee"}.fa-cc-visa:before{content:"\f1f0"}.fa-cc-mastercard:before{content:"\f1f1"}.fa-cc-discover:before{content:"\f1f2"}.fa-cc-amex:before{content:"\f1f3"}.fa-cc-paypal:before{content:"\f1f4"}.fa-cc-stripe:before{content:"\f1f5"}.fa-bell-slash:before{content:"\f1f6"}.fa-bell-slash-o:before{content:"\f1f7"}.fa-trash:before{content:"\f1f8"}.fa-copyright:before{content:"\f1f9"}.fa-at:before{content:"\f1fa"}.fa-eyedropper:before{content:"\f1fb"}.fa-paint-brush:before{content:"\f1fc"}.fa-birthday-cake:before{content:"\f1fd"}.fa-area-chart:before{content:"\f1fe"}.fa-pie-chart:before{content:"\f200"}.fa-line-chart:before{content:"\f201"}.fa-lastfm:before{content:"\f202"}.fa-lastfm-square:before{content:"\f203"}.fa-toggle-off:before{content:"\f204"}.fa-toggle-on:before{content:"\f205"}.fa-bicycle:before{content:"\f206"}.fa-bus:before{content:"\f207"}.fa-ioxhost:before{content:"\f208"}.fa-angellist:before{content:"\f209"}.fa-cc:before{content:"\f20a"}.fa-shekel:before,.fa-sheqel:before,.fa-ils:before{content:"\f20b"}.fa-meanpath:before{content:"\f20c"}.fa-buysellads:before{content:"\f20d"}.fa-connectdevelop:before{content:"\f20e"}.fa-dashcube:before{content:"\f210"}.fa-forumbee:before{content:"\f211"}.fa-leanpub:before{content:"\f212"}.fa-sellsy:before{content:"\f213"}.fa-shirtsinbulk:before{content:"\f214"}.fa-simplybuilt:before{content:"\f215"}.fa-skyatlas:before{content:"\f216"}.fa-cart-plus:before{content:"\f217"}.fa-cart-arrow-down:before{content:"\f218"}.fa-diamond:before{content:"\f219"}.fa-ship:before{content:"\f21a"}.fa-user-secret:before{content:"\f21b"}.fa-motorcycle:before{content:"\f21c"}.fa-street-view:before{content:"\f21d"}.fa-heartbeat:before{content:"\f21e"}.fa-venus:before{content:"\f221"}.fa-mars:before{content:"\f222"}.fa-mercury:before{content:"\f223"}.fa-intersex:before,.fa-transgender:before{content:"\f224"}.fa-transgender-alt:before{content:"\f225"}.fa-venus-double:before{content:"\f226"}.fa-mars-double:before{content:"\f227"}.fa-venus-mars:before{content:"\f228"}.fa-mars-stroke:before{content:"\f229"}.fa-mars-stroke-v:before{content:"\f22a"}.fa-mars-stroke-h:before{content:"\f22b"}.fa-neuter:before{content:"\f22c"}.fa-genderless:before{content:"\f22d"}.fa-facebook-official:before{content:"\f230"}.fa-pinterest-p:before{content:"\f231"}.fa-whatsapp:before{content:"\f232"}.fa-server:before{content:"\f233"}.fa-user-plus:before{content:"\f234"}.fa-user-times:before{content:"\f235"}.fa-hotel:before,.fa-bed:before{content:"\f236"}.fa-viacoin:before{content:"\f237"}.fa-train:before{content:"\f238"}.fa-subway:before{content:"\f239"}.fa-medium:before{content:"\f23a"}.fa-yc:before,.fa-y-combinator:before{content:"\f23b"}.fa-optin-monster:before{content:"\f23c"}.fa-opencart:before{content:"\f23d"}.fa-expeditedssl:before{content:"\f23e"}.fa-battery-4:before,.fa-battery:before,.fa-battery-full:before{content:"\f240"}.fa-battery-3:before,.fa-battery-three-quarters:before{content:"\f241"}.fa-battery-2:before,.fa-battery-half:before{content:"\f242"}.fa-battery-1:before,.fa-battery-quarter:before{content:"\f243"}.fa-battery-0:before,.fa-battery-empty:before{content:"\f244"}.fa-mouse-pointer:before{content:"\f245"}.fa-i-cursor:before{content:"\f246"}.fa-object-group:before{content:"\f247"}.fa-object-ungroup:before{content:"\f248"}.fa-sticky-note:before{content:"\f249"}.fa-sticky-note-o:before{content:"\f24a"}.fa-cc-jcb:before{content:"\f24b"}.fa-cc-diners-club:before{content:"\f24c"}.fa-clone:before{content:"\f24d"}.fa-balance-scale:before{content:"\f24e"}.fa-hourglass-o:before{content:"\f250"}.fa-hourglass-1:before,.fa-hourglass-start:before{content:"\f251"}.fa-hourglass-2:before,.fa-hourglass-half:before{content:"\f252"}.fa-hourglass-3:before,.fa-hourglass-end:before{content:"\f253"}.fa-hourglass:before{content:"\f254"}.fa-hand-grab-o:before,.fa-hand-rock-o:before{content:"\f255"}.fa-hand-stop-o:before,.fa-hand-paper-o:before{content:"\f256"}.fa-hand-scissors-o:before{content:"\f257"}.fa-hand-lizard-o:before{content:"\f258"}.fa-hand-spock-o:before{content:"\f259"}.fa-hand-pointer-o:before{content:"\f25a"}.fa-hand-peace-o:before{content:"\f25b"}.fa-trademark:before{content:"\f25c"}.fa-registered:before{content:"\f25d"}.fa-creative-commons:before{content:"\f25e"}.fa-gg:before{content:"\f260"}.fa-gg-circle:before{content:"\f261"}.fa-tripadvisor:before{content:"\f262"}.fa-odnoklassniki:before{content:"\f263"}.fa-odnoklassniki-square:before{content:"\f264"}.fa-get-pocket:before{content:"\f265"}.fa-wikipedia-w:before{content:"\f266"}.fa-safari:before{content:"\f267"}.fa-chrome:before{content:"\f268"}.fa-firefox:before{content:"\f269"}.fa-opera:before{content:"\f26a"}.fa-internet-explorer:before{content:"\f26b"}.fa-tv:before,.fa-television:before{content:"\f26c"}.fa-contao:before{content:"\f26d"}.fa-500px:before{content:"\f26e"}.fa-amazon:before{content:"\f270"}.fa-calendar-plus-o:before{content:"\f271"}.fa-calendar-minus-o:before{content:"\f272"}.fa-calendar-times-o:before{content:"\f273"}.fa-calendar-check-o:before{content:"\f274"}.fa-industry:before{content:"\f275"}.fa-map-pin:before{content:"\f276"}.fa-map-signs:before{content:"\f277"}.fa-map-o:before{content:"\f278"}.fa-map:before{content:"\f279"}.fa-commenting:before{content:"\f27a"}.fa-commenting-o:before{content:"\f27b"}.fa-houzz:before{content:"\f27c"}.fa-vimeo:before{content:"\f27d"}.fa-black-tie:before{content:"\f27e"}.fa-fonticons:before{content:"\f280"}.fa-reddit-alien:before{content:"\f281"}.fa-edge:before{content:"\f282"}.fa-credit-card-alt:before{content:"\f283"}.fa-codiepie:before{content:"\f284"}.fa-modx:before{content:"\f285"}.fa-fort-awesome:before{content:"\f286"}.fa-usb:before{content:"\f287"}.fa-product-hunt:before{content:"\f288"}.fa-mixcloud:before{content:"\f289"}.fa-scribd:before{content:"\f28a"}.fa-pause-circle:before{content:"\f28b"}.fa-pause-circle-o:before{content:"\f28c"}.fa-stop-circle:before{content:"\f28d"}.fa-stop-circle-o:before{content:"\f28e"}.fa-shopping-bag:before{content:"\f290"}.fa-shopping-basket:before{content:"\f291"}.fa-hashtag:before{content:"\f292"}.fa-bluetooth:before{content:"\f293"}.fa-bluetooth-b:before{content:"\f294"}.fa-percent:before{content:"\f295"}.fa-gitlab:before{content:"\f296"}.fa-wpbeginner:before{content:"\f297"}.fa-wpforms:before{content:"\f298"}.fa-envira:before{content:"\f299"}.fa-universal-access:before{content:"\f29a"}.fa-wheelchair-alt:before{content:"\f29b"}.fa-question-circle-o:before{content:"\f29c"}.fa-blind:before{content:"\f29d"}.fa-audio-description:before{content:"\f29e"}.fa-volume-control-phone:before{content:"\f2a0"}.fa-braille:before{content:"\f2a1"}.fa-assistive-listening-systems:before{content:"\f2a2"}.fa-asl-interpreting:before,.fa-american-sign-language-interpreting:before{content:"\f2a3"}.fa-deafness:before,.fa-hard-of-hearing:before,.fa-deaf:before{content:"\f2a4"}.fa-glide:before{content:"\f2a5"}.fa-glide-g:before{content:"\f2a6"}.fa-signing:before,.fa-sign-language:before{content:"\f2a7"}.fa-low-vision:before{content:"\f2a8"}.fa-viadeo:before{content:"\f2a9"}.fa-viadeo-square:before{content:"\f2aa"}.fa-snapchat:before{content:"\f2ab"}.fa-snapchat-ghost:before{content:"\f2ac"}.fa-snapchat-square:before{content:"\f2ad"}.fa-pied-piper:before{content:"\f2ae"}.fa-first-order:before{content:"\f2b0"}.fa-yoast:before{content:"\f2b1"}.fa-themeisle:before{content:"\f2b2"}.fa-google-plus-circle:before,.fa-google-plus-official:before{content:"\f2b3"}.fa-fa:before,.fa-font-awesome:before{content:"\f2b4"}.fa-handshake-o:before{content:"\f2b5"}.fa-envelope-open:before{content:"\f2b6"}.fa-envelope-open-o:before{content:"\f2b7"}.fa-linode:before{content:"\f2b8"}.fa-address-book:before{content:"\f2b9"}.fa-address-book-o:before{content:"\f2ba"}.fa-vcard:before,.fa-address-card:before{content:"\f2bb"}.fa-vcard-o:before,.fa-address-card-o:before{content:"\f2bc"}.fa-user-circle:before{content:"\f2bd"}.fa-user-circle-o:before{content:"\f2be"}.fa-user-o:before{content:"\f2c0"}.fa-id-badge:before{content:"\f2c1"}.fa-drivers-license:before,.fa-id-card:before{content:"\f2c2"}.fa-drivers-license-o:before,.fa-id-card-o:before{content:"\f2c3"}.fa-quora:before{content:"\f2c4"}.fa-free-code-camp:before{content:"\f2c5"}.fa-telegram:before{content:"\f2c6"}.fa-thermometer-4:before,.fa-thermometer:before,.fa-thermometer-full:before{content:"\f2c7"}.fa-thermometer-3:before,.fa-thermometer-three-quarters:before{content:"\f2c8"}.fa-thermometer-2:before,.fa-thermometer-half:before{content:"\f2c9"}.fa-thermometer-1:before,.fa-thermometer-quarter:before{content:"\f2ca"}.fa-thermometer-0:before,.fa-thermometer-empty:before{content:"\f2cb"}.fa-shower:before{content:"\f2cc"}.fa-bathtub:before,.fa-s15:before,.fa-bath:before{content:"\f2cd"}.fa-podcast:before{content:"\f2ce"}.fa-window-maximize:before{content:"\f2d0"}.fa-window-minimize:before{content:"\f2d1"}.fa-window-restore:before{content:"\f2d2"}.fa-times-rectangle:before,.fa-window-close:before{content:"\f2d3"}.fa-times-rectangle-o:before,.fa-window-close-o:before{content:"\f2d4"}.fa-bandcamp:before{content:"\f2d5"}.fa-grav:before{content:"\f2d6"}.fa-etsy:before{content:"\f2d7"}.fa-imdb:before{content:"\f2d8"}.fa-ravelry:before{content:"\f2d9"}.fa-eercast:before{content:"\f2da"}.fa-microchip:before{content:"\f2db"}.fa-snowflake-o:before{content:"\f2dc"}.fa-superpowers:before{content:"\f2dd"}.fa-wpexplorer:before{content:"\f2de"}.fa-meetup:before{content:"\f2e0"}.sr-only{position:absolute;width:1px;height:1px;padding:0;margin:-1px;overflow:hidden;clip:rect(0, 0, 0, 0);border:0}.sr-only-focusable:active,.sr-only-focusable:focus{position:static;width:auto;height:auto;margin:0;overflow:visible;clip:auto}]]></content>
  </entry>
  <entry>
    <title><![CDATA[跳跃表实现]]></title>
    <url>%2F2020%2F12%2F04%2F%E8%B7%B3%E8%B7%83%E8%A1%A8%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172class Node&#123; private $id; public $value; public $level; public $forward = []; public function __construct($value, $level) &#123; $this-&gt;id = uniqid(); $this-&gt;level = $level; $this-&gt;value = $value; for ($i = 0; $i &lt; $level; $i++) &#123; $this-&gt;forward[$i] = 0; &#125; &#125; public function getID() &#123; return $this-&gt;id; &#125;&#125;class SkipList&#123; private $maxLevel; public $nodePool = []; public $header; public function __construct($maxLevel) &#123; $this-&gt;maxLevel = $maxLevel; $header = new Node(-1, $maxLevel); $this-&gt;addToNodePool($header-&gt;getID(), $header); $this-&gt;header = $header-&gt;getID(); &#125; public function addToNodePool($id, $object) &#123; $this-&gt;nodePool[$id] = $object; &#125; /** * @param $id * @return Node */ public function getFromNodePool($id) &#123; return isset($this-&gt;nodePool[$id]) ? $this-&gt;nodePool[$id] : null; &#125; public function insert($value) &#123; $visitTrace = []; $count = 0; $tmp = $this-&gt;getFromNodePool($this-&gt;header); for ($i = $this-&gt;maxLevel - 1; $i &gt;= 0; $i--) &#123; while ($tmp &amp;&amp; $tmp-&gt;forward[$i]) &#123; $count++; if ($count &gt; 20) &#123; break; &#125; $forward = $this-&gt;getFromNodePool($tmp-&gt;forward[$i]); if ($forward-&gt;value &lt; $value) &#123; $tmp = $forward; &#125; else if ($forward-&gt;value &gt; $value) &#123; break; &#125; else &#123; return false; &#125; &#125; if ($tmp) &#123; $visitTrace[$i] = $tmp-&gt;getID(); &#125; &#125; $level = $this-&gt;randomLevel(); $newNode = new Node($value, $level); $this-&gt;addToNodePool($newNode-&gt;getID(), $newNode); for ($i = 0; $i &lt; $level; $i++) &#123; $trace = $this-&gt;getFromNodePool($visitTrace[$i]); $newNode-&gt;forward[$i] = $trace-&gt;forward[$i]; $trace-&gt;forward[$i] = $newNode-&gt;getID(); &#125; return true; &#125; public function find($value) &#123; $tmp = $this-&gt;getFromNodePool($this-&gt;header); $count = 0; for ($i = $this-&gt;maxLevel - 1; $i &gt;= 0; $i--) &#123; while ($tmp &amp;&amp; $tmp-&gt;forward[$i]) &#123; $count++; if ($count &gt; 20) &#123; break; &#125; $forward = $this-&gt;getFromNodePool($tmp-&gt;forward[$i]); if ($forward-&gt;value &lt; $value) &#123; $tmp = $forward; &#125; else if ($forward-&gt;value &gt; $value) &#123; break; &#125; else &#123; return true; &#125; &#125; &#125; return false; &#125; private function randomLevel() &#123; $level = 1; if (rand(0, 1) &amp;&amp; $level &lt; $this-&gt;maxLevel) &#123; $level++; &#125; return $level; &#125;&#125;$testData = [898888, 300, 234, 123, 333, 456, 23, 99];$skipList = new SkipList(3);foreach ($testData as $value) &#123; $skipList-&gt;insert($value);&#125;$test = [898888, 300, 234, 123, 333, 456, 23, 99, 100, 111];foreach ($test as $value) &#123; $result = $skipList-&gt;find($value); if (in_array($value, $testData) &amp;&amp; in_array($value, $test)) &#123; if ($result) &#123; echo '正确&lt;br&gt;'; &#125; else &#123; echo '错误&lt;br&gt;'; &#125; &#125; else &#123; if ($result) &#123; echo '错误&lt;br&gt;'; &#125; else &#123; echo '正确&lt;br&gt;'; &#125; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是跳跃表？]]></title>
    <url>%2F2020%2F12%2F04%2F%E4%BB%80%E4%B9%88%E6%98%AF%E8%B7%B3%E8%B7%83%E8%A1%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
  </entry>
  <entry>
    <title><![CDATA[第10章 实盘交易与账务管理]]></title>
    <url>%2F2020%2F11%2F27%2F%E7%AC%AC10%E7%AB%A0-%E5%AE%9E%E7%9B%98%E4%BA%A4%E6%98%93%E4%B8%8E%E8%B4%A6%E5%8A%A1%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章提供实盘交易的完整策略，都是由第5~9章的内容整合而来。代码是进行实盘交易的代码，必须通过FastOS下单机下单，所以读者必须先通过账户登录FastOS下单机。 另外，本章将会介绍委托查询，通过Python串接委托查询功能。 本示例所提供的实盘交易策略着重于交易流程的展示，并不保证能够稳定获利，读者可以通过示例去进行扩展，但不建议直接用于实盘交易。 技巧111 【程序】固定时间买进卖出策略该策略是通过固定时间点买进卖出，并设置止损/止盈点，而开仓一律是买进，交易逻辑如下。 1.进场 每日的9点进场(参考技巧79)。 2.出场 进场后，逐笔查看是否触发止损/止盈价位(进场成交价的上下10点)则立即出场(参考技巧88)，最晚10点出场。以下为固定时间买进卖出策略的代码。 文件名:110.py 12 技巧112 【程序】顺势交易策略(海龟策略)该策略就是突破高低点区间顺势交易的策略。 1.进场 9点以后开始判断进场，进场条件是突破9点以前的高低点加上高低点的价差。例如9点以前的高、低点分别为10 530、10 500，价差为30点，则9点以后必须向上突破 10 560 (10 530 + 30)才进行顺势买进，向下突破 10 470(10 500 − 30)才进行顺势做空，详情参考技巧 85。若到了 10 点尚未进场，则当日不进行交易。 2.出场 出场则是设置固定 10 点止损(参考技巧 88)以及价格回跌止盈(参考技巧 89)。以买 单新仓为例，若市场当前价高于进场价位20点，则开始计算最高价位，接着只要当价格回 跌至最高获利点位的 75%则获利出场。若没有接触到止损获利点，则最后会在结束时间 12 点出场。以下为顺势交易策略的代码。 文件名:111.py 12 技巧113 【程序】MA交叉买进卖出策略该策略就是常见的MA交易策略，通过逐笔信息计算。该策略一天当中仅交易一次，若要来回进行多次交易，则可在策略进出场判断之外再使用一层循环，如下所示: 12345678# 判断是否再次进场，例如:在12点以前持续交易 while 时间小于12点 :# 进场条件判断 while index=0:...# 出场条件判断 while index!=0:... MA策略的交易逻辑如下。 1.进场 通过委托量判断当日趋势，通过 3 个时间点来进行判断，分别为 8:50、9:00、9:03，趋 势判断可参考技巧 56。 趋势判断完成后，与 10MA 比较价格，以趋势看涨为例，价格向上突破 MA 则买进， 详情可参考技巧 65。 2.出场 出场与进场的方式一样都是通过 MA 交叉来判断;不同的是，买进是价格向上突破MA，平仓则是价格向下突破 MA，可参考技巧 73。 以下是 MA 交叉买进卖出策略的代码。 文件名:112.py 12 技巧114 【概念】何谓账务账务也就是投资人目前的账户信息，其中包含了常用的权益数、交易记录和未平仓记 录。权益数代表投资人目前可动用的资金。 通过账户类查询，可以了解自己的账户信息，甚至可以在策略中进行动态净值的计算。 FastOS 提供了委托查询、未平仓查询和权益数查询的相关子程序。 技巧 115 【程序】获取总委托明细在第 9 章中已介绍过如何查询单笔委托明细，但在本技巧中是一次性将所有委托明细取出，我们可以通过这项功能来记录自己每天的交易，返回值请参考技巧106单笔委托查询。以下为获取总委托明细的代码。 文件名:order.py12 技巧 116 【程序】获取未平仓明细未平仓明细代表目前投资人持仓的部位，数据内容以“，”分隔每一个字段，字段依序 为:市场类别、账号、商品、买卖类型、未平仓部位、当日未平仓部位、平均成本(3 位 小数)、每点价值、单次手续费、交易税。 下面通过 Python 的子程序 OnOpenInterest.exe 来进行未平仓查询。文件名:order.py 12 在 Python 中获取未平仓明细的执行过程如下: 技巧 117 【程序】获取权益数可用资金数即目前账户里可动用的资金量，通过权益数的查询，可以判断目前可以交 易的合约数量，并做好资金量管控。 权益数可以扩展委托动态净值，通过程序去计算目前的动态损益。 返回的字符串内容以“，”分隔每一个字段，字段依序为: 账户余额、浮动损益、已实现费用、交易税、预扣权利金、权利金收付、权益数、 超额保证金、存提款、买方市值、卖方市值、期货平仓损益、盘中未实现、原始保证金、 维持保证金、持仓原始保证金、持仓维持保证金、委托保证金、超额最佳保证金、权利 总值、预扣费用、原始保证金、昨日余额、期权组合单加不加收保证金、维持率、币种、 足额原始保证金、足额维持保证金、足额可用、抵缴金额、有价可用、超额保证金、足 额现金可用、有价价值、风险指标、期权到期差异、期权到期差损、期货到期损益和追 加保证金。 以下为权益数的查询函数代码。 12]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python期货量化交易实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9章 连接券商的即时报价与下单函数]]></title>
    <url>%2F2020%2F11%2F27%2F%E7%AC%AC9%E7%AB%A0-%E8%BF%9E%E6%8E%A5%E5%88%B8%E5%95%86%E7%9A%84%E5%8D%B3%E6%97%B6%E6%8A%A5%E4%BB%B7%E4%B8%8E%E4%B8%8B%E5%8D%95%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 踏进真实市场交易的第一步，就是要取得即时报价，通过算法的逻辑进行价量运算后进行自动下单。券商通常会提供下单的API来让使用者接入，但这对于一般使用者较为困难，因此我们提供了FastOS程序连接群益期货的报价与下单服务，即可获取报价，并通过命令进行下单与委托查询的动作，创建属于自己的交易系统。 本章将介绍报价的原理与实现，并提供下单程序以及Python的接入方式，让投资者可以迅速下单。 技巧97 程序交易流程本技巧介绍实盘交易的流程，回测构建的流程可参考技巧41和技巧42，虽然回测与实盘交易都是以交易为基础，但是实盘交易比起回测构建更加注重即时信息的获取以及下 单的处理方式。 在了解程序交易的流程以前，必须先了解整体的市场交易结构。市场上简易的结构分为几个单位: • 交易所;• 券商;• 信息商;• 投资人。 上述每个单位都是市场中不可或缺的部分。其中，券商接收投资人的委托，冻结投资人保证金，向交易所传递委托信息;交易所将会接收委托并进行撮合，发布市场即时信息;信息商负责获取交易所的即时信息，给投资人发布信息，类似于现在的看盘软件;最后投资人接收市场信息，进行交易判断，接着发送委托单给券商。这当中的所有行为都是环环相扣，所以整个市场结构是不断循环的。市场交易结构如图 9-1 所示。 无论是程序交易还是主观交易(即手 工交易)，都会有 3 个步骤。 步骤 1:取得市场信息。 步骤 2:进行交易(主观)判断。 步骤 3:发送交易委托。 在上述步骤中，主观交易者会通过看 盘软件来完成，而程序交易者则会通过“取 报价”“算法判断”和“通过程序进行委托” 来完成，这些就是程序交易的流程。 图 9-1 在算法判断当中，本书的目录结构从第 5 章开始也正好是实盘算法的流程，读者可以按章节顺序阅读，了解完整的算法架构。下面列出算法流程。 步骤 1:获取报价与设计指标。步骤 2:判断涨跌的趋势。步骤 3:规划进场的时机。步骤 4:设置出场及止损获利的条件。步骤 5:通过程序下单。 技巧 98 【概念】交易所解释信息 台湾期货交易所为了促进市场活跃，并且让交易信息更为透明，配合社会推广“开源 数据”与“大数据”，因此会发布逐笔成交信息，以适应当地的期货市场逐笔成交制度，在 盘中发布 20 多种不同类型的信息。 对于这么多种类型的即时信息，本书仅介绍与即时价量有关的信息，包括委托信息、 成交信息和上下五档价信息。 1.I020 成交价量揭示信息，将逐笔成交信息即时揭露。在本书所附的交易程序中，报价文件 名称为“日期_Match.txt”，例如“20170803_ Match.txt”。文件中的字段如下:时间，成交价，成交量，总量，成交买笔，成交卖笔，最高价，最低价 2.I030 商品累计委托量信息，将所有商品分别统计委托累计信息，以每 5 秒发布一次。在本书所附的交易程序中，报价文件名称为“日期_Commission.txt”，例如“20170803_Commission.txt”。 文件中的字段如下: 时间，委托买笔，委托买手，委托卖笔，委托卖手 3.I080 最佳上下五档价量信息，是委托簿信息的一部分，期交所用来发布个别商品的最佳五 档价量。在本书所附的交易程序中，报价文件名称为“日期_UpDn5.txt”，例如“20170803_ UpDn5.txt”。 文件中的字段如下: 时间，下一档价格，下一档数量，下两档价格，下两档数量，下三档价格，下三档数量，下四档价格，下四档数量，下五档价格，下五档数量，上一档价格，上一档数量，上两档价格，上两档数量，上三档价格，上三档数量，上四档价格，上四 档数量，上五档价格，上五档数量 技巧 99 【概念】获取报价的方式 在技巧 51 中介绍了获取即时报价信息的代码，本技巧将介绍程序交易中获取报价的概念。 接收报价部分属于跨程序的调用，在本书中由 FastOS 来串接 Python。跨程序调用有许 多方式，如何应用也是程序交易者必须克服的门槛。 从信息技术的角度来说，目前设计的程序交易系统架构为了符合弹性、多语言兼容的特性而选择较常用的“文件”传输方案，选择这个方案能降低整个交易系统难度，程序降低程序编写的门槛。因为是文件存取的调用方式，所以交易程序会主动读取报价， 而不是被推送数据。 读写报价的交易系统结构如图 9-2 所示。 接着该如何通过文件进行即时报价读取呢?首先，我们必须了解读文件的方式。因为 我们只需要“最新”的报价，所以只需要访问文件的尾部信息，这时就该思考如何有效地 读取文件的尾部信息，如图 9-3 所示。 图 9-2 图 9-3 以下是我们建议的解决方案。 (1)通过 Python os 包中的 tail 命令来读取文件。 本方案在 Windows 上并不被支持，该包仅支持 Linux，所以在本书中不介绍。 (2)通过 Python 的 open 函数以及 read 函数来读取文件。 通过 Python 内置的文件读写函数，也能够获取文件内容，并且通过 seek 函数可以设定目前的文件存取访问点，通过这样的方式再自行编写算法，就能够获取最后一笔数据。通过 seek 函数，必须准确获取最后一笔的数据，才有办法准确地抓出最新一笔数据， 而在 Python 中，有公开的外部包，可以直接读取文件的尾部信息，参考下面的方案。(3)通过 Python 的 tailer 包来读取文件。 tailer 包必须额外安装，具体的安装过程如下。pip 安装详细介绍可以参考技巧 8，安装完成后就可以在 Python 中使用了。 ailer 提供了几个相关的函数，可以从文件的尾部读取数据(tail)，也可以从文件的头 部读取数据(head)，还可以跟踪文件变化并读取增长的行(follow)。 本书将通过 Python 的 tailer 包使用即时报价的信息，读者可参考技巧 51。 技巧 100 【概念】实盘交易算法与回测算法差异 实盘交易算法与回测算法最大的差异在于数据的获取以及运用方式，回测算法是通 过既有的历史信息来进行运算，而实盘算法则是通过目前交易所最新的报价来进行数据 获取。举个简单的示例，假设要在 9:00 准时进场，11:00 准时出场，通过回测算法，可以直接通过当天的历史信息进行筛选，获取最靠近特定时间点的数据。即时算法则必须要不断 地去读取当前报价文件的最新数据，直到当前的报价时间超过 11 点才会出场。这两种算法 的写法截然不同，读者也可以观察第 4 章以前的示例以及之后实盘流程的交易示例。除了数据的获取和运用以外，下单部分也是相当重要的。在进行回测时，触发进出场 点的动作只是将成交时间和成交价记录下来，并没有触及真正的下单动作。若要真正落实 实盘交易的交易所撮合规则，就必须去查看当前的上下五档价，但是也不全然正确，毕竟模拟单没有真正送入交易所委托簿中，我们只能通过历史数据做出最佳判断。若觉得麻烦， 可以在回测中设定一个滑点，因为最佳上下一档价通常与成交价相差一点，也是最有可能 成交的价位(遇到波动较大的情况，则可能会滑点在一点以上)，而一买一卖则会产生两个 滑点，更详细的介绍详见技巧 76。 另外，因为实盘交易的下单部分会直接影响交易绩效，所以是整个程序交易中需要特 别注意的部分。实际下单有以下两个层面需要考虑。 • 能否下单成功。• 是否能获取相对较佳的成交价位。 以上两点都与下市价单及限价单有关，因为期货市场活跃度高，成交概率非常大，市价单不会考虑能否成交的问题，但往往没办法取得相对较佳的成交价位;限价单则相反，可以设定有相对优势的价位，但能否下单成功仍会成为隐忧。 这些都是程序交易必须经历的，要在绩效与执行力上做出抉择。举个例子来说，假设 每次通过市价单交易，一买一卖可能会有 2 个滑点，而通过限价单则不会产生滑点，但是 可能会面临委托未成交的情形而错过相对较好的进场点，只能等到下次进场条件触发。若无法准确下单，则在实际的策略中必须做出相对应的措施，否则会导致交易策略 充满不确定性，比如没有触发成交的委托单应该如何处理，也是程序交易中应该要面对 的问题。我们将会在技巧 108 中介绍下单命令，尝试解决市价单及限价单之间的矛盾，让投资 人提高策略执行力并取得相对较佳的价位。技巧 101 【概念】下单参数介绍 在本书的策略中，会提供下单程序，在执行程序下单时，需要送出交易相关的参数，执行的命令简称为下单命令，如下所示:程序名称、商品名称、买或卖、价格、数量和市价或限价、下单条件、是否日内。 例如: Order.exe TX00 B 11000 1 LMT ROD 1 命令参数介绍如表 9-1 所示。 表 9-1 命令参数 程序名称 商品合约名称买或卖 价格 数量市价或限价下单命令参数 说明 程序名称指的是传达交易命令的程序，书中提供的程序名称为“Order.exe”商品合约名称为交易商品合约的名称，以 2017 年 6 月 30 日的大台指为例，期 交所定义的合约名称为 TXFG7，但是按照群益期货所定义的商品合约名称规则 当月合约为 TX00，而远月份合约为“TX+月份”，例如:7 月份合约名为“TX07”设置该笔订单是买进(B)还是卖出(S)设置要买入或卖出的价格，仅在限价单生效。如果是市价单，就可用空值(“ “)设置要买入或卖出的合约数量市价(Market Price，MKT)是指当前市场的价格，限价(Limit Price，LMT) 是我们指定成交的价格 技巧101【概念】下单参数介绍 175 命令参数 说明续表 下单条件是否日内交易交易参数有 3 个:IOC、FOK 与 ROD。其中，IOC 为 Immediate or Cancel，意 为立即成交否则取消(这条命令与 FOK 类似，差别在于允许部分成交);FOK 为 Fill or Kill，意为全部成交否则取消;ROD 为 Rest of Day，意为当日有效单， 即当日收盘前都是有效的。 下单条件要搭配限价或市价使用，一般而言，如果下了市价单(MKT)就会使用下单 条件立即成交(IOC);如果下了限价单(LMT)就会使用下单条件当日成交(ROD)日内交易与否牵涉到保证金是否减半，但日内交易也有条件与资格限制，其中 0 表示非日内交易，1 表示日内交易比较特别的是，下单账户没有在下单参数中，会以 FastOS 系统的下单账户选项来定。 若当前 FastOS 的交易账户设定为 A 账户，则下单程序会通过 A 账户进行委托;若 要通过 B 账户进行委托，则必须修改 FastOS 中的账户选项，如图 9-4 所示1。图 9-4 下单账户 技巧 102 【概念】实盘委托的市场机制事件触发(通过算法)后进行的下单动作，不论是开仓或平仓都需要发送交易委托， 本技巧将阐述目前实盘委托的市场机制。下单就是投资人发送委托至券商，经由券商的风控检验2后，再送到交易所进行买卖。1 图 9-4 中的“当冲与否”指是否日内交易，交易所可能会对当日和隔日交易收取不同的手续费。 2 此处的风控检验主要涉及持仓和资金方面。 异步社区回家抄作业(13357721075) 专享 请尊重版权 技巧102【概念】实盘委托的市场机制 177 每次进行委托时，券商端会对投资人做扣缴保证金，成功后才会将交易委托送至交易所。投资人在每次对券商发送委托后，券商会先回传委托回报，委托成功后才会等待交易 所撮合，撮合成功后交易所会回传成交回报给券商，券商再回传成交信息给投资人，投资 人收到成交回报时，才会确定成交的相关信息，如图 9-5 所示。图 9-5如果使用的是“市价单”，并且要买，就会以市场上最佳的卖价成交;如果我们要卖， 就会以市场上最佳的买价成交。以台湾指数期货市场而言，只要下市价单就会马上成交， 交易所会传回成交信息，流程如图 9-6 所示。图 9-6 如果使用的是“限价单”，就会以我们指定的价格成交。如果市场上有其他委托单触碰到指定委托的价格就会传回成交回报，否则就会一直挂在交易所委托簿之中，如图 9-7 所示。 技巧 103 【程序】完整下单函数介绍完整的实际下单函数会包含委托下单、撤销委托、委托查询和下单命令等。以下是笔 者提供的下单函数库，通过 subprocess 包进行外部命令的调用，并且取得下单程序的回报 值，以确保下单能正确执行。subprocess 包(注:如果是从官网下载的 Python，基本已经内置了 subprocess 包)，通 过以下命令进行安装:pip install subprocess安装外部包详情请参考技巧 8。 以下所提供的代码皆为基本下单应用，读者若有更深入的需求可以自行修改代码。 下单函数库的文件名称为 order.py，内容如下。文件名:order.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding: UTF-8 -*-# 导入相关包 import subprocess# 下单子程序的存放位置 ExecPath="./bin/"# 市价单下单def OrderMKT(Product,BS,Qty):OrderNo=subprocess.check_output([ExecPath+"order.exe",Product,BS,"0",Qty,"MKT","I OC", "0"]).strip('\r\n')while True: ReturnInfo=subprocess.check_output([ExecPath+"GetAccount.exe",OrderNo]).strip('\ r\n').split(',') if len(ReturnInfo)&gt;1: return ReturnInfo# 限价单委托def OrderLMT(Product,BS,Price,Qty):OrderNo=subprocess.check_output([ExecPath+"order.exe",Product,BS,Price,Qty,"LMT", "ROD", "0"]).strip('\r\n') return OrderNo# 查询委托明细def QueryOrder(Keyno):ReturnInfo=subprocess.check_output([ExecPath+"GetAccount.exe",Keyno]).strip('\r\ n') return ReturnInfo.split(',')# 查询委托明细def QueryAllOrder():ReturnInfo=subprocess.check_output([ExecPath+"GetAccount.exe","ALL"]).strip('\r\n'). split('\r\n')ReturnInfo= [ line.split(',') for line in ReturnInfo] return ReturnInfo# 查询未平仓信息def QueryOnOpen():ReturnInfo=subprocess.check_output([ExecPath+"OnOpenInterest.exe"]).strip('\r\n') return ReturnInfo.split(',')# 查询权益数信息 def QueryRight():ReturnInfo=subprocess.check_output([ExecPath+"FutureRights.exe"]).strip('\r\n') return ReturnInfo.split(',')# 撤销委托def CancelOrder(Keyno):ReturnInfo=subprocess.check_output([ExecPath+"order.exe","Delete",Keyno]) if "cancel send" in ReturnInfo: return True else:return False# 限价转删单def LMT2DEL(Product,BS,Price,Qty,Sec):OrderNo=OrderLMT(Product,BS,Price,Qty) StartTime=time.time()while time.time()-StartTime&lt;Sec:ReturnInfo=QueryOrder(OrderNo) if len(ReturnInfo)!=1: return ReturnInfo CancelOrder(OrderNo) return False# 限价转市价def LMT2MKT(Product,BS,Price,Qty,Sec):OrderNo=OrderLMT(Product,BS,Price,Qty) StartTime=time.time()while time.time()-StartTime&lt;Sec:ReturnInfo=QueryOrder(OrderNo) if len(ReturnInfo)!=1: return ReturnInfo if CancelOrder(OrderNo):ReturnInfo=OrderMKT(Product,BS,Qty) return ReturnInfo 程序内容包含多个下单函数，将分别在本章和第 10 章的函数技巧中介绍。 技巧104【程序】发送市价委托函数本技巧将介绍通过 Python 编写市价委托函数。FastOS 提供了子程序 Order.exe，通过 这个子程序就可以进行市价委托，前提是 FastOS 必须先登录群益交易账户。 市价单必须通过 MKT 参数，并在成交价参数中随意输入任何数字，不可忽略该参数。 在以下的市价委托函数代码中，会去执行外部命令 Order.exe，执行后就成功委托了。 需要注意的是子程序放置的位置，若在Python中没有将子程序路径设置好，则无法正确执 行。外部程序 Order.exe 的文件位置在当前目录下的 bin 目录中，而市价单函数会执行的动 作为: • 执行市价单委托。• 取委托明细，查询至成交回报委托明细。 文件名:order.py 12345678910111213141516171819@市价单下单 # -*- coding: UTF-8 -*-# 导入相关包 import subprocess# 下单子程序的存放位置 ExecPath="./bin/"# 市价单下单def OrderMKT(Product,BS,Qty):OrderNo=subprocess.check_output([ExecPath+"order.exe",Product,BS,"0",Qty,"MKT","I OC", "0"]).strip('\r\n')while True: ReturnInfo=subprocess.check_output([ExecPath+"GetAccount.exe",OrderNo]).strip('\ r\n').split(',') if len(ReturnInfo)&gt;1: return ReturnInfo``` 执行下单委托，在 Python 中的执行过程如下:回传的是成交信息的 list 对象。技巧 105 【程序】发送限价委托函数本技巧将介绍用 Python 进行限价委托。FastOS 提供了子程序 Order.exe，可以进行限 价委托。限价委托与市价委托的不同点在于，限价委托并不会立即成交，所以 FastOS 当初```bash &gt;&gt;&gt; OrderMKT('TX00','B','1')['0610034000396', '\xa6\xa8\xa5\xe6', 'FITX 201710', '\xb6R', '10437', '1', '09:29:46', 'F020000', '0000693', 'TW', 'u0025', '', '', '70000351', '0000000', '8888','\xa5\xbf\xb1`'] 技巧106【程序】获取单笔委托明细 在设计子程序时，限价委托不会等待成交回报，而是直接回传委托序列号。 委托序列号是券商提供给投资人每笔委托的辨识码，通过该码可以进行委托查询等相 关操作。 获取委托序列号后，通过 Python 去获取委托信息，确认是否成交，否则当限价委托不 断等待成交回报时会造成程序瘫痪。举例来说:当前成交价为 10 100，而我们下了 10 000 的限价买单(不会成交的情况)，这时如果子程序等待限价单成交回报，则整个策略程序会 维持在等待成交回报的无限循环之中，无法继续进行任何动作。 以下是限价委托函数的代码:文件名:order.py @限价单委托 1234567# -*- coding: UTF-8 -*-# 导入相关包 import subprocess# 下单子程序的存放位置 ExecPath="./bin/"# 限价单委托def OrderLMT(Product,BS,Price,Qty):OrderNo=subprocess.check_output([ExecPath+"order.exe",Product,BS,Price,Qty,"LMT","ROD", "0"]).strip('\r\n') return OrderNo 在 Python 中执行下单过程如下，回传的是委托序列号，获取该序列号后，可以对该笔 委托进行委托查询:委托查询会在下个技巧中进行介绍。技巧 106 【程序】获取单笔委托明细获取单笔成交信息，在策略中通常用来查询限价单是否成交，也是交易命令中必须用 到的，因为限价单存在不会成交的风险，所以要分别进行委托并需要提取委托明细来确保 策略程序稳定执行。 &gt;&gt;&gt; OrderLMT(&#39;TX00&#39;,&#39;B&#39;,&#39;10444&#39;,&#39;1&#39;) &#39;0610034000500&#39; OrderLMT(‘TX00’,’B’,’10449’,’1’) ‘0610034000502’ 回报的字符串内容以“，”分隔每一个字段，字段依序为:1委托序列号、2状态、 3商品代号、4多空、5价格、6手数、7时间、8分公司代号、9交易账号、10交易所、委托书号、 异动变更前量、 异动变更后量、 成交序列号、 子账号、 营业员编 号和 委托状态。以下是获取单笔委托明细的代码。文件名:order.py1234567@查询委托明细 # -*- coding: UTF-8 -*-# 导入相关包 import subprocess# 下单子程序的存放位置 ExecPath="./bin/"# 查询委托明细def QueryOrder(Keyno):ReturnInfo=subprocess.check_output([ExecPath+"GetAccount.exe",Keyno]).strip('\r\ n') return ReturnInfo.split(',') 在 Python 中，执行过程如下: 123456 &gt;&gt;&gt; OrderLMT('TX00','B','10444','1') '0610034000500'&gt;&gt;&gt; QueryOrder('0610034000500') ['Nodata']&gt;&gt;&gt; OrderLMT('TX00','B','10449','1')'0610034000502'&gt;&gt;&gt; QueryOrder('0610034000502')['0610034000502', '\xa6\xa8\xa5\xe6', 'FITX 201710', '\xb6R', '10449', '1', '09:39:10', 'F020000', '0000693', 'TW', 'o0029', '', '', '70000447', '0000000', '8888', '\xa5\xbf\xb1`'] 若未成交，则会回传 Nodata 字符串;若成交，则会回传成交明细。 技巧 107 【程序】撤销委托函数 撤销委托函数是指当委托无法成交或改变交易内容时可以使用的命令。当委托成交后， 无法撤销委托。 撤销委托需要提交委托序列号才能准确执行，常搭配交易命令使用。 以下是撤销委托的代码。 文件名:order.py@撤销委托 123456789# -*- coding: UTF-8 -*-# 导入相关包 import subprocess# 下单子程序的存放位置 ExecPath="./bin/"# 撤销委托def CancelOrder(Keyno):ReturnInfo=subprocess.check_output([ExecPath+"order.exe","Delete",Keyno]) if "cancel send" in ReturnInfo: return True else:return False 在 Python 中，执行过程如下: 1234 &gt;&gt;&gt; OrderLMT('TX00','B','10444','1') '0610034000500'&gt;&gt;&gt; QueryOrder('0610034000500') ['Nodata']&gt;&gt;&gt; CancelOrder('0610034000500') True&gt;&gt;&gt; CancelOrder('0610034000500') False 若回传字符串中有“cancel send”字符串，则认定撤单成功。 技巧 108 【概念】认识交易命令目前市场上既有的交易框架就是券商提供的下单函数:市价单和限价单。既然都已经 踏入了程序交易的领域，就应该能通过程序语言(本书以 Python 为例)延伸出更多交易函 数的组合。 在技巧 100 中提到市价单和限价单之间的矛盾之处，也就是成交价位与成交成功率的 问题，而交易命令就是用来解决这个问题的。 在市价单与限价单的选择中，可以衍生出折中方案“交易命令”，当我们自行编写程序 交易时，可以通过券商提供的交易命令再进行延伸。后面将会介绍简易的委托、删单功能 以及一些初级衍生的交易指令，例如限价单到期转市价单、限价单到期转撤单。 按照策略，我们应该能够搭配不同的交易命令来做配合。假设目前的策略不是通过价格或量来计算指标，在进出场时价格的波动就不会那么大，这时就可以通过限价单来进场。 若是通过价或量计算指标的策略，则必须使用“限价单到期转市价单”;对于小波段投资， 当没有在第一时间成交时，就可以考虑“限价单到期撤单”的交易命令。 本章后面的技巧将会介绍一些交易命令，让读者了解交易命令的编写方式，读者也可 以依照自己的需求进一步修改。 技巧 109 【程序】限价单到期转市价单“限价单到期转市价单”是交易指令的应用，也就是把券商的下单函数、自己的程序算 法搭配使用。 本技巧通过限价单委托，发送委托后检测是否成交。若限价委托成交就直接传送成交 回报;若未成交，到我们设定的秒数后，就转市价委托进行追单。 该函数为 LMT2MKT，参数为交易商品合约、买卖、价格、量以及到期秒数，执行函 数的语法如下:LMT2MKT(‘TX00’,’B’,’10510’,’1’,10)该函数代表以 10 510 的限价下了一手大台指数期货的买单，若在 10 秒内没有成交， 则会将限价委托撤销，转为市价单。 以下为限价单到期转市价单的代码，其中会用到本章的其他函数，详情可查看示例文件 order.py。 文件名:order.py123456789101112@ 限价转市价 # -*- coding: UTF-8 -*-# 导入相关包 import subprocess# 下单子程序的存放位置 ExecPath="./bin/"# 限价转市价def LMT2MKT(Product,BS,Price,Qty,Sec):OrderNo=OrderLMT(Product,BS,Price,Qty) StartTime=time.time()while time.time()-StartTime&lt;Sec:ReturnInfo=QueryOrder(OrderNo) if len(ReturnInfo)!=1: return ReturnInfoif CancelOrder(OrderNo): ReturnInfo=OrderMKT(Product,BS,Qty) return ReturnInfo 在 Python 中执行限价单到期转市价单的过程如下: 1234 &gt;&gt;&gt; LMT2MKT('TX00','B','10444','1',10)['0610034000509', '\xa6\xa8\xa5\xe6', 'FITX 201710', '\xb6R', '10444', '1', '09:39:59', 'F020000', '0000693', 'TW', 'x0032', '', '', '70000452', '0000000', '8888', '\xa5\xbf\xb1`']&gt;&gt;&gt; LMT2MKT('TX00','B','10400','1',10)['0610034000612', '\xa6\xa8\xa5\xe6', 'FITX 201710', '\xb6R', '10456', '1', '10:01:46', 'F020000', '0000693', 'TW', 'o0035', '', '', '70000552', '0000000', '8888', '\xa5\xbf\xb1`'] 技巧 110 【程序】限价单到期撤单本技巧与上述技巧的代码差异不大，只是将最后程序的市价单委托去掉，限价单到期后就撤销委托。 在用途上，两者是不太一样的。限价单到期撤单意味着这次进场没有成交，不做交易， 通常用于高频交易。在高频交易中，我们会寻求最佳的进场时机，若这次没有进场，则会 再寻找其他机会，而不是义无反顾地跟进。 本技巧通过限价单委托，在发送委托后检测是否成交。若限价委托成交，就直接传送 成交回报;若未成交，到我们设定的秒数后就强制撤销委托。 该函数为 LMT2DEL，参数为交易商品合约、买卖、价格、量以及到期秒数，执行函 数的语法如下: LMT2DEL(‘TX00’,’B’,’10510’,’1’,10)该函数代表以 10 510 的限价下了一手大台指数期货的买单，若在 10 秒内没有成交， 则会将限价委托撤销，转为市价单。以下是限价单到期删单的代码，其中会用到本章的其他函数，详情可查看示例文件 order.py。文件名:order.py@限价转撤单 12345678910111213 # -*- coding: UTF-8 -*- # 导入相关包186 第9章 连接券商的即时报价与下单函数 import subprocess# 下单子程序的存放位置 ExecPath="./bin/"# 限价转撤单def LMT2DEL(Product,BS,Price,Qty,Sec):OrderNo=OrderLMT(Product,BS,Price,Qty) StartTime=time.time()while time.time()-StartTime&lt;Sec:ReturnInfo=QueryOrder(OrderNo) if len(ReturnInfo)!=1: return ReturnInfo CancelOrder(OrderNo) return Canceled 在 Python 中执行限价单到期转市价单的过程如下: 1234&gt;&gt;&gt; LMT2DEL('TX00','B','10444','1',10)['0610034000423', '\xa6\xa8\xa5\xe6', 'FITX 201710', '\xb6R', '10444', '1', '09:32:09', 'F020000', '0000693', 'TW', 'm0025', '', '', '70000376', '0000000', '8888', '\xa5\xbf\xb1`']&gt;&gt;&gt; LMT2DEL('TX00','B','10440','1',10)Canceled]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python期货量化交易实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8章 设置出场及止损获利的条件]]></title>
    <url>%2F2020%2F11%2F26%2F%E7%AC%AC8%E7%AB%A0-%E8%AE%BE%E7%BD%AE%E5%87%BA%E5%9C%BA%E5%8F%8A%E6%AD%A2%E6%8D%9F%E8%8E%B7%E5%88%A9%E7%9A%84%E6%9D%A1%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在一个自动交易策略中，稳定的出场规则是相当重要的，这是在主观交易中很难实现的部分，因为人性具有贪婪以及恐惧的特质，当这些情绪影响到交易者，就很难控制交易的风险。 程序策略的出场可能会因为太过于死板而错过许多赚钱的机会，要在固定的交易逻辑中既能控制风险又能兼顾获利的稳定是计量交易者必备的功课。本章所提供的出场示例是由目前常见的一些出场条件以及一些笔者本身的交易经验所汇集而成。 技巧87 【概念】何谓出场商品交易分为进场和出场，其中出场的意思就是将目前的“持仓头寸”进行结算，“持仓”就是存有投资商品在自己名下，“头寸”代表资金，出场则代表另外一个含义，即获利 了结或停止亏损。 当投资人手上有持仓头寸时，就会思考如何处理这些头寸，若目前持仓头寸符合当前的趋势，则思考如何止盈；反之，若当前头寸的多空不符合当前的趋势，则思考如何止损。 许多投资人会用进场时机的交易逻辑去判别何时平仓，但平仓还需要考虑到止损，所以当持仓头寸的动态损益已经亏损到一个基准点时，这个时间点也就是投资人平仓的时机，也是风险管控的重要课题。 在状态不明、亏损过大或情绪不稳定时，建议先平仓，退出市场观察后再决定是否要继续交易。这个观念反映的是市场的不确定性与高风险性，因为日内交易往往价格波动比较大，若遇到非预期的状况，建议先出场，等待趋势明确后再进场。 技巧88 【程序】价格止损与获利第一个出场的技巧几乎是每个策略都会用到的价格止损或价格止盈。站在一个投资的角度，不仅要考虑获利，也要考虑投资风险。作为一个程序化交易者，当然要运用程序的优势进行精准的止损/止盈，控制投资的获利与风险。 策略的出场并非一定是价格的因素，有可能是某个事件触发，但是在所有出场条件中价格这个指标必须考虑，因为若没有考虑价格，则可能会导致保证金不足而直接爆仓。 价格止损与价格止盈，是可以分别使用的。许多人会用价格作为止损指标来控制风险， 但是不一定会用单一价位作为止盈的基准。 单一价格的止盈较少被使用，原因是整个市场每天的活跃度都是不同的，若是达到某些特定条件，例如：交易所涨跌幅的限制为10%，则可在此区间附近进行止盈。以下是价格止损/止盈的代码。 文件名:88.py 1234567891011121314151617181920212223242526272829303132# -*- coding: UTF-8 -*-# 获取报价信息，详情请查看技巧51 exec(open("function.py", encoding = 'utf-8').read())# 定义指标变量stopLoss=10takeProfit=10# 假设目前仓位为买方，进场部分请参考第7章index=1orderPrice=10300coverPrice=0# 获取成交信息for i in getMatch(): MatchInfo=i.split(',') MatchPrice=int(MatchInfo[1]) # 出场判断if index==1: if MatchPrice&gt;=orderPrice+takeProfit or MatchPrice&lt;=orderPrice-stopLoss: index=0 coverPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") breakelif index==-1: if MatchPrice&lt;=orderPrice-takeProfit or MatchPrice&gt;=orderPrice+stopLoss: index=0 coverPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break 技巧89 【程序】价格回跌获利出场从技巧88延伸至此，换个角度思考，若止盈出场不是通过单一价差，而是能够随着时间与市场成交价有所改变，则是一个不错的想法。 本技巧将在当前价高于进场价加上特定的止盈基准点时开始进行侦测。假设我们设定30点为止盈基准点，回跌25%出场，我们在10000点进场，其中价格最高飙到10040，回跌至10030[10000 + (40 × 75%)]时则出场，若价格没有突破10030，则回跌不计。 以下为价格回跌止盈出场的代码，其中止盈基准点为20，回跌至75%则出场。 文件名:89.py 1234567891011121314151617181920212223242526272829303132# -*- coding: UTF-8 -*-#取得報價資訊，詳情請查看技巧51exec(open("function.py", encoding = 'utf-8').read())#定義指標變數stopLoss=10takeProfit=10#假設目前倉位為買方，進場部分請參考第七章index=1orderPrice=10300coverPrice=0#取得成交資訊for i in getMatch(): MatchInfo=i.split(',') MatchPrice=int(MatchInfo[1]) # 出場判斷 if index==1: if MatchPrice&gt;=orderPrice+takeProfit or MatchPrice&lt;=orderPrice-stopLoss: index=0 coverPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break elif index==-1: if MatchPrice&lt;=orderPrice-takeProfit or MatchPrice&gt;=orderPrice+stopLoss: index=0 coverPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break 技巧90 【程序】MA穿越价格出场在第7章的技巧80中，已经介绍过价格穿越MA的进场判断，而本技巧则是通过MA来进行出场条件的判断。 策略的进出场条件:不一定进场有MA条件，出场就必须有MA条件，每个策略都可以通过进出场条件的特性去互相搭配。MA出场有一个特性，即当价格趋于平稳时就是出场时机。 或许通过某些有趣的配合，例如爆量进场与MA穿越出场，不过这在实际的市场买卖中还是要考虑滑点风险的。 以下为MA穿越价格出场的代码。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# -*- coding: UTF-8 -*-#取得報價資訊，詳情請查看技巧51exec(open("function.py", encoding = 'utf-8').read())#定義指標變數MAarray=[]MAnum=10lastHMTime=""lastMAValue=0lastPrice=0#假設目前倉位為買方，進場部分請參考第七章index=1orderPrice=10300coverPrice=0#取得成交資訊for i in getMatch(): MatchInfo=i.split(',') HMTime=MatchInfo[0][0:2]+MatchInfo[0][3:5] MatchPrice=int(MatchInfo[1]) if len(MAarray)==0: MAarray+=[MatchPrice] lastHMTime=HMTime else: if HMTime==lastHMTime: MAarray[-1]=MatchPrice elif HMTime!=lastHMTime: if len(MAarray)&lt;MAnum: MAarray+=[MatchPrice] elif len(MAarray)==MAnum: MAarray=MAarray[1:]+[MatchPrice] lastHMTime=HMTime #出場判斷 if len(MAarray)==MAnum : MAValue=float(sum(MAarray))/len(MAarray) if lastMAValue==0 and lastPrice==0: lastMAValue=MAValue lastPrice=MatchPrice continue print("Price",MatchPrice,"MA",MAValue ) if index==1: if MatchPrice&lt;MAValue and lastPrice&gt;=lastMAValue: index=0 coverPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break elif index==-1: if MatchPrice&gt;MAValue and lastPrice&lt;=lastMAValue: index=0 coverPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break lastMAValue=MAValue lastPrice=MatchPrice 技巧91 【程序MA慢线追过快线出场在第7章的技巧81中，已经介绍过MA快线穿越MA慢线的进场判断，而本技巧则是通过MA来进行出场条件的判断。 本技巧与技巧90的差异在于，双MA线不会受到价格的直接影响。以下是MA慢线追过快线出场的代码。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding: UTF-8 -*-#取得報價資訊，詳情請查看技巧51exec(open("function.py", encoding = 'utf-8').read())#定義指標變數MAarray=[]longMAnum=14shortMAnum=7lastHMTime=""lastShortMAValue=0lastLongMAValue=0#假設目前倉位為買方，進場部分請參考第七章index=1orderPrice=10300coverPrice=0#取得成交資訊for i in getMatch(): MatchInfo=i.split(',') HMTime=MatchInfo[0][0:2]+MatchInfo[0][3:5] MatchPrice=int(MatchInfo[1]) if len(MAarray)==0: MAarray+=[MatchPrice] lastHMTime=HMTime else: if HMTime==lastHMTime: MAarray[-1]=MatchPrice elif HMTime!=lastHMTime: if len(MAarray)&lt;longMAnum: MAarray+=[MatchPrice] elif len(MAarray)==longMAnum: MAarray=MAarray[1:]+[MatchPrice] lastHMTime=HMTime #出場判斷 if len(MAarray)==longMAnum : longMAValue=float(sum(MAarray))/longMAnum shortMAValue=float(sum(MAarray[longMAnum-shortMAnum:]))/shortMAnum if lastLongMAValue==0 and lastShortMAValue==0: lastLongMAValue=longMAValue lastShortMAValue=shortMAValue continue print("ShortMA",shortMAValue,"LongMA",longMAValue ) if index==1: if shortMAValue&lt;lastLongMAValue and lastShortMAValue&gt;=lastLongMAValue: index=0 coverPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break elif index==-1: if shortMAValue&gt;lastLongMAValue and lastShortMAValue&lt;=lastLongMAValue: index=0 coverPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break lastLongMAValue=longMAValue lastShortMAValue=shortMAValue 技巧92 【程序】委托比重反转出场在趋势判断的章节（第6章）中，有通过委托量来进行趋势判断的技巧，而许多策略会依据这些技巧来作为趋势判断。 本技巧为趋势不明的策略出场条件。若进场时，委托比重为买方大于卖方，而在进场后委托比重反转为卖方大于买方，这时趋势已经不明确了，或许就该出场了。 若没有依据委托比重作为进场趋势的判断，则通过该技巧的出场条件可能会造成进场后马上出场的情况，所以必须谨慎规划策略，才不会造成无谓的损失。 以下为委托比重反转出场的代码。 文件名：92.py 123456789101112131415161718192021222324252627282930313233343536# -*- coding: UTF-8 -*-exec(open("function.py", encoding = 'utf-8').read())#定義指標變數lastBAmount=0lastSAmount=0#假設目前倉位為買方，進場部分請參考第七章index=1orderPrice=10300#取得委託資訊for i in getOrder(): OrderInfo=i.split(',') OrderBAmount=int(OrderInfo[2]) OrderSAmount=int(OrderInfo[4]) if lastBAmount==0 and lastSAmount==0: lastBAmount=OrderBAmount lastSAmount=OrderSAmount diffBAmount=OrderBAmount-lastBAmount diffSAmount=OrderSAmount-lastSAmount #抽單出場判斷 if index==1: if diffBAmount &lt;= -100: index=0 print(MatchInfo[0],"Order Sell Success!") break elif index==-1: if diffSAmount &lt;= -100: index=0 print(MatchInfo[0],"Order Buy Success!") break 技巧93 【程序】委托量抽单出场委托簿的信息属于累计信息，从中我们可以了解到每5秒的变动，而在某些时刻会有委托撤单的现象。撤单是委托簿的累计信息不增反减，例如委托买卖量上5秒的信息比当前委托买卖量还高，代表这5秒有投资人将委托单进行取消。 委托下单是需要保证金的，当市场上的交易大户要进行大手数的委托时，需要有足额的保证金，所以会有大手数撤单，代表有高额保证金的转移，这往往是趋势发生的前兆。我们可以利用这种市场行为来作为策略的判断依据，但也要依照每个读者的看法做策略的用途。 本技巧将通过委托量单笔的大量减少来作为出场的判断，例如当仓位为买单，买方的委托总量单笔减少200手，则出场;当仓位为卖单，卖方的委托总量单笔减少200手，则出场。 以下是委托量撤单出场的代码，该示例以100手为基准，撤单大于100手则为出场信号。 文件名：93.py 12345678910111213141516171819202122232425262728# -*- coding: UTF-8 -*-#取得報價資訊，詳情請查看技巧51exec(open("function.py", encoding = 'utf-8').read())#假設目前倉位為買方，進場部分請參考第七章index=1orderPrice=10300#取得委託資訊for i in getOrder(): OrderInfo=i.split(',') OrderBCnt=int(OrderInfo[1]) OrderBAmount=float(OrderInfo[2]) OrderSCnt=int(OrderInfo[3]) OrderSAmount=float(OrderInfo[4]) #出場判斷 if index==1: if OrderBAmount/OrderBCnt&lt;OrderSAmount/OrderSCnt: index=0 print(MatchInfo[0],"Order Sell Success!") break elif index==-1: if OrderBAmount/OrderBCnt&gt;OrderSAmount/OrderSCnt: index=0 print(MatchInfo[0],"Order Buy Success!") break 技巧94 【程序】内外盘量反转出场在前面的章节中，无论是指标函数（参见技巧56、技巧57）以及趋势判断（参见技巧73）都有介绍到内外盘比率。 需要注意的是，若趋势判断、进场条件与出场条件不相同时，则我们在每个时期都会有不同的计算指标；假设趋势判断为大户指标累计量，但出场条件是内外盘，则会依照每个策略的定义；若需要从一开始就计算内外盘指标，则在进场条件判断中就要提前开始计算外盘指标值。 若趋势判断不是通过内外盘指标，则需要考虑该策略的连贯性，否则可能会面临一进场即出场的窘境，造成无谓的损失。 内外盘反转有几种看法：当内外盘比率发生极端值时（例如80%）进场，出场条件可 能就不会设置为50%反转，而是在一个特定比例（60%；80%~20%）内出场，否则等待到反转时可能已经错过好的出场点了。 以下是内外盘量反转出场的代码。 文件名：94.py 12345678910111213141516171819202122232425262728293031323334353637383940414243# -*- coding: UTF-8 -*-exec(open("function.py", encoding = 'utf-8').read())#定義指標變數OutDesk=0InDesk=0#假設目前倉位為買方，進場部分請參考第七章index=1orderPrice=10300coverPrice=0#取得成交資訊for i in getMatch(): MatchInfo=i.split(',') MatchTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") MatchPrcie=int(MatchInfo[1]) MatchQty=int(MatchInfo[2]) UpDn5Info=getLastUpDn5() Dn1Price=int(UpDn5Info[1]) Up1Price=int(UpDn5Info[11]) if MatchPrcie&gt;=Up1Price: OutDesk+=MatchQty if MatchPrcie&lt;=Dn1Price: InDesk+=MatchQty #出場判斷 if index==1: if InDesk&gt;OutDesk: index=0 coverPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break elif index==-1: if InDesk&lt;OutDesk: index=0 coverPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break print(MatchInfo[0],"OutDesk",OutDesk,"InDesk",InDesk) 技巧95 【程序】一分钟爆量出场交易市场往往是量能带动价格走势，我们在看盘软件上常见的就是以一分钟为单位的量能变动图，本书中也有提到量能的指标计算（见技巧53、技巧63）。 有句俗语：新手看价，高手看量，老手看筹码。我们可以将这句话解读为：量能的迅速剧增，可以大幅地造成价格涨跌，投资人一般会认为该市场行为一旦发生，应该要进入市场大赚一笔（认为是进场信号）。 但读者有没有发现，这个技巧的定位是在出场判断。也就是说，换个角度想，若我们可以将它作为止盈的基础，是不是可以找到一个稳定的获利出场点？爆量时并非不能设定为进场点，但是若没有快速的下单通道，通常都是跟进后成交价位都是处于趋势末端，之后往往找不到合适的出场点，导致徒劳无功。 通过图8-1来看看爆量出场是否合理。 图8-1 在图8-1的9点~10点的时候，有量能爆发的情况。量能爆发应该如何定义，这也是计量回测的功课之一。下面提出几个定义给大家参考。 1.定义固定基准 例如每分钟超过1 000手成交量称为“量能爆发”。 2.计算当日每分钟平均量能 只要突破该平均量能就视为量能爆发，该定义可能会导致不稳定触发，当天若是震荡盘，则有可能误判。 3.计算平均值，并且设置最低界线 若平均值未超过最低界线，则平均值无效;反之，当平均值超过最低界线时，就将该平均值作为爆量基准。 以下为爆量出场的代码，定义固定基准爆量出场值为1 000，分钟累计量一旦突破1 000就视为出场条件。 文件名:95.py 1234567891011121314151617181920212223242526272829303132333435363738394041# -*- coding: UTF-8 -*-exec(open("function.py", encoding = 'utf-8').read())#定義指標變數Qty=[]lastHMTime=""lastAmount=0#假設目前倉位為買方，進場部分請參考第七章index=1orderPrice=10300#取得成交資訊for i in getMatch(): MatchInfo=i.split(',') HMTime=MatchInfo[0][0:2]+MatchInfo[0][3:5] MatchAmount=int(MatchInfo[3]) if lastAmount==0: lastAmount=MatchAmount lastHMTime=HMTime if HMTime==lastHMTime: Qty=MatchAmount-lastAmount else: Qty=0 lastAmount=MatchAmount lastHMTime=HMTime #出場判斷 if Qty&gt;=1000: if index==1: index=0 print(MatchInfo[0],"Order Sell Success!") break if index==-1: index=0 print(MatchInfo[0],"Order Buy Success!") break print(Qty) 通过Python指令进行爆量出场，过程如下： 12345678910&gt; python 95.py0123...88795998409:50:48.18 Order Sell Success! 技巧96 【程序】大户指标反转出场在前面的章节中，无论是指标函数(技巧66)、趋势判断(技巧74)以及进场判断(技巧86)都有介绍到大户指标。需要注意的是，若趋势判断与出场条件的判断指标不相同(假设趋势判断为内外盘，但出场条件是大户指标累计量)，则会依照每个策略的定义。若需要从一开始就计算大户指标累计量，则在进场条件判断中就要提前开始计算了。 另外，若进场的趋势判断不是通过大户指标累计量，则需要考虑该策略的连贯性，否则可能会面临反复进出场的窘境，造成无谓的损失。 当大户指标的累计量反转，我们可以判定另外一方的压力已经涌入，这时候必须谨慎判断何时出场。 以下为大户指标反转出场的代码。 文件名:96.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# -*- coding: UTF-8 -*-exec(open("function.py", encoding = 'utf-8').read())#定義指標變數lastBcnt=0lastScnt=0accB=0accS=0#假設目前倉位為買方，進場部分請參考第七章index=1orderPrice=10300coverPrice=0#取得成交資訊for i in getMatch(): MatchInfo=i.split(',') MatchTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") MatchPrice=int(MatchInfo[1]) MatchQty=int(MatchInfo[2]) MatchBcnt=int(MatchInfo[4]) MatchScnt=int(MatchInfo[5]) if lastBcnt==0 and lastScnt==0: lastBcnt=MatchBcnt lastScnt=MatchScnt else: diffBcnt=MatchBcnt-lastBcnt diffScnt=MatchScnt-lastScnt if MatchQty&gt;=10: if diffBcnt==1 and diffScnt&gt;1: accB+=MatchQty print(MatchInfo[0],MatchPrice,MatchQty,0,accB,accS) elif diffScnt==1 and diffBcnt&gt;1: accS+=MatchQty print(MatchInfo[0],MatchPrice,0,MatchQty,accB,accS) #出場判斷 if index==1: if accB&lt;accS: index=0 coverPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break elif index==-1: if accB&gt;accS: index=0 coverPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break lastBcnt=MatchBcnt lastScnt=MatchScnt]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python期货量化交易实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章 规划进场的时机]]></title>
    <url>%2F2020%2F11%2F26%2F%E7%AC%AC7%E7%AB%A0-%E8%A7%84%E5%88%92%E8%BF%9B%E5%9C%BA%E7%9A%84%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在整个交易流程当中，进场时机的规划是重要的环节之一，而市场上并没有完美的进场点，每个不同的策略会创造属于该策略的进场时机，而不是单从当日高低点可以进行判断的。走极短线交易风格的交易者，或许并不需要判断当日的高低点及目前的价位的对应关系，只需要在发生某个事件时进场。 技巧75 【概念】何谓进场投资人下单的第一步必须要先了解未来价格可能的走势，所以必须通过经验法则、价量关系以及指标函数来帮助我们判断。简单来说，投资人能利用目前市场上常用的观察方法找出进场时机，例如：MA指标、布尔信道以及K线图表分析等。当然投资人也能将其组合成一个进场时机综合判断的方法，将不同的技术指标结合起来，当多项指标同时符合下单条件时为进场时机，这样就有机会加强投资的准确性。 技巧76 【概念】进场点及成交价在进行程序交易时，往往程序触发点与市场成交价不一样，通常会滑价1~2 点。例如: 若是MA穿越的策略，当前价穿越MA，而当目前市场价格10 000点向上穿越9 999点MA指标，以市价买进一手，则成交价通常都是10 001点或以上，一买一卖则产生了两次滑点，影响获利绩效两点以上。这是为何呢？有以下4个原因。 （1）程序化交易获取当前报价成交在10 000点，也是策略的进场触发点，这10 000点成交价是市场上一买一卖的最佳成交价，但是这个信息是已经发生的数据，并不保证往后的价格关联性。 （2）MA策略本来就是众多投资人关注的交易指标，若交易逻辑差异不大，则可能许多投资人同时触发进场点，这时就有可能造成上几档价都被成交，造成成交滑点问题。 （3）市场上的交易规则，市价买单会成交在市场最佳上一档价，也就是说，假设目前成交价为10 000，上一档价可能是10 001或以上，因此下市价单极有可能会成交在10 001 或以上。 （4）市场大户一笔订单成交于多个价位。例如：买单10 000与10 001的价格都被成交完，因此只能成交在10 002。 技巧77 【概念】趋势交易和顺势交易的进场区别通常一整个完整的交易程序，会包含进场和出场机制，也就是说，假设我们拥有一支当冲的交易策略，其中会包含进场判断和出场判断，并且在当日一定会将既有的仓位平仓。 完整的交易策略当中的进场点，从信息的角度来说，分 为趋势交易进场与顺势交易进场，单纯是因为两者的算法架构不同，并非是金融操作上的不同。 就构架来说，趋势策略进场会包含趋势判断和进场判断，例如委托判断多空，MA穿越判断进场；而顺势策略仅有进场判断，例如，通过大户指标，买方一笔成交40手以上，则顺势做多。趋势交易及顺势交易的流程如图7-1所示。 图7-1 技巧78 【概念】如何通过Python进行实盘委托在程序化交易中，Python所扮演的角色就是运算与判断平台，通过外部的程序来进行下单，所以我们会将焦点放在如何通过Python执行外部的程序。 Python可以通过subprocess包中的check_output函数来进行外部命令，并且执行外部命令后，还能获取回传值，通过这样的搭配，我们就可以在Python中设立下单机制，甚至是委托系统。 本示例介绍的是进场条件的判断，重点并非下单的处理，所以有关下单的代码都会通过print函数以显示来代替实盘交易，在后面章节中才会提到如何进行实际下单与构建委托函数。 说明下单的机制与委托的读取，可参阅第9章的介绍。 技巧79 【程序】固定时间进场进场条件最简单的示例就是在固定时间进场，也就是当时间穿越指定的时间后就会进行进场动作。进场的动作在本章中将不进行真实下单，而以列出一行文字的方式显示，代码如下所示： 1print("Order Buy Success!") 以下为固定时间进场的策略。 文件名：79.py 123456789101112131415161718192021222324# -*- coding: UTF-8 -*-# 获取报价信息，详情请查看技巧51exec(open("function.py", encoding = 'utf-8').read())orderTime=datetime.datetime.strptime('09:00:00.00',"%H:%M:%S.%f")# 设置初始仓位，若为0，则为空仓index=0orderPrice=0# 获取成交信息for i in getMatch(): MatchInfo=i.split(',') MatchTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") MatchPrice=int(MatchInfo[1]) if MatchTime&gt;=orderTime: index=1 orderPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break# 后续是出场条件判断，本章不做介绍 通过Python指令执行该程序，结果如下: 12&gt; python 79.py09:00:00.09 Order Buy Success! 曾听过一种交易策略：在开盘时，由于价格震荡较大，通过两个交易账户在同一个价位的多方和空方各下一手并设置止损和止盈点，当趋势发生时，趋势相反的一方会进行止损，正确的一方则会赚取一个价格小波段。 固定时间进场都是一些特殊的时间点，例如8:45期货开盘，9:00现货（股票）开盘，13:30现货（股票）收盘。另外，或许是人们的习惯，整点（如10点、11点）发生行情变化的机会都较高，也是进场的时机点。 技巧80 【程序】价格穿越MA进场MA策略有许多变化，其中常见的就是快线追慢线。本技巧将介绍的是价格（快线）追MA（慢线），若快线向上突破，则做多；反之，若快线向下突破，则做空。 通过逐笔的成交价进行价格穿越判断，该策略优缺点是并存的：优点是可以比一般看盘软件的投资人提早判断进场点；缺点是当价格波动小的时候，可能会造成反复穿越，必须通过其他进场判断机制来提高策略的准确度。 通常MA穿越策略，都是趋势交易的策略，会先决定多空的方向，毕竟在价格波动较大的期货市场中，在逐笔计算的情况下很有可能多次交叉穿越，这时若没有趋势判断，则可能会造成多次下单。 实盘交易时的MA穿越会搭配趋势判断，本示例仅展示价格由下往上穿越MA时买进一手，并没有搭配趋势判断。以下是MA策略和价格穿越MA的代码。 文件名：80.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding: UTF-8 -*-exec(open("function.py", encoding = 'utf-8').read())# 设置指标变量MAarray=[]MAnum=10lastHMTime=""lastMAValue=0lastPrice=0# 设置趋势trend=1# 设置初始仓位，若为0，则为空仓index=0orderPrice=0# 获取成交信息for i in getMatch(): MatchInfo=i.split(',') HMTime=MatchInfo[0][0:2]+MatchInfo[0][3:5] MatchPrice=int(MatchInfo[1]) if len(MAarray)==0: MAarray+=[MatchPrice] lastHMTime=HMTime else: if HMTime==lastHMTime: MAarray[-1]=MatchPrice elif HMTime!=lastHMTime: if len(MAarray)&lt;MAnum: MAarray+=[MatchPrice] elif len(MAarray)==MAnum: MAarray=MAarray[1:]+[MatchPrice] lastHMTime=HMTime if len(MAarray)==MAnum : MAValue=float(sum(MAarray))/len(MAarray) if lastMAValue==0 and lastPrice==0: lastMAValue=MAValue lastPrice=MatchPrice continue print("Price",MatchPrice,"MA",MAValue ) if trend==1: if MatchPrice&gt;MAValue and lastPrice&lt;=lastMAValue: index=1 orderPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break elif trend==-1: if MatchPrice&lt;MAValue and lastPrice&gt;=lastMAValue: index=-1 orderPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break lastMAValue=MAValue lastPrice=MatchPrice # 后续是出场条件判断，本章不做介绍 通过Python指令执行该程序，结果如下: 123456789&gt; python 80.pyPrice 10302 MA 10298.0 Price 10302 MA 10298.0 Price 10302 MA 10298.0Price 10301 MA 10297.9Price 10298 MA 10297.6 Price 10297 MA 10297.5Price 10298 MA 10297.609:32:52.06 Order Buy Success! 技巧81 【程序】MA快线追慢线进场本技巧是在技巧80的基础上所进行的改良，改良的原因是期货的价格波动较大，所以很多时机点都是价格在一瞬间进行的假突破，接着成交价就往另外一方走了，这时就很有可能止损出场。因此通过比较两个MA，可以减少价格所带来的瞬间影响力。消化过价格变化后，MA的穿越显得相对稳定。 缺点是对于进场的判断时机较为缓慢。读者可以对该进场点进行修改，加上其他判断机制，让整个进场机制更加完整。 以下是MA快线追慢线进场的代码。 文件名：81.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960# -*- coding: UTF-8 -*-exec(open("function.py", encoding = 'utf-8').read())# 设置指标变量MAarray=[]longMAnum=14shortMAnum=7lastHMTime=""lastShortMAValue=0lastLongMAValue=0# 设置趋势trend=1# 设置初始仓位，若为0，则为空仓index=0orderPrice=0# 获取成交信息for i in getMatch(): MatchInfo=i.split(',') HMTime=MatchInfo[0][0:2]+MatchInfo[0][3:5] MatchPrice=int(MatchInfo[1]) if len(MAarray)==0: MAarray+=[MatchPrice] lastHMTime=HMTime else: if HMTime==lastHMTime: MAarray[-1]=MatchPrice elif HMTime!=lastHMTime: if len(MAarray)&lt;longMAnum: MAarray+=[MatchPrice] elif len(MAarray)==longMAnum: MAarray=MAarray[1:]+[MatchPrice] lastHMTime=HMTime if len(MAarray)==longMAnum : longMAValue=float(sum(MAarray))/longMAnum shortMAValue=float(sum(MAarray[longMAnum-shortMAnum:]))/shortMAnum if lastLongMAValue==0 and lastShortMAValue==0: lastLongMAValue=longMAValue lastShortMAValue=shortMAValue continue print("ShortMA",shortMAValue,"LongMA",longMAValue ) if trend==1: if shortMAValue&gt;lastLongMAValue and lastShortMAValue&lt;=lastLongMAValue: index=1 orderPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break elif trend==-1: if shortMAValue&lt;lastLongMAValue and lastShortMAValue&gt;=lastLongMAValue: index=-1 orderPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break lastLongMAValue=longMAValue lastShortMAValue=shortMAValue 通过Python指令执行该程序，结果如下： 12 技巧82 【程序】MA第二次穿越进场本技巧是技巧81的衍生策略。在真实的市场中，若大家都关注某一个指标的变化，那么有心操作的市场大户就可以进行假突破，接着反向拉价，这时可能许多人进场后会发现情况不对而仓皇止损；从程序化交易的角度来说，就有可能会触发止损条件而出场。 通过这个示例，我们就可以延缓进场，等趋势较确定后再进场。 图7-2为某一天9:00以后的价格走势以及MA线，圈内的走势在当天的一开始就向下突破，接着价格逆涨30点，许多在9:00左右做空的投资人应该都已经止损了。不过，第二次穿越之后，价格就一路走低。 图7-2 以下策略在第二次穿越后进场，通过一个标签（pass变量）来记录目前穿越次数。 文件名:82.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869# -*- coding: UTF-8 -*-#取得報價資訊，詳情請查看技巧51exec(open("function.py", encoding = 'utf-8').read())#設定指標變數MAarray=[]longMAnum=14shortMAnum=7lastHMTime=""lastShortMAValue=0lastLongMAValue=0crossTime=0#設定趨勢trend=1#設定初始倉位，若為0則為無在倉部位index=0orderPrice=0#取得成交資訊for i in getMatch(): MatchInfo=i.split(',') HMTime=MatchInfo[0][0:2]+MatchInfo[0][3:5] MatchPrice=int(MatchInfo[1]) if len(MAarray)==0: MAarray+=[MatchPrice] lastHMTime=HMTime else: if HMTime==lastHMTime: MAarray[-1]=MatchPrice elif HMTime!=lastHMTime: if len(MAarray)&lt;longMAnum: MAarray+=[MatchPrice] elif len(MAarray)==longMAnum: MAarray=MAarray[1:]+[MatchPrice] lastHMTime=HMTime if len(MAarray)==longMAnum : longMAValue=float(sum(MAarray))/longMAnum shortMAValue=float(sum(MAarray[longMAnum-shortMAnum:]))/shortMAnum if lastLongMAValue==0 and lastShortMAValue==0: lastLongMAValue=longMAValue lastShortMAValue=shortMAValue continue print("ShortMA",shortMAValue,"LongMA",longMAValue ) if trend==1: if shortMAValue&gt;lastLongMAValue and lastShortMAValue&lt;=lastLongMAValue: crossTime+=1 print("Cross",MatchInfo[0]) if crossTime==2: index=1 orderPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break elif trend==-1: if shortMAValue&lt;lastLongMAValue and lastShortMAValue&gt;=lastLongMAValue: crossTime+=1 print("Cross",MatchInfo[0]) if crossTime==2: index=-1 orderPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break lastLongMAValue=longMAValue lastShortMAValue=shortMAValue 通过Python指令执行该程序，结果如下： 1234567891011121314151617181920&gt; python 82.pyShortMA 10379.7142857 LongMA 10376.1428571 ShortMA 10379.7142857 LongMA 10376.1428571 ShortMA 10379.7142857 LongMA 10376.1428571 ShortMA 10379.7142857 LongMA 10376.1428571 ...ShortMA 10377.5714286 LongMA 10377.9285714 ShortMA 10378.2857143 LongMA 10378.0Cross 09:25:00.03ShortMA 10378.2857143 LongMA 10378.0 ShortMA 10378.1428571 LongMA 10377.9285714 ...ShortMA 10381.0 LongMA 10381.0714286 ShortMA 10381.0 LongMA 10381.0714286 ShortMA 10381.0 LongMA 10381.0714286 ShortMA 10381.1428571 LongMA 10381.1428571 Cross 09:41:04.2709:41:04.27 Order Buy Success! 技巧83 【程序】MA延迟进场第二次穿越进场本技巧是技巧82的延伸，为了应对许多价格短时间剧烈震荡而造成太早进场。市场是瞬息万变的，有些时候价格平稳，有些时候大幅度震荡。当市场价格较为平稳时，MA策略就可能会发生来回穿越，如图7-3所示，就是价格来回震荡的走势。 图7-3 这时我们可以用某些方式来解决。 策略出场条件不使用MA穿越出场。 价格与MA的差异在某个范围内不出场，假设目前部位为一手多单，但价格与MA差距未超过10点，不出场。 延缓时间二次穿越进场，当前穿越后不进场，而是在数分钟以后第二次穿越进场。除了价格走势平稳以外，也可以预防市场的第一波走势被横扫的风险。MA延迟进场第二次穿越进场的代码如下。 文件名：83.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273# -*- coding: UTF-8 -*-#取得報價資訊，詳情請查看技巧51exec(open("function.py", encoding = 'utf-8').read())#設定指標變數MAarray=[]longMAnum=14shortMAnum=7lastHMTime=""lastShortMAValue=0lastLongMAValue=0crossTime=0interval=300#設定趨勢trend=1#設定初始倉位，若為0則為無在倉部位index=0orderPrice=0#取得成交資訊for i in getMatch(): MatchInfo=i.split(',') HMTime=MatchInfo[0][0:2]+MatchInfo[0][3:5] MatchPrice=int(MatchInfo[1]) if len(MAarray)==0: MAarray+=[MatchPrice] lastHMTime=HMTime else: if HMTime==lastHMTime: MAarray[-1]=MatchPrice elif HMTime!=lastHMTime: if len(MAarray)&lt;longMAnum: MAarray+=[MatchPrice] elif len(MAarray)==longMAnum: MAarray=MAarray[1:]+[MatchPrice] lastHMTime=HMTime if len(MAarray)==longMAnum : longMAValue=float(sum(MAarray))/longMAnum shortMAValue=float(sum(MAarray[longMAnum-shortMAnum:]))/shortMAnum if lastLongMAValue==0 and lastShortMAValue==0: lastLongMAValue=longMAValue lastShortMAValue=shortMAValue continue print("ShortMA",shortMAValue,"LongMA",longMAValue ) if trend==1: if shortMAValue&gt;lastLongMAValue and lastShortMAValue&lt;=lastLongMAValue: if crossTime==0: crossTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") print("Cross",MatchInfo[0]) elif datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") &gt; crossTime+datetime.timedelta(0,interval): index=1 orderPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break elif trend==-1: if shortMAValue&lt;lastLongMAValue and lastShortMAValue&gt;=lastLongMAValue: if crossTime==0: crossTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") print("Cross",MatchInfo[0]) elif datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") &gt; crossTime+datetime.timedelta(0,interval): index=-1 orderPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break lastLongMAValue=longMAValue lastShortMAValue=shortMAValue #接著以下為出場條件判斷，本章不做介紹 通过Python指令执行该程序，结果如下: 123456789101112131415&gt; python 83.pyShortMA 10378.1428571 LongMA 10376.4285714 ShortMA 10378.1428571 LongMA 10376.4285714 ShortMA 10378.1428571 LongMA 10376.4285714 ShortMA 10378.1428571 LongMA 10376.4285714 ShortMA 10378.0 LongMA 10376.3571429...ShortMA 10378.2857143 LongMA 10378.0Cross 09:25:00.03ShortMA 10378.2857143 LongMA 10378.0 ShortMA 10378.1428571 LongMA 10377.928571 ...ShortMA 10381.0 LongMA 10381.0714286 ShortMA 10381.0 LongMA 10381.0714286 ShortMA 10381.1428571 LongMA 10381.1428571 09:41:04.27 Order Buy Success! 技巧84 【程序】上下穿越高低点顺势进场本技巧是市场上常见的策略。许多人会通过前几日的高低点来作为基准点，若向上或向下突破了相对高低点，则顺势进场交易。 在期货的日内交易中，常用的方式就是在开盘前几分钟设置价格高低点，当突破该高低点就顺势进场。 以下是上下穿越高低点顺势进场的代码，由于FastOS本身提供了当日开盘的高低价，因此直接通过该特性编写代码，节省许多不必要的运算。 文件名：84-1.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445# -*- coding: UTF-8 -*-#取得報價資訊，詳情請查看技巧51exec(open("function.py", encoding = 'utf-8').read())#設定指標變數trendEndTime=datetime.datetime.strptime("09:00:00.00","%H:%M:%S.%f")highPoint=0lowPoint=0#設定初始倉位，若為0則為無在倉部位index=0orderPrice=0#取得高低點for i in getMatch(): MatchInfo=i.split(',') MatchTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") MatchHigh=int(MatchInfo[6]) MatchLow=int(MatchInfo[7]) if MatchTime&gt;=trendEndTime: highPoint=MatchHigh lowPoint=MatchLow breakprint("HighPoint",highPoint,"LowPoint",lowPoint)#進場判斷for i in getMatch(): MatchInfo=i.split(',') MatchPrice=int(MatchInfo[1]) if MatchPrice&gt;highPoint: index=1 orderPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break elif MatchPrice&lt;lowPoint: index=-1 orderPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break#接著以下為出場條件判斷，本章不做介紹 通过Python指令执行该程离，结果如下： 12 &gt;python 84-1.pyHighPoint 10370 LowPoint 10354 09:04:59.98 Order Buy Success! 因为通过所发布的最高价及最低价信息，只能记录从开盘至当前的信息，若要计算从程序开启开始至特定时间的最高价和最低价，可以通过以下代码来实现。 文件名：84-2.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: UTF-8 -*-#取得報價資訊，詳情請查看技巧51exec(open("function.py", encoding = 'utf-8').read())#設定指標變數trendEndTime=datetime.datetime.strptime("09:00:00.00","%H:%M:%S.%f")highPoint=0lowPoint=999999999#設定初始倉位，若為0則為無在倉部位index=0orderPrice=0#取得高低點for i in getMatch(): MatchInfo=i.split(',') MatchTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") MatchPrice=int(MatchInfo[1]) if MatchPrice&gt;highPoint: highPoint=MatchPrice if MatchPrice&lt;lowPoint: lowPoint=MatcMatchPricehLow if MatchTime&gt;=trendEndTime: break print("HighPoint",highPoint,"LowPoint",lowPoint)#進場判斷for i in getMatch(): MatchInfo=i.split(',') MatchPrice=int(MatchInfo[1]) if MatchPrice&gt;highPoint: index=1 orderPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break elif MatchPrice&lt;lowPoint: index=-1 orderPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break#接著以下為出場條件判斷，本章不做介紹 技巧85 【程序】上下穿越高低点加上高低点区间顺势进场本技巧是技巧84的延伸，突破高低点区间，该进场条件是市场常见的进场策略。太明显的散户趋势可能会成为大户套利的机会，也就是说大户趁机布单接着反向拉价，这时就会造成假突破，接着减仓（清仓）出场。为了避免这种情况发生，可以用两种方式解决该问题。 1、动态侦测价格 若连续一分钟判断价格是假突破（查看价格有无回归），此解决方案会延后进场时机。 2、在上下区间以外再加上额外点数 通常设置上下区间的价差为额外点数。例如最高价与最低价分别为10 000、9 900，进场点则变为向上突破10 100[10 000 + (10 000 − 9 900)]以及向下突破9 800[9 000 − (10 000 − 9 900)]。此解决方案会降低获利。 本技巧将介绍上述的第二个解决方案，上下穿越高低点加上高低点区间顺势进场，以下为代码。 文件名：85-1.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# -*- coding: UTF-8 -*-#取得報價資訊，詳情請查看技巧51exec(open("function.py", encoding = 'utf-8').read())#設定指標變數trendEndTime=datetime.datetime.strptime("09:00:00.00","%H:%M:%S.%f")highPoint=0lowPoint=0spread=0#設定初始倉位，若為0則為無在倉部位index=0orderPrice=0#取得高低點for i in getMatch(): MatchInfo=i.split(',') MatchTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") MatchHigh=int(MatchInfo[6]) MatchLow=int(MatchInfo[7]) if MatchTime&gt;=trendEndTime: highPoint=MatchHigh lowPoint=MatchLow spread=highPoint-lowPoint breakprint("HighPoint",highPoint,"LowPoint",lowPoint,"Spread",spread)#進場判斷for i in getMatch(): MatchInfo=i.split(',') MatchPrice=int(MatchInfo[1]) if MatchPrice&gt;highPoint+spread: index=1 orderPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break elif MatchPrice&lt;lowPoint-spread: index=-1 orderPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break#接著以下為出場條件判斷，本章不做介紹 通过Python指令执行该程序，结果如下： 通过所发布的最高价及最低价信息只能记录从开盘至此，若要计算从程序开启开始至特定时间的最高价和最低价，可以通过以下代码来实现。 文件名：85-2.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# -*- coding: UTF-8 -*-#取得報價資訊，詳情請查看技巧51exec(open("function.py", encoding = 'utf-8').read())#設定指標變數trendEndTime=datetime.datetime.strptime("09:00:00.00","%H:%M:%S.%f")highPoint=0lowPoint=999999999spread=0#設定初始倉位，若為0則為無在倉部位index=0orderPrice=0#取得高低點for i in getMatch(): MatchInfo=i.split(',') MatchTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") MatchPrice=int(MatchInfo[1]) if MatchPrice&gt;highPoint: highPoint=MatchPrice if MatchPrice&lt;lowPoint: lowPoint=MatcMatchPricehLow if MatchTime&gt;=trendEndTime: spread=highPoint-lowPoint break print("HighPoint",highPoint,"LowPoint",lowPoint,"Spread",spread)#進場判斷for i in getMatch(): MatchInfo=i.split(',') MatchPrice=int(MatchInfo[1]) if MatchPrice&gt;highPoint+spread: index=1 orderPrice=MatchPrice print MatchInfo[0],"Order Buy Success!" break elif MatchPrice&lt;lowPoint-spread: index=-1 orderPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break #接著以下為出場條件判斷，本章不做介紹 技巧86 【程序】大户指标触发进场大户指标的运用，既可以用来判断目前的趋势变化，也可以用来判断单一事件。(在第5章中，介绍过大户指标；在关于“趋势判断”的章节中，也有通过大户指标进行判断的内容。) 进场条件是单一事件的触发，也就是说，我们可以通过单一一笔较大的量作为信号来进场。 以下将通过单笔30手以上大单并且配合大单累积量同时符合时才进场，也就是说，假设目前大单累计买量500手，大单累计卖量700手，卖方新增一笔50手大单，则做空。 此进场还有一个基础，设想当一个人下了30手以上的大单时，是不是在市场上就形成了一股无形的压力？以下是大户指标触发进场的代码。 文件名：86.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152# -*- coding: UTF-8 -*-#取得報價資訊，詳情請查看技巧51exec(open("function.py", encoding = 'utf-8').read())#設定指標變數lastBcnt=0lastScnt=0accB=0accS=0#設定初始倉位，若為0則為無在倉部位index=0orderPrice=0#取得成交資訊for i in getMatch(): MatchInfo=i.split(',') MatchTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") MatchPrice=int(MatchInfo[1]) MatchQty=int(MatchInfo[2]) MatchBcnt=int(MatchInfo[4]) MatchScnt=int(MatchInfo[5]) if lastBcnt==0 and lastScnt==0: lastBcnt=MatchBcnt lastScnt=MatchScnt else: diffBcnt=MatchBcnt-lastBcnt diffScnt=MatchScnt-lastScnt if MatchQty&gt;=10: if diffBcnt==1 and diffScnt&gt;1: accB+=MatchQty print(MatchInfo[0],MatchPrice,MatchQty,0,accB,accS) if MatchQty&gt;=30 and accB&gt;accS: index=1 orderPrice=MatchPrice print(MatchInfo[0],"Order Buy Success!") break elif diffScnt==1 and diffBcnt&gt;1: accS+=MatchQty print(MatchInfo[0],MatchPrice,0,MatchQty,accB,accS) if MatchQty&gt;=30 and accS&gt;accS: index=-1 orderPrice=MatchPrice print(MatchInfo[0],"Order Sell Success!") break lastBcnt=MatchBcnt lastScnt=MatchScnt #接著以下為出場條件判斷，本章不做介紹 通过Python指令执行该程序结果如下： 1&gt; python 86.py]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python期货量化交易实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 判断涨跌的趋势]]></title>
    <url>%2F2020%2F11%2F26%2F%E7%AC%AC6%E7%AB%A0-%E5%88%A4%E6%96%AD%E6%B6%A8%E8%B7%8C%E7%9A%84%E8%B6%8B%E5%8A%BF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在金融市场的交易之中，许多人都想通过交易市场赚钱，所以每日的成交信息与涨幅结果都是买卖双方厮杀的结果。量化交易追求的并非是一夕之间赚进大把钱财，而是长期投资能够保持稳定获利，所以当我们在进行市场涨跌的趋势判断时，并不期望能够获取百分之百的准确度，甚至就算是低于50%的准确度，只要掌握好进出场点，掌控好止损，也是会稳定获利的。 技巧67 【概念】趋势的发生与判断在期货交易中，允许先买后卖（称为多方），也允许先卖后买（称为空方）。如果未来趋势看涨，自然会先买后卖以赚取价差；如果趋势看跌，也可以先卖个好价钱，再用比较低的成本买回，同样可赚取价差。 在期货交易市场中，必须有人愿意以某一个价格卖出，也有人愿意以这个价格买入，才会成交。交易的首要判断就是：要做多还是做空，也就是要买还是卖，买进代表此商品后势看涨，卖出代表此商品后势看跌。 如何判断交易商品的多空，方法不胜枚举，且依照投资的性质也有所差异。就期货日内交易来说，每次交易的趋势多空判断可能是当日委托买卖平均手数的比较，也有可能是当日成交量平均手数的比较，但就股票长期持有而言，就会依照长期走势的推算来判断多空。 在交易策略中，判断多空的时机与进场时机并不相等，就意义上而言，判断多空就像断定了当天的趋势，而进场时机是找一个好的时间点下单。 不论在哪种商品的交易市场中，趋势都有可能发生改变。若趋势发生改变，则可以考虑止损并反向持仓，只是在同一个趋势中投资人不该随意反向持仓，违背交易原则，可能会导致重大亏损。 技巧68 【概念】趋势交易与顺势交易在研发量化投资策略时，通常分为两种交易策略形态：“趋势交易”和“顺势交易”。在五花八门的交易策略中，并不是所有交易策略都需要趋势判断，有一类的交易策略需要趋势判断，但另外一类的交易策略不需要。 不需要趋势判断的策略称为“顺势交易策略”。顺势交易不必判断多空，而是触发特定条件直接进场。例如：海龟策略，如果当日突破特定区间的高点即买多，突破低点即买空。 简单来说，若我们使用的策略是趋势交易，则我们的进场算法必须通过趋势判断进场; 若为顺势交易，则只需要进行进场判断，详细介绍在技巧77中。 技巧69 【程序】时间区段价格走势判断趋势最简单、直观的方式就是用两个时间点比较，因为买卖双方在这段时间区段中经互相对抗后才会形成价格的涨跌，我们就利用这点来进行趋势判断。 通常我们会在8:45至9:00之间进行趋势判断，接着在9:00后寻找相对低点进场，而进场的说明在第7章中将会介绍。 可通过8:45至9:00时间区段的价格走势来进行趋势判断，代码如下: 文件名:69.py 1234567891011121314151617181920212223242526272829# -*- coding: UTF-8 -*-# 获取报价信息，详情请查看技巧51exec(open("function.py", encoding = 'utf-8').read())# 定义判断时间trendStartTime=datetime.datetime.strptime('08:45:00.00',"%H:%M:%S.%f")trendStartPrice=0trendEndTime=datetime.datetime.strptime('09:00:00.00',"%H:%M:%S.%f")trendEndPrice=0trend=0# 获取成交信息for i in getMatch(): MatchInfo=i.split(',') MatchTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") MatchPrice=int(MatchInfo[1]) # 判断趋势开始或结尾的成交价格 if trendStartPrice==0 and MatchTime&gt;trendStartTime: trendStartPrice=MatchPrice elif trendEndPrice==0 and MatchTime&gt;trendEndTime: trendEndPrice=MatchPrice if trendEndPrice&gt;trendStartPrice: trend+=1 elif trendEndPrice&lt;trendStartPrice: trend-=1 breakprint("TrendStartPrice",trendStartPrice,"TrendEndPrice",trendEndPrice,"Trend:",trend) 通过Python命令执行该程序，结果如下： 12 技巧70 【程序】多点查看委托量比重在趋势的判断中，委托信息是成交的先行信息，许多投资人会与委托信息做连接，若可以掌握委托信息，就有机会预测当日的趋势。 本技巧通过买卖双方委托量各自的平均数来进行比较，若多方大于空方，则趋势看涨；反之，若空方大于多方，则趋势看跌。 本技巧当中加入了另外一个条件，就是多点查看，委托量为累计信息，所以当我们在9点整查看委托信息时，是由8:30至9:00的累计数据，若我们只查看一个时间点的委托比重，或许没有那么足够的信心支撑，此时就必须通过多个时间点的检验。 本技巧将会通过3个时间点委托比重的校验，若3个时间点中多方委托比重（OrderBAmount/OrderBCnt）较大（OrderBAmount/OrderBCnt大于OrderSAmount/OrderSCnt）两次以上，则趋 势看涨，反之，空方委托比重（OrderSAmount/OrderSCnt）较大两次以上，则趋势看跌。 通过数学原理，只要每次判断会加一或减一，经过3次判断，则结果必定会是大于或小于0，若趋势变数大于0，则看多；小于0，则看空。 通过8:50、9:00、9:03这3个时间点作为判断时机点，代码如下: 文件名：70.py 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748# -*- coding: UTF-8 -*-exec(open("function.py", encoding = 'utf-8').read())# 定义判断时间trendTime1=datetime.datetime.strptime('08:50:00.00',"%H:%M:%S.%f")trendTime2=datetime.datetime.strptime('09:00:00.00',"%H:%M:%S.%f")trendTime3=datetime.datetime.strptime('09:03:00.00',"%H:%M:%S.%f")trendNum=0trend=0# 获取成交信息for i in getOrder(): OrderInfo=i.split(',') OrderTime=datetime.datetime.strptime(OrderInfo[0],"%H:%M:%S.%f") OrderBCnt=int(OrderInfo[1]) OrderBAmount=float(OrderInfo[2]) OrderSCnt=int(OrderInfo[3]) OrderSAmount=float(OrderInfo[4]) # 趋势判断 if OrderTime&gt;=trendTime1 and trendNum==0: if OrderBAmount/OrderBCnt &gt; OrderSAmount/OrderSCnt: trend+=1 elif OrderBAmount/OrderBCnt &lt; OrderSAmount/OrderSCnt: trend-=1 trendNum+=1 print(OrderInfo[0],"B",OrderBAmount/OrderBCnt,"S",OrderSAmount/OrderSCnt) # 趋势判断 if OrderTime&gt;=trendTime2 and trendNum==1: if OrderBAmount/OrderBCnt &gt; OrderSAmount/OrderSCnt: trend+=1 elif OrderBAmount/OrderBCnt &lt; OrderSAmount/OrderSCnt: trend-=1 trendNum+=1 print(OrderInfo[0],"B",OrderBAmount/OrderBCnt,"S",OrderSAmount/OrderSCnt) # 趋势判断 if OrderTime&gt;=trendTime3 and trendNum==2: if OrderBAmount/OrderBCnt &gt; OrderSAmount/OrderSCnt: trend+=1 elif OrderBAmount/OrderBCnt &lt; OrderSAmount/OrderSCnt: trend-=1 print(OrderInfo[0],"B",OrderBAmount/OrderBCnt,"S",OrderSAmount/OrderSCnt) breakprint("Trend",trend) 通过Python命令执行该程序，结果如下： 12 技巧71 【程序】多区段查看委托量变化技巧70谈到的是多点查看委托量比重，而本技巧也是查看委托量信息，不同的是，它并不是通过单一时间点的检验来确定当天的趋势，而是通过每个区段的委托量变化去判定。 何谓区段的委托量变化呢？就是我们将两个时间点的委托信息进行相减，取出该区段的变动量来进行趋势判断。 本技巧在8:45至9:00之间，每5分钟作为一个区段，查看每个区段的委托总量变化。 文件名：71.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364# -*- coding: UTF-8 -*-exec(open("function.py", encoding = 'utf-8').read())trendTime0=datetime.datetime.strptime('08:45:00.00',"%H:%M:%S.%f")trendTime1=datetime.datetime.strptime('08:50:00.00',"%H:%M:%S.%f")trendTime2=datetime.datetime.strptime('08:55:00.00',"%H:%M:%S.%f")trendTime3=datetime.datetime.strptime('09:00:00.00',"%H:%M:%S.%f")trendNum=0trend=0# 定义指标变量lastBAmount=0lastSAmount=0# 获取成交信息for i in getOrder(): OrderInfo=i.split(',') OrderTime=datetime.datetime.strptime(OrderInfo[0],"%H:%M:%S.%f") OrderBAmount=int(OrderInfo[2]) OrderSAmount=int(OrderInfo[4]) if OrderTime&gt;=trendTime0 and lastBAmount==0 and lastSAmount==0: lastBAmount=OrderBAmount lastSAmount=OrderSAmount # 趋势判断 if OrderTime&gt;=trendTime1 and trendNum==0: diffBAmount=OrderBAmount-lastBAmount diffSAmount=OrderSAmount-lastSAmount if diffBAmount &gt; diffSAmount: trend+=1 elif diffBAmount &lt; diffSAmount: trend-=1 trendNum+=1 lastBAmount=OrderBAmount lastSAmount=OrderSAmount print(OrderInfo[0],"B",diffBAmount,"S",diffSAmount) # 趋势判断 if OrderTime&gt;=trendTime2 and trendNum==1: diffBAmount=OrderBAmount-lastBAmount diffSAmount=OrderSAmount-lastSAmount if diffBAmount &gt; diffSAmount: trend+=1 elif diffBAmount &lt; diffSAmount: trend-=1 trendNum+=1 lastBAmount=OrderBAmount lastSAmount=OrderSAmount print(OrderInfo[0],"B",diffBAmount,"S",diffSAmount) # 趋势判断 if OrderTime&gt;=trendTime2 and trendNum==2: diffBAmount=OrderBAmount-lastBAmount diffSAmount=OrderSAmount-lastSAmount if diffBAmount &gt; diffSAmount: trend+=1 elif diffBAmount &lt; diffSAmount: trend-=1 print(OrderInfo[0],"B",diffBAmount,"S",diffSAmount) breakprint("Trend",trend) 通过Python命令执行该程序，结果如下： 12 技巧72 【程序】查看买卖平均成交手数趋势的判断也可以通过成交的累计信息来进行预测。在第5章有提到买卖平均成交手 数的指标，而这个技巧会通过该指标进行趋势判断。 买方平均的手数与卖方平均的手数比较，若买方平均的手数较大，则我们看涨；反之，若卖方平均的手数较大，我们看跌。 本技巧在9:00判断买卖平均成交手数，若买方平均手数较大，则趋势看多;若卖方平均手数较大，则趋势看空，代码如下。 文件名：72.py 1234567891011121314151617181920212223242526# -*- coding: UTF-8 -*-exec(open("function.py", encoding = 'utf-8').read())# 定义判断时间trendTime=datetime.datetime.strptime('09:00:00.00',"%H:%M:%S.%f")trend=0# 获取成交信息for i in getMatch(): MatchInfo=i.split(',') MatchTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") MatchAmount=float(MatchInfo[3]) MatchBcnt=int(MatchInfo[4]) MatchScnt=int(MatchInfo[5]) # 趋势判断 if MatchTime&gt;=trendTime: if MatchAmount/MatchBcnt&gt;MatchAmount/MatchScnt: trend+=1 elif MatchAmount/MatchBcnt&lt;MatchAmount/MatchScnt: trend-=1 print(MatchInfo[0],"B",MatchAmount/MatchBcnt,"S",MatchAmount/MatchScnt) breakprint("Trend",trend) 通过Python指令执行，结果如下： 12 技巧73 【程序】查看内外盘总量在第5章中，有提到内外盘的用途及意义。简单来说，内外盘代表着目前买卖方的积极度，所以我们可以通过买卖方以往的积极度来预测目前市场的趋势。 可以选择比较通过某个时间点的内外盘总量来预测未来市场的趋势。 文件名:73.py 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding: UTF-8 -*-exec(open("function.py", encoding = 'utf-8').read())# 定义判断时间trendTime=datetime.datetime.strptime('09:00:00.00',"%H:%M:%S.%f")trend=0# 定义指标变量OutDesk=0InDesk=0# 获取成交信息for i in getMatch(): MatchInfo=i.split(',') MatchTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") MatchPrcie=int(MatchInfo[1]) MatchQty=int(MatchInfo[2]) UpDn5Info=getLastUpDn5() Dn1Price=int(UpDn5Info[1]) Up1Price=int(UpDn5Info[11]) if MatchPrcie&gt;=Up1Price: OutDesk+=MatchQty if MatchPrcie&lt;=Dn1Price: InDesk+=MatchQty # 趋势判断 if MatchTime &gt;= trendTime: if OutDesk&gt;InDesk: trend+=1 elif OutDesk&lt;InDesk: trend-=1 break print(MatchInfo[0],"OutDesk",OutDesk,"InDesk",InDesk)print("Trend",trend) 通过 Python 命令执行该程序，结果如下: 1&gt; python 73.py 技巧74 【程序】大户指标趋势判断在第5章中提到计算的大户指标包含了单笔和总量的信息揭露，而多空方的总量能够作为趋势判断，通过特定时间点的大户指标的累计买卖数量进行比较。若累计买方数量较多，代表目前是买方强势，趋势看涨；反之，若空方累计数量较多，则空方强势，趋势看跌。 若要了解大户指标详细内容，请参考技巧66。本例在9点整进行趋势判断（多方大单累积量大于空方大单累计量）。以下为通过大户指标趋势判断的代码。 文件名:74.py 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849# -*- coding: UTF-8 -*-exec(open("function.py", encoding = 'utf-8').read())# 定义判断时间trendTime=datetime.datetime.strptime('09:00:00.00',"%H:%M:%S.%f")trend=0# 定义指标变量lastBcnt=0lastScnt=0accB=0accS=0# 获取成交信息for i in getMatch(): MatchInfo=i.split(',') MatchTime=datetime.datetime.strptime(MatchInfo[0],"%H:%M:%S.%f") MatchPrice=int(MatchInfo[1]) MatchQty=int(MatchInfo[2]) MatchBcnt=int(MatchInfo[4]) MatchScnt=int(MatchInfo[5]) if lastBcnt==0 and lastScnt==0: lastBcnt=MatchBcnt lastScnt=MatchScnt else: diffBcnt=MatchBcnt-lastBcnt diffScnt=MatchScnt-lastScnt if MatchQty&gt;=10: if diffBcnt==1 and diffScnt&gt;1: accB+=MatchQty print(MatchInfo[0],MatchPrice,MatchQty,0,accB,accS) elif diffScnt==1 and diffBcnt&gt;1: accS+=MatchQty print(MatchInfo[0],MatchPrice,0,MatchQty,accB,accS) # 趋势判断 if MatchTime&gt;=trendTime: if accB&gt;accS: trend+=1 elif accB&lt;accS: trend-=1 break lastBcnt=MatchBcnt lastScnt=MatchScntprint("Trend",trend) 通过Python命令执行该程序，结果如下： 1&gt; python 74.py]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python期货量化交易实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章 设计自己的指标函数]]></title>
    <url>%2F2020%2F11%2F26%2F%E7%AC%AC5%E7%AB%A0-%E8%AE%BE%E8%AE%A1%E8%87%AA%E5%B7%B1%E7%9A%84%E6%8C%87%E6%A0%87%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在目前的投资领域中，许多投资人都会通过既有的商品技术指标来进行投资买卖，好处是因为许多人同时在关注这些指标，且大家的投资理念相同，所以当信号触发时会形成 一股趋势，坏处是股市中拥有大部分资金的投资人会利用这种现象来制造假信号，以致投资人遭受损失。 所以当我们设计自己的函数指标时，一方面可以比市场上的分钟频率的指标来得快， 另一方面能够照着自己的方式来呈现。本章将会把一些常用的技术指标通过代码，在取报 价时同时生成指标。 技巧49【概念】何谓指标函数 指标是根据使用者的经验所产生的量化数据，简单来说，当我们在通过看盘软件进行 下单判断时，就已经在接收指标信息了。常见的指标有价格走势图、K线图、量能图、委 托比例图和上下五档价等。 这些指标是由提供看盘软件的公司来绘制的，也是多数投资人会观察的指标，但是要 通过程序进行交易，我们就必须取得这些信息，并非只是单纯地通过眼睛观察盘中的指标 图，而在获取交易所的报价揭示信息后，通过程序转换成指标。 通过这样的做法，能够真正地实践程序化交易，假如每天要花3个小时观察盘势，现在只需要确定计算机开机和程序正确执行，就可以进行自动化交易了。 技巧50 【概念】定义输入及输出本技巧将会与FastOS串接即时报价文件(分为3个文件，分别是成交信息、委托信息和上下五档价信息)，而程序也会依照交易者不同需求获取相关的即时信息。 即时交易程序会分别对这3个文件进行即时报价。作为指标的输入值，在编写即时算 法时，可以选择是否要计算指标，也可以直接通过报价信息进行判断。 在有了标准的输入信息(即时报价)后，我们就可以通过程序进行金融技术指标的计算，转换成我们想要的信息，例如:MA、高开低收量(K 线)和内外盘等技术指标。每种自行定义的技术指标都应该有自定义标准的输出值，以便在交易策略中使用。 技巧51 【程序】获取即时报价咨询对于程序化交易来说，获取即时报价信息是整个程序中的第一步，在获取即时信息后， 往后的交易算法才能被正确执行。为了计算指标，必须先了解如何获取即时报价。 关于交易所披露信息以及取得即时报价的概念说明，之后会在第9章进行详细介绍。 在这里我们将通过FastOS使用券商的API获取最新的报价信息，包含成交信息、委托信息 以及上下五档价信息。 以下是获取即时报价的函数，其中即时报价分为委托信息、成交信息以及上下五档价信息。在后续的代码中，都需要通过该函数获取即时报价，所以将以下代码设为固定的函 数库文件(function.py)，在其他代码中直接使用即可。存取报价分为循环持续存取以及单笔存取，依照不同运算需求，会有不同的使用搭配。例如:计算内外盘，就会通过取 得当前成交信息的循环存取，当每次取得成交信息后，就会再去取得上下五档价进行内外盘计算。 其中加载相关包的部分，如time以及datetime包，都是在即时策略当中会运用到的包，而tailer包是帮助我们进行快速报价的包。另外，在启动实盘交易以前，必须确保所有需要 的包都已安装，包的安装在技巧8中有详细介绍。 存取报价的细节可以参考技巧99(介绍存取报价的概念)。 代码如下: 文件名:function.py 123456789101112131415161718192021222324252627282930313233343536373839# -*- coding: UTF-8 -*-#載入相關套件import timeimport datetimeimport tailer#取得當天日期Date=time.strftime("%Y%m%d")#設定檔案位置DataPath="D:/data/"#開啟這三個檔案MatchFile=open(DataPath+Date+'_Match.txt')OrderFile=open(DataPath+Date+'_Commission.txt')UpDn5File=open(DataPath+Date+'_UpDn5.txt')#持續取得成交資訊def getMatch(): return tailer.follow(MatchFile,0)#持續取得委託資訊def getOrder(): return tailer.follow(OrderFile,0)#持續取得上下五檔價資訊def getUpDn5(): return tailer.follow(UpDn5File,0)#取得最新一筆成交資訊def getLastMatch(): return tailer.tail(MatchFile,3)[-2].split(",")#取得最新一筆委託資訊def getLastOrder(): return tailer.tail(OrderFile,3)[-2].split(",")#取得最新一筆上下五檔價資訊def getLastUpDn5(): return tailer.tail(UpDn5File,3)[-2].split(",") 以下是获取报价咨询的操作过程:123456789101112131415161718192021&gt;&gt;&gt; exec(open('function.py').read())&gt;&gt;&gt; for i in getMatch(): #通过循环，去持续获取当前成交信息 ... print (i)...10:15:05.69,10334,2,76880,36922,39553,10340,10290 10:15:06.34,10334,1,76881,36923,39555,10340,10290 10:15:06.82,10333,1,76882,36924,39556,10340,10290 10:15:07.06,10334,2,76884,36925,39557,10340,10290... #Ctrl+C 可中断&gt;&gt;&gt; for i in getOrder(): #通过循环，去持续获取当前成交信息 ... print (i)...10:24:53.20,34888,88931,36490,89257 10:24:58.18,34891,88944,36508,89301 10:25:03.19,34917,89064,36509,89392 10:25:08.18,34920,89066,36512,89397... #Ctrl+C 可中断 &gt;&gt;&gt; for i in getUpDn5(): #通过循环，去持续获取上下五档成交信息... print (i)... 10:26:24.82,10330,89,10329,104,10328,145,10327,75,10326,105,10331,84,10332,276, 10333,69,10334,57,10335,102 10:26:25.05,10330,84,10329,104,10328,145,10327,75,10326,105,10331,84,10332,276, 10333,69,10334,57,10335,102 10:26:25.18,10330,84,10329,104,10328,145,10327,75,10326,105,10331,83,10332,276, 10333,69,10334,57,10335,102 10:26:25.67,10330,84,10329,104,10328,145,10327,75,10326,105,10331,83,10332,276, 10333,69,10334,57,10335,102 10:26:26.06,10330,84,10329,106,10328,145,10327,75,10326,105,10331,83,10332,276, 10333,69,10334,57,10335,102...&gt;&gt;&gt; getLastMatch()['09:58:19.71', '10329', '1', '69891', '33858', '36117', '10339', '10290'] &gt;&gt;&gt; getLastOrder()['09:58:53.25', '31047', '79073', '32623', '79623']&gt;&gt;&gt; getLastUpDn5()['09:58:14.46', '10329', '26', '10328', '95', '10327', '49', '10326', '132', '10325', '81', '10330', '15', '10331', '66', '10332', '82', '10333', '68','10334', '56'] 技巧 52 【程序】计算每分钟的高开低收价通过技巧 51 获取当前信息后，就可以用来计算各式各样的指标。该技巧将介绍如何获取高开低收价。 在之前的章节已介绍过计算历史数据的 K 线，并将 K 线图绘制出来，现在将通过获取即时报价信息来计算 K 线。 即时计算和历史计算是有差异的:历史的可以通过列表对象特性直接进行数据筛选，即时的必须动态更新计算数据。 该指标通过列表来作为容器，因为会动态更新数据，元组并不允许更新，所以选 用列表。 定义初始值，只需要中括号即可定义列表，代码如下:1OHLC=[] 接着开始计算高开低收，每分钟过后都会进行数据的叠加。假设策略已经从 8:45 执行 至 8:48，就应该会有3笔数据，分别是8:46、8:47、8:48，数据叠加的好处是我们的策略可 以有多样的变化，让策略不会局限于只能判断最近一分钟的状况。 在每分钟转换时，我们通过简单的字符串判断，例如:“850”代表 8点50分。当时间转换到“851”，则代表分钟变换了。通过该方式来减少算法的困难度，而在之后的例子若 有相关的应用，也都用该方式来进行判断。以下为计算每分钟高开低收的代码。文件名:52.py12345678910111213141516171819202122232425262728293031# -*- coding: UTF-8 -*-#取得報價資訊，詳情請查看技巧51exec(open("function.py", encoding = 'utf-8').read())#定義指標變數OHLC=[]#取得成交資訊for i in getMatch(): MatchInfo=i.split(',') #定義HHMM的時間字串，方便進行分鐘轉換判斷 HMTime=MatchInfo[0][0:2]+MatchInfo[0][3:5] MatchPrice=int(MatchInfo[1]) #若OHLC為空，先填值 if len(OHLC)==0: OHLC.append([HMTime,MatchPrice,MatchPrice,MatchPrice,MatchPrice]) else: #進行該分鐘是否結束 if HMTime==OHLC[-1][0]: #進行高、低價判斷 if MatchPrice&gt;OHLC[-1][2]: OHLC[-1][2]=MatchPrice if MatchPrice&lt;OHLC[-1][3]: OHLC[-1][3]=MatchPrice OHLC[-1][4]=MatchPrice else: #該分鐘結束則加入新行 OHLC.append([HMTime,MatchPrice,MatchPrice,MatchPrice,MatchPrice]) #顯示當前開高低收 print(OHLC[-1]) 通过 Python 命令执行该程序，展示如下: python 52.py[‘0849’, 10359, 10359, 10355, 10355] [‘0849’, 10359, 10359, 10355, 10355] [‘0849’, 10359, 10359, 10355, 10357] [‘0849’, 10359, 10359, 10355, 10356] [‘0849’, 10359, 10359, 10355, 10357] [‘0849’, 10359, 10359, 10355, 10355] [‘0850’, 10357, 10357, 10357, 10357] [‘0850’, 10357, 10357, 10357, 10357]异步社区回家抄作业(13357721075) 专享 请尊重版权 技巧 53 【程序】计算每分钟的累计量我们在看盘软件中，常见的就是价格走势图搭配量能图。本技巧就是用来计算每分钟 累积量的程序，若原本就是通过量来进行策略进出场判断，则能够通过此技巧来计算并加 以判断。计算成交量，可以通过单笔成交量计算，也可以通过总量计算。在这里我们使用总量 计算，因为单笔成交量需要高度的信息准确性，若数据不完整，计算出来的指标参考度也 就不高，所以我们通过交易所揭示出来的交易总量来进行计算，可以不必考虑数据的高度 准确性，也能达到相同的计算效果。 数据输出的格式有两个字段，一个是时间，另一个是一分钟时间累积量，即每分钟会叠加信息。以下是计算每分钟累计量的代码。文件名:53.py123456789101112131415161718192021# -*- coding: UTF-8 -*-# 获取报价信息，详情请查看技巧 51 exec(open('function.py').read())# 定义指标变量 Qty=[] lastAmount=0# 获取成交信息for i in getMatch():MatchInfo=i.split(',')# 定义HHMM的时间字符串，方便进行分钟转换判断 HMTime=MatchInfo[0][0:2]+MatchInfo[0][3:5] MatchAmount=int(MatchInfo[3])# 进行每分钟价格计算 if len(Qty)==0:Qty.append([HMTime,0])lastAmount=MatchAmount else:['0850', 10357, 10357, 10357, 10357]['0850', 10357, 10357, 10356, 10356]['0850', 10357, 10357, 10355, 10355]['0850', 10357, 10357, 10355, 10357]['0850', 10357, 10357, 10355, 10355] if HMTime==Qty[-1][0]: Qty[-1][1]=MatchAmount-lastAmountelse: Qty.append([HMTime,0]) lastAmount=MatchAmountprint (Qty) 通过 Python 命令执行该程序，结果如下: python 53.py [[‘1114’, 0]] [[‘1114’, 1]] [[‘1114’, 3]] [[‘1114’, 4]] [[‘1114’, 8]] [[‘1114’, 13]] [[‘1114’, 21]] [[‘1114’, 23]] [[‘1114’, 26]] …[[‘1114’, 43], [‘1115’, 101], [‘1116’, 59]][[‘1114’, 43], [‘1115’, 101], [‘1116’, 60]][[‘1114’, 43], [‘1115’, 101], [‘1116’, 61]][[‘1114’, 43], [‘1115’, 101], [‘1116’, 62]][[‘1114’, 43], [‘1115’, 101], [‘1116’, 63]][[‘1114’, 43], [‘1115’, 101], [‘1116’, 64]][[‘1114’, 43], [‘1115’, 101], [‘1116’, 65]] 技巧 54 【程序】计算买卖方每笔平均成交手数在研究金融市场时，大家经常关注的无非就是成交价和成交量，而很少有人去关注买卖的成交笔数。期交所正好有提供相关的成交笔数信息，通过这些字段，我们可以得知目 前的买方以及卖方的平均成交手数，也就是买卖方每笔订单所成交的手数。 假设目前的成交量为12000，而买方的成交笔数为3000，卖方为4000，则平均买手为4、平均卖手为3，我们可以判读此数据，若平均买方单一订单的量较大，则可认为市场 大户在买方。 以下为计算买卖方每笔平均成交手数的程序代码。 文件名:54.py -- coding: UTF-8 --取得报价信息，详情请查看技巧 51 exec(open(‘function.py’).read())]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python期货量化交易实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十一章 日内点数图]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E5%8D%81%E4%B8%80%E7%AB%A0-%E6%97%A5%E5%86%85%E7%82%B9%E6%95%B0%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第十章 摆动指数和相反意见理论]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E5%8D%81%E7%AB%A0-%E6%91%86%E5%8A%A8%E6%8C%87%E6%95%B0%E5%92%8C%E7%9B%B8%E5%8F%8D%E6%84%8F%E8%A7%81%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第八章 长期图表和商品指数]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E5%85%AB%E7%AB%A0-%E9%95%BF%E6%9C%9F%E5%9B%BE%E8%A1%A8%E5%92%8C%E5%95%86%E5%93%81%E6%8C%87%E6%95%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 引言在期货行业，当分析者从事市场预测和交易时，日线图显然是最受青睐的。但是通常，一张日线图只能覆盖合约有效期中的6到9个月。不过，由于大部分商品期货的交易商和分析师的兴趣主要局限于相对短期的市场行为，日线图当然被他们广泛地接受，成了期货分析者的首选工具。另外，日线图的维持相对来说简单易行，而且我们也可以从商业化的图表服务系统中随时获取，这也是其盛行的原因（随着计算机技术和信息传输系统的发展，日内图表也越来越行时了，凭借日内图表，我们可以更细致地了解市场情况）。 然而，恰恰因为一般交易商过分依赖日线图，一门心思地关注短期市场行为，所以，不少人忽视了价格图表中 另外非常有用的部分—连续周线图和连续月线图。利用这些长期图表，我们可以进行更长期趋势的分析、预测。 这些图表的用武之地并不仅限于个别市场。事实上，运用它们来研究一般商品指数和各种商品群体指数的主要趋势， 也极为有益。 在合约的全部有效历史里，日线图只能覆盖相对短的范围。而如果要对市场趋势进行透彻的分析，就得把逐日的价格变化放到长期的趋势结构中去，考察其相互关系。为此，我们必须采用更长期的连续图表。我们知道，在日线图上，每根坚直线段代表当日一天的价格变化，那么在周线图和月线图上，每根竖直线段就分别代表对应一星期和一个月的价格变化。周线图和月线图的根本目的，就在于把价格变化所经历的时间大为压缩，从而在水平方向容纳更长的时间范围，提供更大时域的研究工具。 大范围透视的意义通过长期图表，我们能够对市场趋势有很好的透视，而这个优势仅仅从日线图上是不可能取得的。在第一章我们介绍技术分析的理论基础时，曾强调指出，技术分析有个最大的长处，即我们可以把它应用于任何时间尺度之下，当然也包括长期性预测了。我们也提到过，有些人持有一种错误的看法，认为技术分析的天地只局限于短期选择时 机，而长期性的预测则应该由基础分析去完成。 那么，朋友们请注意以下的图表，我相信，它们能够充分证明技术分析的各项原则—包括趋势分析、支撑和阻挡水平、趋势线和管道、百分比回撤、以及价格形态等，能够相当完美地适用于长期市场分析。在这里，顺便还要指出，不论是谁，如果他不考虑这些长期图表，就错过了大量价值不菲的价格信息。 连续图表的绘制 商品期货合约在到期前，一般大约有一年半的交易寿命。技术分析者为了回顾数年的历史资料，需要构造长期的连续图表，那么，期货合约的这种有限寿命的特征显然就构成障碍了。股市技术分析者没有这个麻烦。每种普通股以及各种股市平均价格指数的图表，从其上市之日起就是现成的。在商品期货行业，分析师面对着一个月份接一 个月份不断推陈出新的一张张合约，怎样才能构造长期图表呢？ 我们的办法是绘制连续图表。注意，“连续”二字是重点。最通行的一种技巧是，简单地把一串合约的价格图表接续起来就成了。这张合约到期后，就接上下一张合约。为了保证连续性，最简便也最常用的方法是，始终采用最近到期的合约的价格资料。当最近一张合约停止交易后，同一商品的下一张合约就成为新的最近到期的合约，接下 去我们画的就是它。 本章出现的连续图表都源于商品研究局:该机构每周出版一期《CRB期货图表服务》，提供所有期货市场的日线图。作为对日线图的补充，它也提供连续周线图。此外，它每季还推出一系列的连续月线图，邮寄给客户。其周线图覆盖的时间为四年半，月线图一直可以上溯到 22 年以前。 构造连续图表的其余方法 把最近到期的合约图表连接起来的办法，既简单易行，又解决了期货合约图表的连续性问题。不过这个方法也有些小小的缺陷。有时候，接近到期合约的价格同下一张合约比起来有比较大的升水或贴水，那么，当我们从旧合约转接到新合约时，在图表上可能出现跳上或跳下的情形。另外，某些合约在接近到期日时，其价格具有极端的遽 变性，这也是一种潜在的偏差。 技术分析者为了纠正这些偶尔发生的偏差，想尽了法子。有些人在当前合约到期前一二个月的时候，就换上下一张合约，以避开最后一个月的遽变性。也有些人则避开最近到期合约，采用其次或复其次到期的合约。还有个办法是，选择具有最高持仓兴趣的合约画图，因为从理论上说这种到期月份的合约才真正代表了其市场价值。 我们也可以采用选定日历月份的办法来构造连续图表。比方说，所谓 11 月大豆连续图表，就是逐个地连接每年11月到期大豆合约的历史资料（这种连接特定月份合约的技术尤为W·D·江恩所钟爱）。有些图表分析师甚至走得更远。他们把几种月份合约的价格加以平均，或者构造某种价格指数，以修正上述图表转换时升水或贴水的影响。 无期限合约 TM 在《商品》杂志（现名为《期货》杂志）1983年3月号上，刊登了题为“无限期合约有益于技术分析”的文章，其中为解决价格的连续性问题，提出了一种新的方案。作者罗伯特·佩尔蒂埃是商品信息系统公司的总裁。文章中介绍了一个新概念，“无期限合约 TM”（“无期限合约 TM”和“CSI 无期限合约 TM”是该公司的注册商标）。 他提出“无期限合约 TM”的目的，在于按照一组连续的时间序列，来编排某种期货数年的价格历史。具体做法是:以连续推移的未来时间段为基础，建立一个时间序列。比如说，我们可以由这个时间序列来求得3个月或6个月后的某个数值。时间段可长可短，随用户选择。然后，把相应的时间段内前后相邻的两种合约的价格加权平均， 就得到了“无期限合约 TM”的价格。举个例子。假定我们计算的是三个月“无期限合约 TM”，现在是 1 月，那么三 个月后就是 4 月。然后，我们选取 4 月 l 前后的两个交易活跃的月份的合约价格，假定为 3 月和5月的，来加权平均（原文对如何计算加权平均值有更加周全的介绍）。如果今天是1月20日，那就取来一张价格图表，在三个月后的位置上（4月20日）标出一条竖直线段。下一步，在图上把这两张合约的当前价格分别点在它们的到期日（比方说 分别是 3 月 26 日和 5 月 28 日）上。然后，把这两点连接起来，得到的直线同 4 月 20 日那根竖直线相交，其交点的 价格读数就是三个月无期限合约 TM 的价格。 无期限合约 TM 的数值并非真正的价格。而是上述两个价格的加权平均值，如果您有意进一步了解该加投平均值的构造方法及其优越性，请参阅前面引用的那篇文章，或者同该公司（CSI）联系。据佩尔蒂埃介绍，无期限合约TM的主要优势是，不需要完全依赖最近到期的合约。从而消除了连续图表在新旧合约切换时可能发生的偏差。 无期限指数 TM商品信息系统公司最近又推出了一个更新的概念，“无期限指数 TM”。无期限合约 TM 是以期货合约价格为基础的。 而无期限指数则把这些数值转换成指数。采用指数有个明显的长处，那就是我们能够比较容易地借助指数来比较不 同市场的相对表现。CSI 也在各种市场群类中引入了无期限指数 TM，其方法大抵与 CRB 指数相伯仲。这种指数与 CRB 期货指数所涵盖的对象是一样的，只是基期选择得不同罢了。到底这些复杂的花样是否比我们的最近到期合约方法更为有效，还有待进一步的考察。不过必须强调，即使这 些办法中出现的偏差相对小些，连接最近到期合约这一简单方法依然是最通用的，操作也很便当。更重要的是，通 过长期的实践证明，这种简单方法相当有效。相反，如果我们要逐日绘制所有市场的无期限合约 TM 的图表，那实在是繁琐不堪。当然，用户也也可利用计算 机和电话数据转换器，每天从 CSI 获得这些加权平均值，但是其成本高昂。因此，朋友们有必要权衡权衡，或者保 存历史资料，采用简便的传统方法;或者选择烦难的新技术，支付更高的代价。 图表分析技术可以应用于长期图表 绝大部分图表分析技术既可以应用于日线图，也同样适用于周线图和月线图。这一点值得反复重申。我们甚至可以更进一步地说，预测长期趋势常常比预测短期市场还要容易些。技术分析有两个基本的信条:（1）市场以趋势方式演变;（2）趋势具有惯性。在长期图表上，不但趋势具有明确的特征，而且其中长期趋势往往延续数年，而这 两个方面正是长期图表最显著的特征。 想想看，我们只要在长期图表上做一次分析，就能管用几年呐!可是，目前在期货行业，绝大部分市场通讯专注于短期性研究。往往在读者从邮局拿到之前，就已经时过境迁了。如此一来，在下一期发出之前，市场通讯的主办人都得借助电子信箱和电话热线频频刷新自己的分析，以保证自己的分析切合一日千里的现实。 长期趋势的持久性特点非常突出，从而引出了我们对另一个问题的有趣的思索—市场的随机性。技术分析者并不接收市场行为“随机论”或“不可捉摸论”，但是为了稳妥起见，我们还是必须承认，从非常短暂的意义上说，市场上确实可能存在着这样那样的随机性价格变化。但是，我们从长期图表上明显可以看出，既存趋势具有长期的 时间跨度，在许多情况下甚至持续数年之久，这个事实有力地驳斥了随机行走理论所谓价格在时间顺序上互不关联， 过去对未来毫无影响的论调。 技术分析理论摘要 在考察以下的价格图表之前。我们先概述一下在图例中涉及的各种技术分析原则，以便朋友们体味。在技术分析的理论基础中，最重要的一条就是，分析者预测市场方向需要的所有信息都巳经反映在价格图表之中。技术分析者坚信，所有最终可能影响价格变化的信息都包容、消化（或者反映）在价格里。价格上涨，则表明市场的心理是 牛气的，而价格下跌，则反映市场心理是熊气的。 技术派认为，技术分析在某种意义上已经包含了基础分析，因为图表也反映了市场对基础性供求关系的估价，而正是这种估价才导致了牛市或熊市。因此，图表师有理由判断，如果价格上升，那么需求必定超过供给，基础因素就是看好的。从而，他就可以通过对市场行为的研究，来寻找价格最可能的走向的线索。他之所以这么做，就是要尽早发觉价格资料的重要趋势，越早越好。如前面所说，价格以趋势形式演变，并且其趋势具有强烈的持续下去的倾向。绝大多数技术性顺势系统的主要意图就在于，在趋势发生发展的初期，把它及时地判别出来;然后，这些 系统就顺着趋势的方向开立头寸，一直维持到价格变化表明该趋势已经终结或反转为止。 在过去的 100 多年中，技术派为了描述不同类型的市场行为，以及各种技术预测手段，建立了一整套技术分析术语。所谓趋势，就是价格变化的一般方向。上升趋势的规范定义是，一系列逐步递升的峰和谷。下降趋势则是一系列逐步递降的峰和谷。横向延伸趋势的峰和谷依次水平伸展。趋势通常又分为三级，主要趋势、次要趋势和短暂 趋势。主要趋势常常持续数年。本章要讨论的就是这种主要趋势。 技术分析术语 阻挡，是一个价格水平（或区域），在其上方，卖方压力将增强。一般而言，前一个峰值就是一个阻挡术平。支撑，也是一个价格水平（或区域），在其下方，买方的支撑较强。通常，前一个答值就是一个支撑水平。历史支撑水平和历史阻挡水平的由来，可以上溯到数年之前。它们具有持久不衰的影响力，这是长期图表的最为令人注目的特征。一旦市场以足够大的幅度穿破了支撑水平，后者就转化成阻挡水平。在上升趋势中，阻挡水平被冲破后，就演变成新的支撑水平。图8.7是活牛期货的图表，是这一现象的典型例证，其中的历史阻挡水平 35.00 和 56.00 后来 均转化为支撑水平了。 趋势线在这些图表中的应用，也出奇地有效。在上升趋势中，基本的上升趋势线是通过向上反弹低点连接而成的。只要这条趋势线不被跌破，则上升趋势就有效。下降趋势线向右下方倾斜，是沿着上冲高点连接而成的。有时，市场会形成价格管道，在价格管道中，管道线平行于基本趋势线，位于价格的上方或下方。图 8.1 是商品研究局期 货价格指数图，其中展示了一个为时 10 年的价格管道。 既成趋势常常按照一定的百分比例进行调整。最为知名的百分比回撤为50%回撤。例如，在上升趋势中，一个中等的调整或许要回撤到先前运动的50%的位置上，然后市场才恢复上涨。最小回撤约为先前运动的1/3，而最大回撤为其2/3。如果市场回撤到远超过 2/3 的程度，那么市场通常可能就要返回原先的起点了。因此，2/3 回撤 区是非常关键的。图 8.8 和图 8.11a 分别是糖和黄金的图表，例示了市场在 2/3 回撤点发生转折的情形。 图表上的形态 长期图表上也具备各种价格形态，其研读方法与日线图一致。在这些长期图表上，双重顶和双重底这两种形态 非常醒目。当市场无力克服前一个峰值阻挡，而掉头向下，跌破了最近一个向上反弹低点之后，双重顶就形成了。 双重底的情况正好相反。主要的双重顶出现在图8.5和图8.12a的玉米和铜的图表上，两个峰相距几乎有7年之久。图8.10显示的是一个头肩形底，例示的是小麦市场，时间从1964年到1972年。三角形，通常属于持续性形态，但有时也以反转形态的面且出现，在这里的表现也很突出。请看，在图 8.2 的 CRB 期货指数周线图上，就有个对称三角形。 还有一类形态也在这些图表中频繁露面，那就是周反转和月反转。举例来说，在月线图上，市场在当月向上达到了新的高点，但月末收市价格反而低于前一个月的月末收市价，那么这往往就是一个要紧的转折点，特别是当它发生在重要支撑或阻挡区附近时，尤其具有重要意义。周反转在周线图上也相当常见。这些形态同日线图上的关键反转日是对等的。不过，在长期图表上出现的反转形态的影响深远得多。 利用长期图表来从事趋势分析的最大优越性还在于图表自身。在后面的图例中，包括了几个覆盖时间长达20年的周线图和月线图的范例。我希望这些例子足以表明其价值，足以说明在进行趋势分析时它们是何等犀利有力。如果你从未识荆，恐怕要惊喜一番了。 从长期图表到短期图表 如果我们要进行透彻的趋势分析，那么，特别重要的是采取正确的读图顺序。图表分析的恰当次序应该是，从长期图表开始，逐步过渡到近期的图表。当朋友们与不同的时间范围打交道时，这样做的原因就一目了然了。如果分析者只能从短期图表开始研究，那么随着时间尺度的扩大，新的价格资料不断地参加进来，他就不得不相应地修 正上一步的结论。即使朋友们已经完成了对日线图的深入分析，但当你再看到长期图表时，或许还得推倒重来。反 过来，如果从大的背景入手，一下子考察了 20 年的全部价格资料，那么你就对市场首先有了恰当的纵览。分析者从 长期透视中了解了当前市场的来龙之后，就可以逐步“聚焦”，找到市场当前的去脉。 在后面的图例中，第一张是为期 20年的连续图表。分析者应当首先从这张图上找出较明显的图表形态，主要趋势线以及大致的主要支撑和阻挡水平等要素。然后再转向最近5年的周线图，重复上述程序。最后，再把注意力集中到日线图上，研究最近 6 个月到 9 个月的市场行为。这样就完成了从“宏观”到“微观”的过渡。交易商也不妨 再向前走一步，研究研究日内价格图表，从而得到更细致入微的结果。 起点：商品价格指数 在股票行业，所有的市场分析方法都是从广泛的市场平均值，例如道琼斯指数、标准普尔氏500种股票指数等出发的，从中可以得出总体市场的一般方向。股票交易商或投资者首先必须弄清楚股票市场在总体上是牛市还是熊市，然后才谈得上选购具体的股票。股市分析者往往是在考察了广泛的市场平均值之后，再研究哪类行业的表现最出色。也就是力图在表现最佳的行业群类中，挑选出最佳企业的股票。全过程分三步进行。分析者起先要有非常广泛的印象，然后逐步逐步地缩小范围。期货交易商也应该采取相同的步骤。 商品研究局期货价格指数在我们分析任何商品市场的时候，第一步理所当然是要弄清总体商品价格的方向。我们可以通过分析商品研究局期货价格指数来解决这个问题，它是最受关注的商品价格的晴雨表。该指数含有27种商品期货，反映了商品市场 的总体趋势。因此，它是我们的必不可少的起点，由之可以确定商品市场总体上是上涨还是下跌，具体市场所处的大环境是牛气的还是熊气的。 CRB 群类指数 第二步，分析者应该考察各种市场群类，挑选出最坚挺的或最疲弱的商品群。举例来说，如果CRB期货指数为上升趋势，或者正处于向上反转的过程中，那么分析者就可以采用相对强度的概念，从这一类指数中选出技术特色上最坚挺的商品群类。下面，就该把注意力放到这些强者中去了。 个别市场 第三步，我们要集中注意力，从表现最坚挺的群类中甄选出表现最强的个别市场（我们这里是以看涨的大气候为例，分析者从多头的角度考虑问题）。在价格膨胀的阶段，CRB期货指数趋涨（比如在70年代），那么分析者就应该集中精力，对付涨势最强的市场群类，从其中挑出最坚挺的具体期货市场，以寻求买进的良机。而在价格萎缩的 阶段（比如从 1980 年以来），CRB 指数趋跌，交易者就应该着眼于最疲弱的市场群类，从中抓住最软弱的具体期货， 以寻求卖出良机。 所以，在分析者打开某个市场的图表之前，他就应该对总的商品市场的价格水平到底是看涨还是看跌、以及该市场所处的期货群类的价格水平到底是看涨还是看跌等背景，做到心中有数了。 综上所述，当我们对某市场进行透彻的趋势分析的时候，应该遵循下列正确的步骤;首先分析CRB期货价格指数的20年的月线图，然后是其5年的周线图，最后是其日线图。接下来，考虑各种CRB群类指数（或者分析者感兴趣的某群体）的长期周线图和日线图;最后一步，研究个别市场，由月线图而周线图，最后至日线图。本章后面 的图例的编排，正是出自上面的考虑。第一例，图 8.1，就是 CRB 期货价格指数的 20 年连续月线图。 是否应对长期图表进行通货膨胀的修正？ 在结束我们的说明之前，还需要作几点补充。第一个问题是，是否应该对长期图表上的历史价格进行通货膨胀修正。不管怎么说，从70年代早期之后，通货膨胀率是惊人的，到了80年代，通货紧缩也是不同寻常的，那么，美元的价值前后就有了较大的变化。如果我们不对长期图表的历史价格进行修正，它们上面的峰和谷还有意义吗？ 分析师们对这个问题颇有争议。 我个人认为，不必要对长期图表进行任何修正，理由很多。主要的，我相信市场自身已经进行了必要的修正。当货币贬值时，就会导致用该货币表示的商品价格的上涨。因此，随着美元的贬值，商品价格就会相应上升。毫无疑问，商品期货的长期图表上 70 年代的价格上涨，在很大程度上仅仅反映了美元的疲弱。对应地，最近 5 年商品价 格的下跌，在很大程度上则直接归因于美元的坚挺。 第二个值得推敲的问题是，从70年代商品价格的巨额抬升，到80年代商品价格的大幅下跌，都是通货膨胀作用的经典实例。因此，尽管在70年代商品价格翻了两番乃至三番，要对它们进行通货膨胀修正还是没有根据的。商品价格的上涨正是通货膨胀的结果。在 80 年代，经济学家曾经把商品价格的下跌作为通货膨胀受到控制的标志。金 价现在已经跌到 1980 年的一半以下了，难道我们有必要用较低的通货膨胀率对它修正一番吗？我想市场本身对这方 面的问题早已“置之度内”了。 最后一个问题，牵涉到技术分析理论的核心，“市场行为最终包容、消化一切因素”这条基本前提。市场自我调节，自动适应了通货膨胀、通货紧缩以及货币币值变化的要求。到底是否要用通货膨胀修正长期图表？这个问题的真正解答还在于长期图表本身，“解铃还待系铃人”。图 8.12a 是铜的图表，其中 1980 年的牛市的最高点恰好达到了1974年牛市的最高点，然后市场便开始下跌，一直跌到、并稳定于1975—1977年的熊市低点上。许多市场都无力冲破数年以前形成的历史阻挡水平，而且从此开始下滑，一直跌到数年前形成的历史支撑水平。如果长期图表需 要进行通货膨胀修正的话，这类价格变化将无从发生。 长期图表不直接服务于交易 长期图表不宜直接应用于交易中。我们必须把对市场的分析预测和出入市时机抉择这两项工作区别开来。长期图表在确认主要趋势和价格目标时大有裨益。不过，它们不适用于出入市时机的选择，不应该服务于这种目的。后面这方面的研究更为灵敏，因而必须采用日线图以及日内线图来进行。 结语在以下图例中出现的各种技术工具都是较为基础的，传统的图表分析者当能一目了然。其中我们只采用了从第一章到第七章的一些原理。不过，其它图表分析技术也毫不例外地适用于周线图和月线图。比如，长期图表也可以用来研究长期性周期。艾略特波浪理论在长期图表上也一样有用武之地。在玉米和棉花的月线图图例中，就有 5 浪 牛市的例子。 在这些图表上，长期性移动平均线的应用还是个薄弱环节。作者几年前曾经做过一点尝试，实践表明，在周线图上大可采用10周和30周移动平均线来追踪长期趋势。这些平均线同股市分析中所采用的平均线大同小异，但是它们在期货市场上一直没受到重视。 对长期图表，我们只需要每隔一段时间深入地研究一下就行了。在短时间内，长期图表上的价格形态变化甚少。 因此，平时我们只需要对之略加观察，就足以获得有关的背景知识了。 日线图依然是期货商的基本工具。对短线的操作者来说，日内图表也是大为得力的工具。本章的意图并不是要改变上述事实。无论如何，我们希望朋友们牢记的是，长期图表是对短期图表的重要补充，如果没有前者，我们将错过大量极有价值的价格信息。朋友们应当清楚，如果在我们的分析过程中把广泛性商品价格指数的研究也包括进 来，那是很有益处的。 目前人们已经日益了解了这些长期图表和指数的价值。当我们把它们与日线图共同使用的时候，我们的图表分 析就具备了一个全新的视野，为技术分析在期货市场的应用增色不少。 周线图和月线图的实例 在本章以下的几页中，有几张是长期周线图和月线图。这些图表在很大程度上可谓“其义自现”，无需另做解说。不过在图8.5和8.6中，我们用到了一点艾略特波浪的5浪牛市的内容，但极为基本。图中所标注的，仅限于长期的支撑和阻挡水平、长期趋势线、百分比回撤、周反转、以及间或出现的价格形态等。 随便翻翻这些图表吧 t 请注意，其中大量的历史资料在日线图上完全是看不到的。日线图与5年的周线图相比，缺失了80%的价格资料，同20年的月线图相比，丧失了95%的历史内容。好在现在朋友们就可以一睹这些历史资料的风采了，不妨体味体味结合使用它们从事分析的妙处。 图 8.1 CRB 期货价格指数月线图。 图 8.2 CRB 期货价格指数的周线图。注意其中的双重顶和对称三角形。目前价格依然处于下降趋势中，但已经进入了由1982年的低点形成的支撑区中。组成CRB期货价格指数的27种商品是:大麦、活牛、可可、咖啡、铜、玉米、棉花、原油（NY）、亚麻子、黄金（COMEX）、2 号取暖油、生猪、木材、燕麦（CHl）、橙汁、铂、猪脯、马铃薯、油 菜籽、裸麦、白银（NY）、大豆、豆粕、豆油、世界级原糖、小麦（CHI）、小麦（MPLS）。 图 8.3 CRB 贵金属期货指数周线图。注意图中并然有序的下降趋势，其中的支撑水平后来均演化为阻挡水平了。该指数目前正处在主要支撑区。研究一下本指数，有助于对具体的贵金属市场的分析。 图 8.4 一些 CRB 群类指数的例子。在研究各个群粪中的具体市场之前，应当首先分析一下这些群类指数。这里请注意，进口类指数在图中的三个指数中最坚挺。这就意味着在可可、咖啡、和原糖市场中可以找出最具有上涨潜力的市场。注意，沿着图表底部给出了各个群类的组成。 图 8.5 注意，1980 年的顶与 1974 年的顶处在同一水平。还要注意其中的五浪牛市。 图8.6 请注意$1.00附近的主要阻挡，以及60美分处的支撑。还请注意从 1977 年到 1980 年的五浪结构的牛市 图 8.7 注意，35 美分和 56 美分原先分别为阻挡水平，但被向上突破后，都演 变成支撑了。活牛价格自从 1979 年来，一直处于幅度为 20 美分的交易区间中 图 8.8 世界级原糖月线图。 图 8.9 请注意图中的历史的主撑和阻挡水平是如何在数年后发生影响的。 图 8.10 小麦月线图。 图 8.11a 和 b 黄金月线图和周线图 图 8.12a 和 b 铜月线图和周线图。 图 8.13a 和 b 在取暖油市场的长期图表上，有一个为时 6 年的从 1.05 美元到 70 美分的交易区间。 图 8.14a 和 b 在 8.14a 的周线图中，债券的价格正在试探 73—16 附近的阻挡。在 8.14b 的月线图中，其价格也正在试探一条长期下降趋势线 图 8.15a 和 b 在上图（8.15a）中，请注意其中的长期下降趋势 线。在下图（8.15b）.注意沿着 1982/1983 的高点形成的主要阻挡 图 8·16a 和 b 从这张瑞士法朗的月线图上看，可以看到长期支撑 区，这在日线图上一个也找不到。注意自 1979 年以来的下降趋势线 图8.17 这是S&amp;P500期货指数的周线图.本图比日线图提供了清晰得多的市场透视。1983/1984的下 跌恰好回撤到 1982/1983 的牛市的 1/3 的位置。注意 1984 年年中在 150 附近形成的双重底，以及在两个 底部处的向上周反转。还请注意，在1984 年下半年的下滑中，市场从过去的阻挡水平 163 处得到了支撑。 通常，长期图表为长期趋势提供了优越得多的图隶。从本图来看，它比短期图表所显示的趋势要牛气很多。 技术指标 下一章，我们将探讨最流行的一种技术指标—移动平均线，这也是绝大部分趋势顺应系统的机关之所在。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第七章 交易量和持仓兴趣]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E4%B8%83%E7%AB%A0-%E4%BA%A4%E6%98%93%E9%87%8F%E5%92%8C%E6%8C%81%E4%BB%93%E5%85%B4%E8%B6%A3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 引言大部分期货市场技术分析者同时跟踪三组数字—价格、交易量和持仓兴趣，以使自己的分析手段具备三度空间。在第三章介绍线图的作法时，我们讲解了如何把上述三类资料展现在图表上。我们强调指出，尽管在商品市场上对应于每个交割月份的个别交易量和持仓兴趣都可以得到，但是，我们一般只使用同一商品的总额进行预测。当然，我们也建议朋友们关注各个交割月份的个别持仓兴趣，以把自己的交易活动集中到最活跃的（或者说是流动性最好的）合约上。 到目前为止，我们关于图表分析理论的讨论主要是围绕着价格进行的，顺带着才提及交易量等。在本章中，我们将进一步，介绍交易量和持仓兴趣在预测过程中的作用，从而引入第二度和第三度空间。 交易量和持仓兴趣是次要指标首先，我们要给交易量和持仓兴趣赋予恰当的地位。价格显然是最重要的因素。交易量和持仓兴趣是次要的，主要作为验证性指标使用。而在这两者之中，交易量又更重要些，持仓兴趣居末位。如果我们把三类信息按照从l到10的比例排列出来，那么，价格为5，交易量为3，持仓兴趣为 2。有些分析者或许不同意上述安排，那么，我只 能说这是基于我个人的市场经验的一点看法。 有些职业人员完全忽略了交易量和持仓兴趣，而有些人则对它们过于重视。依据我的个人经验，我宁愿采取某种折衷的立场。我发现，如果在研究价格变化的同时，也追踪交易量和持仓兴趣的轨迹，有时能发现市场方向的重要线索，但有时价值也不大。不过，严谨的技术分析者应该把这两方面纳入自己的考察之中，并且随时留意它们发 出的重要信息。 交易量 现在，我们给它们重新定义。交易量是指在我们所研究的基本时间单位内成交的合约总额。因为我们主要研究的是日线图，所以，我们最关心的是每日的交易量。每日交易量在图表下部、价格变化之下，以一条竖直线段表示，如图7.1所示。请注意，交易量的比例尺标在图表右侧价格刻度的下方。 在周线图上，我们同样可以作出交易量。这里，我们在价格图下方对应于每一周的位置上，画出这一周的交易量之和。不过，在月线图上，通常不再采用交易量。还请朋友们注意，只有交易量和持仓兴趣的全额才被用于预测。 持仓兴趣到某日收市时为止，所有未平仓了结的合约的总数就是当日的持仓兴趣，如图 7.1 所示。也请注意，持仓兴趣的刻度标在图表下部左侧。持仓兴趣也描画在对应日期的价格之下，但其位置高于交易量。请记着，在商品市场上，交易所顺延一天发布正式的交易量和持仓兴趣的报告，从而在图表上，也相应地出现一天延迟的情况（每天我们只能获得上一个交易日这两种信息的估计数字）。这就是说，图表师每天可以作出最近一个交易日的高、低和收市价的价格线段，但只能作出这一日的前一个交易日的正式交易量和持仓兴趣。 持仓兴趣代表市场上多头一边或空头一边的未平仓合约的总数，而不是两方的总和。持仓兴趣以合约张数为单位。只有两个市场参与者—买方和卖方—会同起来才能创生一张合约。在每日公布的持仓兴趣数字后，总跟着一个正数或者一个负数，分别表示这一天相应的合约张数的增加或者减少。正是持仓兴趣水平的变化（或者上升或者下降），为图表师分析入市行为的变化特点提供了线索，从而使持仓兴趣具备了预测价值。 持仓兴趣的季节性变化 我们对图7.1多作一点解释。前面我们介绍了价格线段、交易量线段以及持仓兴趣曲线，沿着图表底部还剩下一条虚线，它表示持仓兴趣5年的平均值的情况。我们用这条平均线来显示持仓兴趣的季节性倾向。如同价格变化一样。持仓兴趣具有非常明确的季节性倾向，我们应当把这种情况也考虑进来。 举例来说，仅当持仓兴趣的增加超过了其季节性的增长之后，这个变化才具重要意义。在图表上，我们通过两条曲线的比较来剔除季节性倾向，由此得出的持仓兴趣的净变化的效果更优越。正是持仓兴趣的实际变化（实线）同通常的季节性变化（虚线）之间的差异，给两条持仓兴趣曲线增添了意义。 图7.1 注意图表下方右侧的交易量刻度。持仓兴趣的刻度标在图表下方左侧。虚线表示持仓兴趣的5年平均值，用来显示季节倾向。注意，在11月底，随着价格的疲软，交易量有所扩张。这是一个清晰的看跌信号。较重的交易量应当出现在价格趋势的相同方向 持仓兴趣的变化如何发生 持仓兴趣数值的变化意味深长，为了掌握其中的奥妙，我们必须首先理解每笔交易 如何对该数字发生影响。 每当交易所大厅内一笔交易完成后，持仓兴趣就有三种变化的可能性:增加、减少、或不变。下面我们看看这 些变化是如何发生的。 在第一种情况下，买方和卖方均开立了新头寸，产生了新的合约。在第二种情况下，买方建立新的多头头寸，但卖方只是平仓了结原有的多头头寸。一方入市交易，另一方退出市场，结果双方扯平，合约总数没有变化。在第三种情况下，情况也一样，只是此处卖方开立了新的空头头寸，而买方只是平仓了结原有空头头寸。也是一方入市，一方退出，合约总数不会有任何变化。在第四种情况下，交易双方都平仓了结原有头寸，从而持仓兴趣减少。 综合上述，如果买卖双方均建立了新的头寸，则持仓兴趣增加。如果双方均是平仓了结原有头寸，则持仓兴趣减少。如果一方开立新的交易，而另一方平仓了结原有交易，那么持仓兴趣维持不变。在每个交易日结柬之后，图表师通过考察总的持仓兴趣的净变化，就能确定资金到底是流入市场，还是流出市场。根据这个信息，分析者能够 就当前市场趋势的坚挺或疲软程度做出一些推测。 交易量和持仓兴趣的一般解释规刚 市场技术分析者一般把交易量和持仓兴趣的信息综合应用于市场分析之中。因为交易量和持仓兴趣两者颇为相似，所以，我们把它们的解读规则合起来介绍。不过，两者之间毕竟有所不同，我们首先叙述一下两者共同的一般规则，然后分开讨论，量后再把它们综合起来（见下表）。 如果交易量和持仓兴趣均上升。那么，当前趋势很可能按照现有方向继续发展（无论是上涨还是下跌）。如果交易量和持仓兴趣都下降，那么，我们就把这种变化本身视为当前趋势或许即将终结的警讯（见图7.2）。下面我们来分别考察交易量和持仓兴趣。 图 7.2 从 10 月到 11 月，持仓兴趣的增长验证了价格的上升趋势。然后，持仓兴趣持平发展，反映市场上正在平仓获利，发出了可能出现顶部过程的早期警讯。注意，1月的第二个峰的持仓兴趣低于11月的价格峰的持仓兴趣的水平。还请注意，在第二个价格峰，交易量较轻，而在 1 月价格下滑时，交易量较重。这些都是看跌的信号。 交易量的解释 交易量水平是对价格运动背后的市场的强度或迫切性的估价。交易量越高，则反应出的市场的强烈程度和压力就越甚。技术师通过观察配合价格变化的交易量的水平能够较好地估量市场运动背后买入或卖出的压力。我们也可以利用这项资料来验证价格运动，或者作为识别价格变化可靠与否的警讯（见图 7.3 和 7.4）。 如果把这个规则表达得更简明些，那么，交易量应当在现有价格趋势的方向上，相应地增加或扩张。在上升趋势中，当价格上升时，交易量应较重，而在价格回跌时，交易量则应减少或收缩。只要上述情形仍在持续，那就说明交易量正在验证价格趋势。 同时，图表师也会密切注意相互背离现象的迹象（这里又碰上这个概念了）。如果在上升价格趋势中，前一个峰被向上穿越，而与之同时交易量反而有所下降，那么就发生了背离现象。这就警告图表师，市场的买入压力正在减轻。如果交易量在价格下跌时还变本加厉，倾向于有所增加的话，那么分析者就要注意上升趋势即将发生变故了。 图7.3 注意，图中较重的交易量往往出现在价格趋势的方向上。6月，在市场的顶部之前，较重的交易量在价格上升的一边。而在随后的熊市中，较重的 交易量在价格下跌的一边。我们可以看到 11 月在价格下跌时，交易量较重。 图 7.4 这是交易量追随价格趋势的另一个实例。在本图中，自 7 月以来， 表现出明确的牛市倾向。特别要注意，在12月中当价格上冲时，交易量扩张，而当市场调整时，交易量减轻。这表明交易量验证了价格的上涨。 交易量验证价格形态 在第五章和第六章我们讨价格形态时，曾数次提及交易量，把它看作重要的验证指标。头肩形顶成立的预兆之一就是，在头部形成过程中，当价格冲到新高点耐交易量较轻，而在随后跌向颈线时交易量却较重。在双重顶和三重顶中，在价格上冲到每个后继的峰时，交易量都较轻，而在随后的回落中，交易量却较重。在持续形态形成过程中，如三角形，与之伴随的交易量逐渐下降。一般地，所有价格形态在完结（突破点）时，只要这个突破信号是成 立的，那么它就应当伴有较重的交易活动（见图 7.5）。 在下降趋势中，当价格下跌时交易量应较重，而在价格上弹时较轻。只要交易量的变化保持上述特点，那么就说明卖出压力大于买进压力，下降趋势也将持续下去。仅当这种情形发生了变化后，图表师才会着手探究市场的底 部信号。 图7.5 价格形态的完结应当有较重的交易量来配合。本图展示了一个下降三角形。注意当下侧的趋势线被突破时的较重的交易量。还要注意，从10月到11月，持仓兴趣有高额的积累。与之同时，价格尚处于巩固阶段。在巩固阶段的持仓兴趣的增长，加剧了随后的突破动作 交易量领先于价格 在对价格和交易量的对照研究中，我们实际上是使用两种不同的工具来估价同一对象—市场力量。仅仅根据价格趋向于上升这一事实，我们就可以判断市场上的买进压力大于卖出压力。我们不妨推论，较重的交易量应当发生在与市场的流行趋势一致的方向上。如果说技术分析者认为交易量预测了价格，那么他其实是说，无论是在上升趋势中价格上涨压力的减少，还是在下降趋势中价格下跌压力的减小，都通过交易量资料预先反应出来了。而就价格本身来说，这一点要等到价格趋势实际反转时才能体现出来。 权衡交易量（OBV）法 技术分析者尝试过许多种交易量指标，以定量表示市场的买压或卖压（见图 7.6a 到 7.8b）。要知道，即使我们竭尽能事，仔细察看图表底部的交易量线段，也并不总能准确地揭示交易量的重要变化。在这些交易量指标中，最简单的也最著名的是所谓权衡交易量，或称OBV法。这种方法系约瑟夫·格兰维尔创立的，并通过他的《格兰维尔氏股市获利新秘诀》（普伦蒂斯·霍尔版，1963年）而广为流行。OBV法实际上沿着价格图表的底部添了一条交易量的曲线。我们既可以用这条曲线来验证当前价格趋势的可靠性，也可以通过它与价格变化的相互背离现象，来 获得趋势即将反转的警讯。 图 7.6a 在这里的长期国债的交易量刷形图上，如果只凭双眼来观察这些交易量的竖直线段，是很难分辨变易量的增减方向的。 图 7.6b 本图下方为权衡交易量（或 OBV）线。请注意，这么一来追踪交易量流向的工作就大为简易了。 图 7.7a 本图下方的曲线是 OBV 法的另一个实例。注意，其中的 OBV 线也处于上升态势，验证了价格的牛市。 图7.7b 请注意，在本例中，目前OBV线正处于横向延伸之中，未能验证价格 的下降趋势。这或许构成了警告信号，说明在下降趋势的这个地方不能过于看跌 图 7.8a S&amp;P 期货合约的周线图，由每周的最高价、最低价和最后一天的收市价构成。 图7.8b 在逐周作出的价格图表上，也可以画出权衡交易量（OBV）曲 线。注意。在本例中，OBV 线已经升到了新的高点，发出了看涨信号。 图 7.6a 展示了一张标准的日线图，其中既有价格线条，也有交易量线条。分析者或许可以通过仔细地审察交易量的刷形图，来判别交易量的重要变化。图7.6b与上图相同，但沿着图表底部，我们用OBV线替代了交易量的图线。请注意，在这里，OBV 线大大简化了跟踪交易量趋势的工作。 OBV 线的构造方法很简单。我们先把每一个交易日的收市价格与相邻的前一个交易日的收市价格相比较，得出其相对高低，然后，在当日的交易量数值前，对应地添加一个正号或负号。如果当日的收市价格有所上升，那么，当日交易量数值的符号为正，反之，若当日的收市价有所下降，则符号为负。下一步，再选定一个基准日，从基准日起到当日止，逐日地按照上述方法得出每日的交易量数值，然后把它们进行简单的算术累加，即根据每天的收市价格的增减方向，从前一日的累计总值中，相应地加上或减去当日的交易量，最后就得到当日的累计总值—OBV 值。 在这种方法中，具备重要意义的是OBV线的方向（其趋势），而不是该数字本身的实际水平。然而，为了防止OBV值滑入负数区域，我们一般不是从零开始，而是在基准日选择一个成整的大数字，作为起算值。当然，这只是为了使OBV线维持在正数区而易于描画。我们一般选择如 10000 这样的数字作起算值。实际上，OBV 值到底是正 还是负并无意义。 权衡交易量线应当与价格趋势方向一致。如果在价格图上反映出一系列依次上升的峰和谷（上升趋势），那么OBV线也应当如此。而如果价格趋势向下，则OBV线的趋势也应当向下。恰恰是在权衡交易量线与价格趋势不协调一致的情况下。构成了相互背离现象，警告我们趋势有可能要反转。 针对 OBV 线，我们也可以如同对价格所进行的趋势分析那样，采用各种技术指标进行分析。在权衡交易量线上，峰（阻挡）和谷（支撑）也是显而易见的。同时，我们也可以把趋势线分析和移动平均线方法移植过来，用于辨别OBV值的趋势反转。另外，摆动指数分析也完全适用于权衡交易量线。在这里所附的图例中，有一些充分显示了 OBV 法的妙用。 交易量累积（VA）法: OBV 法之外的另一个选择 利用权衡交易量，我们能够相当有效地达到上述目的，但它也有一些缺点。举例来说，仅仅根据当天的收市价 格的大小，我们就把全天的交易量添上了正号或负号，这看起来并没有充分的依据。试想，如果市场的收市价格只比前一天高出某个小量，比如一二个点子，我们就在全天的交易活动量前标上正号合理吗?或者考虑这种情形，市场当天大部分时间处于前一收市价之上，只在收市时才稍稍低一些，我们是否应该把当天全部交易量都标上负号呢? 为了解决这些问题，技术师尝试了许多种 OBV 法的变通办法，以求发现真正的向上的交易量和向下的交易量。 变通办法之一是，给趋势较强的日子赋予较大的权重。比如，在价格上升的日子，就用价格的涨幅乘以交易量。 本方法虽然依旧采用正负号，但我们把价格变化较大的日子给予了较大的权重，从而减少了价格实际变化较小的日 子的影响。 另一种对格兰维尔的权衡交易量法的变通办法，是马克·蔡金设计的，称为交易量累积（VA法）。蔡金的交易量累积法利用日内价格变化来估价当日的交易量。一般认为，这种方法在股市中更有用，但是它也同样地适用于商品期货，特别是具有大量公众参予的期货市场。OBV 法给全天的交易量都标上正号或负号，但交易量累积法只为当日交易量中的一定百分比例计入正负符号。根据收市价格同当日平均价格的相对高低，也就是说，如果市场收市于全日平均价格或全日价格区间的中点之上，则当日交易量的一定百分比例便标正号。如果价格收市于中点之下，则 当日交易量值的一定百分比例就标为负号（见图 7.9a 到 7.10 b）。 仅当收市价格与当日最高价相同时，我们才把全天的交易量都计为正值。如果情况正好相反，即收市价格恰好 位于当日最低价，那么，我们把当日所有的交易量均计为负值。 我们假定基准日的起算值为 10000，并通过以下公式来构造图线: VA—{[（C—L）一（H—C）]/（H—L）}×V 其中 H 为当日最高价，C 为收市价，L 为最低价，V 为交易量。 交易量累积线与价格变化的配合使用方法，与 OBV 线完全一致，它或者同价格变化相互验证，或者与之相互 背离。为了跟踪 VA 线的趋势，我们也可以采用各种技术工具。当然也可以利用摆动指数来考察 VA 线，我们将在第 十章讨论这个问题。关于价格和交易量的参照使用方法，还有其它更复杂的公式。加利福尼亚的詹姆斯·西贝特创立的所谓需求指数就是其中的一例。上述三种交种交易量指标的计算机软件均已有售，为我们省却了构造和维持其图表的冗长乏味的繁杂负担。在新奥尔良的 Compu Trac 集团的技术分析软件中，涵盖了上述三种方法。在今后各章中，我们还将采 用更多 compu Trac 的图例。 图7.9a 黄金合约的收市价格图 图7.9b OBV线（上方的曲线）与交易量累积线（下方的曲线）的比较。在这一 例中，交易量累积（VA）线显得更灵敏。11 月，VA 线的剧烈上涨应该视为伪信号 图7.10a 取暖油合约的收市价图 图7.10b OBV线与VA线的另一例比较。其中OBV线（上方的曲线）目前已经急剧地上弹，而VA线（下方的曲线）却依然达到了新的低点。从后来的市场行为看，这里VA线的表现较优。就在本图之后，市场剧烈地下跌了话说回来，即便采用了更为复杂的 OBV 法的变体，我们的目的始终也是一致的—力图确定较重的交易量到底发生在价格向上的一边（看涨的）还是价格向下的一边（看跌的）。因为OBV法很是简明实用，所以，在我们跟踪市场的交易量变化时大有用武之地。根据不同的环境，我们可以把它用作价格运动的孪生指标（验证指标）或者先 行指标。OBV 线更形象地展示了交易量的变化，更易于观察和分析，所以它（及其某些变体）能够成为图表师非常 有用的新式武器。 在期货市场中交易量分析不十分有用 我们认为，交易量分析在商品期货上不如在股市上有用。首先，在期货市场上交易量报告有个一天延迟的问题。 再者，如果采用所有合约的交易量的总额，而不是具体合约的个别的交易量数额来研究这个具体合约，相对说来，有点不伦不类。正如前面所指出，我们是有充分理由选用交易量总额来研究市场的。但是，当在同一种商品的不同合约中，有些收市价格有所上升，而另外一些反而有所下降的时候，我们怎么办呢?另外，涨跌限价规定也造成了其它问题。在市场因为受到交易所涨停板的限制而被锁定的交易日中，交易量通常极轻。这是市场坚挺的情况，买方的需求量压倒性地超出了卖方的供给量，价格很快上升到当日的上限，于是交易活动实际上陷于停滞。根据通常 的解释规则，在上冲时伴随着较轻的交易量就是看跌信号。而这种在限价日出现的较轻的交易量，显然就不符合上 述通行规则，它们有可能歪曲 OBV 的效值。 还有个问题。在股票市场上，关于平均股价指数，我们可以获得与其上涨或下跌分别相对应的交易量，对于个 别股票，也可以获得分别对应于价格上涨或下跌的成交股数。但在商品期货市场，我们却缺乏相应的资料，没有这 些有用的信息。 无论如何，尽管交易量分析在期货市场中有上述局限，但它仍然大有用武之地。技术型交易商如果注意观察交 易量的指标的话，那是很明智的。 对持仓兴趣的解释 持仓兴趣的解释规则同交易量大体类似，这里作一些进一步的说明。 1.在上升趋势中，如果当价格上涨时，持仓兴趣总额的增加超过其季节性平均值的增加（5 年平均值），就说明 新的资金正在流入市场，反映出新的买方行动大胆积极，所以，这是一个看涨信号。 2.反过来，如果当价格上涨的时候，持仓兴趣的下降超过了其季节性的下降，那么就说明这种价格上冲主要来自空头者买进斩仓的行为（这就是说，正日益蒙受损失的空头头寸持有者们终于缴械投降，被迫平仓了结空头头寸）。这时候，资金从市场流出而不是流入。在这种情况下，一旦上述被迫平仓了结空头头寸的过程完成之后，上升趋势 很可能就要失去上涨的推动力，因此这是一个看跌信号。 3.在下降趋势中，如果当价格下跌时，持仓兴趣总额的增加超过了其季节性平均值的增加，那么就说明新的资 金正流入市场，反映出新的卖方行动大胆积极。这就表明下降趋势将持续下去的可能性有所增加，从而这是一个看 跌信号。 4.反过来，如果价格下跌时，持仓兴趣总额的减少超过了其季节性的减少，那么这种价格下跌主要是由于日益蒙受损受的多头者最终不得不卖出斩仓的行为所引起的。在这种情况下，一旦持仓兴趣减少得足够低，上述大多数多头交易者已经完成了卖出平仓的过程，下降趋势很可能即将终结，因此这是表明市场逐渐坚挺的技术信号。 下面我们把上述四点归纳一下: 1.在上升趋势中，持仓兴趣增加是看涨信号。 2.在上升趋势中，持仓兴趣减少是看跌信号。 3.在下降趋势中，持仓兴趣增加是看跌信号。 4.在下降趋势中，持仓兴趣减少是看涨信号。 持仓兴趣具备重要意义的其它情形 除了上述倾向性以外，还有其它一些市场环境，如果我们研究一下持仓兴趣也能有所助益。1.当一场主要的市场运动接近尾声时，持仓兴趣已经随着价格趋势的整个过程增加到一定的高度了，那么，一旦持仓兴趣不再继续增加乃至开始减少，这经常就是趋势即将生变的先期警讯（见图 7.11）。 图 7.11a 持仓兴趣的上升验证了价格上冲的实例。但是请注意，当2月份持仓兴趣拐平后，就构成了市场顶部的预警信号。从这里起，价格急剧下跌 2.如果在市场顶部，持仓兴趣处在高水平，而价格下跌又突如其来，那么这是一个看跌信号。这种情况就意味着，在上升趋势接近尾声时建立多头头寸的所有多头交易者均处于损失之中。因为他们被迫卖出斩仓，所以使价格遭到了压力，这种情况一直将维持到持仓兴趣减少到足够大幅度之后。下面举一个例子，假设一个上升趋势已经进行过一段时间后，上一个月持仓兴趣曾经有显著的增加。请记住，在持仓兴趣中，每增加一张合约，就意味着市场同时出现了一张多头合约，一张空头合约。突然，价格开始剧烈地下跌，跌到上个月所经历的最低价格之下。那么， 在上个月建立的每一张新的多头合约均处于亏损状态。 图 7.11b 在这张原糖图表中，价格剧烈地向上反转，并伴随着交易量和持仓兴趣的迅速膨胀。注意，在7月份价格猛涨之前，交易量和持仓兴趣均急剧地萎缩。同时请注意，7月间交易量和持仓兴趣的增长表明了市场气氛由熊气向牛气的转换，加强了市场的重要底部可能已经完成的可能性。 于是，这些多头合约的持有者就被迫卖出斩仓，从而使价格遭到很大的压力，这种情况一直持续到他们的亏损头寸全部被平仓了结为止。更糟糕的是，他们这种被迫卖出斩仓的行为，自我反馈、恶性循环。价格被压迫得越低，则有更多的处于边际的多头合约持有者加入被迫卖出平仓的行列，于是反回来进一步加剧新的价格下跌。这种现象有一个最为触目惊心的实例，发生在1980年年底。商品市场在登峰造极之后，经历了为时5年的下滑历程。好几个市场一路进入了创历史纪录的高额持仓兴趣的状态中，而这个窘境又在接踵而来的价格崩溃中助纣为虐。我们把这 里所阐述的第 2 点推论如下:在牛市中，不同寻常的高额持仓兴趣是个危险信号（见图 7.12）。 3.如果在市场横向延伸的调整期间，或者处于水平交易区间之中时，持仓兴趣逐渐积累增加，那么一旦发生向上或向下的价格突破，随后而来的价格运动将会加剧。这完全是顺理成章的事情。当市场处于犹豫不决的状态时，没人能够确切地知道新趋势即将向哪个方向突破。但是，持仓兴趣的增加表明，许多交易商已预期突破的降临，并相应地建立了头寸。一旦突破果然发生，那么许多交易商（其中的一半）将陷于市场对自己不利的一边（请回头考察图7.5，图中白银市场的向下突破展示了这种现象）。 我们假设市场上出了一个为期三个月的横向交易区间，与此同时，持仓兴趣快步上升了l0000张合约。这个数字意味着，在这个时期内，市场上新增开了10000个多头头寸和10000个空头头寸。现在价格向上突破，开创了三个月来的新的最高价。因为此时价格处在三个月来的最高点，原先在这段时间里开立的每一个空头头寸（所有的10000个）均处于亏损状态中了。于是，那些蒙受损失的空头持有者，争相买进平仓，市场上一片混乱。如此一来，自然进一步加强了价格上涨的推动力，反过来，甚至造成了更大的恐慌。一直到所有的10000个空头头寸或其中绝大部分均已买进平仓之后，这股力量才会平息，而在此期间，价格将保持坚挺。如果当初的突破方向向下，那么就该多头持有者手忙脚乱地争相卖出平仓了，而空头持有者就会开开心心地坐收渔利了。 每当突破发生、新趋势初露端倪的时候，市场通常都处在巨大的恐慌之中，而这种局面正是那些陷足于市场的错误一边的交易商急于平仓了结其损失头寸的慌乱行为所造成的。陷足于错误一边的交易商越多（这一点通过高额的持仓兴趣可以体现出来）。那么他们对突如其来的不利的市场运动的反应就越激烈。说起来，也真是几家欢乐几家愁。那些选择了市场正确一边的交易商（心机明敏的人或走运的人）为新趋势推波助澜，因为事实证明他们的判断是正确的，他们现在可以利用其累积的帐面盈利为资本增开新的头寸了（这里有一点，值得我们冷静地思索一下。 只要持仓兴趣每增加一张合约，则必定有人犯了一个错误）。由上述讨论可见，在一个交易区间中（实际上对于任何市场状况都是同样的道理），持仓兴趣增加得越多，那么在突破发生后，价格运动的潜力就越大。 图 7.12 这是一个经典的例于，表明如果价格开始下跌，那么事前的非常高昂的持仓兴趣可以构成下跌的动力。在两周内，价格下跌了$2.00。自从8月底以来建立的所有的多头头寸均沦为亏损头寸。在这些亏损头寸平仓了结之前，价格将维持下降趋势。注意持仓兴趣随后的急剧下降 4.在价格形态完成时，持仓兴趣的增加可视为新趋势信号可靠程度的旁证。举例来说，在头肩底形态中，当颈线被向上突破时，如果在交易量增长的同时，持仓兴趣也相应增加，那么该底部形态就更为可靠。不过，在这里分析者必须留神。因为当新趋势产生的初始信号出现之后，随之而来的跟风性市场动力往往来自失陷于市场错误一边的交易商的斩仓行为，所以，在有的情况下，当新趋势初生时，持仓兴趣可能稍有减少。在这种情况下，持仓兴趣这种初始性的稍减，有可能使那些不谨慎的朋友误入歧途。因此，从这种现象可以看出，我们不应该对持仓兴趣在 极短时期内的变化过分拘泥。 交易量和持仓兴趣规则举要 以下我们归纳一下关于价格、交易量以及持仓兴趣的几个较为重要的方面。 1.只能以交易量和持仓兴趣的总额作为预测依据。 2.对持仓兴趣必须做季度性修正。3.如果交易量和持仓兴趣增长，就意味着当前价格趋势可能持续发展。4.如果交易量和持仓兴趣萎缩，就表明当前价格趋势或许要生变。5.交易量超前于价格。从交易量的变化可以判断买方或卖方力量的消长，因而它领先于实际价格的变化。6.OBV 法或者其它类似的方法，可以更为明了地揭示交易量压力的方向。7.在上升趋势中，如果持仓兴趣突然停止增长，甚至开始下降，那么经常是趋势生变的警讯。8.如果在市场顶部，持仓兴趣不同寻常地高昂，那就非常危险，因为这种情况大大增加了市场向下的压力。9.在调整期间，如果持仓兴趣积累地增长，那么就强化了市场随后的突破。10.交易量和持仓兴趣的增长有助于验证价格形态的确定，也有助于验证其它各种预示新趋势即将发生的重要图表信号。 胀爆和抛售高潮 关于交易量和持仓兴趣，还剩下最后一种典型情况值得说一说，这是两种经常发生在市场顶部或底部的剧烈变化—所谓胀爆和抛售高潮。胀爆出现在市场顶部，抛售高潮则在市场的底部。在市场顶部发生胀爆的具体情况是，价格经过长期上涨后，突然急剧上冲，与之同时，交易量也大为增加，持仓兴趣却显著地下降。在抛售高潮中，价 格则在长期下跌的基础上，突然急剧地坠落，与之同时，交易量大大加重，而持仓兴趣则大幅下降（见图 7.13）。 图7.13 胀爆现象的例子。注意在上升趋势的最后阶段的重大交易量。更具意义的是，在价格到 顶之前一周，持仓兴趣已经急剧地下降了。在价格上涨后，如果持仓兴趣降低，则构成看跌信号。 在两种情况下，我们都必须密切注意两点，一是交易量的陡然膨胀，一是持仓兴趣的急剧萎缩。在价格向上或向下过分伸展的情况下，如果两个因素一齐出现，就表明当时在市场上正发生着大规模的平仓活动，从而警告我们风雨即将来临，趋势很可能就要突然变化了。 交易商分类报告 为了完成关于持仓兴趣的讨论，我们还得介绍一下交易商分类报告，以及如何利用它作为我们的技术分析工具。 该报告由商品期货委员会（CFTC）在每月的第11个工作日公布，其中的数据是截止到上月底的持仓兴趣的统计资料。在这份月报里，把持仓兴趣的数字划分成三类来源—大户保值商、大户投机商和散户。只要期货商的交易规模达到了各个市场的规定水平，就必须向CFTC报告。CFTC把这些来自大户交易商的报告编排归总之后，就形成了交易商分类报告中关于大户保值商和大户投机商的统计数字。然后，CFTC 再从总的持仓兴趣中减去上述两项，余额便算作散户的持仓量。 上述分类的几种数字当然自有用场。我们的理论依据是，一般认为，大户属于“投注能手”。而我们通常所说的小户，信息较不灵通，而且从交易技术上说也较不机敏。同时，如果小户成熟起来后，也就不再成其为小户，而是跨入到大户的行列了。另一方面，如果大户败落了，也就不再成其为大户，而是很快地退居小户的地位。 这种类型的分析在股市技术师中间早就盛行。他们认为，股票买卖专家对市场方向的判断通常是正确的，因此他们密切关注这些专家的一举一动。相反地，他们认为散户（即大众投资者）对市场方向的判别，在绝大部分时候是错误的，所以常常轻蔑地称散户为“小鬼头”。 从一些期货市场的研究结果来看，在上述三类交易商中，大户保值商在预期市场转折点这一方面最为成功，其 次数大户投机商，小户屈陪末座（见图 7.14）。 我们如何恰当地利用这些统计数字呢?说白了，就是要加盟“投注能手”的一边，而避免陷入其余不太如意的行列。图7.14是一份交易商分类报告的实例，引自CRB期货图表服务，其中每类都分成四个小栏目—多头百分比、空头百分比、持仓兴趣净值、△。△表示同上一个月相比较的持仓兴趣净值的增减额。例如在本表中，1984年12月31日在活牛市场上，大户保值商中有14%为多头，43%为空头。第三栏的“-29”的意思是净空头比教为29%（43%-14%）。在第四栏中，“-2”表示活牛市场的大户保值商当月的净空头数比上月净空头数增加了 2%。 在表格底部的备注中，解释了表中数据的理解方法。请注意，其中有条说明，表中相应的百分数之和并不总为100%。这是因为本表并未包括市场之间交叉套利交易的统计资料。如果我们把活牛这一行的所有三类多头百分比的数字加起来—14%属于大户保值商。19%属于大户投机商，62%属于小户—我们只得到 95%的总数。市场之间 交叉套利的交易就占据了剩下的 5%。 备注:表中△表示与上月比较持仓兴趣净值的百分比变化值（正号表示多头的增加， 或空头的减少；负号表示空头的增加，或多头的减少；O 表示原数值小于 0.5%）。 注意，表中头寸总和并不等于 100%，因为其中没有包括市场之间的统计数字。 图 7.14 交易商分类报告。 季节性修正 在进一步研究图 7.14 中的数据之前，我们必须首先考虑它们的一个重要特征:季节性变化。表中每个群体都表现出特定的季节性倾向。只有超出这种季节特征的变化才揭示了交易商对市场的态度。在1985年的《商品年鉴》中，发表了一篇文章（威廉·L·吉勒，商品研究局，1985 年），其中对这家机构利用这些统计数字的方式作了介绍， 也讨论了他自己在该领域的一些独到的研究成果。 当前净持仓兴趣同季节性的净持仓兴趣的正常值之差，在某种程度上，为市场的牛气或熊气的程度提了直观的百分比度量（分析 CFTC 的交易商分类报告有助于预测期货价格，吉勒，第 521 页）。 随后，文章交代了一些普遍的要领最牛气的市场格局是:大户保值商的净持仓兴趣为多头，且其数量大大地超出了季节性正常值；大户投机商明显地持有净多头头寸；而小户的净头寸为空头，且其数量也大大地超过季节性正常值。这种情况代表了一个极端。 另一个极端则是市场最熊气的格局，情况与上面正好相反—大户保值商净持仓兴趣为空头，且数额庞大，等等。 朋友们务请注意净持仓兴趣偏离长期平均值达 40%以上的情形，同时也要忽略偏离程度小于 5%的情形。 CRB（商品研究局）的这项研究表明，两种大户的成绩记录均属上乘，但大户保值商的成绩优于大户投机商。 在三者之中小户的表现最差。 图 7.15 是几张样图，显示了 CRB 研究出的上述三类交易商的季节性倾向（引自前述同一文章）。这里的诀窍是，我们应当比较表中的实际数值同图中的所谓季节性正常值之间的差异。下面我们还是以图 7.14 那份报告为例，从 中得出一些结论。图7.15 本图是三种交易商的季节性交易习惯的例子。当我们已知每 类交易商对市场的态度时，应当考虑到上述季节性倾向。这一点很重要 请看有关豆粕的统计数字。在1985年1月18日的《CRB期货图表服务》的技术性评论部分，本作者曾指出，“交易商分类报告揭示了该市场一个异乎寻常的看好的态势”。为什么这么说呢?报告中说，大户保值商为净多头，其百分比为21%，比上一个月增加了 15%。小户则为净空头，百分比为 16%，比前一个月增加了 17%。因此，大 户保值商是看好者，并且日益牛气，小户是看淡者，并且日益熊气。 现在再来看豆粕的CRB季节性图表。到12月底，大户保值商的正常情况是8%的净空头，而小户则大约为6%的净多头。这就意味着，有关的差额甚至比当前的实际数值更加倾向于看涨这一边。大户以29%的比例比正常情况更为牛气（从一8%到+21%），同时小户以 22%的比例比正常情况更为熊气（从+6%到-16%）。表面看来，大户为 看好者，小户为着淡者，这已经是牛气性质的了。而实际上经过季节性修正后，从有关数据来看，形势还更加牛气。 要是我们随意看看其余一些数字，还有几点也便呼之欲出了。我们来扫一眼三个类别的最后一列，找一找其中 的较大变化。请注意在大户保值者名下那些较大的正数变化:原油为+23%，橙汁为+14%，英镑为+21%，瑞士法朗呈现日渐增强的正面态度。或许这种情况对这些市场来说，倒是看跌的信号。小户对橙汁以及外币表现出较强的负面态度（-10%），也可能形成了这些市场看好的信号。 我们还有一个运用这些数字的方法，即在小户名下的多头一栏或空头一栏中，搜求不同寻常的大幅变化（70%以上为“大幅”）。因为小户这一群体通常被认为是错误的，那么他们在某市场对哪个方向的强烈倾向就是个警告信号，表明市场将向相反的方向变化（这正是前面那个“理论基础”之所以成立的原因了）。 在这份报告中，在小户名下的多头一栏中，有大幅变化（潜在的看跌信号）的是活牛（62%）和木材（63%）。 也可以在 NYSE 综合指数（62%）和价值线股价指数（77%）中看到这种情况。不过从股价指数近来的动作来看，小户的判断似乎得到了验证。所以，我们必须说明，本领域的绝大部分研究是针对传统的农产品市场进行的。朋友们务请注意，不要在历史较短的金融期货市场上，过分倚重交易商分类报告，我们不妨拭目等待对这个方面的更多 的研究。 我们也可以对交易商分类报告进行逐月的分析，以从各项持仓兴趣资料中揭示三类交易者的所作所为。不过， 本方法有一个重要缺陷。可供分析的有关统计资料至少都是两周以前的情况，可能因为这一延迟而丧失部分价值。 在期货市场上，上面介绍的这种技术分析手段并没有受到足够重视。它在股票市场上倒是大行其道，但在期货分析者中却“曲高和寡”。无论如何，这正是一个颇具潜力的领域。由于我们能够利用它来检测市场情绪，因此，我们必须对它引起重视，并进一步加以研究利用（在第十章讨论相反意见理论的时候，我们将进一步探讨市场情绪）。 在任何情况下，交易商分类报告都是重要的技术分析领域，分析者至少必须对之有所了解，并且时常关心关心。有一本书，《商品市场价格行为的图表分析》（第二版，L·迪伊·贝尔维尔，道·琼斯一欧文出版公司，1985年），花了很大的力气来讨论“持仓兴趣”这个题目。 结论现在，我们就完成了对交易量和持仓兴趣的研究。从本书开头到这里为止，我们已经讲完了商品期货市场的技术分析理论的一个重要的组成部分，我们交代了技术分析的理论基础，讨论了技术分析的基本砖石，介绍了图表的构造方法，研究了价格形态，也阐明了技术分析者的三条信息渠道—价格、交易量和持仓兴趣。 但是，我们的研究还仅仅局限于日线图。下一步，我们就该拓展时间视野，把前面这些富有价值的分析手段应用到长期性质的周线图和月线图中，来进行长期趋势分析，与此同时，也要补充一些关于较广泛的商品价格指数和各种市场群类指数的研究。这些便是下一章的任务。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第六章 持续形态]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E5%85%AD%E7%AB%A0-%E6%8C%81%E7%BB%AD%E5%BD%A2%E6%80%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 引言本章探讨的图表形态属于持续型形态。这类形态通常表示，图表上的横向价格伸展仅仅是当前趋势的暂时休止， 下一步的市场运动将与事前趋势的原方向一致。前一章的那些形态通常表明趋势的反转正在形成，因此与这里介绍的对象截然不同。 反转形态与持续形态的另一个差别是它们的持续时间不同。反转形态的发展过程通常花费更长的时间，并且它也构成了主要的趋势变化。相反，持续形态通常为时较短暂，在更多的情况下，明显属于短暂形态或中等形态的类别。 请注意，我们连续使用了“通常”这个限定语。在所有的图表形态中，我们都不得不面对着一定的普遍倾向性，而没有严格的规则可循。总有例外，甚至有时我们对价格形态所作的分类也是模棱两可的。三角形通常属于持续形态，但有时也会作为反转形态出现;虽然三角形通常被看成中等形态，它们偶尔也可能出现在长线图表上，具有主要趋势的意义。三角形的一种变体—反转三角形—通常标志着市场的主要顶部。甚至连头肩形这种最著名的主要反转形态，偶尔也会以调整形态的面目出现。 即使图表形态因为存在一定程度的含混以及偶尔的例外而打了折扣，一般也仍然可以把它们归结为上述两种类 型。并且，只要图表分析者解释得当，就可以由其确定它们之后的大部分时间内可能出现的市场行为。 三角形我们首先研究三角形。三角形可分为三类—对称三角形、上升三角形和下降三角形（有些图表分析者还把所谓扩展三角形或者喇叭形归结为三角形的第四种类型，我们以后将单独处理这种形态）。每种三角形均具备稍有差别的形状，具有不同的预测意义。 图6.1a到c是各种三角形的图例。对称三角形（见图6.1a）具有两条逐渐聚拢的趋势线，上面的直线下倾，下面的直线上升。左侧的垂直虚线，表示了形态的高度，称为底边，两条直线在右侧相交，交点称为顶点。对称三角形也被称为“绕线筒”，显然这是针对其外形而称的。 上升三角形的下边线上倾，上边线水平（见图6.1b）。下降三角形（图6.1c）与之相反，上边线下降，下边线水平。以下我们就来分别地进行研究。 图6.1a 看涨对称三角形的例子。注意，其中两根趋势线是相互聚拢的。无论收市价格超出哪一根趋势线，形态均告完成。左侧的竖直线段是它的底边，右侧的两线交点为顶点 图6.1b 上升三角形的例子。注意，其中上侧直线水平，而下侧直线上斜，一般来说，它属于看涨形态。 图6.1c 下降三角形的例子。注意，其中下边线水平，上边线下斜，它一般属于看跌形态。 对称三角形对称三角形（绕线筒）通常属于持续型形态。它表示既有趋势暂时处于休整状态，随后将恢复发展。在6.1a所示的例子中，原先趋势向上，因而最终可能性较大的是，以价格向上突破来了结这场三角形调整。如果原先趋势向下，那么对称三角形具有看跌的意义。 在三角形中，我们要求其中至少有四个转折点。请记住，至少需要两个点才能作出一条趋势线，因此，为了得到两条聚拢的趋势线，市场在每根线上必须至少发生两次转折。在图6.1a中，三角形实际上从点1开始，这也就是上升趋势的调整的开端。接着，价格撤回点2，然后上冲到点3，点3低于点 1。仅当价格从点3再度回落之后，我们方能作出上边趋势线。 注意，点4高过点2。仅当价格从点4向上反弹之后，我们才能作出上倾的下边线。正是在这一刻，分析者开始 揣测，手头这个形态可能属于对称三角形。现在，我们得到了四个转折点（1，2，3，4），以及两条聚拢的趋势线。 虽然三角形的最低要求是四个转折点，但是实际上，大部分三角形通常具有6个转折点，如图6.1a所示。这就是说在三角形内，其实包含了三个峰和三个谷，总共形成5个波浪（在我们讲到艾略特波浪理论时，还要进一步讨论三角形的五浪倾向）。 三角形完结的时间极限 三角形形态的完结，具有时间极限，这就是两边线的交点—顶点。一般地，价格应该在三角形横向宽度的一半到四分之三之间的某个位置上，顺着原趋势方向突围而出。该宽度就是从左侧竖直的底边到右侧顶点的距离。因为两条聚拢的边线必定相交，所以，只要画出了两条边线，我们就可以测得上述距离。向上突破的信号是市场对上边趋势线的穿越。如果价格始终局限于三角形内，并超出了上述四分之三的范围，那么，这个三角形就开始丧失其潜力，这通常意味着价格将持久地漂泊下去，直到顶点以外。 于是，三角形构成了价格与时间的一种有趣的结合。一方面，聚拢的趋势线界定了形态的价格边界，我们可以根据价格对上边趋势线的穿越（在上升趋势情况下），判断何时该形态完成、原趋势恢复。另一方面，两条趋势线通过其形态宽度，也提供了时间目标。举例来说，如果其宽度为 20 个星期，那么突破就应发生在第 10 周到第 1 5 周之 间的某个时刻。 实际的趋势性信号，是以收市价格穿越某条趋势线为标志的。有时候，价格突破后也会向这条趋势线反扑一下。在上升趋势中，上边的趋势线被突破后演化为支撑线。而在下降趋势中，下边线被突破后变成阻挡线。在突破后，顶点也构成重要的支撑或阻挡水平。类似于前两章的有关内容，我们也可以应用各种穿越原则来鉴别此处的突破。 最低穿越原则是市场以收市价越过两条趋势线之一，而不能仅仅是一个日内穿越。 偶然的伪信号 出于某些奇怪的原因，有时在看涨三角形中，恰恰在上升趋势恢复之前，会闪现出看跌信号。这种信号通常发生在三角形的第五个阶段（即最后阶段）。它们经常在三角形内接近顶点的地方出现，表明其中的横向趋势向右侧延伸得过远了。其特点是，在两三日内，价格先以重大交易量向下突破，随后又同样急剧地向上回弹，并恢复上升趋 势。 交易量的重要性 在三角形内，价格的摆动幅度越来越小，交易量也应相应地日趋萎缩。这种交易量的收缩倾向，在所有的调整 性形态中都普遍存在。但当趋势线被穿越从而形态完成时，交易量应该明显地增加。在随后的反扑中，交易量轻弱。 然后，当趋势恢复时，交易活动更为活跃。 关于交易量，我们还需要说明两点。同反转形态的情况一样，交易量在向上突破时比向下突破时，更具重要意义。在所有调整形态中，当上升趋势恢复时，交易量的相应增加都是至关紧要的。而在向下突破时，交易量虽然也重要，但在头几天内并不如此关键。事实上，当价格向下突破时，如果交易量大大地跳升，特别是在接近三角形顶 点的情况下，反而是可能出现虚假看跌信号的警兆，前面曾谈到过这个现象。 关于交易量要说明的第二点是，虽然交易活动在形态形成过程中逐渐减弱，但如果我们仔细地考察交易量的变化，通常仍可获得较重的交易量到底是发生在上升运动中还是下降运动中的线索。举例来说，上升趋势应当有个微弱的倾向，当价格上弹时交易量较重，而在价格下跌时交易量较轻。 测算技术 对三角形，我们也有测算技术。在对称三角形的情况下，一般可以采用几种方法。最简单的是，先测出三角形最宽的部分（底边）的竖直线段的高度，然后从突破点或顶点起，顺势测出相等的距离。图6.2a展示了从突破点向相应方向投射等距离的情形，我偏向于这种方法。 第二种方法是，从底边的端点（点 A 处）出发，作出平行于下边趋势线的平行线。这条管道线就是上升趋势上方的价格目标。因为市场还有一种倾向，新的上升过程同以前的上升过程（三角形形成前），具有大体上差不多的坡度或倾角，所以，价格触及上方管道线的地方既是价格目标，也是大致的时间目标。 图6.2a 对称三角形的价格目标有两种测算法。其一，先量出底边（AB）的高度，然后从突破点c起或从顶点 起，投射出与这个高度相等的垂直距离。其二，从底边的上端点（A）引出一条平行于三角形下边线的平行线。 上升三角形 上升三角形和下降三角形都是对称三角形的变体，但是它们分别具有不同的预测意义。图6.3a和b是上升三角形的例子。请注意，其中上边趋势线持平，而下边线则上升。本形态显示，买方比卖方更为积极主动。它属于看涨形态，通常以向上的突破作为完结的标志。 上升三角形和下降三角形均与对称三角形有着很重要的区别。上升三角形或下降三角形无论出现在趋势结构中的哪个部分，都具有明确的预测意义。上升三角形看涨，下降三角形看跌。另一方面，对称三角形在本质上属于中性形态。不过，这并不是说对称三角形不具备预测价值，相反，因为对称三角形是持续形态，所以，分析者只要找 出原有趋势的方向，然后假设该既有趋势即将恢复就够了。 有些人宣称，因为对称三角形没有先天性的偏向，所以，其本身不具预测价值。这种说法是错误的，因为本类 三角形的结果通常是原先趋势的继续。很清楚，对称三角形确实具有预测价值。 现在我们回到上升三角形上。如前所述，上升三角形经常是看涨的。其看涨的突破，以收市价格决定性地超出上边水平趋势线为标志。正如所有各种有效向上突破那样，此时交易量应当显著地增加。随后市场对被突破趋势线（水平的上边线）的反扑也不罕见，但它应在较轻的交易量下发生。 图6.2b 在 CRB 期货价格指数（下方的曲线）上，从7月底到11月底，形成了一个看跌的对称三角形。 如果我们测出其底边的高度，从突破点起把它投射下去，那么向下的目标为242。目前这个目标已经实现了 图6.2c 对称三角形充当反转形态的一例。1983 年 10 月其下边线被突破，构成主要看跌信号 注意，在最右侧介于 7.00 和 8.00 之间，另有一个小的对称三角形，它属于看跌的持续形态，测算技术 上升三角形的测算技术相对简单。先量出该形态最宽处的高度，然后从突破点起，简单地向上投射出相等距离 就行了。这也是利用价格形态的波动性来确定其价格目标的一例。 图6.3a 上升三角形。当收市价格决定性地超出上边线后，本形态就完结了。突破发生时，交易量应有急剧的增加。突破后，这条上边线（阻挡线）将在之后的下跌中起到支撑作用。其最小价格目标的算法是，先测出三角形的高度（AB），然后从突破点C起，向上投射出相等的竖直距离。 图6.3b 在 8 月里，横向延伸的巩固阶段是以上升三角形的形式出现的。注意，其上边线水平，下边线上斜。还要注意在7月里的向下倾斜的旗形。在 2 月到5月的下降趋势中，请注意其中有很多上倾的旗形 图6.3c 在本图中，英镑市场在4月到6月的巩固阶段是个上升三角形的精采实例。这种形态通常属于看涨形态。注意，在本例中，下侧的上升边线同时也是自底部引出的主要上升趋势线。而上侧的水平边线则是一个主要头肩形的颈线。还请注意，图中自 11 月到次年 2 月的管道界定分明。 图 6.3d 本图是上例中英镑日线图的局部放大。注意，其中有三个向上的跳空。也请注意低点处的关键反转日，它属于“抛售高潮”和V形反转底的类型。注意图中左侧的趋势线如何在突破后成了支撑线。在4月，上升趋势无力抵达上方的管道线，发出了向下调整的警讯。 图 6.3e 本图继续研究前二例中的英镑合约，在这里，上升三角形更容易辨认。上方的目标测算已 经完成，它就是从向上突破点起向上投射三角形的高度得来的。图下的数字列举了各种回撤的参数。 按收市价计算，4月的向下调整，回撤到了先前上涨的 47.4%的位置。而从日内价格来看，几乎恰 好为 50%。本图和前面两个例子说明，在同一个分析中，我们可以揉合各种技术形态和技术工具。 充当底部形态的上升三角形 上升三角形最经常地出现在上升趋势中，属于持续性形态。不过，它有时也会以底部形态的面目出现。在下降趋势处于强弩之末的阶段时，出现上升三角形也是不足为怪的。但即使是在这种情况下，该形态的含义也仍然是看涨的。上边线的突破标志着底部形态的完成，构成了牛市信号。上升三角形和下降三角形有时均被称为直角三角形。 下降三角形 下降三角形仅仅是上升三角形的镜像，一般认为，它属于看跌形态。注意，在图6.4a和b中，上边线下降， 下边线水平。这种形态说明，卖方比买方更为积极主动。它通常是以向下突破而告完结的。向下的突破信号以收市价格决定性地低于下边趋势线为标志，并且在通常情况下，交易量应有所增加。有时市场随后也会发生反扑现象，不过在下边趋势线下应遭到阻挡。 其测算技术与上升三角形完全相同—分析者先在左侧底边测得形态的高度，然后从突破点起，向下投射出相 同的距离。 充当顶部形态的下降三角形 尽管下降三角形属于持续形态，通常发生在下降趋势中，但偶尔也能在市场顶部发现其踪迹。当这种形态确然发生在顶部过程时，要辨别它并不困难。在这种情况下，如果收市价低于水平的下边线，可能就标志着向下的主要趋势反转。 交易量形态 在上升三角形和下降三角形中，它们的交易量形态很相似。随着形态的逐步发展，交易量也相应地萎缩，然后在突破时又大为增加。同对称三角形的情况一样，在其形成过程中，图表分析者可以细究交易量形态配合价格摆动所呈现出的蛛丝马迹。这就是说，在上升形态中交易量倾向于在价格上弹时稍重，而在价格下落时稍轻。在下降形 态中，交易量应该在价格向下时较重而在向上反弹时较轻。 三角形的时间因素 关于三角形，我们最后要考虑的是它们的时间尺度。一般认为，三角形属于中等形态，即它的形成过程通常花费1个月以上的时间，但一般少于3个月。持续时间短于1个月的三角形可能属于另外的形态类别，例如三角旗形，后面我们很快就讲到了。早些时候我们曾说过，三角形有时也会出现在长期的价格图表上，但是就其自然本性来说， 它还是日线图的专利。 图6.4a 下降三角形。当收市价格决定性地跌过下侧水平线后，本 看跌形态完成。其测算技术是，自点 C 起向下投射三角形高度（AB）。 图 6.4b 看跌下降三角形的实例。请注意，在这里，虽然三角形内的最后一个峰向上突破了上边线，但是无力超越9月里的高点所形成的阻挡。向下的价格目标已经实现了。在$6.00附近，存在着某种“心理上的”支撑。注意，自11月以来的下降趋势线何其漂亮地阻扼了各次上弹。 扩大形态（喇叭形） 下面这种形态，是三角形的不同寻常的变体，相对较少见。它其实是反向的三角形。以前所探讨的三角形的两 条边线都是相互聚拢的。喇叭形与此正相反，可谓名符其实。如图 6.5a 所示，在扩大形态中，两条边线逐渐分离， 呈现出扩大三角形的轮廓。本形态的交易量形态也与众不同。在其余三角形中，随着价格的摆动幅度逐步缩小，交易量也倾向于相应地收缩。但是在扩大形态中，情况恰恰相反。交易量随着价格摆幅的日益放大，而相应地扩张。这种情况显示市场已失去控制，变得极为情绪化。因为本形态代表了公众参与交易活动非常积极的情形（这是不同寻常的），所以最常发生 在市场的主要顶部过程中。因此，喇叭形通常是看跌形态，图6.5a 扩大形顶。这类扩大形形态通常发生在主要顶部过程中。其中显示出三个依次上升的峰，以及两个依次降低的谷。当第二个谷被向下穿越后，形态完结。在这种形态中，通常难于交易，不过，相对来说它们还是较少见的。 图 6.5b 扩大形顶的实例。这是一种相对少见的反转形态，通常出现在主要顶部过程中。 喇叭形顶如何形成 图 6.5a 例示了该形态最常见的外形。图中出现了三个依次增高的峰（点l、3、和5）以及两个依次降低的谷（点2、4）。显然，在这种形态下进行交易是极为困难的，因为在其形成过程中出现了许多错误信号。在前面关于顺应趋势理论中，我们曾讲过，当前一个高点被向上穿越时，通常意味着上升趋势的恢复，而价格向下突破前—个低点，一般表明下降趋势的开始或者恢复，但是这个形态却与上述理论背道而驰。在这里，如果交易者机械地根据向上或向下的突破信号采取行动，则必将受挫于一系列错误信号。 形态的完成 当来自第三峰的回落突破了第二谷（见点6）之后，本形态就完成了，并且构成了主要看跌信号。如同检验所有的重要突破一样，为了减少错误信号，这里我们也可采用借助各种过滤器。因为本形态具有三峰、两谷，有时又被称为五点反转形态。请注意，这里再度出现了 5 这个数字，在前面关于对称三角形的讨论中，我们也曾提到过它。 在本形态完成顶部过程、发出看跌信号后，价格反扑是很正常的，其回撤幅度可能达到前一段下跌的50%，然后，初生的再恢复下跌。尽管第三峰通常高于前二峰，但它偶尔甚至也会达不到第二峰的高度。在这种情况下，分析者据之可以得出市场上冲失败的及早警示。而且该形态实际上已经开始同具有下倾颈线的头肩形顶相像起来。 扩大形态小结 首先，扩大形态是相对少见的。不过一旦它出现了，通常便是市场的重要顶部。它的形状如同扩大的三角形，有三个依次上升的峰，二个相继下降的谷。在价格摆动幅度逐步增大的同时，伴随着交易活动的逐步增长。在第三峰完成后，如果价格跌破第二谷，就标志着该形态的完结。 钻石形态 钻石形态通常出现在市场顶部，是另一种相对罕见的形态。本形态的特别之处在于，它其实是由两种不同类型的三角形—扩大三角形和对称三角形组合而成的。请看图6.6a，该钻石形的前一半类似一个扩大三角形，后一半是对称三角形。这种价格变化所对应的交易量形态是，在形态前一半，交易量扩张;在后一半，交易量随着价格摆 幅的日益缩小而逐渐减轻。 在这种形态中，先是两根边线逐渐分离，然后两条边线再逐渐聚拢，围成了与钻石相像的图表形状，图表形态由此得名。本形态相对少见，一般出现在市场的顶部。它经常地充当反转形态，而较少作为持续形态露面。在钻石形的后半部分，当下边的上升趋势线被向下突破后，形态完成。一般在其向下突破时，会配合着交易活动的增加。 如何测算钻石形 钻石形的测算技术与前面三角形形态类似。我们先测出该形态最宽部分的竖直距离，然后，从突破点起向下投 射相同距离。有时候也会出现反扑现象，市场回到下方的阻挡线附近，但新趋势应从这里恢复。 图 6.6a 钻石形的例子。它通常构成顶部反转形态。它的前半部分类似于扩大形，后半部分类似于对称三角形。当下侧的上倾趋势线被向下突破后，本形态完成。其测算方法是，从其最宽处量出该形态的高度，然后从突破点起，向下投射出相等的距离。 图6.6b 钻石形顶的实例。注意，其左侧为扩大形，右侧为对称三角形。当右侧的上倾直线被跌破后，标志 着趋势的反转。其价格目标的算法是，先测出钻石形的垂直宽度，然后从突破点出发向下投射出相等的距离。图 6.6c 钻石形充当看跌持续形态的实例。 结语以上对钻石形的讨论，结束了我们对三角形这个课题的研究。在图表形态分析中，三角形通常指对称三角形、 上升三角形和下降三角形三者。扩大三角形和钻石形代表了三角形的奇特的变体。下面我们继续讨论其余一些常用 的持续形态。 旗形和三角旗形 扩大形态和钻石形相对较少见，而旗形和三角旗形在期货市场却相当普遍。因为它们在外形上非常相似，往往 出现在趋势结构中的相同位置上，并具备相同的交易量和测算原则，所以，我们通常把它们放在一起研究。 旗形和三角旗形表示市场充满活力，但暂时处于休止状态。事实上，剧烈的、几乎是直线式的市场运动，是旗形和三角旗形出现的先决条件。这两种形态说明，市场的陡峭上升或下跌过于“超前”了，因而需要稍作休整，“喘息一会儿”，然后再顺着原方向飞奔而去。 旗形和三角旗形是两种最可靠的持续形态，仅在极少数情况下引发市场的反转。图6.7a和b显示了两者的图 例。首先，请注意在形态出现前的陡峭的价格上升及其重大的伴随交易量。还请注意在该调整形成过程中交易量的 急剧萎缩，以及在向上突破时交易活动的突然迸发。 图6.7a 看涨旗形的例子。旗形通常发生在市场急剧运动之后，代表着趋势 的短暂休止。它应当倾斜向趋势的相反方向。在其形成过程中，交易量应当日 益萎缩，然后，当突破发生时，再度扩张。旗形通常出现在市场运动的中途。 图 6.7b 看涨的三角旗形。它就象一个小的对称三角形，但通常其持续时间不超过三 周。在其形成过程中，交易量应渐轻。在三角旗形完结后，市场应当重复之前的运动 图6.7c 旗形和三角旗形是剧烈的市场运动的特征。两者都代表着趋势的暂时中断。注意，在本图的欧洲美元的上涨过程中，有很多旗形和三角旗形 图6.7d 图中左起的第一个形态，既可以算作对称三角形，也可以属于三角旗形的类型。 第二个构造的轮廓类似于上升的旗形。在下降趋势中，它们的持续时间很少有能过数星期。 旗形和三角旗形的结构 这两种形态的结构稍有不同。旗形与平行四边形或矩形相像，是由两条向流行趋势相反方向倾斜的、相互平行的趋势线围成的。在下降趋势中，旗形或许具有稍稍向上的倾角。 三角旗形以两条相互聚拢的趋势线为特征，从总体上说，更呈现出水平向发展的特点，极像小的对称三角形。 在两种形态中，还有一个重要的先决条件。随着两个形态的逐渐形成，交易量应该显著地枯竭。相对而言，两个形态都是短期的，应当在1到3个星期内完成。三角旗形和旗形在下降趋势中延续时间往往较短，经常不超过一到两周。在上升趋势中，两种形态的完成均以对上边趋势线的突破为标志。而在下降趋势中，下 边趋势线的突破意味着下降趋势的恢复。对上述趋势线的突破应当发生在较重大的交易量背景下。通常，向上突破时的交易量因素比向下突破时，起着更为关键的验证作用。 测算技术 两个形态的测算意义是一致的。旗形和三角旗形被比喻成旗帜在旗杆中点作“降半旗状”。旗杆就是先前的剧烈 上升或下跌的轨迹。而“半旗”的含义是，这类小型持续形态倾向于出现在整个运动的中点。一般地说，在形态完 成之后，即趋势恢复后，市场将重复原先的那一半“旗杆”（或者说形态形成之前的运动）。 更确切地说，我们应当从原始的突破点起计算先前运动的距离。换言之，起算点应为当前趋势萌生时信号发生 的那一点。具体地说，这一点要么是价格穿越重要支撑或阻挡水平的点，要么是市场突破重要趋势线的点。然后， 从旗形或三角旗形的突破点—在上升趋势中，为上边线被突破的点，而在下降趋势中，为下边线被突破的点— 起，顺着当前趋势的方向，量出相等的竖直距离，就得到了价格目标。 小结我们来总结一下两种形态的要点。 1.在两者之前，市场上几乎都是直线式的价格运动（称作旗杆），且其交易量重大。2.然后，价格在非常轻弱的交易量下休整一到三个星期。3.趋势恢复，同时交易活动迸发式地增强。4.两种形态均出现在当前市场运动的中点附近。5.三角旗形同小型的水平向对称三角形相像。6.旗形像小的平行四边形，其倾斜方向与流行趋势相反。7.在下降趋势中，两种形态持续时间都较短。 8.在期货市场，两者都非常普遍。 楔形 就外形和持续时间两方面看，楔形与对称三角形相似。象对称三角形那样，该形态也以两条相互聚拢的趋势线 为特征，其交点称为顶点。从时间角度看，楔形通常持续一个月以上，但不超过三个月，从而属于中等形态的范畴。 楔形的与众不回之处在其明显的倾角上。楔形具有鲜明的倾角，方向很明确，要么向上，要么向下。一般地说，楔形如同旗形一样，其倾斜方向与流行趋势相反。于是，下降楔形属于看涨形态，而上升楔形为看跌形态。注意，在图6.8a中是一个看涨楔形，它在两条聚拢的趋势线包围下倾斜向下。而在图 6.8b 所示下降趋势中，两条聚拢的趋势线无疑是倾斜向上的。 充当顶部或底部反转形态的楔形 楔形最经常地出现在既存趋势中间，通常属于持续形态。楔形也可能出现在顶部或底部过程中，标志着趋势的反转。但这种情况比前者少见得多。在上升趋势接近尾声时，图表分析者或许会观察到一个清晰的上升楔形。因为在上升趋势中，持续性楔形应当逆着流行趋势而倾斜向下，所以，这个不寻常的上升楔形就成了一条重要线索，这 是看跌的而不是看涨的。在底部，下降楔形或者是熊市可能终结的警讯。图 6.8a 看涨下倾楔形的例子。楔形形态具有两条相互聚扰的趋势 线，但它们均倾斜向当前趋势的相反方向。下倾楔形通常是看涨的图 6.8b 看跌楔形的例子。看跌楔形的倾斜方向也应与主流趋势相反，冲下。无论楔形出现在市场运动的中间还是尾部，市场分析者总能从以下这条一般经验中得到些启发:上升楔形看跌， 下降楔形看涨。市场在从楔形形态中突围之前，通常至少要朝顶点经历过其全部距离的 2/3，有时甚至直达到顶点后，形态才 告完结（在楔形中，有些时候价格倾向于一直移动到顶点，然后才能突围而出。这是它与对称三角形的另一个区别）。 在楔形形成过程中，交易量应当收缩，而在突破时交易量应增加。楔形在下降趋势中比在上升趋势中持续的时间更 短。图 6.8c 本图为 CRB 能源期货指数，其中有四个不同的形态。从左上侧起，第一个为 上升趋势中的矩形巩固形态。第二个形态发生在 8 月到 9 月，为看跌的上倾楔形。第三 个形态出现在 10 月和 11 月间，是看跌的三角旗形。第四个形态是 12 月前后的上倾旗形图6.8d 本图为2号取暖油的图表，其中在10月到11月的上冲形成了上倾的楔形，这是 个典型的实例。它的两条边线相互聚拢，并倾斜向上。12 月前后的上冲的轮廓象是上倾旗形 矩形 矩形有许多绰号，不过在价格图表上通常是易于辨识的。它也是趋势中的休整阶段，在形态中，价格在两条平行的水平直线之间横向伸展（见图 6.9a 到 c）。 图6.9a 上升趋势中的看涨矩形的例子。本形态也被称为“交易 区间”，其中价格在两条水平趋势线之间波动。也称之为“密集区” 图6.9b 看跌矩形的例子。尽管矩形通常属于持续性形态，但是我 们必须始终提防它演变成反转形态的蛛丝马迹，比如演化成三重底。 图 6.9c 从 7 月到 9 月的横向巩固阶段类似于矩形形态。在此类形态中，价格 在两条水平的趋势线之间横向伸展。在 11 月，又出现了一个更小的交易区间。 有时，我们把矩形称为交易区间或密集区。在道氏理论中，相应的说法为“直线”。不管怎样称谓，它通常只是既存趋势中的调整阶段，最终市场将顺着之前的趋势方向完结它。从预测意义这方面来看，它算是与对称三角形类似，但它的两条趋势线边线都是水平直线，而不是聚拢相交的直线。 当价格决定性地收市于上边界或下边界以外时，矩形形态完成，并且指向现行趋势的方向。不过市场分析者必须始终保持警惕，留意矩形调整会不会演化成反转形态。例如，在图6.9a所示的上升趋势中，请注意，其中三个峰或许可能演化成三重顶反转形态。 交易量形态的重要性 在这种形态中，交易量形态是值得观察的重要线索。因为价格向两个方向的摆动幅度均相当广阔，所以分析者应当密切注意在哪个方向上交易量更重。如果在价格上冲时交易量较重，而下撤时交易量较轻，那么该形态可能是上升趋势中的持续形态。如果较重的交易量发生在向下运动这一边。那么这可以看成趋势可能正在反转的警讯。 可以在局限于一定区间内的价格波动中交易 有些图表师针对局限于这类形态的价格波动，在价格下跌到接近底边的时候买进，在价格上冲到接近上边的时 候卖出。这种方法使短线交易商得以充分利用界定良好的价格边界，从一个无趋势可寻的市场中获利。因为我们把头寸建立在形态的极限位置上，在其上方和下方，市场的趋势状态有明确的区分，所以风险相对较小。只要交易区间完好如初，这种反趋势的交易方法就行之有效。当突破发生时，交易商不仅应当立即了结亏损的头寸，而且应该顺着新趋势的方向建立新的头寸以扭转原来的头寸方向。摆动指数在横向交易区间中特别有用，但是一旦发生突破， 其效用便会下降。我们将在第十章讨论这方面问题。 也有些交易商认为，既然矩形是持续形态，那么在上升趋势中，就应当在价格范围的下边界建立多头头寸，或者在下降趋势中，在接近上边界时建立空头头寸。另外也有人完全避开此类无趋势的市场，直等到清晰的突破信号出现后，才投入资金。第十五章我们将研究在处于这种多变的、不明朗的市场阶段时，自动交易系统遇到的问题。 大多数趋势顺应系统在这种横向伸展的无趋势市场中表现极拙劣。在这儿，朋友们只要对这一点知道个大概就够了。 其它相似性和差异性 就持续时间来说，矩形通常属于 1 到 3 个月的类别，与三角形和楔形类似。但其交易量形态与其它持续形态有 所不同。由于矩形的价格摆动范围广阔，避免了在其余形态中通常可见的交易活动萎缩的现象。 关于矩形，最常用的测算技术是基于价格区间的高度之上的。我们先从顶到底地量出交易区间的高度，然后从 突破点起，顺势投射相等的竖直距离。本方法类似于前面提到的各种竖直测算技术，也是以市场波动性为基础的。 在我们介绍点数图分析中的“数算法”时，还将就水平方向的价格测算方法作进一步的探讨，前面讲过的价格突破时的交易量变化特点，以及反扑动作出现的可能性等内容，此处也同样适用。在矩形中，因为上边界和下边界均是水平的，有最好的界定，所以，支撑和阻挡水平更为清晰易辨。这就意味着，在向上突破 发生后，原先价格区间的上边线将在所有抛售中提供坚实的支撑。而在向下突破发生后，交易区间的底边（原先的 支撑区）现在应该在所有上冲中构成坚实的阻挡。 对等运动 所谓对等运动，有时又称为自测摇动。它所描述的是，主要的市场上升或下降的过程（如图 6.10a 所示），可 以分成距离相等、相互平行的两个部分。只有当市场运动相当有序并且节奏分明的情况下，本方法才有用武之地。 对等运动实际上是我们前面涉猎的某些技术的变体。从一些调整形态中，诸如旗形和三角旗形中，朋友们已经看到， 它们通常出现在整个市场运动的中途。我们也曾经交代，市场具有首先回撤之前趋势的 1/3 到一半、然后才恢复原 有趋势的倾向。 图 6.10a 上升趋势中的对等运动（又称为自测运动）的例子。根据这个理论， 在上最过程中的第二阶段（CD），市场应当从规模和倾斜程度两个方面重复第一阶段（AB）。其中调整性浪（BC）常常回撤到AB的1/3到一半的位置，然后恢复上升趋势。当图表分析者看出市场步调明确的时候（如图 6.10a 所示的情形），对等运动的概念就很有用了。价格从点A上冲到点B，然后从点B逆着趋势摆动到点C（这个调整回撤到了AB浪的三分之一到一半的位置）。根据对等运动理论。我们认为，当前市场正处在该上升趋势的下一阶段（CD）中，而它应当差不多是第一阶段（AB）的翻版。于 是，我们根据 AB 浪的高度，从调整阶段的底点 C 起，向上测量出相等的距离。另外，所谓翻版，同时包括了两方 面的内容:下一阶段的规模及其倾斜程度。因此，市场在这种场合，具有一种强烈倾向，即第二个主要的上升运动不仅将经历与第一个运动的相同距离，而且从角度上说，平行于或相当于第一个运动。在结束本节前，我们还要指出，在对等运动的理论中，还有其它更为复杂的测算技术，我们将在后面的部分一一介绍。 图 6.10b 下降趋势中的对等运动（自测运动）的实例。注意，其中第二个下跌阶段（CD）恰好具备第一下跌段 （AB）的长度和倾斜程度。在两个下跌运动之间的上冲阶段（BC）中，市场回撤到了第一个下跌阶段的一半处。 持续型头肩形形态 在前一章，我们曾较详细地探讨了头肩形形态，告诉朋友们，它是最广为人知也最为可靠的反转形态。为了防止诸位以为本书所有的问题均易如反掌而麻痹自满，我们这里特地为大家摆出了一些迷魂阵。有的时候，头肩形竟然是持续形态，而不是反转形态（我们还要交代，大凡书中或文章中列举的图例，都经过极细心的挑选，所以，总是如同水晶般地明晰。这就容易误导那些好高骛远的朋友，使他们错误地以为技术分析这个行当不过是碟小菜。在实际工作中，我们是很少如此走运的）。在持续头肩形形态中，价格图形的外观与横向伸展的矩形形态极相似，但是例外的一点是，在上升趋势中，中 间低谷低于两肩（见图 6.11a）。而在下降趋势中（见图 6.11b），这种调整过程的中间峰超过了两侧的峰。在两种情况下，同正常情况相比，头肩形都恰好是倒置的。也正因为它们是倒置的，我们才不可能把它们同头肩形反转形 态相混淆（了解了这一点后，有些朋友恐怕又要飘飘然了）。一旦我们识别出持续头肩形形态后，便可照常绘出其颈线。从此时起，对该形态的解释与前一章的对应内容一 致（除了这里趋势可能将继续而不是反转这一点之外，而这个分别非常重要）。颈线被突破后，原趋势将恢复，其交易量的变化规则及其测算方法均与上一章相同。持续头肩形与反转头肩形在应用中唯一的实际分别是，前者测算的 价格目标可靠性比较弱，并且对交易量的要求不如后者严格。 图 6.11a 看涨的持续型头肩形形态的例子。 图 6.11b 看跌的持续型头肩形形态的例子。 图 6.11c 如果朋友们仔细观察 6 月黄金合约的图表（上半图），将会看到一个小型的头 肩形持续形态。注意其中的三个峰和颈线。也要注意颈线突破后的反扑动作。在图中右 下方，在 12 月间，有一个小的三角旗形。下半图显示了现货黄金图中的矩形巩固形态。 市场特性原则 一般来说，这两章介绍的所有图表形态都可以应用到任何市场。在技术分析界有一种经验之谈，大意是说，在 应用技术分析原理分析研读某张图表的时候，我们甚至不必知道这种股票或期货的名称。所谓“图表就是图表”，这话是时常听得到的。上述说法一般而言是相当正确的，不过按照我们的常例，也需要对它作一点修饰和补充。图表分析的基本原则确实普遍适用于绝大部分市场，不过，这并不意味着所有市场都按同样的方式行事。很显然，每个市场都独具自己的特性，所以，我们应该具体问题具体分析。 我们可以通过计算机来对各种技术指标进行检验。以移动平均线为例，其测试结果表明，虽然也存在在大部分市场都能左右逢源的某种移动平均方法，但在各个市场上。表现最佳的还是其独有的移动平均方法。初看这句话似乎前后矛盾，其实不然。同图表形态一样，特定的移动平均线在所有的条件下都能良好地显示和追踪市场的趋势。 不过，在大部分情况下表现良好的，在各单个市场中未必是表现最佳的。我们借助计算机模拟，在优化过程中发现，每个市场看来均具备其独有的特征或个性，因此我们应该把各种技术工具，包括图表形态，配合各个市场的具体特性，作相应的剪裁和调整。 在第九章中，我们还要再次介绍移动平均线的优化问题。我们这里的讨论仅限于图表形态这个主题。大多数有经验的交易商和图表分析者对每个市场的个性至少都直觉地有所了解。猪脯市场和铜市场大不一样，小麦同日元也相距甚远。因为这些市场分别来自实业界和金融业等不同的领域，其行为差异当然是不奇怪的。 图表分析者也清楚，有些市场的构图特点优于其它的市场。铜和黄金就是构图特性良好的两个市场。小麦和大 豆是另外两个好例子。不过，在我们利用标准的图表技术对猪脯市场和橙汁市场进行分析时，就困难得多了。 关于不同市场的特征或个性的问题，在现有的著述中极少有研究。有本小册子，名为《如何利用图表预测商品 价格》，作者是威廉·L·吉勒（纽约商品研究局，1982 年，第 8 页），其中涉及到市场特性的问题。 一般地，对同一商品来说，其图表形态倾向于具有相似的序列，而不同商品则各有自己的“套路”。换言之，各 种商品的图表往往显示出该商品所独具的本性或特征。举例来说，在棉花的图表中，显示出许多圆顶和圆底，甚至形成一系列这种形态的组合，而这种形态在大豆或小麦的图表上却难得一见。通过观察为期数年的大豆图表，我们可以发现，三角形在这里大出风头。而在小麦图表中，头肩形形态则随处可见。所有的商品都倾向于表现出各自的 特定行为模式。 在 1972 年 8 月号的《商品》杂志（现已改名为《期货》杂志）中，罗伯特·乔尔·泰勒的“主要商品的技术个 性”论述了与上述相同的观点。泰勒认为，每个市场确实都具备其自身的个性，他还从图表形态的出现频率、以及在不同商品中各种具体的技术形态的预测意义的可靠性两个角度，对各种市场的图表形态个性进行了研究，并且为许多常用的图表形态编制了“技术可靠性指数”，分别表示它们在不同市场中的出现频率及其可靠程度。 现在有些分析者仍沿用技术可靠性指数，以测定某种图表形态的真正应验次数在其出现总数中所占的百分比例。 根据这种指数，在我们实际采纳某个图表形态来预测市场之前，首先必须要求其可靠性程度达到 70%以上。 在这个方面，近年来几乎没有著述可资参考，所以，经验依然是我们最好的老师。通过年复一年的市场实践， 技术师就能够对不同市场的个性（和怪癖）心中有数了。在我们综合应用各种图表分析原理时，应该考虑到上述个性差异。 相互验证和相互背离 相互验证原则是一个常见的题目，贯穿了市场分析的始终。它与它的对立面—相互背离原则，总是连在一起 使用的。因此，我们这里把两者放在一起介绍。另外，鉴于这个问题具有极为重要的意义。今后本书将一再地反复讨论。现在，我们只是就价格形态来讨论其相互验证原则，而实际上，它在技术分析的各个方面都有应用。所谓相互验证，是指我们应把所有技术信号和指标都加以比较参照，从而保证它们中的大部分相互验证，指向共同的方向。 在价格形态的范畴内，相互验证，意味着我们应当对同一市场的各种到期月份合约的图表形态进行分析比较， 以确保它们的相互一致。在某一种到期月份图表上的看涨或看跌的形态，应该从其余到期月份图表上的类似内容中得到验证。还不止于此。相互验证原则还进一步要求我们同时考察所有相关的市场。在相关市场所组成的群类中，各个市场倾向于同进同止，因此，我们有必要探究一下与研究对象同属一个群类的其它市场的行为。如果我们分析的是某金属的市场，那么也应该东张西望一下，看看其它金属市场情况如何。 此外，这样做还有另一个原因，对相关市场的研究经常为我们的分析对象本身提供一些线索。 再进一步，我们还要检讨一下广泛性商品价格指数，考察我们的分析是否与商品市场的大方向一致。如果商品市场在总体上处于下降趋势中，那么，对任何个别市场的看涨分析，我们都需要把它的份量打些折扣。因此，我们必须明确，商品市场的总体环境到底是牛气的，还是熊气的。 最后，我们考察连续周线图和连续月线图，以寻求更高层次的验证。看看这里是否也满足相互验证原则。然后，我们把工具囊中的所有技术指标，例如移动平均线、摆动指数、趋势线、交易量和持仓兴趣等等，也拿出来查验查验，以保证上述一致性。简单说来，相互验证原则表明，分析者关于某市场的分析结论所拥有的技术证据越多，则 对自己的分析越具信心，正确决策的把握就越大。 相互背离同相互验证恰恰相反，是指在同一市场的不同到期月份合约之间，或者在相关市场的不同市场之间， 或者在同一合约的各类技术指标之间不能相互验证的情形。虽然此处我们是把相互背离概念从负面引入的，但在市场分析中它其实极有价值，也是趋势即将反转的最好的先期警讯之一。在第十章我们讨论摆指数时，将对相互背离原则作更深入的探讨。 现在，我们就完成了关于价格形态的讨论。早些时候，我们曾指出，技术分析的原始资料有三种—价格、交易量和持仓兴趣。到这里为止，我们的主要内容都是围绕价格进行的。下面我们就来进一步地研究交易量和持仓兴趣这两个方面，探讨一下如何把它们揉合进分析过程中。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第五章 主要反转形态]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E4%BA%94%E7%AB%A0-%E4%B8%BB%E8%A6%81%E5%8F%8D%E8%BD%AC%E5%BD%A2%E6%80%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 引言到这里，我们已经涉猎了道氏理论，这是目前实际应用的绝大多数趋势顺应机制的理论起点；也探讨了趋势的基本概念，诸如支撑、阻挡和趋势线等；对交易量和持仓兴趣也作了介绍。那么下一步，就该学习图表形态了。很快我们就会发现，这些形态就是建立在上述概念的基础之上的。 上一章，我们把趋势定义为一系列依次上升或下降的峰和谷。只要它们相对变化的方向向上，则趋势向上；如果其相对变化的方向向下，那么趋势就向下。我们还强调指出，在相当部分时间内，市场处于横向伸展的态势之中。而正是这种横向延伸的市场运动，构成了接下来两章的主要课题。 千万不要以为绝大部分趋势的变化突如其来，事实上，趋势在发生重要变异之前，通常需要一段酝酿的时间。问题就在于，这种酝酿时期并不总意味着趋势将要逆转，有时候，这只是既存趋势的休整，随后原有的趋势仍将继续。 价格形态研究这种酝酿时期及其预测性意义就是价格形态所要解决的问题。那么，什么是价格形态呢？价格形态是股票或期货价格图上的特定图案或花样，它们具有预测性价值，我们可以把它们分门别类。 形态具有两个类别：反转型和持续型 价格形态有两种最主要的分类—反转型形态和持续型形态。反转形态名符其实，意味着趋势正在发生重要反转；相反地，持续形态显示市场很可能仅仅是暂时作一段时间的休整，把近期的超买或超卖状况调整一番，过后，现存趋势仍将继续发展。关键是，必须在形态形成的过程中尽早判别出其所属类型。 本章将讨论五种最常用的主要反转形态：头肩形、三重顶（底）、双重顶（底）、V字顶（底）、以及圆形（盆形）顶（底）等形态。我们将考察价格本身的变化过程，及其变化在图表上的显示，还有判别它们的方法。然后，我们还要研究另外两方面重要因素—伴生的交易量的形态，以及价格形态的测算意义。 交易量在所有价格形态中，都起到重要的验证作用。在形势不明时（许多情况下都是这样的），研究一下与价格数据伴生的交易量形态，是判断当前价格形态是否可靠的决定性办法。 绝大多数价格形态各有其具体的测算技术，可以确定出最小价格目标。虽然这些目标仅仅是对下一步市场运动的大致估算，但仍有助于交易商确定其报偿—风险比。 下一章，我们将讨论形态的另一个大类—持续型形态，内容包括三角形、旗形和三角旗形、楔形、以及矩形。 这类形态通常反映出现行趋势正处于休整状态，而不是趋势的反转，因此，通常被归纳为中等的或次要的形态，算不上主要形态。 反转形态所共有的基本要领 在单独地剖析各个主要反转形态之前，我们先交待所有反转形态所共有的几个基本要领。 1.在市场上事先确有趋势存在，是所有反转形态存在的前提。 2.现行趋势即将反转的第一个信号，经常是重要的趋势线被突破。 3.形态的规模越大，则随之而来的市场动作越大。 4.顶部形态所经历的时间通常短于底部形态，但其波动性较强。 5.底部形态的价格范围通常较小，但其酝酿时间较长。 6.交易量在验证向上突破信号的可靠性方面，更具参考价值。 事先存在趋势的必要性。市场上确有趋势存在是所有反转形态存在的先决条件。市场必需先有明确的目标，然后才谈得上反转。在图表上，偶尔会出现一些与反转形态相像的图形，但是如果事前并无趋势存在，那么它便无物可反，因而意义有限。在我们辩识形态的过程中，正确把握趋势的总体结构，有的放矢地对最可能出现一定形态的阶段提高警惕，是成功的关键。 正因为反转形态事先必须有趋势可反，所以它才具备了测算意义。前面曾强调，绝大多数测算技术仅仅给出最小价格目标，那么，最大目标就是事前趋势的起点。如果市场发生过一轮主要的牛市，并且主要反转形态已经完成，就预示着价格向下运动的最大余地便是100%地回撤整个牛市，从它的终点回到它的起点。 重要趋势线的突破即将降临的反转过程，经常以突破重要的趋势线为其前兆。不过朋友们请记住，主要趋势线被突破，并不一定意味着趋势的反转。这个信号本身的意义是，原趋势正有所改变。主要向上趋势线被突破后，或许表示横向延伸的价格形态开始出场，以后，随着事态的进一步发展，我们才能够把该形态确认为反转型或连续型。 在有些情况下，主要趋势线被突破同价格形态的完成恰好同步实现。 形态的规模越大，则随之而来的市场动作越大。这里所谓规模大小，是就价格形态的高度和宽度而言的。高度标志着形态的波动性的强弱，而宽度则代表着该形态从发展到完成所花费的时间的多寡。形态的规模越大—即价格在形态内摆动的范围（高度）越大、经历的时间（宽度）越长—那么该形态就越重要，随之而来的价格运动的余地就越大。 实际上，这两章所介绍的所有的测算技术，均是以形态高度为基础的。这种方法主要适用于线图，这就是所谓垂直测算原则。而测量价格形态横向宽度的方法，通常应用在点数图分析中。在后面要讲的这种图表分析法中，采用了“横向数算”的技术，它认为顶或底部形态的宽度，同随之而来的价格运动的目标之间，存在着一一对应的关系。 顶和底的差别。顶部形态与底部形态相比，它的持续时间短但波动性更强。在顶部形态中，价格波动不但幅度更大，而且更剧烈，它的形成时间也较短。底部形态通常具有较小的价格波动幅度，但耗费的时间较长。正因如此，辨别和捕捉市场底部比捕捉其顶部，通常来得容易些，损失也相应少些。不过对喜欢“压顶”的朋友来说，尚有一点可资安慰，即价格通常倾向于跌快而升慢，因而顶部形态尽管难于对付，却也自有其引人之处。通常，交易商在捕捉住熊市的卖出机会的时候比抓住牛市的买入机会的时候，盈利快得多。事实上，一切都是风险与回报之间的平 衡。较高的风险从较高的回报中获得补偿，反之亦然。顶部形态虽然更难捕捉，却也更具盈利的潜力。 交易量在验证向上突破信号时更具重要性。交易量一般应该顺着市场趋势的方向相应地增长，这是验证所有价 格形态完成与否的重要线索。任何形态在完成时，均应伴随着交易量的显著增加。但是，在趋势的顶部反转过程的早期，交易量并不如此重要。一旦熊市潜入，市场惯于“因自重而下降”。图表分析者当然希望看到，在价格下跌的同时，交易活动也更为活跃，不过，在顶部反转过程中，这不是关键。然而，在底部反转过程中，交易量的相应扩张，却是绝对必需的。如果当价格向上突破的时候，交易量形态并未呈现出显著增长的态势，那么，整个价格形态 的可靠性，就值得怀疑了。在第七章中，我们将更深入地研究交易量。 头肩形反转形态 我们现在来细细地探讨一下头肩形反转形态。这种反转形态可能是最著名、最可靠的。我们将花费较多的篇幅来研究这类形态，因为一方面它本身颇为重要。另一方面，我们也需要通过它来讲解各种新概念。其它绝大多数反转形态仅仅是头肩形的变体，因此，等以后讲到它们的时候，我们就可以省却许多笔墨了。 就如其余所有的反转形态一样，头肩形主要反转形态其实也是前一章中的趋势概念的进一步提炼。举例来说， 在上升趋势中，一系列依次上升的波峰和波谷首先把上涨势头逐渐放缓，然后上升趋势开始停顿。此时，供求双方的力量对比处于相对平衡之中。一旦这个“消散阶段”完成，那么，上述调整的横向交易区间底边处的支撑就被打破了，从而，市场确立了新的下降趋势，反转形态大功告成。新的下降趋势具备依次降低的波峰和波谷。 我们来看看在头肩形顶中上述情况的具体表现（见图5.1a和b）。在点A，上升趋势一如既往，毫无反转的迹 向。交易量在价格上升到新高度的同时，也相应地扩张，表现正常。在B点的调整性下降中，交易量见轻，也符合要求。然而到了点C，警觉的图表分析者或许注意到，当这一轮上涨向上突破点A时，其交易量同前一轮上涨时的交易量相比，已经有所减少。虽然这个变化本身并不具有重大意义，但是这时候，分析者应该在脑海里亮起一盏黄色警告灯了。 后来，价格跌回到点D，出现了一些更令人困惑的问题。这一轮下跌的低点低于从前的高点A。请记住，在上升趋势中，以前的高点一旦被向上穿越后就在随后的市场调整中起到支撑作用。而这次下跌明显地低于A点，几乎达到前一个向上反弹的低点 B 的水平，这就是个警讯，说明该上升趋势可能出了问题。 图5.1a 头肩形顶的例子。左肩和右肩（A和E）的高度差不多相同，头（C）比两肩高。请注意在每个峰处逐渐减轻的交易量。当收市价居于颈线（2线）之下时，形态完成。其最近目标的求法是，自颈线上的突破点起，向下投射从头部到颈线的竖直距离。突破颈线后，常常出现回向颈线的反扑现象，但它不应再返回颈线的另一边 图5.1b 头肩形顶。其中有三个峰，头部高于两肩。注意观察在右肩形成前， 主要上升趋势线是如何被突破的。也请注意向下突破颈线后的返回颈线的反扑现象。从颈线上的突破点起，向下投射头部到颈线的竖直距离，就得到最小价格目标 然后，市场再次上冲到点E，这一次，交易量更轻，甚至不能达到冲击高点C时的水平（点E这轮最后的冲击，经常回撤到从点D到C之间下降幅度的一半到三分之二之间）。我们知道，如果上升趋势要持续发展，则每一轮新高点都必须超过前一轮上冲高点。点 E 处的上升无力达到前一轮高点 C，满足了新的下降趋势所要求的一半条件—即依次下降的波峰。 到了这个时候，在点 D，主要上升趋势线（线1）通常已经被跌破，从而构成了另一个危险信号。但是，尽管发生了上述许多警告讯号，此时我们唯一可以肯定的一点是：趋势已经从上升转化成横向延伸了。这也许是了结多头头寸的充分根据，但还不足以构成卖出做空头的理由。 突破颈线，完成形态 至此，通过最后两个向上反弹的低点（点B和点D），我们可以作出一条较为平缓的趋势线，称为颈线（如线2所示）。在顶部，颈线一般轻微上斜（尽管有时也可能水平，或者在更少数情况下略倾斜向下）。头肩顶成立的决定 性因素是，收市价格明确地突破到颈线之下。在这种情况下，市场终于突破了由底点B和D构成的趋势线，并跌破D点的支撑，从而完全满足了新趋势产生的前提条件—依次下降的峰和谷。于是，从依次下降的峰点和谷点C、D、E、F上，我们可以确定新的一轮下降趋势。顺便说明一下，在顶部形态完成后的初始阶段，当市场向下突破时交易量是否急剧扩张并不是至关重要的。 反扑 接下来，通常市场会出现反扑现象，即价格重新弹回颈线或者前一个向上反弹的低点D（如点G所示）。此时，这两者均已在市场上方构成了阻挡。反扑现象并不一定总能发生，有时或者只能形成一段极小的反弹。交易量也许有助于我们推测这种反弹的幅度大小。如果在突破颈线的初始阶段交易量极重，那么反扑的余地便大为减小，因为 上述突然增加的交易活动反应出市场上较重的向下压力。反过来，如果初始突破时的交易量较轻，那么反扑的可能性便大为增加。无论如何，这种反弹应当以较少的交易量进行，并且随后，当新的下降趋势恢复下跌的时侯，应该伴随着显著加重的交易活动。 小结我们来归纳一下形成头肩顶的各个要素。 1.事先的上升趋势。2.左肩（点A）伴随著较重的交易量，且之后市场向下调整到点B。3.以较轻的交易量上冲到新高点（点C）。4.随后的下跌低于前一个峰（A点处），且接近前一个向上反弹低点（点D）。5.第三轮上冲（点E）具有显著减轻的交易量，且无力达到头顶的高度（点C处）。6.收市价低于颈线。7.反扑回颈线（点G），然后下跌至新低点 这里有三个显著的波峰，它们的界定颇为明确。中间的峰（头）稍高于双肩（点A和E）。然而，只有当市场以收市价格的形式，决定性地突破颈线之后，该形态才得以最后完成。同样地，我们也可以采用3%穿越原则（或在前一章所介绍的其余价格过滤器）、或者双日原则（即市场连续两天收市于颈线之下），作为进一步的验证手段。另外， 除非确实发生了向下突破，不然始终存在以下这种可能性：整个图形并不是真正的头肩顶，在未来某一时刻，上升 趋势也许仍将恢复。 交易量的重要性 与价格变化相对应的交易量形态，在头肩顶形态的发展过程中担负着重要的角色。在其它的价格形态中，交易量的作用也都如此。一般来说，第二高峰（头）的伴随交易量比左肩为轻。这一点倒不是必要条件，而是市场在这种情况下通常具有的一种强烈的倾向性，也是说明市场上买进压力减轻的早期警讯。最重要的交易量信号，发生在第三高峰（右肩），此处的交易量应比前两个高峰处显著地减轻。在突破趋势线的时候，交易量应扩张；在价格反扑时，交易量应减少。然后，一旦反扑完结，交易量便再度扩张。 我们曾经交代，在市场顶部的形成过程中，交易量的关键性比底部过程要逊色些。但是在某些场合，如果新生的下降趋势能够持续的话，交易量依然应当开始增加。而在市场的底部过程中，交易量则担负着更为关键的角色，很快我们将讨论这个问题。现在我们先讨论一下头肩形的测算意义。 发现价格目标 形态高度是测算价格目标的基础。具体做法是，先测出从头（点C）到颈线的垂直距离，然后从颈线上被突破 的点出发，向下投射相同的距离。举个例子。假定头顶位于100，相应的颈线位置在80，那么其垂直距离便是两者的差，20。如果颈线如图5.1a所示，那么我们就应该从颈线上的突破点开始，向下量出20点。突破点位于82，那么，向下突破的目标就被投射到62的水平（82-20-62）。 还有一种较简便的方法：先简单地量出下降运动中第一浪（从点C到D）的长度，然后往下翻出一番。这两种情况的道理都是一样的，形态高度越大（即波动性越大），那么其“前程”便越远大。第四章中所介绍的关于趋势线被穿越的测算技巧，同此处的头肩形测算方法类似。现在朋友们不妨比较比较。大略地说，价格在突破趋势线后所走出的距离，同它在趋势线之上曾经经历的距离相当。贯穿我们关于价格形态的讨论，你都将看到，线图上的绝大多数价格目标是建立在各种形态的高度（或者说，波动性）之上的。从突破点开始顺势投射与形态高度一致的距离，这是个老话题，我们将会一再地提起。 重要的是，上述价格目标仅仅是最近的目标，而实际上，价格运动经常越过上述目标。不过，如果我们对最近目标心中有数，那么对判断市场运动是否还有足够余地来开立头寸无疑是大有帮助的。即便市场越过了这个价格目标，那么剩下的也只是蛋糕上的那层奶油。当然，最大目标是原先趋势的整个范围。比如说，原先的牛市从30涨到了l00，那么从顶反转形态得出的最大下跌目标便为30，从哪里来，还回撤到哪里去。从反转形态上，我们仅能预期 市场对原先趋势的反转或回撤。 价格目标的调整 在我们预计价格目标的时候，还应当考虑到其余许多因素。价格形态本身的测算技巧（如上面介绍的关于头肩形顶的相应情况），只是第一个步骤。其余技术性因素也应予以考虑。举例来说，由原先牛市中的向上反弹低点所形成的重要支撑水平在何处？熊市经常会在这些水平上被扼止住。百分比回撤的位置怎样？最大回撤目标是原先牛市 的 100%回撤。但 50%和 66%回撤的水平又在哪里？它们同样常常成为市场下方的重要支撑。价格跳空的情况怎样？ 它们同样常常演变成支撑区域。另外，市场下方有无长期趋势线存在？ 在从价格形态确定价格目标时，技术分析者必须考虑其余技术资料。比如说，如果向下的价格测算目标是30，而32是一个重要支撑水平，那么，明智的做法是，把向下测算目标放在32，而不是30。一般地，当测算目标同清晰的支撑或阻挡水平只有微小差别的时候，我们通常把价格目标调整到这些支撑或阻挡水平上，以求可靠。这种综合考虑其余技术信息来调整价格形态测算目标的做法，常常是很有必要的。我们都知道，有许多不同的工具可供分 析者选择，那么，最巧妙的技术分析者正是那些懂得如何恰如其分地综合使用各种工具的人。 倒头肩形 头肩形底有时也被称为倒头肩形，它恰好与头肩形顶互为镜像。正如图5.2a所示，它具有三个清楚的底谷，其中头（中间的谷）稍低于两肩。收市价格决定性地向上突破颈线，也是该形态得以完成的必要条件，而且它的测算技术也与头肩形顶的一样。稍有差别的一点是，在底部，当颈线被向上突破后，市场更惯于反扑。 头肩顶和头肩底最重要的区别在与之配合的交易量序列上。在判别头肩底形态及其突破的时候，交易量起到更 为关键的验证作用。前面我们讲过，市场具有“因自重而下跌”的倾向性，因此在底部，当市场力图发动一轮牛市的时候，必须具有较多的交易量才行，也就是说，必须具有显著增强的买进推力。 图5.2a倒头肩形的例子。这种形态的底部形式是顶部形式的镜像。其中最重要的区别是在形态后半部分的交易量形态上。在底部过程中，自头部弹起的上冲，应当具有较重的变易量，而当颈线被突破时，交易活动应更是具有进发性的扩张。回向颈线的反扑在底部过程中也更多见。 图5.2b 倒头肩形底的实例。左肩形成于10月，右肩形成于5月。头部形成于2月和3月，其外形与 V 形反转底相似。7月，本图的CRB外汇期货 指数收市于为期8个月的颈线之上，从而构成了外汇市场的主要看涨信号。 我们不妨把这种市场特点同重力规律对照一下。我们都知道，当物体从手中释放后，无需我们再作努力，便很快地跌向地面。举起某物则是另一回事，我们必须付出劳动。要是朋友们对体育运动较有体验的话，请设想一下山路赛跑的情况。在下山时，我们一直会跑得很轻快。然而上山的赛程才是考验耐力的关键之处。“波士顿马拉松赛” 的场地末端是块上坡地，人称“伤心坡”，要是它是下坡的话，可能就会以“快活坡”这样的名字而著称了。 我们用更带技术性的方式来理解这个区别。市场常常会仅仅因为惯性而下降，但市场却不因为惯性而上升。需 求不足、或者交易商缺乏买进兴趣等原因，经常就足以把市场压低。但只有在需求超过供给，并且买方比卖方更积 极时，价格才能上涨。在本形态前半部分，交易量形态同头肩顶很相似。就是说，头部的交易量是比左肩的稍有减少。然而，在头部 的上冲阶段，不但应该显示出交易活动有所增加，而且其交易量水平经常要超过左肩的上冲对应的交易量水平。右肩下跌部分的交易量应该非常轻弱。关键时刻是市场突破颈线而上冲的时候。这个突破信号如果成立，那么所伴随的交易量非得相应地急剧膨胀不可。 这一点是头肩底同头肩顶最大的分别。在底部，强劲的交易量绝对是完成形态的关键组成部分。反扑在底部比 在顶部更经常发生，不过，其交易量应该轻弱。随后，新的上升趋势应该在较重的交易量下恢复。头肩形底的测算 方法与头肩顶相同。 颈线的倾斜程度 顶部的颈线通常稍稍倾斜向上，不过也有时是水平的。这两种情况并没有太大差异。然而，偶尔顶部的颈线会向下倾斜。这种坡度是市场疲弱的一种表现，通常，随之而来的右肩也很软弱。不过，这并不全是好消息，而是利弊参半。如果分析者要等顶线突破再开立头寸的话，就不得不等待较长时间，因为该信号在向下倾斜的颈线上出现得很晚，而且届时大部分的下降运动已经发生了。对底部形态而盲，绝大多数颈线稍倾向下。而向上倾斜的颈线意味着市场的坚挺，不过此处同样也有信号过迟的缺陷。 复杂头肩形形态 在我们的图表上，有时会出现一些头肩形的变体，称为复杂头肩形。这种形态可能呈现出双头或二个左肩和二 个右肩的情况。它们不如其原型常见，但具有同样的测算意义。对付这种情况有个窍门。那就是利用头肩形形态所具有的强烈的对称倾向。单个的左肩通常对应着单个的右肩，双重左肩则使出现双重右肩的可能性增加了不少。 对策 在所有的期货交易中，交易策略问题均是举足轻重的，我们在以后章节中还将更耀入地探讨。并非所有的技术型交易商都愿意等到颈线突破后，才开立新头寸，如图5.3所示，较为大胆积极的交易者在相信自己已经正确地判明头肩底之后，在右肩形成过程中就开始尝试着买进，或者在右肩下跌完结的第一个信号出现时就买进了。 图 5.3 头肩形底中的交易策略。右肩（E）尚处在形成过程中的时候，很多技术型交易商就开始建立多头 头寸了。在从点 C到D的上冲的一半到三分之二的回撤位置上，或者当价格跌向近期的支撑水平或支撑性跳空的时候，或者在价格跌到与左肩点 A的水平差不多的时候，或者当短暂的下降趋势线（线1）被向上突破时，统统是早期的入市机会。当颈线果然被突破后，或者事后发生回向颈线的反扑时，可以追加更多的头寸 有些人先测出从头部的底点上冲的距离（点 C 到 D），然后在其50%或66%回撤位置买进。还有些人会看看市场下方有无跳空存在，以利用之作为买进点。也有些人或许沿着点D和E画出一条短期的下降趋势线，该趋势线一被突破便买进。有些人考虑到这种形态具有相当的对称性，从而当右肩的发展接近了左肩的低点的水平时买进。这里要说明的是，在右肩形成过程中，会发生许多预期性的买进行为。如果上述尝试性头寸果真有利可图，那么，在颈线被实际穿越时或者在颈线突破后市场反扑时，交易商就会追加更多的买进头寸。 流产的头肩形形态 一旦价格越过颈线，头肩形形态就完成了，市场也就不应再返回颈线的另一边。在顶部，一旦颈线被向下突破 了，那么只要随后有任何一个收市价格返回到颈线上方，都是严重的警讯，表明此次突破可能是无效信号。显而易 见，这就是流产头肩形的由来。此类形态起初貌似典型的头肩形反转，但在其演化过程中的一定时刻（无论是在颈线突破前还是其稍后），价格将恢复原先的趋势。 由此，我们可以得出两条教训。其一，没有哪个图表形态百发百中。它们在大多数时间是成功的，但并不是永 远如此，其二，技术型交易商必须永远警惕自己分析中的错误信号。在期货市场，致胜的关键之一，就是要尽快摆 脱亏损的交易头寸（逮将在第十六章关于资金管理及其策略的讨论中介绍）。确保交易损失限于小额。这里，我们或 许可以为图表分析这门工具添加一条最实用的长处：它能够警告交易商认清现实、纠正错误。在期货行业，迅速地 发现并承认自己的交易决策错误，及时采取断然的保护性措施，这样的能力和意志力是难能可贵的，我们绝不可以等闲视之。 头肩形作为调整形态 在接着讲述下一种价格形态之前，关于头肩形尚有最后一点需要补充。本章开头曾把它列举为最广为人知且最可靠的主要反转形态。但是朋友们必须明白，本图形偶尔也会充当调整性形态而不是反转形态。不过，后面这种情 况与其说是贯例，不如说是例外。在第六章讨论持续型形态时我们将有详细讲解。 三重顶和三重底 我们在讨论头肩形形态时所引入的大部分要领，也适用于其它种类的反转形态（见图 5.4a 到c）。三重顶（或底），比头肩形少见得多，其实是前者的小小变体。其主要区别是，三重顶或底的三个峰或谷位于大致相同的水平上（见图5.4a）。在判断某个反转形态到底应属于头肩形还是三重顶的问题上，图表分析者经常有争议。因为两种形 态其实是一回事，所以这种论争是迂腐的。 在三重顶中，交易量往往随着相继的峰而递减，而在向下突破时则应增加。三重顶只有在沿着两个中间低点的 支撑水平被向下突破后，才得以完成。在三重底中，情况正相反，形态完成的必要条件是，收市价格向上越过两个中间峰值的水平（我们还有另一种对策，那就是把价格突破最邻近的峰或谷选作反转信号）。底部形态完成时，向上突破的交易量是否强劲有力，也是同样关键的。 它们的测算意义与头肩形相似，以形态的高度为基础。通常，价格在突破颈线后，由突破点起算，至少将要走出等于形态高度的距离。一旦突破，随后回向突破水平的反扑现象也很常见。考虑到三重顶（或底）只是头肩形形态的稍许变化，我们这里就不再赘述了。 图5.4a 三重顶。它与头肩形类似，只是其中三个峰都处在同一水平。每个上冲峰的交易量均应见轻。当其中两个谷被市场以较量的交易量向下跌破后，本形态宪结。其测算技术是，自突破点起，向下投射出与形态的高度相等的距离。在突破发生后，回向下方直线的反扑现象也不少见。 图5.4b 三重底。它与头肩形底类似，只是其中每个低点均处于同一个水 平上。它是三重顶的镜像，不过对于向上突破来说，交易量因素更重要。 图5.4c 三重顶反转。请注意，其中8月到9月所形成的三个峰均处于250的水平。220附近一直是支撑区，一旦被向下跌破，则演化成阻挡区。同时，还要注意，后来价格何其接近其下方的目标。如果朋友们仔细观察，那么将看出，在这个顶部形态中，当 价格下跌时，交易量更胜一筹。当11月发生向下的突破时，交易量更是显著地扩张。 双重顶和双重底 双重顶（或底）反转形态比三重顶（或底）常见得多，这种形态仅次于头肩形，出现得也很频繁，且易于辨识（见图5.5a到e）。图5.5a和5.5b各展示了双重顶和双重底的两个例子。出于显而易见的原因，这类顶经常被称为“M顶”，这类底被称为“W 底”。从一般特点上讲，双重顶与头肩形顶、三重顶类似，只是此处只有两个峰，而不是三个。交易量形态与测算法则也均类似。 在上升趋势中（如图5.5a所示），市场在点A确立了新的高点，通常其交易量亦有所增加。然后，在减少的交易量背景之下，市场跌至B点。到此为止，一切均符合上升趋势的正常要求，趋势进展良好。然而，下一轮上冲抵达了C点后，收市价格却无力穿越前一个高点 A 点。接着，价格就开始跌回。此时，一个潜在的双重顶便跃然纸上。我们之所以讲“潜在”，是因为这才是所有的反转形态成立的必要条件，而只有在收市价格突破前一个低点B的支撑之后，这个反转才能成立。除非发生突破，否则价格可能仅仅是处于横向延伸的调整阶段中，为原先趋势的恢复作准备。 理想的双重顶具有两个显著的峰，且其价格水平大致相同。交易量倾向于在第一个峰时较重，而在第二峰时较 轻。在较重交易量下，当价格决定性地收市于中间谷点 B 点之下时，顶部形态就完成了，标志着趋势向下方的反转。 以后，在下降趋势恢复之前，市场往往先要反扑回突破点的水平。 双重顶的测算技术 双重顶的测算方法是，自向下突破点（中间谷点B即被突破的价位）开始，往下投射与形态高度相等的距离。另一种方法是，先测出双重顶中第一条下降轨迹（点A到B）的幅度，然后从位于B点的中间谷点开始，向下投射相同的长度。双重底的测算方法一样，只是方向相反。 图 5.5a 双重顶的例子。本形态有二个峰（A 和C），处在大致相同的水平。当其中的中谷（点B）被收市价跌破后，本形态完结。通常，在第二个峰（点C）交易量较轻，而在向下突破时（点D），变易量有所增加。回向下方直线的反扑现象也不罕见。最小测算目标是，从突破点起，向下投射出与形态高度相等的距离 图 5.5b 双重底的例子，它是双重顶的镜像。对这里的向上突破来说，交易量因素更有份量。在底部形态中，回向突破点的反扑现象较多见。 图5.5c 双重底的实例。请注意在5月到6月期间，在5800附近形成了两个清晰的底。当价格收市于 6116 以上时，底部形态完成，趋势转而向上。注意，在图中右上角，价格已经从前一峰值（72）处挡下。 在上升趋势中，这种情况并不少见。但无论如何，价格必须收市于6916的低点之下，方可完成这个双重顶 图5.5d 双重顶和底的实例。注意在5月到6月间稍高于30的经典的双重顶。在7月到9月间的两个底部也有可能形成一个双重底。 图5.5e 在连续周线图上，反转形态出现得相当频繁。注意1983年下半年形成的头肩形顶。其中向下的价格目标效用不凡。也请注意接近150处的小些的双重底，以及174附近的潜在的双重顶。从这张图上，我们也许可以得出如下看法；1984年年底的高点可能是一个主要的双重顶的第二个峰。当然，市 场必须收市于 148 之下，才能确认这种看跌的解释。价格从重要的的阻挡水平上弹下的现象并不稀奇。 理想形态的变体 各种市场分析的领域都一样，现实情况通常都是理想模型的某种变体。比如说，有时双重顶的两个峰并不处于严格相同的水平上。有时第二峰相当疲弱，达不到第一峰的高度，这并不太成问题。而当第二峰实际上约略超过第一峰时，就出了些岔子。起初它貌似有效的向上突破，显示上升趋势已经恢复。然而好景不长，不久，它竟演化成 顶部过程的一个部分。为了解决这个两难问题，前面曾经提到过的那些过滤法则或许会派上用场。 过滤器 在判别突破成立与否的时候，大多数图表分析者都要求收市价格越过前一个阻挡峰值，而不仅仅是日内的穿越。 其次，我们还可以采用某种价格过滤器。其中的一例便是百分比穿越原则（例如1%或3%过滤器）。第三，也可以 选用双日穿越原则，这是时间过滤器的一例。换言之，为了证明向上穿越的有效性，价格必须接连两天收市于第一峰之上。 上述过滤器肯定不会是绝对可靠的，不过，它们的确有助于减少经常发生的错误信号（所谓“拉锯”现象）。这 些过滤器有时有效用，有时也没用。分析者必须清楚，他面对的是百分比概率和可能性，错误信号的出现是免不了的，这是交易现实的客观规律。 在牛市中，双重顶的最后一程或最后一波在建立新高点之后，掉头转而向下的现象并不稀奇。在这种情况下， 最后的一轮向上突破就形成了“牛市陷阱”（见图 5.6a 和 b）。但是足资安慰的是，绝大多数趋势信号还是能贯彻始 终的，否则，整个趋势顺应理论就要丧失一大半价值和一大半可靠性了。 图5.6a 图中为伪突破信号的例子。这种情常常称为“牛市陷阱”。有时，在接近 主要上升趋势的尾声时，价格先是向上超越先前的峰，而后却溃不成军。图表师借助 时间和价格过滤器来避开此类拉锯现象。这里的顶部形态很可能属于双重顶的类型。 图5.6b 伪向上突破信号的实例。注意,在图表上方,价格起先向上突破了过去的高点,发出了错误 的看涨信号,然后,它却掉转方向,完成了一个双重顶的形体。不过也请注意,价格并没能够在先前峰值上方维持 2 个相继的交易日。在这种情况下,如果采用了双日时间过滤器的话，就有可能避免亏损 “双重顶”术语被大大滥用了 “双重顶”术语在期货市场上被大大地滥用了，大多数潜在的双重顶（或底）最终演化得面目全非。归根结底，价格本具有从前一峰值挡下，或者从前一低点弹起的强烈倾向，这种价格变化正是市场在阻挡或支撑水平上的自然反应，其本身并不足以构成反转形态。请记着，在顶部，价格必须真正跌破前一个向上反弹的低点，才能表明双重顶成立。 注意，在图5.7a中，在点C，价格被前一个高点 A 挡下。这一变化在上升趋势中完全正常。然而，许多期货交易商在价格第一次试探前一个高点失败之后，马上就判断这个图形为双重顶。图5.7b显示了在下降趋势中的对应的情况。对图表分析师来说，要判定价格从前一个高点的下撤，到底是双重顶反转形态的开端，还是仅仅是既存趋势的暂时挫折（或者反过来，要判定从前一个低点的上弹是不是双重底反转形态的发韧），是极为困难的。在通常情况下，从技术角度看，趋势继续发展的可能性更大，所以明智的做法是，一定要等到形态完成之后，才采取相应的动作。 图 5.7a 在上升趋势中，在价格恢复上升之前， 图5.7b市场从先前的低点正常上弹的例子。这也属于先从过去的峰值正常挡下的例子。这属于正常的正常的市场行为，切不可与双重底混淆。在正常情况下，市场行为，切不可与双重顶混为一谈。仅当点B价格在达到先前的低点时，至少总要上弹一次。这种正 支的撑被跌破后，双重顶才能成立。 常现象可能诱使一些朋友犯了过早预期双重底的错误。 两峰或两谷之间的持续时间很重要 最后，形态的规模始终是很重要的一个方面。双峰之间持续的时间越长、形态的高度越大，则即将来临的反转的潜力越大。这一点对所有的图表形态而言，都是成立的。一般地，在最有效力的双重顶或底形态中，市场至少应该在双峰或双谷之间持续一个月，有时甚至可能达到两、三个月之久（在更大范围的月线图和周线图上，这类形态可能跨越数年）。这里所列举的大部分例子，是市场的顶部形态。现在朋友们应该清楚了，底部形态只是顶部形态的镜像，而两者之间的几点一般性的差别，在本章的开头部分我们已有交代。 圆顶和圆底 下面要讲的反转形态比前面几种都少见得多。它有好几个名字——圆顶或圆底、圆形、盆形或者碗形（如果系 顶部形态，则不妨加上“倒扣”二字）。本形态代表着趋势的很平缓的、逐渐的变化。图 5.8a 和 b 展示了这种图表形态。 请注意，图中价格从上升到下降、或者从下降到上升的变化过程，极为平缓。同时也请注意，图表下方的交易 量也倾向于形成相应的盆状形态。在顶部和底部，交易量均随着市场的逐步转向而收缩，最后，当新的价格方向占据主动时，又都相应地逐步增加。 有时在圆底中点的稍后的位置上（如图 5.8b 所示），价格在异乎寻常的重大交易量的背景之下突破，向上冲刺， 然后又回落到缓慢的圆形形态过程中。在底部的末端，有时会出现一个“盆把”（或者说“平台”），随后新的上升趋势将恢复。请注意，在交易量图上的圆底上，过了中点之后，交易量突然开始上升，随着价格进一步上涨，交易活动相应逐步增加；平台出现时，交易量下降；接下来，当价格向上方突破时，交易量又进一步扩张。 图 5.8a 圆顶的例子。上升趋势逐步丧失上升的动力，慢慢地转化为新的下降趋势。 注意，与之相应，交易量往往也形成了自己的圆形形态。这种顶部形态又称“倒扣碗形” 图5.8b圆底的例子。注意交易量的圆形形态。有时候，在底部形态的中点稍后，交易活动会突然增加。在右侧，常常形成平台，此类形态在底部比在顶部更多见。底部形态的完结既可以以A点的峰被向上突破为标志，也可以以点B处向上突破平台为标志。 我们很难确切地说圆形形态何时完成。如果在中点 A 处价格上冲，那么此后，当这个高点被向上穿越时，可能 就是牛市信号。还有一个变通的办法，即把从平台向上的突破，作为底部完成的信号。 圆底不具备精确的测算规则。不过技术分析师还是拥有其他各种技术工具，可以测算出新趋势的潜力。比如说，原有趋势的规模就是个重要的参考，能够提供价格回撤的一些大致范围。同时，圆形形态本身持续的时间也是很有价值的信息，其持续时间越长，则未来运动的潜力越大。另外，技术分析者还需要考虑其它要素——诸如原先的支 撑和阻挡水平、百分比回撤、跳空、或长期趋势线等等。 如前面所述，相对来说盆形或者圆形形态，出现得较不频繁。此处之所以要着重讲述圆形底形态，是因为根据 我个人的经验，一旦这种罕见形态果真出现了，通常便是市场的底部。我怀疑，在过去十年，此类形态罕见的原因之一，在于我们所经历的特定市场条件。1970年代以剧烈牛市为特点，而1980年代则以熊市为代表，都不具备滋生圆底的环境条件。今后，在期货市场再度稳定以后，在各种主要底部形态中，我们很可能将看到圆底卷土重来。 图 5.8c 这张咖啡图展示了圆形底的一个实例，注意在 9 月到 11 月的趋势的逐渐变化过程。这一类市场底部通常是缓慢乏味的V 形形态，或称长钉形 最后要讲的这种反转形态可谓神出鬼没，在其出现时最难于判别，但它并不罕见。实际上，因为V形顶或底（或称长钉形）其实不是形态，所以我们极难判定。前面讨论的所有的反转形态均代表着趋势的逐渐变化。现存趋势先逐渐放缓，进而供求双方的力量对比达到相对平衡，最终，买卖双方通过“拔河比赛”，决定原有趋势到底是反转还 是恢复。 在前面的各种形态中，价格有一段横向延伸的时间，分析者能够利用这个机会研究市场行为，仔仔细细地探求 其去向的线索。这种阶段称为转换阶段。这是绝大部分反转形态的特点。 然而，V 形形态代表着剧烈的市场反转，同市场逐步改变方向的惯常方式大相径庭。当它发生时，在几乎毫无 先兆的情况下，趋势出人意料地突然转向，随即向相反的方向剧烈地运动。因为其身后并无形态可寻，从而其本质是非形态的。这类变化极为经常地孕育在关键反转日或岛状反转（见第四章有关内容）之中。交易商如何预期这类形态的降临，从而在其实际发生时，及时地把它判别（或至少猜测）出来并采取适当的措施呢？为了解答这些问题，我们要进一步深入研究V形顶形态（见图 5.9a 到 c）。 图 5.9a V 形顶（或称长钉形顶）的例子。此类形态通 图 5.9b V 形底（或称长钉形底）的例子。下降趋势常出现在失控的牛市环境中，事前市场向上伸展得太极快地反转为上升趋势，事先毫无征兆，中间也没有过分了。转折点通常以关键反转日或者岛形反转的形转换阶段。这可能是最难以识别和交易的价格形态。 式发生。届时市场陡然反转，突然掉头。 首先，事先必须有趋势存在。趋势以 V 形反转的现象，极经常地出现在市场持续上涨，一路很少调整或只有微小调整的情况下。通常，事前已经发生过数次价格跳空。当前的局面显得失去了控制，市场似乎已远远超出了绝大多数正常预期。目前，大部分职业交易商对这种情况已经提高警惕了。 我们可以想见，交易商当然梦想着自己能够在这种脱缰了似的市场中赶上潮流。但是从某个时刻开始，即便是最富经验的交易商也开始因为上涨的持续而不安。这种情况实在好象“骑虎难下”一样，抓住老虎，安全地爬上虎背只是开头，如何不出危险又不失体面地从虎背上下来才是棘手的难题。 这种困扰事出有因。市场有个极难对付的坏习惯，一旦它脱缰之后，起初总要朝一个方向走得过远，然后，又常常会向相反的方向突然反噬回来，就象一根橡皮带被拉得太长，突然“唰”地反弹回来。这类突然回弹的特点是，事先通常无迹可寻，事后，市场向相反方向的剧烈运动，往往引发一系列交易所涨（或跌）限价。 图5.9c V形反转的实例。在取暖油市场的图表上，象V字或长钉一样的突然反转屡屡发生。由于其中缺乏转换阶段，市场变得难以驾驭。请注意图中的许多关键反转日和岛形反转 V 形反转的形成条件 形成 V 形反转的主要条件是陡峭的或脱缰的趋势。其转折点以关键反转日或岛状反转形态为标志，同时伴随着重大的交易量。有些时候，这种反转的唯一有效信号是，市场对其非常陡峭的趋势线的突破。移动平均线在这种情形下帮助不大，因为它的天性使它滞后于失控的价格变化。 随之而来的下跌，通常在极短的时间内回撤到原先趋势的某个显要的比例（多达 1，3 或50%“）位置。发生这 种反向剧烈运动的原因之一是，在原先趋势中缺乏支撑和阻挡水平，它一路上的许多价格跳空也留下了“真空”。 事情发生后，在市场顶部被套牢的人急于抛售，以摆脱亏损头寸，这就反过来进一步加剧了下跌的速度。所以，另外一个危险的信号是，事前市场上高得非同寻常的持仓兴趣，尤其是在持仓兴趣的增长主要发生在原先趋势的后面部分的情况下（我们将在第七章中更多地讨论持仓兴趣）。 交易商面临着两难选择，一方面，市场趋势强劲，大大地有利可图；另一方面，他不得不选择恰当的时机，及时平仓出市，以免被套住。他总可以利用逐步尾随的保护性止损指令“让利润充分增长”，这是既能防止趋势突然反向，又能充分积累利润的常用的方法。问题是，在市场失控之后，V 形反转突如其来，即使我们已经预先设置好止损指令，但是由于市场在相反的方向经常发生限价的情况，平仓出市变得出奇地困难。而如果交易商试图猜想此类顶部即将降临，预先平仓获利，那么结果通常是过早地出市，丧失了更多的潜在利润。当然，话说回来，没有人敢说发财是件如履平地的容易事。 这里，我们主要讲述了市场的顶部。底部介绍得较少。虽然本形态在两种情况下均有发生，但最剧烈的实例还 是出现在顶部。 扩展 V 形反转形态 V 形形态有一种变体，称为扩展 V 形形态。在这种形态中，当市场反向后，很快形成一个小平台，除此之外，它与V形形态基本一致。如图5.10a所示，平台通常形成在图形的右侧。它与旗形形态（在第六章中讲解）颇为相似，也朝新趋势的相反方向稍稍倾斜。 在顶部，平台向上倾斜；而在底部，则往往向下倾斜。当平台出现时，交易量亦会有所下降，然后在趋势恢复之后，交易量再度增长。在平台突破后，我们就认为该形态已经完成了。扩展V形反转形态比真正的V形形态要少见些，但它能够为图表分析者提供更多的反应机会。在平台阶段，我们要么可以平仓了结旧头寸，要么可以顺着新 趋势的方向开立新头寸。 图 5.10a扩展V形顶的例子。在市场转折后，马上形图5.10b左侧扩展V形顶的例子。这类形态相当成了一个小平台。通常，它稍稍地斜向新趋势的相反方少见。它与正常的扩展V形一样，只是其平台超前向。当平台被突破时，趋势反转的过程也就完成了。底 于市场的转折点。 部扩展 V 形反转的形态与此类似，但上下正好倒过来。 左侧扩展 V 形形态 本形态比扩展 V 形形态更为少见，其中平台出现在形态的左侧，先于市场的反转（见图 5.10b）。尽管这种形态在市场反向后对交易商无甚价值，但它也能提供一点参考。它原先在图上形成的向上反弹低点一旦被向下突破，则顶部形态便完成了。这个向上反弹低点也许暂时从市场下方提供了一定的支撑，从而减缓了下跌的速度，使交易商有更多的应对时间。 结语本章我们讨论了五种最常用的主要反转形态—头肩形、双重顶和底、三重顶和底、圆形以及V形。其中最普遍的是头肩形，双重顶和底，以及V形反转。这些形态通常意味着趋势正在发生重要的转折，因而被划分到主要反转形态这一类中。还有另一类形态，它们在本质上较为短期，且通常表示趋势的休整而不是反转，所以恰如其分地，我们把它们归结为持续形态。下一章我们将对后面这类形态展开研究。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第四章 趋势的基本概念]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E8%B6%8B%E5%8A%BF%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 趋势的定义在技术分析这种市场研究方法中，趋势的概念绝对是核心内容。图表分析师所使用的全部工具，诸如支撑和阻挡水平、价格形态、移动平均线、趋势线等等，其唯一的目的就是辅助我们估量市场趋势，从而顺应着趋势的方向做交易。在市场上，“永远顺着趋势交易”、“决不可逆趋势而动”、或者“趋势即良友”等等，实在已经是老生常谈了。因此我们要花些功夫，给趋势加以定义和分类。 从一般意义上说，趋势就是市场何去何从的方向。不过，为了便于实际应用，我们需要更具体的定义。在通常情况下，市场不会朝任何方向直来直去，市场运动的特征就是曲折蜿蜒，它的轨迹酷似一系列前赴后继的波浪，具有相当明显的峰和谷。所谓市场趋势，正是由这些波峰和波谷依次上升或下降的方向所构成的。无论这些峰和谷是依次递升还是依次递降，或者横向延伸，其方向就构成了市场的趋势。所以，我们把上升趋势定义为一系列依次上升的峰和谷；把下降趋势定义为一系列依次下降的峰和谷；把横向延伸趋势定义为一系列依次横向伸展的峰和谷（见图4. 1a到d）。 图4.1a 上升趋势的例子，其中峰和谷均依次递升 图4.1b 下降趋势的例子，其中峰和谷均依次递降 图4.1c 横向延伸趋势的例子，其中峰和谷均水平伸展。这类市场常常被称为“无趋势”市场。 图4.1d 图中左边为下降趋势，当前为横向延伸趋势。如果市场决定性地向上突破了8月/11月的高点，则将开始新一轮上升趋势。如果市场收市于7月/9月的低点之下，则下降趋势恢复。 趋势具有三种方向我们所说的上升、下降、横向延伸三种趋势都是有充分的依据的。许多人习惯上认为市场只有两种趋势方向，要么上升，要么下降。但是事实上，市场具有三个运动方向—上升，下降，以及横向延伸。仅就保守的估计来看，至少有三分之一的时间，价格处在水平延伸的形态中，属于所谓交易区间，所以，弄清楚这个分别颇为重要。这种水平伸展的状况表明，市场在一段时间内处于均衡状态，也就是说，在上述价格区间中，供求双方的力量达到了相对的平衡（我们曾经交代，道氏理论用水平直线来描述此类价格形态），不过，虽然我们把这种持平的市场定义成横向延伸趋势，但是更通用的说法还是“没有趋势”。 大多数技术工具和系统在本质上都是顺应趋势的，其主要设计意图在于追随上升或下降的市场。当市场进入这种持平的或者说“没有趋势”的阶段时，它们通常表现拙劣，甚至根本不起作用。恰恰是在这种市场横向延伸的时期，技术型交易商最易受挫折，而采用交易系统的人也蒙受着最大的损失。顾名思义，对顺应趋势系统来说，首先必须有趋势可循，然后才能施展功用。所以，失败的根源不在系统本身，而是在于交易商，是交易商操作错误，把设计要求在趋势市场条件下工作的系统，运用到没有趋势的市场环境之中了。 期货交易商有三种选择—先买后卖（做多头）、先卖后买（做空头）、或者拱手静观。当市场上升的时候，先买后卖当然是上策。而在市场下跌的时候，第二种选择则是首选。顺理成章，逢到市场横向延伸的时候，第三个办法—拱手静观—通常是最明智的。 趋势具有三种类型（规模）趋势不但具有三个方向，而且通常还可以划分为三种类型，这在前一章我们已有介绍。这三种类型就是主要趋势、次要趋势和短暂趋势。实际上在市场上，从覆盖几分钟或数小时的非常短暂的趋势开始，到延续50年乃至100年的极长期趋势为止，随时都有无数个大大小小的趋势同时并存、共同作用。然而，大多数技术分析人员对趋势的分类仅限于上述三种，那么在不同的分析者之间，对各类趋势的定义当然不免就有一定混乱了。 例如在道氏理论中，主要趋势实际上是针对长于一年者而言。因为期货交易商所操作的时间域比股票投资者要短些，所以在期货市场上，我们倾向于认为长于六个月便是主要趋势。道氏把次要趋势（或中趋势）定义为延续三个星期到数月者，这在期货市场上也大抵合适。至于短暂趋势，通常被定义成短于2到3个星期者。 每个趋势都是其上一级更长期趋势的一个组成部分。比如说，中趋势便是主要趋势中的一段调整。在长期的上升趋势中，市场暂缓涨势，先调整数月，然后再恢复上升，就是一个很好的例子。而这个中趋势本身往往也由一些较短期的波浪构成，呈现出一系列短暂的上升和下降。我们反复强调，每个趋势都是其更长期一级趋势的组成部分，同时它自身也是由更短期的趋势所构成（见图4.2a和b）。 图4.2a 本图例展示了趋势的三种规模：主要趋势、次要趋势和短暂趋势。点1、2、3、4表示了主要上升趋势。2-3浪代表主要上升趋势中的次要性调整。同时，每一个次要的浪也可划分成短暂趋势。例如，次要浪2-3可以分成短暂浪A-B-C。 图4.2b 本图为棉花合约日线图。如果有人问及其中的趋势，那么，主要趋势向下，中等趋势（过去6周内）为横向伸展，短暂趋势（过去2周内）向上。在言及趋势的方向前，我们首先必须明确其规模。 在图4.2a中，如点1、2、3、4所示，相邻的峰和谷依次上升，从而主要趋势为上升趋势。点2-3之间的调整阶段表示了一个调整性次要趋势，它是上升主要趋势的一部分，但请注意，点2-3之间的变化同时也由A、B、C三个较小波折构成。在点C，分析者或许会判断主要趋势依然为升势，但次要趋势和短暂趋势却是跌势。在点4，三个较小趋势均呈升势。趋势具有各种时间规模，理解它们在时间尺度上的分别是极为重要的。如果有人问您某市场趋势怎样，那么除非您了解此人是针对何种时期而言，否则要回答他，即使不是不可能，也是非常困难的。或许您不得不照上面划分三种趋势类型的办法，来个对号入座。 不同交易商所理解的趋势往往也不同，所以有相当多误解。对长线交易商来说，为时几天乃至几个星期的价格变化也许无关紧要。而在当日交易者眼中，持续二三天的上升便构成一个主要的上升趋势了。所以，当我们讨论市场时，特别要紧的是弄清楚趋势的时间规模，确认双方所指的是否是同一个概念。 一般说来，在期货市场上，大多数顺应趋势方法的焦点实际上是中趋势，即可能延续数月者。短暂趋势主要用来选择出入市的时机。在中等的上升趋势中，短暂的回落可以用来建立多头头寸。而在中等的下降趋势中，短暂的上弹可以用来开立空头头寸。 支撑和阻挡在前面关于趋势的讨论中，我们说价格运动是由一系列波峰和波谷构成的，它们依次升降的方向决定了市场的趋势。现在我们就来给这些峰和谷适当地命名，同时也引入支撑和阻挡两个概念。 我们把谷，或者说“向上反弹低点”，称为支撑，用某个价格水平或者图表上某个区域来表示。这个术语名实归一。在其下方，买方兴趣强大，足以撑拒卖方形成的压力。结果价格在这里停止下跌，回头向上反弹。通常，当前一个向上反弹的低点形成后，就可以确定一个支撑水平了。在图4.3a中，点2和4分别代表上升趋势中的两个支撑水平（见图4.3a）。 图4.3a 本例表示上升趋势中依次上升的支撑和阻挡水平。点2和4为支撑水平，通常由过去的向上反弹低点形成。点1和3为阻挡水平，通常以过去的峰为标志。 阻挡，也以某个价格水平或图表区域来表示。与支撑相反，在其上方，卖方压力挡住了买方的推进，于是价格由升转跌。阻挡水平通常以前一个峰值为标志。在图4.3b中，点1和3分别是两个阻挡水平。图4.3a所示为上升趋势。在上升趋势中，支撑和阻挡水平呈现出逐步上升的态势。图4.3b展示的是下降趋势，其中峰和谷都依次降低。在这个下降趋势中，点1和3为市场下方的支撑水平，点2和4为市场上方的阻挡水平。 图4.3b 本图表示下降趋势中的支撑和阻挡水平。 在上升趋势中，阻挡水平意味着上升势头将在此处稍息，但此后它迟早会被向上穿越。而在下降趋势中，支撑水平也不足以长久地撑拒市场的下滑，不过至少能使之暂时受挫。 为了完整地理解趋势理论，我们必须切实领会支撑和阻挡这两个概念。如果上升趋势要持续下去，每个相继的低点（支撑水平）就必须高过前一个低点。每个相继的上冲高点（阻挡水平）也非得高过前一个高点不可。在上升趋势中，如果新的一轮调整一直下降到前一个低点的水平，这或许就是该上升趋势即将终结、或者至少即将蜕化成横向延伸趋势的先期警讯。如果这个支撑水平被击穿，可能就意味着趋势即将由上升反转为下降。 在上升趋势中，每当市场向上试探前一个峰值阻挡的时候，这个上升趋势总是处于极为关键的时刻。一旦在上升趋势中市场不能越过前一个高点，或者在下降趋势中市场无力跌破前一个低谷支撑，便发出了现行趋势即将有变的第一个警告信号。在市场试探这些支撑和阻挡水平的过程中，在图表上会形成各种图案，这就是所谓价格形态。在第五章和第六章，我们就要表明，市场如何通过各种价格形态，来暗示自己到底是处在趋势反转过程中、还是仅仅处在既存趋势的休整之中。无论如何，构造这些形态的基本砖石还是支撑和阻挡水平。 图4.4a到c是趋势反转的典型范例。请注意，在图4.4a中，价格在点5，先是无力冲越前一高点（点3），然后就掉头向下，跌破了点4所示的前一个低点。这种趋势反转其实可以简单地通过观察支撑和阻挡水平来判别。这类反转形态就是所谓双重顶。 图4.4a 趋势反转的例子。在点5，价格无力向上超越过去的峰点3，然后又向下跌破了先前的低点4，这就构成了向下的趋势反转。此类形态称为“双重顶”。 图4.4b 底部反转形态的示例。通常，形成底部形态的第一个征兆是价格在点5能够维持在先前的低点3之上，而当价格向上穿越了先前的峰点4，这个底部形态就得到了验证。 图4.4c 底部反转形态的一个典型范例。请注意，6月的低点维持在5月的低点之上。当6月中旬的峰被向上穿越后，趋势转而向上。 支撑水平和阻挡水平可以互换角色到此为止，我们把“支撑”定义为前一个低点，“阻挡”定义为前一个高点。实际上，情况并不始终如此。下面我们就来谈谈支撑和阻挡的另一个更有意思也更鲜为人知的方面—它们的角色互换。只要支撑或阻挡水平被足够大的价格变化切实地击破了，它们就互换角色，演变成自身原先的反面。换言之，阻挡水平就变成了支撑水平，而支撑水平变成了阻挡水平。为了理解其中的奥妙，下面我们先讲一讲形成支撑和阻挡水平的一点心理根由。 支撑和阻挡的心理学简明起见，我们把市场参与者分为三种—多头者，空头者，和观望者。多头者为已经买进了合约的交易商，空头者指已经卖出了合约的交易商；观望者则或者是已经平仓出市者，或者是尚在买与卖之间犹豫不决者。 我们假定市场在某个支撑区域波动了一段时间之后开始向上移动。多头者（在接近支撑区域买进的人）很高兴，但心犹不足的是当初没有买得更多些。如果市场再掉回支撑区域附近，再增加些多头头寸，那该多妙啊！空头者现在终于认识到（或者非常怀疑）自己站错了队（市场从该支撑区上升的距离对这种判断当然极有影响力，我们留待稍后讨论），空头者但愿（而且祷告老天）价格再跌回他们卖出的区域，这样，他们就能在入市的水平（即“盈亏平衡点”）脱身。 观望者有两种—有的从未持有过头寸，有的因为这样那样的原因已经在支撑区把手上的多头头寸卖出平仓了。后一种人过早地平掉了多头头寸，当然追悔莫及，于是他们指望再有机会在接近他们卖出的地方把那些多头头寸补回来。 最后说到那些犹豫不决的人了。他们现在终于认识到价格将进一步上涨，下决心在下一个买入的好时机进入市场，站到多头一边。所有的四种人现在都决意在下一轮下跌中买进，那么市场下方的这个支撑区域就关系到大家的“既得利益”。如果价格下降到该支撑附近，上述四个群体新的买进自然会把价格推上去。 在该支撑区域发生的交易越频繁，就意味着越多的市场参与者在此处拥有“既得利益”，因而该支撑区就越发重要。支撑或阻挡区的重要程度可以由以下三个方面决定：市场在该处所经历的时间、交易量、以及交易活动的发生时间距当前的远近。 价格在某个支撑或阻挡区逗留的时间越长，该区域就越重要。比方说，如果价格在上升之前，在一个“乱麻区域”徘徊了三个月，那么这个支撑区就比市场仅逗留了三天的一个支撑水平重要。 交易量是衡量支撑和阻挡区重要程度的另一依据。如果支撑区域在形成过程中伴随着高额的交易量，就意味着此处有大量合约易手，相应的水平就比交易平淡之处的水平重要。点数图能够展示每日内的交易活动细节，把它用来辨识那些交易发生得最多、因而可能最有效的支撑和阻挡的时候，特别有用。 第三个办法是根据交易发生的时间距当前的远近程度，来判断相应的支撑或阻挡区的重要性。因为交易商是针对市场变化、针对现有头寸或未及开立的头寸采取行动的，所以，交易活动发生的时间越近，有关水平发生影响的潜力越大。 现在我们反过来，设想市场不是上升，而是下降。正如上面的例子所展示，在上升趋势中因为价格有所上升，市场参与者对每次下降的综合反应是更多地买进（因而产生了新的支撑）。然而，如果价格开始下跌，且跌破了前一个支撑区域，情况便恰然相反。所有在支撑区买进的人现在都认识到他们弄错了。更糟糕的是他们的经纪人开始发疯地催促他们追加保证金。因为期货交易具有高杠杆率，交易商难以对亏损的头寸坐视得太久。他们要么得补足保证金，要么得忍痛割爱，平掉多头头寸。 原本造就支撑区域的，是在其下方占压倒多数的买进指令，而现在所有买进指令全部转化成位于其上方的卖出指令。这一来，支撑就转变为阻挡。原先的支撑区越重要-就是说，那里的交易越活跃、距目前越接近—那么，现在的阻挡潜力便越强大。上述三种人-多头者，空头者，和观望者—当初造就支撑的所有动因，现在恰好反过来，为以后的价格上冲或者弹升压上了一个盖子。 图表分析师所使用的价格形态、以及诸如支撑和阻挡等概念确实能够说明问题，我们不妨对其原因推敲推敲，作一点反思。事实上，绝不是图表或我们在图表上画出的辅助线条具备什么魔力。这些工具之所以发生作用，是因为它们如实描画了市场参与者的所作所为，使我们得以清晰地把握市场参与者对各类市场事件的反应。图表分析其实是对人类心理学，即交易商对不断发展的市场情况所作反应的研究。遗憾的是，由于商品期货市场的世界变化很快，人们往往过分依赖图表分析的术语及其简称，而把从根本上造就图表形态的真正力量丢在了脑后。我们何以能够从价格图表上辨识支撑和阻挡水平，何以能够用它们来辅助预测市场运动，从心理学上都可以找到切实的依据。 支撑转化为阻挡，反之亦然：穿越程度支撑水平被市场穿越到一定程度之后，就转化为阻挡水平。反之亦然。图4.5a到c与图4.3a和b类似，但稍有改动之处。请注意，在图4.5a中随着价格的上升，向上反弹低点4出现在高点1的价位上或者其上方。点1所示的前一个高点曾经是一个阻挡水平，但是一旦这个阻挡峰值被3浪所示的动作决定性地向上穿越之后，就转化为支撑水平。所有先前在1浪所达高点附近卖出的人（这是导致这一阻挡水平的原因）现在都摇身一变，成了买方。图4.5b展示了价格下跌时对应的情况，点1（曾经是支撑水平）目前演化为点4所示的阻挡水平，给市场封了顶。 图4.5a 在上升趋势中，当阻挡水平被市场以足够大的幅度向上穿越后，就演变为支撑水平。注意，一旦点1处的阻挡被击破，它就在点4处构成了支撑。先前的峰值在以后的市场调整中将起到支撑作用。 图4.5b 在下降趋势中，如果支撑水平被跌破，则演化为阻挡水平。请注意，点1过去是支撑，现在变成了点4处的阻挡。 图4.5c 请注意，图中7月的先前的支撑性低点，在11月演变成了阻挡障碍。支撑变成了阻挡。10月的低点也演化成12月的阻挡。 前面曾提到过，价格从支撑或阻挡水平弹开的距离越大，则该支撑或阻挡的重要程度也就越强。当支撑和阻挡被穿越从而角色变换时，这种距离特点尤为突出。试看例证。有个说法，仅当价格穿越支撑和阻挡水平达到足够程度的情况下，两者才互换角色。但是怎样才算足够呢？在判断这个问题时有相当多的主观色彩。有些图表分析师以穿越幅度达10%作标准，尤其是碰到重要的支撑和阻挡水平的时候。短线的支撑和阻挡区域可能只需要非常小的穿越幅度比例，比如3%到5%便可以肯定。实际上，每个分析师都有自己独立的有效穿越标准。不过请切记，仅当市场从支撑或阻挡水平穿越得足够远、致使市场参与者确信自己判断错误的情况下，两者才能互换角色。市场穿越得越远，人们便越信服自己的新认识。 在判别支撑和阻挡时，习惯数值很重要市场倾向于在习惯数上停止上升或下跌。交易商总喜欢以一些重要的习惯数，比如10，20，25，50，75，100（以及100的整数倍），作为价格目标，并相应地采取措施。因而这些习惯数常常成为“心理上的”支撑或阻挡水平。根据这个常识，交易者可以在市场接近某个重要习惯数时平仓了结，实现利润。 黄金市场可以作为这种现象的绝好例证。1982年熊市的最低点恰好是300美元。接着在1983年首季，市场大举回升到稍高于500美元的位置，然后又跌退至400美元。1983年底，价格跌破400美元。在之后的六个月里，市场曾三次徒劳无功地向上试探400美元（此时已成为阻挡水平了）。就在我们写作本书的时候，金价又跌回300美元的支撑区域。450和350美元两个水平也都是重要的支撑和阻挡区。在300美元以下，下一个长期的支撑区在250美元附近。另外，1974年牛市的最高点曾经接近200美元，而1976年熊市的最低点在100美元。 这一惯例还有个应用，就是说不要将交易指令的水平正好设置在这些明显的习惯数上。比方说，如果交易商试图在上升趋势中趁市场短暂下跌的时机买进，那么把限价指令的水平设置在稍高于某个重要习惯数上就很充分。因为其他人都企图在习惯数上买进，市场或许就跌不到那里。如果交易商试图在下降趋势中利用市场向上反弹的机会卖出，就应该把卖出指令的水平安排在稍低于习惯数的位置上。如果我们要对已有的敞口头寸设置保护性止损指令，那么其做法同开立新头寸的时候正好相反。一般说来，我们应该避免把保护性止损指令的水平设置在明显的习惯数上。举例来说，站在卖出一方的交易商，不应该把止损指令放置在4.00美元，而应放在4.01美元。或者反过来，多头头寸的保护指令应当安排在3.49美元而不是3.50美元。 换言之，买盘（多头）的保护指令应低于习惯数，而卖盘（空头）的保护指令应高于习惯数。市场遵循习惯数，特别是这些较重要习惯数的倾向，是其特征之一，这一特征对期货交易颇有助益，因此技术型交易商应该把它熟记于心。 趋势线 现在朋友们已经理解了支撑和阻挡，那么我们的技术库中就可以添上另一幅基本工具—趋势线了（见图4.6a到c），趋势线是图表分析师所使用的最简便同时也是最有价值的基本技术工具之一。如图4.6a中的直线所示，上升趋势线是沿着相继的向上反弹低点联结而成的一条直线，位于相应的价格图线的下侧。下降趋势线是沿着相继的上冲高点联结而成的，位于价格上侧，如图4.6b所示。 图4.6a 上升趋势线的图例。上升趋势线是由依次上升的向上反弹低点连接而成的。首先在两个相继的依次上升的低点（点1和3）之下作出尝试性趋势线，然后还需要第三个点（点5）来确认该趋势线的有效性。 图4.6b 下降趋势线是通过连接依次下降的上冲高点作出的。先由两点（点1和3）作出尝试性下降趋势线，然后通过第三点（点5）验证其有效性。 图4.6c 下降趋势线的例子。12月的上冲高点验证了由10月/11月的高点作出的趋势线。 趋势线作法 正如图表分析的其它方面一样，正确地作出趋势线也是一门技艺。通常，为了发现恰当的趋势线，我们有必要尝试好几条直线。有时候，一条趋势线起初貌似正确，最终却不得不擦去重来。当然，也有一些颇具价值的要领，有助于我们探索出合适的趋势线。 首先，必须确有根据说明趋势存在。换句话说，为了画出一条上升趋势线，我们至少需要两个有效的向上反弹低点，并且后者要高于前者。不用说，两点决定了一条直线。例如在图4.6a中，仅当价格从点3开始向上推进后，图表分析者才能够合理地判定新一轮向上反弹的低点已经形成，然后才可以通过点1和3画出一条尝试性的上升趋势线。 某些图表分析师要求市场从点3起向上穿越点2所示的峰，从而使上升趋势得到证实之后，才作出这条趋势线。而另外一些人只要求市场从点3起把点2到3之间的价格变化回撤50%，或者上升到接近点2，应该记住的要点是，无论标准是否一致，图表分析者都必须首先合理地确认一个反弹低点已经形成，然后才谈得上判定它的有效性。一旦确认出了两个依次上升的有效低点，把它们连接起来便得到一条趋势线。它位于价格的下侧，向右上方伸展。 试验趋势线与有效趋势线以上所得到的还只是“试验性”的趋势线。为了验证其有效性，必须看到价格第三次触及该线，并从它上面再次反弹出去。如图4.6a所示，价格在点5对上升趋势线试探成功，于是该趋势线的有效性得到了验证。图4.6b展示的是下降趋势的情况，不过道理是一致的，在点5处也出现了对趋势线的成功试探。归纳起来，我们首先必须有两点方可作出趋势线；然后用第三个点来验证其有效性。 怎样使用趋势线只要第三点应验了，并且趋势仍照既定的方向继续发展，那么上述趋势线就在好几方面大有用武之地。趋势概念的基本观点是，既成趋势的下一步常常是顺势发展。由此推论，一旦某个趋势如其趋势线所标志，具备了一定的坡度或演进速率之后，通常将继续保持同样的坡度。因此趋势线不仅可以确定在市场调整阶段价格的极限位置，更重要的是，可以显示出在何种情况下原趋势正在发生变故。 举例来讲，在上升趋势中，调整性的下跌是不可避免的，但它经常只是触及或非常接近相应的上升趋势线。因为期货商的目的就是在上升趋势中乘跌买进，所以趋势线在市场下方所提供的支撑边界，正好可以用作买进区域。而下降趋势线则可以用作阻挡区，达成卖出目的（见图4.7a和b）。 图4.7a 一旦上升趋势线确立以后，就可以利用随后市场跌近该趋势线的机会买进。图中点5和7就是开立新多头或增开多头头寸的好机会。当市场在点9处跌破趋势线后，就意味着趋势要向下反转，要求我们平仓了结所有的多头头寸。 图4.7b 图中点5和7可以用作卖出区。当市场在点9处突破该趋势线后，就构成了向上的趋势反转信号。 只要趋势线未被突破，我们就可以用它来确定买入或卖出区域。然而如图4.7a和4.7b在点9所示，万一趋势线被突破了，也就发出了趋势生变的信号，要求我们平仓了结当初顺着原有趋势方向建立的所有头寸。趋势线的突破常常是趋势生变的最佳预警信号。 如何确定趋势线的重要程度下面我们把对趋势线的讨论深入一步。首先，到底由什么因素来决定一条趋势线的重要程度？答案包含两个方面—它未被触及的时间越长，所经过试探的次数越多，则越重要。比如说，有条趋势线成功地经受了8次试探，从而连续8次地显示了自身的有效性，那么它显然比另一条只经受了3次试探的趋势线重要。另一方面，一条持续有效达9个月之久的趋势线，当然比另一条只有9个星期乃至9天有效历史的趋势线更重要。趋势线的重要性越强，由其引发的信心就越大，那么它的突破也就越具重要影响。 趋势线应描述全部价格变化在线图上作趋势线时，应当把它描画在全部价格范围之下或之上。有些图表分析师更喜欢通过收市价格来作趋势线，这种做法并不标准。虽然收市价格在全天的所有价格中确实可能是最重要的，但它依然只能代表全日价格活动的一个片断。而当日全部价格范围包含了当日的所有价格变化，理应更有意义（见图4.8）。 图4.8 画趋势线的正确方法是，把每天的全部价格区间都包括进来。 如何对待对趋势线的细小穿越有时候某一日内的价格变化可能一度穿越趋势线，但当天的收市价格依苦符合原趋势的要求。在这种情况下，该趋势线是否可以视为被突破？对此，分析者就会有所困惑（见图4.9）如果结果表明这个小小的穿越只是暂时性的，那么为了把新的价格资料包括进来，我们是否有必要重新画一条趋势线呢？图4.9展示了这种情形。当天价格曾一度滑过原趋势线，而后收市价格又回到该趋势线之上。我们有必要重作趋势线吗？ 棘手的是在这种情况下没有一成不变的规则可循。有时候，尤其是在随后的市场行为证明原趋势线依然有效的情况下，我们最好忽略这种“毛刺”。有些时候则必须折衷一下，如图4.9中虚线所示，补充一条新的试验性的趋势线。那么图表分析者在考察未来价格时，就既有原趋势线（实线）、又有新趋势线（虚线）以资参照了。这里有条普遍经验：如果突破原趋势线的动作的规模相对较小，只是当天内的一时之举，并且收市价又回到原趋势线之上，那么上策可能是忽略这个“毛刺”，仍旧使用原趋势线。正如其它许多市场分析领域一样，碰上这种模棱两可的情形时，分析者只有靠自己的经验和主观判断来定夺。 图4.9 有时候，日内价格变化可能一度穿越趋势线。那么，在这种情况下，过去蹬趋势线是否还有效，或者是否应该重新作趋势线呢？折衷的办法是，既保留旧的趋势线（实线），也作出新的趋势线（虚线），这样更便于甄别真正的趋势线。 什么是对趋势线的有效突破解答这个问题也要牵涉到不少主观性的成分。一般地说，收市价格越过趋势线要比仅仅只有日内价格穿越趋势线更有分量。再进一步，有时甚至只有一个收市价的穿越也还不足以说明问题。为了辨识有效的趋势线穿越，排除坏信号（所谓“拉锯现象”），技术分析者设计了不少时间和价格“过滤器”。所谓”3%穿越原则”便是价格过滤器的一例。这种价格过滤器主要用于鉴别长期趋势线的突破，它要求收市价格穿越趋势线的幅度至少达到3%，才能判定为有效突破（3%原则不适用于一些金融期货，例如利率期货市场）。 举例来说，如果在黄金价格图表上，有一条重要上升趋势线当前正处在400美元的水平，那么为了证明该线已被突破，当日收市价格必须在其97%以下的水平（此时收市价格将在趋势线以下12美元开外，即388美元）。显然，对短线交易商来说，要求他们坐视价格走过12美元是不恰当的，1%原则或许更合适。3%原则仅仅是价格过滤器的一种类型。有些图表分析者针对不同市场，选用了各种“最小价格波动容许值”。也有人根本不采用价格过滤器。不论选用何种价格过滤器，都有个一半对一半的机会问题。如果过滤器设置得太小，那么减少“拉锯”影响的效果则不佳。如果选得太大，那么在有效信号出现之前，就错过了一大截初始动作时机。所以此处也不例外，交易商必须结合考虑所追随市场的趋势发育程度，灵活选择最适合的过滤器，具体市场具体分析。 价格过滤器的趋势线有效穿越标准，要求收市价格的变化达到预定的价格幅度或百分比。此外我们还有另一种选择—时间过滤器。其中最常见的为“两天原则”。换句话说，为了对趋势线构成有效突破，市场必须连续两天收市在该直线的另一侧。于是，要突破上升趋势线，价格就必须连续两天收市在该直线的下方。只持续一天的话，突破是不成立的。最后我们还必须补充一点，3%原则和2天原则不仅适用于考察重要趋势线的突破，也同样可以应用于鉴别市场对重要支撑和阻挡水平的突破。 趋势线如何互换角色前面讲过，一旦支撑和阻挡水平被击破，其角色就互相对换。这个规律也用于趋势线（见图4.10a到c），换言之，上升趋势线（支撑线）一旦被决定性地向下突破后，就演化成阻挡线；下降趋势线（阻挡线）一旦被决定性地向上突破后，就演变为支撑线。正因为这一点，我们在趋势线被突破后依然把它们尽可能地向右延长。这种做法颇有玄机。旧的趋势线演化成自身的反面，在未来再度形成支撑线或阻挡线的现象实在屡见不鲜，令人惊叹叫绝。 趋势线的测算意义趋势线有助于测算价格目标。在后面关于价格形态的两章中，我们还要详细讨论价格目标的问题。实际上，那里要讲的由价格形态计算价格目标的内容，同此处趋势线的有关应用很有渊源。简要地说，一旦趋势线被突破了，那么价格离开趋势线的目标距离，通常同趋势反转以前价格在趋势线另一边曾经达到的竖直距离相等。 举例来说，如果在原先的趋势中，价格在上升趋势线的上方曾达到50美元（竖直地测量），那么在该趋势线被突破后，我们就可以预计价格将跌到低于趋势线50美元之处。在下一章，我们将看到这种测算技术。与众所周知的头肩形反转形态的测算技术相似，在那里，从“头”到“颈线”的距离，就是预测颈线被突破后的价格目标的依据。 图4.10a 本图表示上升的支撑线演化成了阻挡: 通常，支撑线被跌破后，在之后的上冲中将起到阻挡作用。 图4.10b 下降趋势线一旦被向上突破后，极经常地演化成支撑线。 扇形原理下面讲扇形原理。这是趋势线另一种颇有意思的用法（见图4.11a到c）。有时候，当上升趋势线被突破后，价格先是有所下跌，然后再度上弹，回到原上升趋势线的下边（该线此时已成为阻挡线了）。请注意，在图4.11a中，价格跌破1线后，再度弹升到1线下边，但是未能向上穿越1线。此时我们可以作出新的一条趋势线（2线）。随后2线也被向下突破了，然后价格又一次弹回，向上试探2线未果，于是我们得到第三条趋势线（3线）。第三条趋势线若再次被突破，通常就意味着价格将下跌了。在图4.11b中，第三条下降趋势线（3线）的突破构成了新一轮上 升趋势出台的信号。由上述两例来看。原先的支撑线被突破后均变成了阻挡线，原先的阻挡线被突破后均变成了支撑线，请朋友们注意其转化过程。图中依次变得平缓的三条直线形如扇子，扇形原理由此得名。请切记，第三条趋势线被突破是趋势反转的有效信号。 数字“3”的重要性在扇形原理中有三条直线互相作用。有趣的是，“3”这个数字在各种技术分析的理论和应用中都出现得很频繁，而且各有各的门道。说起来，不仅扇形原理用到三条线，而且重要牛市和熊市通常分成三个阶段（见道氏理论和艾略特波浪理论）；有三种价格跳空（稍后便要讲到）；某些较为典型的反转形态，诸如三重顶、头肩形等，均有三个显著的峰；趋势有三种不周类型（主要趋势、次要趋势和短暂趋势），以及三种不同方向（上升，下降和横向延伸）；在众所周知的持续性形态中，有三类三角形—对称三角形、上升三角形和下降三角形；我们的信息主要来源自三 个渠道—价格、交易量以及持仓兴趣。不管到底是什么缘故，反正3这个数字贯穿了技术分析的整个领域。担负着很重要的角色。 图4.11a 扇形原理示例。第三条趋势线被突破，构成趋势反转信号。请注意，趋势线 l和2被突破后，经常变成阻挡线。 图4.11b 底部过程中的扇形原理。第三条趋势线被突破，构成向上的趋势反转信号。先前被突破的趋势线（线1和2）常常成为支撑线。 图4.11c 扇形原理的实例。在4月的峰值之后的中等的向下调整中，形成了三条相继的扇形线。3线被向上突破后，表明上升趋势恢复。请注意这三条线在被向上突破后是如何演化成支撑线的。同时也请注意，自11月的峰点出发的下降趋势线如何漂亮地容纳了图表左侧的下降趋势。另外，自2月/3月的底部引出的上升趋势线，也很好地描述了新的上升趋势 趋势线的相对陡峭程度（斜率）趋势线的相对陡峭程度也很重要。一般来说，倾斜角度约为450的趋势线最有意义。某些图表分析家甚至简单地从图上某个显著高点或低点引出一条450倾角的直线，作为主要趋势线。江恩对所谓450线技术就特别垂青。这样的直线反映出的价格随着时间上升或下降的速率，恰好从价格、时间两个方面处于完美的平衡之中（江恩非常注重几何角度，而45-线又是其中最重要的。附录3对江恩的几何角度有进一步的介绍）。 如果趋势线过于陡峭（如图4.12中1线所示），那么通常表明价格上升得太快，因而难以持久。如果这样的趋势线被跌破了，可能只是意味着上升趋势的坡度将调整回450线上下（如2线所示），而不是趋势的逆转。如果趋势线过于平缓（如3线所示），则说明这个上升趋势过于衰图4.12大多数有效的趋势线与水平方向大约成450角（见线2）。如果趋势线过于陡峭（如线1），则通常意味着这种上升速度难以持久。而如果趋势线过于平缓（如线3），则说明相应的上升趋势过于衰弱，可能是靠不住的。不少技术分析者将从先前的顶点或底点引出的45直线作为主要的趋势线。 弱，因而不太可靠。除了关于江恩理论的部分外，我们在讨论三点反转和优化点数图时，也要谈到45线。 怎样调整趋势线 在有些场合，有必要对趋势线加以调整，以适应趋势放缓或加速的要求（见图4.13和图4.14a和b），正如前面的图例所示，在陡峭趋势线被突破后，我们可能有必要作出新的较平缓的趋势线。如果原先的趋势线过于平缓，或许也有必要画出新的更陡峭的趋势线来。如图4.13所示，在陡峭趋势线（1线）被突破后，必须作出较平坦的新直线（2线）。在图4.14中，原先的趋势线（线1）过于平缓，所以有必要作出更陡峭的新直线（2线），因为此时上升趋势已经加速了，必须用较陡峭的直线方可描述新的市场情形。要是趋势线距离当前价格变化过远的话，则它对追踪当前趋势的变化帮助不大。 在趋势加速的情况下，有时我们需要按角度依次增加的顺序作出好几条趋势线。某些图表分析师提倡利用弯曲的趋势线刻画这种情形。依据我个人的经验，在这种情况下，最好采用另一种工具-移动平均线，它与弯曲的趋势线异曲同工。同时掌握数种技术工具的好处，就在围4.13趋势线（线1）过于陡峭的例子。事实证明，原来的上升趋势线过于陡峭。经常地，当陡峭的趋势线被突破后，仅仅意味着市场将调整到一个较慢的、更持久的上升趋势线（线2）上。 图4.14a 上升趋势线（线1）过于平缓的例子。当上升趋势加速后，线1显然过于平缓，在这种情况下，我们应当作出另一条更陡峭的趋势线来（线2），以更紧凑地跟踪该上升趋势。 于可以得心应手地根据不同场合选择最合适的工具。本书所介绍的所有技术都不例外，在某些特定环境下表现良好的，在有些条件下可能就很差。如果技术分析师能掌握充分的后备手段，就能扬长避短，在各种特定环境下，分别选择最适合的工具。在加速的趋势中，如果用移动平均线来代替一系列越来越陡峭的趋势线，就更为有效、可靠。这是个很好的例证。 事实上在任何时刻，市场上总有好几种不同时间规模的趋势并存，因而我们有必要相应地采用不同的趋势线来分别描述各个等级的趋势。比如，主要上升趋势线系由主要上升趋势的低点连结而成的。同时也可以用较短的也较灵敏的直线描述中等的价格摆动。另外，还可以用更短的直线来描述短暂的运动（见图4.15）。 图4.15 我们采用各种不同的趋势线来描述不同等级的趋势。在本例中，线1是主要上升趋势线，定义了主要上升趋势。线2、3和4定义了中等的上升趋势。线5定义了处于最后一轮中等上升趋势之中的短暂的上升趋势。在一张图上，技术分析者往往同时采用许多种趋势线 管道线管道线，有时又被称为返回线，是趋势线技术的另一方面应用，也颇有价值。在有些情况下，价格趋势整个地局限于两条平行线之间—其中一条为基本的趋势线，另一条便是管道线。当这种情形出现后，如果分析者判断及时，就有利可图。 管道线的作法相对简单些。如图4.16a所示，在上升趋势中，我们首先沿着低点画出基本的趋势线，然后从第一个显著波峰（点2）出发，用虚线引出其平行线。两条直线均向右上方伸展，共同构成一条管道。如果下一轮上涨抵达管道线后折返下来（如点4处所示），那么该管道就成立了一半。如果这次折返一直跌回原先的趋势线上（如点5处所示），那么该管道就基本上得到了肯定。在下降趋势中，情况与上升趋势类似，但方向相反（见图4.16b）。 读者应该马上看出如此局面的有利可图之处。基本的上升趋势线是开立新的多头头寸的依据，而管道线则可用 作短线地平仓获利的参考。更积极的交易商甚至有可能利用管道线来建立与趋势方向相反的空头头寸（虽然这种逆着流行趋势方向做交易的策略可能招致危险，且常常要付出高昂的代价）。正如趋势线的情况一样，管道线未被触及的时间越长，试探成功的次数越多，那么它就越重要，越可靠。 图4.16a 趋势管道的例子。一旦作出了基本的上升趋势线（通过点1、3者），我们就可以通过点2处的第一个峰引出其平行线（用虚线表示），这就是管道线 图4.16b 在下降趋势中的趋势管道。其管道线从点2处的第一个低点出发，平行于基本的下降趋势线（通过峰1和3者）。价格经常维持在这样的趋势管道中 图4.16c 请注意，图中两条相互平行的上升趋势线包容了整个上升趋势。同时，在这个较大的管道中，还有一个次要的趋势管道。基本的上升趋势线（较低的直线）总是最重要的，不过，在上升趋势中，管道线也有助于标定上方的阻挡区。 重要趋势线被突破后，表明现行趋势发生了重大变故。但是上升管道线的突破恰好具有相反的意义，它表示流行趋势开始加速。有些交易商把上升趋势的管道线的突破视为增加多头头寸的依据。 此外，我们通常还可以利用管道技术来辨别趋势减弱的信号，这就是价格无力抵达管道线的情况。在图4.17中，价格无力达到管道的顶部（点5处），这也许就是趋势即将有变的警讯，显示另一条线（基本的上升趋势线）被突破的可能性有所增加。一般地，如果在既有管道中，价格无力达到某一边，则通常意味着趋势即将发生变化（加速或转折），也就是说管道的另外一边被突破的可能性增大了。 图4.17 如果市场无力抵达上侧的管道线，则经常构成警示信号，说明下侧的直线将被跌破。请注意，在点5处，价格无力达到上侧管道线，随后，在点6，跌破了基本的上升趋势线 我们也可以利用管道线来对基本趋势线进行调整（见图4.18和4.19）。如果价格显著地越过了上升趋势的管道线.则通常表明趋势增强.因此，某些图表分析家根据新的管道线，从最后一个向上反弹低点出发.平行地作出一条更陡峭的直线，作为新的基本上升趋势线（如图4.18所示）。新的更为陡峭的支撑线经常比原先的较为平缓的趋势线更奏效。类似地，在上升趋势中，当价格无力抵达管道的上边线时，我们可以根据连接最后两个波峰连接所得到的阻挡线，从最后的向上反弹低点出发，作出一条平行线.作为新的支撑线（如图4.19所示）。 图4.18 当上方的管道线被突破后（如浪5所示），许多图表师将按照平行于新的 上方管道线的方向，重作基本的上升趋势线。换言之，线4-6是平行于线3-5作出的。因为上升趋势正在加速，所以顺理成章，基本的上升趋势线也应做相应的调整。 图4.19 当价格无力抵达上侧管道线后，我们可以从两个相继降低的峰点 作出下降趋势线（线3-5），然后，通过点4，平行于线3-5，就可以作出尝试性的管道线。下侧这条管道线有时指明了可能出现初始的支撑的位置。 管道线还具有测算意义。一旦在价格管道的两条边线上发生了突破，价格通常将顺着突破方向达到与管道宽度 相等的距离。因此我们可以根据管道的宽度，从管道边线上的突破点起，简单地顺着突破方向投影出去，得出价格目标。 然而朋友们应切记，在组成管道的两条线中，基本的趋势线远比管道线重要，也更为可靠。在趋势线技术中，管道线是第二位的。不过管道线确实也很有用，值得揽入我们的工具囊中。 百分比回撤 朋友们从前面关于上升趋势和下降趋势的所有图例中，肯定已经注意到.在每场重大的市场运动之后，价格总要回撤其中的一部分。然后再按照既有趋势方向继续发展。这类与趋势方向相反的价格变化，往往恰好占先前动作 的一定的百分比。50%回撤便是一个众所周知的例子。举例来说，假定市场处于上升趋势，已经从100的水平上涨到200的水平，那么，接下来的调整常常是回撤到这场运动的一半处，即大约150的水平，然后市场才恢复原来的上升势头。这是一种十分常见的市场倾向，在期货市场上频繁地重现。同时，这种百分比回撤的概念也适用于任何规模的趋势—主要趋势、次要趋势和短暂趋势。 确切地说，在很大的程度上，50%回撤是市场的一种倾向性，而不是一条精确、严格的规则。此外，所谓最大 和最小百分比回撤—三分之一回撤和三分之二回撤—也是广为人知的。换言之，价格趋势可以分成三等份。通常最小的回撤大约是33%，最大的回撤约为66%。这就是说，在一个强劲趋势的调整过程中，市场通常至少回撤到前一个运动的三分之一的位置。有几方面的原因使这一常识极有意义。如果交易商试图在市场下方计划一个值得买入的价格，那么他可以在图表上算出33%-50%回撤的区域.以此为参考，来选择大致的买进机会（见图4.20a和b）。 图4.20a 价格在恢复原来的方向之前，常常要回撤先前的趋势进程的一半。这是50%回撤的情况。最小回撤为三分之一，最大回撤为三分之二。 最大回撤百分数为66%，这里对应着一个特别关键的区域。如果先前的趋势能够持续下去的话，那么调整必须 在三分之二处打住。于是，在这种关键区域，无论是在上升趋势中买进，还是在下降趋势中卖出，相对来说风险都比较小。如果在调整中价格越过了三分之二点，那么趋势反转的可能性就会大于单纯的调整了。下一步，价格通常将返回原先趋势的起点，也就是要100%地回撤了。 有心的朋友或许已经发现，上述三种回撤百分比—50%，33%和66%—都是从道氏理论原原本本地移植来的。当我们学到艾略特理论和菲波纳奇比数的时候，就会发现，它们也都步道氏理论的后尘，引入了38%和62%两种回撤百分比。我宁愿把两组数字结合起来，把最小回撤区域设为33%到38%，把最大回撤区设为从62%到66%。 有些技术分析者进一步地折衷，得出了40%和 60%两种回撤区域。熟悉江恩理论的人都知遵，他把趋势结构划分成八等份—1/8，2/8，…，8/8。不过，即便如此，江恩对3/8（38%），4/8（50%）和（5/8）（62%）的回撤比例也另眼相看，并且也觉得趋势三等分法—1/3（33%）和2/3（66%）—很重要。 谈到三分法，我们不妨再看看另一种将趋势线和百分比回撤融为一体的新技巧—速度线。它是埃德森·古尔德开创的，实质上也属于趋势三分法的具体应用。它与百分比回撤概念的最大的差别在于，速度阻力线（或称速度线）测绘的是趋势上升或下降的速率（或者说是趋势的速度）。 图4.20b 请注意，10月份的价格反弹，回撤到了当月的从86美分到76美分的跌幅的一半（价格恢复了5个美分，回到81美分）。12月早期的反弹几乎正好回撤了7从11月高点开始的下跌的三分之二。还请注意，9月份前期的接近81美分的低点，在10月/11月演变成了阻挡。看，趋势线何其有效地标志了其中一些市场转折点。它们并不总能这样灵验，但有些时候，它们是市场反转的最佳警示 速度阻挡线 在作牛市速度线的时候，首先要找到当前上升趋势的最高点（见图4.21）。在图表上，从这个最高点开始，向下作一条垂直线，直达趋势起点所在的水平位置。然后把所得的竖直线段三等分。通过趋势起点以及上述两个三等分点，我们可以作出两条趋势线，它们分别代表三分之二速度线和三分之一速度线。在下降趋势中，只要把上述程序相应地调整一下即可。也是先作出从下降趋势的最低点到趋势起点的水平位置的垂直线段，然后从趋势起点起，通过该线段的三等分点分别作出两条直线（见图4.21b和c）。 图4.21a 上升趋势中的速度阻挡线的例子。从顶峰到趋势起点的垂直距离被分成三等分。从点1出发，通过点2和3作出了两条趋势线。上方的直线为2/3速度线，下方曲直线为1/3速度线。在市场的调整过程中，这两条线应起到支撑作用。当它们被突破后，就变成了阻挡线。有时，这些速度线从价格变化的区间中穿过。 每当上升趋势出现新的最高点，或下降趋势出现新的最低点之后，我们都必须重新作出上述一系列直线（因为趋势已经有了新的高点或低点）。因为速度线是自趋势起点出发通过那两个三分点作出的，所以，这样的趋势线或许会从某些价格线段中穿过。这种趋势线没有画在低点或高点上，而是从价格变化中间穿过，是趋势线的一种特例。 速度线方法的理论依据同前面的 33%和 66%回撤的类似。如果上升趋势正处于调整之中，那么它向下折返的余 地通常是到上方的速度线（2/3速度线）为止，如果它又被超越了，那么，价格还将跌到下方的速度线（1/3速度线）；如果下方的速度线也被跌破了，那么价格就可能一路而下，直致原趋势的起点的水平。在下降趋势中。下方的速度线如果被突破，那么价格很可能上冲到上方速度线处。要是后者也失守，那就意味着价格将会涨到原趋势的起 点的水平。 图4.21b 下降趋势中的速度线 图4.21c 速度线在上升趋势和下降趋势中的实例。3月份熊市的终结，是以自11月的峰而来的2/3速度线的向上突破为标志的。而1/3速度线被向上突破后，就验证了新的上升趋势。自4月的峰而来的中等的调整过程，在自2月/3月的底部引出的上升的1/3速度线处打住。从春天的高点开始的下降运动，在自 4 月的高点引出的两条下降的速度线被向上突破时完成 正如所有的趋势线一样，速度线一旦被突破，角色也会反串。这样，在上升趋势的调整过程中，如果上面的线（2/3线）被突破，价格则跌到1/3线，再从后者上面反弹。这时候，上面的线已演变成阻挡障碍了。仅当上面这条线被重新穿回，那么价格才可能向原高点挑战。同样的道理在下降趋势中也成立。 反转日在趋势的概念中，还有一方重要的基石—反转日。这是一种特别的图形，有许多名目—如“顶部反转日”，“底部反转日”，“抢购或抛售高潮”，以及“关键反转日”等。这类形态就其本身而言，并不具有重要意义，但是一旦把它与其余技术资料综合起来考虑，就显得极不寻常。下面我们先给它下个定义。 反转日发生在市场顶部或者底部。顶部反转日有个通行的定义:在上升趋势中，某日价格达到了新的高位，但当天收市价格却低于前一日收市价。换句话说，在一个上升运动中，某日市场曾一度创下新的高点纪录（通常在开市时或在开市后不久），但当天价格便逐渐跌落，结果其收市价格反而比前一日的收市价还要低。底部反转日指在下 降趋势中，某天市场曾跌出新的最低点，但当日收市价格却高于前一日收市价。反转日的价格变化的范围越大，交易量越重，那么作为近期趋势可能反转的信号，它的分量就越重。图4.22a到c例示了两种反转日在线图上的形状。请注意，其中反转日对应着较重的交易量。同时也请注意，在这两例中，当日的高点和低点均超过了前一天，形成了所谓的“扩张日”。反转日倒也不一定非是扩张日不可，但是如果它同时也是扩张日，那么其分量就更重了。 图4.22a 顶部反转日的一例。反转日的图4.22b 底部反转日的一例。如果当日的交易量交易量越重、价格范围越大，则越重要。 特别重大，则该底部反转日常被称为“抛售高潮”有时我们也把底部反转日称为“抛售高潮”。这种情况确实是发生在熊市底部的一种剧烈的“大翻身”。在这里，所有已经备受挫折的多头终于忍受不住，不得不斩仓卖出，从而使交易量大增。随后，市场上反倒缺乏卖出压力，形成了所谓卖压真空，于是价格快速上窜，以填补这个空档。抛售高潮是较为剧烈的反转日，不过它并不一定标志 着熊市终于已经见底，而是通常意味着一个重要低点业已完成。 关键反转日对关键反转日概念存在着很普遍的误解。虽然所有的当日反转都是关键反转日的苗头，但实际上只有极少的部分真正演变成关键反转日。许多当日反转仅仅代表了既有趋势的暂时休整，之后趋势仍将继续前进。而真正的关键反转日则标志着一个重要的转折点，不过这一点在当时并不能判断出来，而是要一直等到事实既成之后——即在价 格已经沿着原先趋势的相反方向运动出相当大的距离之后。 双日反转有时候一次反转需要两天的时间才能完成，所以被称为“双日反转”。在上升趋势中，前一天价格走出新高点，并且以接近于高点的水平收市，次日，价格开市于前一天收市价附近，但无力持续上升，于是收市价格跌近前一天的低点。在市场底部发生的双日反转与上述情况恰好相反。同样，如果这两天的价格波动范围越大、交易量越重则该反转也越有影响力（见图4.23a和b）。 图4.22c 请注意，在这张 S&amp;P500 合约图表中，几乎每一个显著的市场转折点都发生在“反转日”。 图4.23a重大交易量下的双日顶部反转的例子。 图4.23b 重大交易量下的底部双日反转的例子。 前面已经说过，反转日本身并不是一个重要的形态，但因时而异，它也可能演化成重要的转折点。要知道，我们必须从全面的技术角度去考察市场。 如果价格持续暴涨，始终不调整，并打破了所有的技术性目标，一直达到一个历史上的重要阻挡区域，同时市场表现出严重超买的状态，那么就值得非常警惕了，这个局面很有向下反转的危睑。在期货市场，大多数重要转折点的出现总是伴随着各种形式的反转日而来的，这些反转日通常只是更大规模的、 更具分量的图表形态的一个组成部分。在头肩形顶部反转形态中，其头部或许就是一个反转日。当然，这并不是说反转日本身便会导致整个趋势的逆转。 关键是要能够确定反转日在何种情况下重要，在何种情况下无关痛痒。而这只有当我们考察了其余各种技术性因素之后，才能做出判断。虽然我们可以把反转日本身视为相对次要的信号，但最好是能在它出现的时候及时地把它识别出来，并对市场趋势反转的危险有所提防。 周反转和月反转这种反转形态在各类线图上均可能出现，而当它出现在周线图和月线图上时，意义尤其深远。在周线图上，每根竖直线段代表相应一个星期的全部价格范围，并以它右侧的线头表示周五的收市价。这样，向上的周反转的情况就是，市场在该星期内向下试探，并且跌出了新的低点，但是周五的收市价却又回到上周五的收市价之上。（米尔顿·吉勒先生年愈古稀，是商品研究局创始人之一。他告诉我，从前把向上的周反转称为“四神恶煞”。后来我问他向下的周反转该怎么讲，他答道:“咦，当然是‘反凶神恶煞’了。”一笑。） 很显然，周反转比日反转重要得多，因此图表分析师对之倍加警惕，力求捕捉重要转折点。依此类推，月线图上的月反转就更要紧了。下面我们即将介绍最后一种反转形式——岛形反转形态，但为了说明得充分些，我们需要先对价格跳空作一个详细的介绍。 价格跳空价格跳空是指在线图上没有发生交易的区域。比如说，在上升趋势中，某日最低价高于前一日的最高价，从而在线图上留下一段当日价格不能覆盖的缺口（或曰空白）。 在下降趋势中，对应情况是当日的最高价格低于前一日的最低价。向上跳空表明市场坚挺，而向下跳空则通常 是市场疲软的标志。跳空现象在长期性质的周线图和月线图上也可能出现，而且一旦发生了，就非同小可。不过它 在日线图上更常见。 关于跳空的解释流传着一些陈辞滥调。其中有句常常听到的俗套:“跳空总会被填回”，这是不正确的。我们且 先花点篇幅，澄清一下概念。 我们将看到，有些跳空确具意义，但有些则很平常，有些会被填回，有些则不会。同时我们也会发现，价格跳 空因其所属的类型及出现的场合不同，具有不同的预测性意义。 跳空具有四种类型跳空一般可分为四种类型——普通跳空，突破跳空，中继跳空（或测量跳空），以及衰竭跳空。 普通跳空：普通跳空在四种类型中预测性价值最低，通常发生在交易量极小的市场情况下，或者是在横向延伸 的交易区间的中间阶段。其主要原因是市场参与者了无兴趣，市场清淡，相对较小的交易指令便足以导致价格跳空。 大多数图表分析师把普通跳空忽略不计。 突破跳空：突破跳空通常发生在重要的价格运动完成之后，或者新的重要运动发生之初。在市场完成了主要的底部反转形态，比如头肩形底之后，对颈线的突破经常就是以突破跳空的形式进行的。在市场的顶部或底部所发生的重要突破。正是滋生此类跳空的温床。另外，因为重要趋势线被突破时意味着趋势反转，所以也可能引发突破跳空。 突破跳空通常是在高额交易量中形成的。突破跳空更经常地是不被填回。价格或许会回到跳空的上边缘（在向上突破的情况下），或者甚至部分地填回到跳空中，但通常其中总有一部分保留如初，不能被填满。一般来说，在这种跳空出现后，交易量越大，那么它被填回的可能性就越小。事实上，如果该跳空被完全填回，价格重新回到了跳空的下方的话，那么这其实倒可能是个信号，说明原先的突破并不成立。向上跳空在之后的市场调整中通常起着支撑作用，而向下跳空在之后的市场反弹中将成为阻挡区域（见图4.24a到c）。 中继跳空（或测量跳空）：当新的市场运动发生、发展过一段之后，大约在整个运动的中间阶段价格将再度跳跃 前进，形成一个跳空或一系列跳空，称为中继跳空。此类跳空反映出市场正以中等的交易量顺利地发展。在上升趋势中，它的出现表明市场坚挺；而在下降趋势中，则显示市场疲软。正如突破跳空的情况一样，在上升趋势中，中继跳空在此后的市场调整中将构成支撑区，它们通常也不会被填回，而一旦价格重新回到中继跳空之下，那就是对 上升趋势的不利信号。 此类跳空又称测量跳空。因为它通常出现在整个趋势的中点，所以我们可以从本趋势的信号发出之处或突破处， 顺着趋势方向翻出一番，从而估计出该趋势今后的发展余地。 衰竭跳空：最后这一类跳空出现在接近市场运动的尾声处。在价格已经抵达了所有目标，并且上面介绍的两种跳空（突破跳空和中继跳空）均巳清晰可辨之后，分析者便开始预期衰竭跳空的降临。在上升趋势的最后阶段，价格在奄奄一息中回光反照，跳上一截。然而，最后的挣扎好景不长，在随后的几天乃至一个星期里价格马上开始下 滑。当收市价格低于这种最后的跳空后，表明衰竭跳空已经形成。上述情况非常典型，说明在上升趋势中，如果跳空被填回，则通常具有疲弱的意味。 岛形反转这样我们又回到了价格跳空之前的话题—岛形反转形态。有时候，在向上衰竭跳空出现后，价格在其上方小范围地盘桓数日乃至一个星期，然后再度跳空而下。在这种情况下，那几天的价格变化在图表上就像一个孤岛，四周为空白（“海水”）所包围。向上的衰竭跳空同向下的突破跳空结合在一起，就完成了一个反转形态，它通常意味着市场将发生一定幅度的折返。当然，这场反转的规模也要取决于它本身在趋势的总体结构中所处的地位。 图4.24a 三类价格跳空。突破跳空标志着底部形态的完成。中继跳空发生在趋势的中途（因此，它也被称为测量跳空）。先有向上的衰竭跳空，然后在一周以后再有向下的突破跳空，两者一起形成了岛形反转顶，请注意，在上涨过程中，突破跳空和中继跳空并未被填回，而这是正常现象。 图4.24b 在8月/10月的下跌中，可以见到三个向下的跳空。突破跳空引发了这段下跌，测量跳空居于这轮下跌的中途，衰竭跳空出现在底部过程开始后一周内。请注意，前两种向下的跳空均未被填回，而衰竭跳空被完全填上。衰竭跳空被填回通常表示市场即将出现一定幅度的反转。 图4.24c 咖啡市场在5月和8月的两个顶部明显地是以岛形反转形态出现的。 注意，在两种情况下，均有一星期的价格变化孤立在外，在它两边各有一个跳空 日内价格跳空在结束对跳空的讨论前，我们还要有所补充。上面所述主要集中于日间跳空，即出现在日线图上的价格跳空。还有许多种跳空发生在日内价格变化中，出现在以日内时间单位为基础的线图上，而在日线图上并没有反映。比如说5分钟线图可以展示许多日内的价格跳空。此类跳空潜藏在日线图中，其运作机理同日间跳空并没有什么两样。有机会获得日内资料的读者如果看到了这些跳空，不妨如法操作，善加利用。 总结本章介绍了一些基本的技术工具—支撑和阻挡，趋势线和管道，百分比回撤，速度阻挡线，反转日，以及跳空。在我看来，它们是图表分析的重要基础。本书以下各章介绍的所有技术手段，统统是对上述基本概念和工具的各种形式的运用。掌握了这些基本知识后，下面我们就可以着手研究价格形态了。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第三章 图表简介]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E4%B8%89%E7%AB%A0-%E5%9B%BE%E8%A1%A8%E7%AE%80%E4%BB%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 引言本章主要是为不熟悉图表的朋友准备的。我们先讲解现有图表的各种不同类型，然后再集中研究其中使用得最广泛的日线图。我们也将介绍怎样理解价格数据，进而交代如何作图。此外还要讲述交易量和持仓兴趣两个概念。接下来再说说线图的其余种类，比如属于长期性质的周线图和月线图，还有以小于一天为时间单位的日内线图。有 了上述预备知识后，在随后的几章将讨论分析线图的几种工具。熟悉图表的读者或许觉得本章过于基础，不妨直接跳到下一章。 现有图表的类型众所周知，日线图在期货交易中使用最广。不过技术分析师也使用其余类型的图表，这里要说两种，点数图和单线图。图3.1是一张标准的日线图。以“线图”为名是指这类图表以竖直的线段表示每一天的价格变化。从日线 图的每一根竖直线段上，通常可以看出当天的最高价格、最低价格和收市价格。每根竖直线段上向右伸出的小横线 标志着当日收市价位。一部分技术分析师也开始采纳开盘价，把它标在线段的左侧，如本图所示。 图 3.2 以单线图的形式重画了上面的日线图。在单线图上，我们只要逐日作出各个收市价格所在的点，然后简单地连线即可。因为收市价格是每个交易日最重要的价格，所以不少图表师觉得这种单线图能更有效地展示价格变 化。根据分析者的不同需要，某些分析手段用在单线图上比用在相应的线图上更简明。 图 3.1 黄金合约的日线图。其中每根竖直线段都表示一天的价格变化。最常用的价格资料是当日的最高价、最低价、和收市价。线段上向右侧伸出的小横线标志着收市价的水平。有些图表师在线段的左侧，用另一个小横线标出当日开市价 图 3.2 本图是图 3.1 的单线形式。其中只把每天的收市价格联起来，形成了一条单的实线。 点数图是第三个类别，如图 3.3 所示。本书后面有两章专门深入讨论这种图表的分析方法。请注意，这张点数 图显示的也是上面两图的价格内容，但是其形式更为简洁紧凑。图中“X”和“O”符号逐列交替出现。“X”组成的 列表示价格上升，“O”组成的列代表价格下降。点数图能够比线图更清楚、准确地显示买、卖信号，同时也具有很 大的灵活性。绘制图 3.3 只需要用到每日最高价、最低价的资料，而这我们从报纸上就很容易取得。 图3.3 本图与图3.1、图3.2的价格资料是相同的，但属于点数图的格式。 请注意，其中“X”列和“O”列交替出现。X 列表示价格上升，O 列代表价格下 降。在这类围上，买卖信号较为精确。还请注意，在这里，价格资料被大大压缩了上面介绍了三种图表，主要通过当日最高价、最低价和收市价格来构图，偶尔也用到开市价格。但是每天在交 易所场内，还有大量交易活动的细节资料，没法在这几种图表上显示出来。有机会使用高级图表系统，比如 ADP 康 川公司的可回馈视觉系统的交易商，可以通过以日内时间单位为基础绘制的线图、单线图和点数图，来获悉每日的 市场活动细节。拿线图来说，这些时间单位可以是 5 分钟、15 分钟以及 l 小时等，在做短线交易时，这些短线图表 妙用无穷。在以后的各章中，还要介绍这类短线图表。当然也不会忽略单线图和点数图。不过此处，我们的讨论只 限于日线图(见图 3.4 和 3.5a 和 b)。图 3.4 长期国债合约的日内线图。其中每根竖直线段代表每 5 分钟内的最高价、最低价、和最后价。本图中总共只有一天的价格变化内容。图3.5a 这是一张黄金合约的日内点数图。在这样的图 上，可以获得大量的价格资料，发现隐含的支撑和阻挡水平图 3.5b 这是一张价格数据表，为瑞士法朗从 1983 年 4 月 29 日到 1983 年 5 月 18 日的实际日内价格数据。要画出日内图表，必须取得日内价格资料。算术刻度和对数刻度在期货行业中，所有商业化图表的价格轴都是以算术刻度表示的，不过，在进行某些形式的分析，特别是在研 究非常长期的趋势时，使用对数刻度图表可能更为便利(见图 3.6 和 3.7)。图 3.6 分别是算术刻度和对数刻度的 两个示例。在算术刻度上，每单位的价格变化都用相等的竖直距离表示。例如，从 5 单位到 10 单位的价格变化与从 50 单位到 55 单位的价格变化在图上所标出的竖直距离是相等的，虽然在前一种情况下价格翻了一番，后者只是上涨 10%。而在对数刻度上，相等的距离表示相等的百分比例的价格变化，比如说从 10 单位到 20 单位(上涨 l00%)的 价格变化，与从 20 单位到 40 单位或者从 40 单位到 80 单位的价格变化在图表上的竖直距离都是相等的。请注意，在算术刻度尺上，刻度是均匀分布的。而在对数刻度上，随着价格读数的增大，由于每单位价格增量占其价格基数 的百分比值递减，于是，从刻度 1 到 2 的距离与从刻度 5 到 10 的距离相等，因为它们同样表示价格翻了一番。尽管 对数图表在长期趋势分析中也许有益，我们手头上却都没有此类图表，而且大部分读者除了传统的算术图表外别无 选择，所以，本书今后仅使用此类图表。图 3.6 算术刻度与对教刻度的对照图。请注意，在左侧的刻度上， 刻度线是均匀分布的。而右侧的对数刻度，则表示百分比的变化。图 3.7 上面两图分别为铜的连续周线图和连续月线图，其中价格轴采取对数刻度。请注意，当价格降低时，刻度放 大;而价格升高时，刻度收密。在对数刻度的图表上，特别是在长期图表上，趋势线和管道的作法很受影响。 日线图作法:价格、交易量以及持仓兴趣日线图的作法非常简易。在线图上既有价格因素，也有时间因素。竖直轴(Y 轴)代表合约的价格，水平轴(X 轴)记录对应的时间项，日期标在图表的底部。我们只要在水平轴上的相应的日期位置，按照价格轴刻度点出当日 最高价和最低价，然后用线段连接起来，就可得到一根竖直线段(称为区间)，然后，在这根竖直线段上，从当日收 市价格的位置向右引出一小截线头，日线图就画成了(见图 3.8)。收市价之所以标在线段右侧，是因为要留出左侧表示开市价格。传统上，我们只保存高、低和收市三种价格的 资料，不过目前在短线操作者中，对开市价的记录和利用日益普遍。画好一天的价格后，次日的价格画在其右边邻近的对应日期上。大多数图表服务系统按每周五个工作日来标定时间轴，略去周六和周日。在每周的五个工作日里， 不论哪一天市场休息，当天的位置上就留出空白。 DATE 841207 841210 841211841212841213841214841217841218OPEN HIGH LOW 337.5 338.3 333.0 335.0 336.0 333.5 335.0 336.1 332.5333.7 337.5 331.0 333.7 333.7 331.7 328.8 332.5 328.5 324.8 325.2 320.0 315.0 318.0 313.5CLOSE 335.5 334.1 334.0334 .1 332 4 329.8 321.1 315.4VOL 28823 23318 312873766622242484864663851000DI 163480 164270 166100164140165050163040163080——1985年4月COMEX黄金(est)图 3.8 上半图表示了 8 天的价格变化。在各个竖直线段上，右侧小横线为收市价，左侧小横线为开 市价。下半图显示了总的交易量(以刷形图表示)以及总的持仓兴趣(以实线表示)。数据表格中包括了 相应的各项数据。最后一天的交易量为估计值。这里也没有最后一天的持仓兴趣，因为迟一天才会公布交易量和持仓兴趣线图上还包含另外两项重要信息——交易量和持仓兴趣。交易量为当日在某商品市场发生的交易总额，也就是 该商品市场到期月份不同的各种合约，在这一天内参与买卖的总的张数。这个概念相当于股市上某日易手的普通股 票总股数。在日线图的底部，对应于每一个交易日，有一根竖直线段，居于当日价格线段之下，代表当日的交易量。 要是这根线段向上伸展得较高，就意味着当日交易量较重，相应地，短线就表示交易量较轻。为了便于描绘交易量 的数据，图表下部也沿着竖直方向标出了交易量的刻度单位(见图 3.9)。持仓兴趣是所有交易商到当日收市为止累计的未平仓合约的总数目。持仓兴趣是买盘或卖盘单边的总数，而不 是双方之和。请记住，我们讨论的是合约交易，有买则必定有卖，每一个买盘(多头头寸)都必定有一个卖盘(空 头头寸)与之相对共存。这样，我们只要知道一边的情况就行了。我们沿着图表下部用一条实线表示持仓兴趣，它 通常在交易量稍上方波动，但低于价格。此外，不少图表服务系统还添上了一条虚线，表示持仓兴趣的 5 年平均线， 意在显示其季节性倾向。交易量和持仓兴趣在全部合约下的总额和在单个合约下的小计 在大多数商业图表系统中，只采用某商品全体合约下的交易量和持仓兴趣的总额。大部分技术分析师也是这样选择的。但同一商品具有到期月份不同的数种交易合约，我们也能分别获得它们个别的交易量和持仓兴趣的资料。 不过在预测市场的时候，一般实际使用的是同一商品的各个个别值的总和。下面谈谈这样做的原因。在合约刚刚上市的时候，它的交易量和持仓兴趣一般相当小。随着其逐渐成熟，这两个数字也相应壮大。最后在临近到期的前几个月，交易量和持仓兴趣又逐步萎缩。显然，这是因为交易商在合约到期之前，必须把敞口头寸 对冲掉。因此，具体合约在刚上市的时候交易量和持仓兴趣的增长，以及在临近到期的时候两者的减少，均与市场 方向无关，而仅仅是商品期货合约的有效期限特点所导致的从生现象。为了保证交易量和持仓兴趣两者的连续性， 也为了使之具备预测性意义，我们普遍采用上述总和。当然，“普遍”不等于“全部”。有些分析师认为，在合约有 效期的中间阶段，相应的个别交易量和持仓兴趣数据也确实有预测性价值。图 3. 9 一张标准的日线图。图表右侧的竖直轴为价格轴，底部为时间轴。交易量总额以图表底部 的刷形图表示。持仓兴趣总额以实线表示，出现在交易量的上方。交易量和持仓兴趣的刻度度分别标 在图表下方的右侧和左侧。下方的虚线表示持仓兴趣的 5 年平均值，用来显示持仓兴趣的季节性形态当日的交易量和持仓兴趣次日公布 交易所是在第二日公布前一日的交易量和持仓兴趣的，所以图表师手中的资料比实际落后一天。这两类数字通常在次日的交易时间内发布，因此次日的金融报纸来不及登载。于是，每天早晨的报纸，只能刊登前一天交易量和 持仓兴趣的估计数字。这种估计数虽然不尽人意，但尚能为分析者就前一日交易的活跃程度，提供一点参考。从读 者角度来看，每天早晨可以读到昨天的市场价格，和昨天的交易量、持仓兴趣的估计数字，以及前天的交易量和持 仓兴趣的所方正式报告。举例来说，在星期三早晨的报纸上，有星期二的价格和估计的交易量、持仓兴趣，还有星 期一的交易量和持仓兴趣的所方正式报告。对重视市场逐日变化者而言，一天的耽搁会造成一些不便利，不过程度 还不太严重(见图 3.10，略)。图 3.10 摘自华尔街日报的期货版。从中我们可以发现作日线图所需要的所有数据。请注意，在每种商品的小 标题下面，各种到期月份合约的资料是按行排列的。到期月份排在每行的最左列，上一个交易日的开市价、最高价、 最低价、结算价(收市价)从左往右顺序排开，最右列展示的是各个合约的个别持仓兴趣，每栏商品的最底下一行， 先是昨天该商品的交易量和持仓兴趣的估计值，然后是前天所方公布的两者的正式数字。最底下这一行的交易量和 持仓兴趣当然都是该商品所有合约下的总和。持仓兴趣前面的正负号，分别代表在相应的交易日里未平仓头寸的增 加或减少。我们在第七章还要讲到，其增减方向具有预测价值。个别交易量和持仓兴趣的意义 在研究市场方向时，个别交易量和持仓兴趣意义不太大，但它的信息还是很有价值的。在我们从同一商品的各种合约中选择具体的交易媒介时，它们能表明何者流动性最佳。一般来说，交易活动只宜限于那些持仓兴趣最高的 合约，而那些持仓兴趣低的合约则应避开。名符其实，持仓兴趣越高，则表明围绕着该种到期月份合约的交易意向 越浓厚。某些交易商更愿意用个别交易量来衡量各种具体市场的活跃程度，我相信持仓兴趣更可靠。具体合约的交 易量数据每天发表在《商贸报》上。 怎样描绘谷物市场的交易量和持仓兴趣在描绘谷物和大豆的交易量及持仓兴趣的图表时，有一点必须明确。某些报纸上的报告是以合约张数为单位的， 但是图表服务系统则使用千或百万蒲式耳为单位。每张合约相当于 5000 蒲式耳。所以，我们在由报纸资料绘图时， 应当把相应的数字乘以 5，折算出同常用图表相对应的数值(见图 3.11)。图3.11 大豆的日线图。注意，图表下方左侧和右侧的竖直刻度以百万蒲 式耳为单位。当我们以《华尔街日报》和《纽约时报》上的交易量和持仓兴 作趣的数字图时，必须把它们分别乘以 5，使其单位从合约张数转换成蒲式耳自己绘图和利用图表系统我们还不打算在此详细讨论交易量和持仓兴趣，那是第七章的任务。这里的全部目的，是要讲清楚数据资料从 何而来，以及如何把这些数据用图表表示出来。我不怂恿您自己绘画图表，那样做，费时费力，不如走捷径，订阅 某种商业化的图表服务，其费用低廉，且大为便利准确。每周，您都可以收到用最新数据刷新过的新图表。其中还 附有很多极具价值的技术性信息，对分析工作大有裨益。此外，在大多数图表服务中，还包括一些图表分析的内容， 至少从及时的角度上说，肯定也是有帮助的。关键是，我们应当把时间花在研究图表上，而不是逐日刷新图表上。 当然，只要朋友们掌握了每个商品市场的价格结构，并在刷新图表上训练有素，那么，每天只要花上不到半小时， 就可以把前一天的整个投资组合中的各种期货资料，统统补充到相应图表上去。周线图与月线图到这里，我们已经对日线图进行了集中的讨论。不过要清楚，我们其实可以以任何时间单位为基础来构造线图。 前面已经提到一些所谓日内线图，如小时线图。此外，我们甚至还可以以 5 分钟为时间单位，选择每 5 分钟内的最 高价、最低价和最后价格来作图，称为 5 分钟线图。另一方面，日线图上一般可以展示 6 个月到 9 个月的价格变化， 然而如果要做更长期的趋势分析，就必须使用周线图和月线图了。第八章将解说使用这种长线图表的益处。周线图 和月线图的绘制方法与日线图一致(见图 3.12 和图 3.13)。在周线图上，每根竖直线段代表对应一星期的全部价格活动。在月线图上，每根竖直线段表示对应一个月内的全都价格变化。显然，为了展示更长期的趋势，周线图和月线图把价格资料大加浓缩了。通过连续周线图，我们可 以一直追朔到 5 年以前的市场情况，而连续月线图可以覆盖 20 年以上。这里所谓的连续图表，得来并不复杂，只要 简单地上溯历史资料，挨次地把最近到期合约的价格图表中的相应片断接续在一起就可以了。这是个简易的技巧， 但能够帮助技术分析师纵览较长时期的市场情况——这类长期透视在期货市场经常欠缺，因而弥足珍贵。图3.12 黄金的连续周线图的一例。其中每根竖直线段均代表最近 到期合约的一周价格变化。从这张图上，可以看到 5 年的价格信息。图 3.13 黄金连续月线图的一例。其中每根竖直线段都表示 一个月的价格资料。从这张图上，可以研究 20 年的价格历史现在我们已经学会了绘制日线图，也了解了三种基本的信息来源——价格、交易量和持仓兴趣，那么下一步就 该介绍如何解释这些资料了。请记住，图表仅仅是数据资料的记载和展示，其自身并无特别的价值。它们就象画笔 和画布，工具本身并不能决定一幅画的艺术水准，只不过在一个天才的画家的手中，就能物尽其用，创造出美好的 形象。用手术刀做比喻或许更恰当。造诣不凡的外科医生能够使用手术刀来挽救生命，可它如果落在我们常人手里， 不唯用处不大，甚至可能带来危险。在您掌握了图表分析的规则之后，在您施展这门预测艺术(或者说技巧)的时 候，图表就极具价值。那么我们就开始吧，下一章，就来讲述趋势的一些基本概念。我认为这是图表分析的建筑基石。本章最后，附录了一张“期货交易要目”，以备不熟悉各种期货合约详情的读者查阅(见图 3.14，略)。其中， 各种市场如何标价、最小和最大价格变化单位及其相应的以美元计算的出入、有关交易所、交易时间等，都是必备 知识。本指南仅是个参考，以帮助读者熟悉不同的期货市场。必须声明，有关的具体情况会定期调整，朋友们在查 阅各种指南时，请务必以最新出版者为准。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第二章 道氏理论]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E9%81%93%E6%B0%8F%E7%90%86%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 基本原则1.平均价格包容消化一切因素 挺耳熟吧？这正是第一章所介绍的技术分析理论的基本前提之一，只是这里用平均价格代替了个别对象的价格。这个原则表明，所有可能影响供求关系的因素都必得由平均市场价格来表现，就连“天灾”，比方说地震或者其它自然灾难也不例外。当然这些灾祸事先谁都难以料到，但是一旦发生，就会很快被市场通过价格变化消化吸收掉。 2.市场具有三种趋势 道氏的趋势定义是，只要相继的上冲价格波峰和波谷都对应地高过前一个波峰、波谷，那么市场就处在上升趋势之中。换言之，上升趋势必须体现在依次上升的峰和谷上。相反，下降趋势则以依次下降的峰和谷为特征。正如将在第四章所讲的，这仍是趋势的基本定义，仍是所有趋势分析的起点。 道氏把趋势分成三类—主要趋势、次要趋势和短暂趋势。其最关心者为主要趋势（或称大趋势），通常持续一年以上，有时甚至好几年。他坚信，大部分股市投资者钟情于市场的主要方向。道氏用大海来比喻这三种趋势，把它们分别对应于潮汐、浪涛和波纹。 主要趋势如同海潮，次要趋势（或称中趋势）是潮汐中的浪涛，而短暂趋势则是浪涛上泛着的波纹。从堤岸标尺上，我们可以读出每次浪涛卷及的最高位置，然后通过挨次地比较这些最高位置的相对高低就能测定海潮到底是涨还是落。如果读数依次递增，那么潮水依然在向陆地推进。只有当浪涛峰值逐步递减的时候，观测者才能确知潮水已经开始退却。 次要趋势（或中趋势）代表主要趋势中的调整，通常持续三个星期到三个月。这类中等规模的调整通常可回撤到界乎先前趋势整个进程的三分之一到三分之二之间的位置。常见的回撤约为一半，即百分之五十。 短暂趋势（或小趋势）通常持续不到三个星期，系中趋势中较短线的波动。我们在第四章讨论趋势概念时，将采用与这里几乎一致的术语，以及差不多的回撤比例。 3.大趋势可分为三个阶段 大趋势通常包括三个阶段。第一阶段又称积累阶段。以熊市末尾牛市开端为例，此时所有经济方面的所谓坏消息已经最终地为市场所包容消化，于是那些最机敏的投资商开始精明地逐步买进。第二阶段，商业新闻趋暖还阳，绝大多数技术性地顺应趋势的投资人开始跟进买入，从而价格快步上扬。第三阶段，即最后一个阶段，报纸上好消息连篇累牍，经济新闻捷报频传，大众投资者积极入市，活跃地买卖，投机性交易量日益增长。正是在这个最后阶段，从市面上看起来谁也不想卖出，但是那些当初在熊市的底部别人谁也不愿买进的时候乘机“积累”、步步吃进的精明人，开始“消散”，逐步抛出平仓。 熟悉艾略特波浪理论的读者肯定不会对上述关于大趋势的三部曲式、各具特色的划分感到陌生。在30年代出版的雷氏的《道氏理论》的基础上，艾略特构造了他自己的波浪理论。艾略特也认识到牛市有三个主要上涨阶段。 在本书的“艾略特波浪理论”一章中，我们将表明，道氏的牛市三部曲同波浪理论的分浪特色惊人地相似。艾略特理论和道氏理论的主要分歧在于相互验证原则，下面我们就要讲到。 4.各种平均价格必须相互验证 具体而言，道氏是指工业股指同铁路股指应相互验证，意思是除非两个平均价 格都同样发出看涨或看跌的信号，否则就不可能发生大规模的牛市或熊市。换句话说，为了标志牛市的发生，两种平均价格都必须涨过各自的前一轮浪涛（中趋势）的峰值。如果只有一个平均价格突破了前一个高峰，那还不是牛市。两个市场倒也不必同时发出上涨信号，不过在时间上越近越好。如果两个平均价格的表现相互背离，那么我们就认为原先的趋势依然有效（参见图2.1）。艾略特波浪理论在这一点上与道氏理论不同，只要求单个平均价格给出信号就足够了。关于相互验证和相互背离原则我们以后还要详细解说（见图2.2）。 图2.1 请注意，当工业类平均股票指数跌破了11月份的最低点的时候，在交通类股票指数中，并末出现类似情形，因而两者之间没有相互验证。这是个警讯，表明当时:工业类指数上的“卖出”信号是可疑的。就目前来看，工业类指数也必须冲破阻挡，以验证交通类指数的向上突破信号 图2.2 我们可以把相互验证的原则应用于任何两个市场或指数之间。本图表示价值线与S&amp;P500 期货指数之间的差价关系（两者价格之差）。请注意，S&amp;P500刚刚跌破其10月份的低点，勉强验证了早些时候价值线图上的突破信号。图中下部为差价图，表明价值线的疲弱程度更甚。通常，这是市场疲软的信号。但是，请注意，差价已出现止跌回升的迹向（向上突破了趋势线），意味着市场可能向上转折。换言之，价值线指数已开始比S&amp;P指数更有起色。通常，这是市场坚挺的信号 5.交易量必须验证趋势 道氏认为交易量分析是第二位的，但作为验证价格图表信号的旁证具有重要价值。简而言之，当价格在顺着大趋势发展的时候，交易量也应该相应递增。如果大趋势向上，那么在价格上涨的同时，交易量应该日益增加，而当价格下跌时，交易量应该日益减少。在一个下降趋势中，情况正好相反，当价格下跌时，交易量扩张，而当价格上涨时交易量则萎缩。当然，我们必须强调，交易量是第二位的参照指标，道氏理论实际使用的买卖信号完全是以收市价格为依据的。在第七章我们将更深入地讨论交易量问题。不过届时您会发现其基本原 则与此处如出一辙。即使是某些更复杂的交易量信号，其目的也主要是确认交易量增减的方向，然后同价格变化加 以参照。 6.唯有发生了确凿无疑的反转信号之后，我们才能判断一个既定的趋势已经终结 在第一章我们也曾涉及到这 条基本原则，它是目前广泛使用的顺应趋势方法的主要基础。这句话其实也就是说，一个既成趋势具有惯性，通常要继续发展。话说回头，要判别反转信号说起来容易，行起来困难。研究诸如支撑和阻挡价格水平、价格形态、趋势线和移动平均线等等倒也是几个实用的办法，我们或许从中能获得关于现行趋势发生变故的信号。摆动指数甚至能够更及时地发出现行趋势动力衰竭的警讯。不过，通常总是选择“趋势还将继续”这一边，把握更大些。掌握这个小小秘诀，就能令您成多败少，大有胜算（见图 2.3a 和 b）。 对信奉道氏理论者或者“因势导利”者来说，最困难之处就在于要有能力把大趋势中常见的次要调整，同掉头反转的新趋势的第一轮冲锋区分清楚。关于什么样的情形才是真正的反转信号，这一点在顺应趋势派中还有争议，图2.3a和2.3b均为衰竭形态，显示了两幅格局。在图2.3a中，我们注意到C点的上涨未能达到相邻的前一个高峰A点的高度，此后价格又回过头跌破了前一个低谷B点的水平。在这种情况下，就存在着两个依次下降的峰和两个依次下降的谷，表明当前一个低点B被跌破时，S点是一个清晰的卖出信号。这种反转形态常常被称为“一蹶 不振”。 图 2.3a “一蹶不振”。先是高点 C 无力 克最高点 A，然后，市场向下跌破了低点 B，从而构成了 S 点的卖出信号。 图 2.3b “物极而反”。请注意，这里点 C 超过了点 A，但之后却跌破了 B 点。有些道氏主义者认为 S1 点是“卖 出”信号，而另一些人则等市场走出了另一个较低的高点B 后，在 S2 点方采取看跌的态度。 在图 2.3b 中，我们注意到这一轮上冲所达的高点已经打破了前一个峰值A点，然后价格才滑破前一个低点B。尽管在S1点，B点价位的支撑显然已经崩溃，有些道氏主义者并不认为这是一个良好的卖出信号，理由是这里只有依次降低的低点，却没有依次降低的高点。他们宁可看到价格再次回到E点而无力达到C点的高度，然后再加上随之而来的下跌又低于D点之后，才认为这时的S2点是真正的卖出信号。因为此处既有依次下降的峰又有依次下降的谷。图2.3b所示的反转形态称为“物极而反”。图 2.3a 所示的。一蹶不振”的形态要比“物极而反”的形态疲软 得多。图 2.4a 和 2.4b 显示了市场在底部时对应于上面两种形态的镜像情形（见图 2.4a 和 2.4b）。 图 2.4a 底部的“一蹶不振”。当 B 点被 图 2.4b 底都的“物极而反”形态。 向上突破后（B1 点），构成“买入”信号。 点 B1 或点 B2 处为“买入”信号。 收市价格的使用和辅助直线的引入 道氏在股市平均价格图表中纯粹依赖收市价格，其信号是以收市价格对前一个高峰或低谷的穿越为标志的。除了收市价格之外，其余日内价格变化即使穿越了上述高、低点也是无效的。他在平均价格图上所使用的辅助直线，就是在某一段时间内界定价格上下变化范围的水平直线。其描述的横向延伸的波动常常出现在调整状态中，也可以 在顶部或底部的反转过程中见到，在现代术语中，这种形态称为矩形。 对道氏理论的某些批评实事求是地说，多年来道氏理论在辨别主要牛市和熊市上是成功的。不过即使如此，它也难逃求全之苛。最常见的批评可能是嫌信号来得太迟。通常道氏理论的买入信号发生在上升趋势的第二阶段，即当市场向上穿越了从底部弹起的第一个峰值的时候。一般来说，在信号发生之前，我们大约错过了新趋势全部价格变化的 20%一25%。顺便说一句，绝大部分顺应趋势的技术系统也是在此时确认和投入新趋势的。 奉行因势导利者对这种批评恐怕很熟悉。请切记，道氏理论从来不是企图抢在趋势前头，而是力求及时揭示大牛市或大熊市的降临。根据现有的记录，它在这方面的表现应当说是相当优良的。本章引言中提到的巴伦氏周刊上的那篇文章曾引用了一些统计材料，表明从 1920 年到 1975 年，道氏理论成功地揭示了工业股指和运输股指的所有 大幅运动中的 68%、标准普尔氏 500 种股指大动作的 67%。 正如绝大多数顺应趋势系统的设计精神一样，道氏理论的目的是捕获市场重要运动中幅度最大的中间阶段。就这种意义上说，上述批评是不能成立的。另一方面，这种责难本身也表明批评者对顺应趋势理论缺乏了解。实质上没有哪个顺应趋势系统试图抓住底或顶。想抄底或压顶的人很少如愿以偿。 还有一种指责由来已久，说没人能真正买卖平均价格指数，而道氏理论并未说明何种股票当买或何种股票当卖。不过现在股票指数期货已顺利上市，交易商确实可以毫不关心个别股票而一心一意地“买卖指数”了。随着股票指数的日益盛行，也许道氏理论将来能为期货技术分析充当更为有力的工具。 道氏理论肯定也不会绝无谬误，它也有错误信号频频发生的糟糕日子。不过任何优良的信号系统也都有缺点和不足。要知道，道氏甚至不曾打算用他的理论去预测股市方向。他觉得，其真正价值在于利用股市方向来作为一般商业活动的晴雨表。道氏的洞察力令人惊叹不已，他不但为我们今天处处运用的预测方法奠定了基础，而且竟然在 那时就已经认识到，股价指数是很好的经济先行指标。 总结本章相当简要地概括了道氏理论中较重要的各个方面。随着对本书的深入学习，您将充分认识到，理解和接受道氏理论可以为学习技术分析打下坚实的基础，同时您也会越来越清楚，今后各章中所讲解的内容代表着道氏理论的各种发展。诸如趋势概念的标准定义、趋势三类型和趋势三阶段的划分、相互验证原则和相互背离原则、交易量 的诠释、以及百分比回撤的用法等等，都是从道氏理论中衍生出来的。 结语在结束对道氏理论的讨论之前，我们还必须指出，虽说道氏理论的绝大部分内容在期货市场均有一定的应用，但也存在着某些重要区别。举例来说，道氏认为大多数投资人只做大趋势，而中等的调整被用作入市时机的选择，短暂趋势则置而不理。很显然，在期货市场情况并非如此。 绝大多数期货商追逐的是中等趋势而不是大趋势。小幅度价格波动对选择时机意义极为重大，这就是说，在一个预计持续数月的中等上升趋势中，顺应趋势者会利用短暂的价格下跌买进。而在一个中等下降趋势中，短暂的价格上弹是卖出的好机会。这样，短暂趋势在期货交易中就显得极为重要。许多短线交易商在非常短的时间内开仓和 平仓，他们更致力于把握日内的价格变化。 除了本章有关介绍以外，《股市趋势的技术分析》一书对道氏理论的基本原则也有很精彩的概括。该书作者是罗 伯特·D·爱得华兹和约翰·马吉，由约翰·马吉公司 1966 年出版。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第一章 技术分析的理论基础]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC%E4%B8%80%E7%AB%A0-%E6%8A%80%E6%9C%AF%E5%88%86%E6%9E%90%E7%9A%84%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 引言这一章我们先来做四个事情。第一，给技术分析下个定义，其二，讨论一下技术分析赖以成立的哲学前提或者说基本原理，接下来把技术分析同基础分析分出个子丑寅卯来，最后谈谈几种常见的反对技术分析的意见。 我坚信，只有先弄清楚了技术分析的所作所为，特别是它的理论基础之后，才谈得上全面理解和掌握它。 首先，我们下定义，技术分析是以预测市场价格变化的未来趋势为目的，以图表为主要手段对市场行为进行的研究。“市场行为”有三方面的含义—价格、交易量和持仓兴趣，它们是分析者通常能够获得的信息来源。另—个概念“价格变化”虽然也常用，但好象太狭窄了，因为大多数分析者也把交易量和持仓兴趣用作分析资料的一部分。在以后的讨论中，“价格变化”和“市场行为”就按这两种意义区别使用。 理论基础技术分析有三个基本假定或者说前提条件： 1、市场行为包容消化一切。 2、价格以趋势方式演变。 3、历史会重演。 市场行为包容消化一切“市场行为包容消化一切”构成了技术分析的基础。除非您已经完全理解和接收这个前提条件，否则以下的讨论毫无意义。技术分析者认为，能够影响某种商品期货价格的任何因素—基础的、政治的、心理的或任何其它方面的—实际上都反映在其价格之中。由此推论，研究价格变化就是我们必须做的事情。这个断语乍听也许过于武断，但是花功夫推敲推敲，就确实没话可说。 这个前提的实质含义其实就是价格变化必定反映供求关系，如果需求大于供给，价格必然上涨；如果供给过于 需求，价格必然下跌。这个供求规律是所有经济的、基础的预测方法的出发点。把它掉过来，那么，只要价格上涨，不论是因为什么具体的原因，需求一定超过供给，从经济基础上说必定看好；如果价格下跌，从经济基础上说必定看淡。您瞧，这段话基础分析的味道多么浓，不过大可不必为它出现在我们这篇纯粹关于技术分析的文章中而惊讶。归根结底，技术分析者不过是通过价格间接地研究经济基础。大多数技术派人士也会同意，正是根本的供求关系，即某种商品的经济基础决定了该商品的市场看涨或者看跌。图表本身并不能导致市场的升跌，只是简明地显示了市场上流行的乐观或悲观的心态。 图表派通常不理会价格涨落的原因，而且在价格趋势形成的早期或者市场正处在关键转折点的时候，往往没人 确切了解市场为什么如此这般古怪地动作。恰恰是在这种至关紧要的时刻，技术分析者常常独辟蹊径，一语中的。所以随着您市场经验日益丰富，遇上这种情况越多，“市场行为包容消化一切”这一点就越发显出不可抗拒的魅力。 顺理成章，既然影响市场价格的所有因素最终必定要通过市场价格反映出来，那么研究价格就足够了。实际上，图表分析师只不过是通过研究价格图表及大量的辅助技术指标，让市场自己揭示它最可能的走势，而并不是分析师凭他的精明“征服”了市场，之后讨论的所有技术工具只不过是市场分析的辅助手段。技术派当然知道市场涨落肯 定有缘故，但他们认为这些原因对于分析预测无关痛痒。 价格以趋势方式演变“趋势”概念是技术分析的核心。还是那句话，除非您也接受这第二个前提，否则就不必再读下去。研究价格图表的全部意义，就是要在一个趋势发生发展的早期及时准确地把它揭示出来，从而达到顺着趋势交易的目的。事实上，本书绝大部分理论在本质上就是顺应趋势，即以判定和追随既成趋势为目的(见图1.1)。 从“价格以趋势方式演变”可以自然而然地推断，对于一个既成的趋势来说，下一步常常是沿着现存趋势方向继续演变，而掉头反向的可能性要小得多。这当然也是牛顿惯性定律的应用。还可以换个说法：当前趋势将一直持续到掉头反向为止。虽然这几句差不多是车轱辘话，但反复强调的无非只有一个意思：坚定不移地顺应一个既成趋势，直至有反向的征兆为止。这就是趋势顺应理论的源头。 历史会重演技术分析和市场行为学与人类心理学有着千丝万缕的联系。比如价格形态，它们通过一些特定的价格图表形状表现出来，而这些图形表示了人们对某市场看好或看淡的心理。其实这些图形在过去的一百多年里早已广为人知、并被分门别类了。既然它们在过去很管用，就不妨认为它们在未来同样有效，因为它们是以人类心理为根据的，而人类心理从来就是“江山易改本性难移”。“历史会重演”说得具体点就是，打开未来之门的钥匙隐藏在历史里，或者说将来是过去的翻版。 技术分析与基础分析之辨 技术分析主要研究市场行为，基础分析则集中考察导致价格涨、落或持平的供求关系。基础分析者为了确定某 商品的内在价值，需要考虑影响价格的所有相关因素。所谓内在价值就是根据供求规律确定的某商品的实际价值， 它是基础分析派的基本概念。如果某商品内在价值小于市场价格，称为价格偏高，就应该卖出这种商品；如果市价小于内在价值，叫做价格偏低，就应买入。 图 1.1 上升趋势的示例。技术分析是基于以下前提之上 的:市场以趋势方式演变，并且其趋势倾向于持续发展两派都试图解决同样的问题，即预测价格变化的方向，只不过着眼点不同。基础派追究市场运动的前因，而技 术派则是研究其后果。技术派理所当然地认为“后果”就是所需的全部资料，而理由、原因等无关紧要。基础派则非得创根究底不可。 大多期货商要么说自己是技术派，要么说自己是基础派。实际上不少人两手兼备。绝大部分基础分析师对图表 分析的基本立场有实用的了解，同时，绝大部分技术分析师对经济基础也至少有个走马观花的印象(不过也有的技 术分析者不遗余力地拒绝知道任何经济信息，人称“技术癖”)。成问题的是，在很多场合，图表的预测和基础的分 析南辕北辙。当一场重要的市场运动初露端倪的时候，市场常常表现得颇为奇特，从基础方面找不出理由。恰恰是在这种趋势萌生的关键时刻，两条道路分歧最大。等趋势发展过一段之后，两者对市场的理解又协调起来，可这个时候往往来得太迟，交易者已经无法下手了。 两种方法貌合神离，而市场价格的变化总要超前于哪怕是最新获得的经济情报。换言之，市场价格是经济基础 的超前指标，也可以说是大众常识的超前指标。经济基础的新发展在被统计报告等资料揭示之前，早已在市场上实 际发生作用，已经被市场消化吸收了。因此，当前的价格实际上是当前尚来不及为人所知的经济基础因素作用的结 果。历史上一些最为剧烈的牛市或熊市在开始的时候，几乎找不到表明经济基础已改变了的资料，等到好消息或坏消息纷纷出笼的时候，新趋势早已滚滚向前了。 而技术派往往非常自信，当大众常识同市场变化牛头不对马嘴的时候，也能够“众人皆醉而我独醒”，应付自如。 他们乐于领先一步，当少数派，因为他们明白，个中原因迟早会大白于天下，不过那肯定是事后诸葛亮，他们既不愿意也没必要坐等，丧失良机。 有了上面的分析，您就不难理解何以技术派总觉得他们的一套比基础派的强。要是一个交易商非得从二者之中 挑一个不可，那么，合乎逻辑的抉择必然是技术分析。因为从定义上说，技术分析已经容纳了基础性因素。如果经 济基础已经反映在价格之中，那么再研究有关的基础性资料就多余了。图表分析抄了基础分析的近道，反过来却不 然。基础分析里不包括价格的变化。如果说单纯利用技术分析从事商品期货交易还可以的话，要是某人毫不理会市 场的技术特点，试图单单利用基础分析来做交易，那就大为可疑了。 技术分析与出、入市时机选择 为把上面最后一句话讲得更清楚，我们把决策过程分为前后两个阶段:先分析市场，而后选择出入市时机。期 货市场的杠杆作用注定了时机是交易成败的关键。请注意，即使您在把握大趋势上没有出问题，仍然很可能赔钱。 因为期货交易所要求的保证金实在太少(通常少于交易额的 10%)，价格朝不利的方向哪怕变化得并不大，交易商也 可能被扫地出门，损失大部分乃至全部保证金。在股票市场上。情况不一样，如果股价跌了，则不妨先拿着股票等 等看，但愿总有涨回来的一天。不少股票交易商就这么着，从投机转变成投资。 期贷交易商可占不到这个便宜。“买了走着瞧”这一套行不通。在市场预测阶段，技术分析或基础分析都可采用， 但到了选择具体出入市时机的时候，就只能仰仗技术分析了。这就是说，只要做交易，就得按步就班地完成这两个 步聚，哪怕您在第一个阶段用的只是基础分析，在第二阶段也还是非用技术分析不可。 技术分析的灵活性和适应性 技术分析有一个了不起的长处，它适用于任何交易媒介和任何时间尺度。不管是做股票交易，还是做商品交易， 没有用不上的地方。 做商品期货，图表派可以随心所欲地同时跟踪许多种类，而基础派往往顾此失彼。经济基础方面的资料太繁杂 了，大多数基础分析师只好从一而终，专门研究某种或某类商品，比如谷物或者金属类。我们绝不可忽视这个差别。 就说这一桩吧，市场有时平平淡淡，有时候高潮迭起；既有趋势明朗的情况，也有杂乱无章的阶段。技术派就不妨集中精力和资源，专门对付趋势良好的市场，暂且不理会其它趋势不明者。这样，在市场上各种商品轮流做庄， 交替活跃，技术派跟着把注意力和资金转移到最行时的对象上去。不同的时候总有不同的商品最火爆，趋势漂漂亮 亮，而且往往此起彼伏。技术分析师大得其宜，随机应变地轮换新宠。而基础派多是“专家”，常常享受不到这份灵 活性。即使他们要东施效颦，也非得付出许多额外的时间去把握新对象不可，缺了图表派那份潇洒。 技术派的另一个优势是“既见树木又见森林。”他们能同时跟踪所有市场，对商品市场在总体上有很好的把握， 避免了从一而终所致的管窥蠡测、坐井观天的毛病。而且许多期货之间存在着内在的联系，对类似的经济因素也会 作出相互关联的反映，因此它们之间在价格变化上可以互为线索、相互参照。 技术分析适用于各种交易媒介 图表分析原则既适用于期货，也适用于股市。它实际上起源于股市分析，后来才移植到期货市场，如今股票指数期货已经上市，两个市场之间的界限正飞快地消失。正如图 1.2 所示，各国股票市场也引入了图表及其分析原理。 10 年来，金融期货，包括利率和汇率期货大行其道，图表分析理论在这些市场上如鱼得水。 技术分析原则在套头交易(差价交易)和期权交易中也有用武之地。另外，商业保值也需要考虑价格未来走向，因而技术分析同样能发挥所长。 技术分析适用于各种时间尺度 图表分析的另一个优点是它能应用在不同的时间尺度之下。无论是研究一天以内的价格变化做当日交易，还是 顺应趋势做中等期限的跟势交易，都可以采用相同的原理。目前较长期技术预测还往往被忽视。有人说图表分析只 适合短时间域，这是无稽之谈。也有人和稀泥，说基础分析适合做长期预测，而技术分析用于短线的时机选择更好。 实践证明，使用周线图或月线图解决长期预测问题也毫不逊色。 只要您完全领会了本书所讨论的技术原理，就能在各种交易工具中、在各种时间尺度上左右逢源。 经济预测 许多人以为技术分析相对冷僻狭隘，或者把它理解成专门对付股票、期货的高度专业化的工具。实际上它的基 本理论完全能够应用到经济形势的预测上来，只不过迄今为止这方面的前景还没有被充分地认识。 技术分析预测的是金融市场的未来轨迹。这些预测对预测经济有价值吗?请看几年前华尔街日报刊登的这篇文 章:《近来债券价格快步上涨，而它历来是经济转折的优良先行指标》(1982 年 9 月 28 日)。文章通过广泛的历史纪 录有力地表明，债券价格是经济滑坡或回升之前的显著征兆。作者写道:“它作为征兆明显优于股票价格，就事论事，也大大胜过官方公布的各种先行指标。” 我们注意到引文中也提起了股票价格。标准普尔氏 500 种股票平均价格指数是商业部随时关注的 12 种经济先行 指标之一。文章引用了马萨诸塞州国立经济研究院的一份研究报告，证明该股票指数在这12种先行指标中表现最佳。 我想强调的是，现在我们既有债券期货，也有标准普尔氏 500 种指数的期货，而技术分析在研究这两种期货时都能 游刃有余，那么，不论您意识到与否，当我们对它们进行技术分析时，也同时成功地分析了经济。有个最生动的例 证:1982 年夏季，股票指数和债券市场同时爆发了—轮剧烈的牛市，及时地宣告一场自二次大战以来为时最长、痛 苦最深的大衰退就此终结——然而经济学界对如此重大的转折当时差不多毫无觉察。 纽约咖啡、糖和可可交易所(CSCE)已经申请开设四种经济指标的期货合约，其中包括住房开工率和工薪消费 者物价指数(CPI—W)，估计商品研究局期货价格指数(CRB 指数)也即将上市。而 CRB 指数早就被看成是显示通货膨胀压力的晴雨表。但这个指数的用途远不止于此。1984 年商品年鉴(商品研究公司，新泽西城)中有篇文章， 对照研究了自 1970 年以来 CRB 指数同各种经济指标的相互关系(见图 1.3)。该研究表明，CRB 指数同工业产出指标有很强的相关性，而且商品价格指数一般领先于后者的变化。有原文为 证:“CRB指数同工业产出指标有很高的相关性，表明CRB是一个非常可靠的一般经济指标。”(期蒂芬·W·麦克， 《作为一般经济指标的 CRB 指数——有27个品种的一篮子商品，一种新期货》，第 46 页)，不妨加一句，我们用图表分析CRB指数有年头了，干得相当漂亮。 综合上述可以清楚地看出，技术分析这一预测工具价值不菲，研究譬如黄金或大豆价格走向等等问题只是牛刀 小试而已。当然，也要清楚，技术分析在预测一般经济趋势上前景虽然广阔，但还有待开发利用。CSCE 最近推出的 消费者物价指数(CPI—W)期货可谓这方面的好榜样。 图 1.3 从图中可以明显看出，在 CRB 期货价格指数 (实线)与工业产出指数(虚线)之间存在着强烈的相关性 技术分析师?图表分析师? 对从事技术分析者有好几种称呼，比如技术分析师、技术师、图表分析师、市场分析家等等。这些说法以前其 实是一个意思，如今技术分析的专业分工越来越细，就有必要讲究讲究，仔细地区分。十年前，所有的技术分析都 是围绕图表开展的，技术分析、图表分析是一码事，现在不行。 随着技术分析领域的不断拓展，采用传统图表分析方法的人仍自成一派，新形成一派，即所谓技术分析派，则 往往借助统计科学和计算机工具。当然这种区分有许多重叠之处，而且大多数人在一定程度上两边都沾得上，但正 如技术派同基础派的分别一样，他们毕竟有所不同。 传统的图表分析师无论是否利用计算机辅助工作，图表依然占首要地位，其余统统是参考。而研究图表必定具有一定的主观色彩，在绝大多数场合，分析成功与否取决于分析者自身的素质。所以研读图表确实需要技艺，图表 分析师又常被称为“图表艺术家”，倒也并非“浪得虚名。” 反过来，技术分析应用了统计科学，以计算机为工具，力求客观地定量测试和改进其自动交易系统。他们把这 种系统或者交易模式编成软件，由计算机计算出“买”、“卖”信号。其中有的简单，有的极为复杂，不过总的一条， 就是要尽量减少甚至完全排除人的主观影响，把交易变成科学实践。图表在这些统计学家那里可有可无，但是只要 他们的工作不超出研究市场变化这个大范围，就仍算是技术分析师。 另外，使用计算机的分析者也可以划分成两类。一类人倾心研制自动交易系统，又称“黑箱技术”；另一种人则 致力于利用计算机开发新的技术信号，对这些技术指标的解释及其实际应用他们自己了然于心。 所有的图表分析师都是技术分析者，可是并非所有的技术分析师都是图表分析师。这也是区分两者的一个办法。 本书不打算刻意区别使用这两种说法，不过应该清楚，图表分析只是广阔的技术分析领域中的一部分。职业技术分 析人员宁愿人称“技术分析师”而不喜欢“图表分析师”这个头衔，就好比一个是“千里马”，一个是“驽马”，前者听起来俨然更加造诣不凡。 技术分析在股市和期货市场应用上的简要比较 常常有人间技术分析在股市和期货市场上的用法是不是一样，答案为既是也不是。 基本原理是共同的，使用的基本工具也一样，比如线图、点数图、价格形态、交易量、趋势线、移动平均线和 摆动指数等等。只要在一个市场上学会运用这些基本知识，就能轻车熟路地适应另外一个市场。当然股票市场和期 货市场毕竟有本质区别，要说技术分析在它们那里的差别，也就是由两个市场本身的先天特征造成的一般意义上的不同，工具本身是没有什么分别的。 标价方式 商品的标价方法比股票复杂得多。每种商品都按特定的单位标价并制定价格增减的最基本幅度。举例来说，谷物市场上的报价方式是每蒲式耳若干美分，金银是每盎司若干美元，利率是基本点数等等。交易商必须明了每个市 场的具体情况:在哪间交易所上市，合约如何标价，最大和最少的价格变化单位是多少，每张合约每基本单位价格 变化相当于多少钱的出入等等。 具有一定的有效期限 商品期货合约都有失效日期，股票则不然。比如美国长期国库券 1985 年 3 月份合约在 1985 年 3 月到期。期货 一般在到期前有大约一年半的交易时间，所以在任何时候同一商品在市场上至少同时流通着 6 种到期月份不同的合 约。交易商事先必须清楚哪一种值得买卖，哪种则应避开(以后解释这一点)。有效期特点给长期价格预测增加了难 度。每当旧合约期满新合约上市，总不得不相应地从头开始画图，而且过期合约的旧图表用处不大，新图表连同各 项新的技术参数都得重砌炉灶。市场上推陈出新不要紧，但要想维持一个长期图表就实在棘手。即使有计算机帮忙， 也必须从零开始，花费可观的人力物力来刷新资料。 较低的保证金水平 恐怕要数这个区别最要紧了。所有的期货都以保证金方式交易，大多数期货所要求的保证金少于交易量的 10%。 较低的保证金水平导致了很高的杠杆效应。价格不管朝哪个方向只变化一点点，就会影响总的交易成绩。正因如此， 在期货市场上可能在很短的时间内赚或者赔一大笔钱。既然交易者只拿出10%的押金，却做了 100%的交易，那么 10%的价格变化就能或者让他本金翻倍，或者让他血本无归。时间也不一定长，吃早饭开头寸，也许不到午饭时分，整个过程就结束了。期货市场的杠杆效应放大了市场动作，使之看起来比实际上更反复无常。要是有人扬言自己在 期货市场上被“洗劫一空”，您请记着他起先是拿 10%博 100%的。 从技术分析的角度看，杠杆效应使选择出入市时机这一步骤在期货市场比在股票市场大为重要。正确地选择入 市和出市的时机一方面是交易成败的关键，另一方面也是市场分析面对的一大课题。正是这样，以技术分析为中心 的交易策略才成为期货交易成败攸关、不可或缺的关键。 时间域大为缩小 在杠杆效应作用下，期货商必须密切关注市场的一举一动，因此所关心的时间域必然也细致入微。与此不同， 股市分析者喜欢更长时间的图表，研究更长时间的问题，他们也许要预测的是 3 个月或半年后的市场。期货商想知道的则是下周、明天乃至下半天的形势如何，所以所提炼出的一些具有即时效用的工具，股市分析师或许闻所未闻。 移动平均线便是一例。在股市分析中用得最广泛的是 30 周或者200天的平均线，而在期货市场，绝大多数在 40 天 以下，其中流行的移动平均线组合是 4 天、9 天和 18 天。 时机更为紧要 对期货商而言，时机决定一切。正确判别市场方向仅仅是问题答案的一小部分。入市时间相差一天，有时甚至 仅几分钟，结果可能就是成与败，截然不同。弄错了市场趋势而赔了钱固然糟糕，然而大方向没错却依然损兵折将 才是期货交易最令人沮丧、畏缩的地方。基础性因素很少一天一变，所以毋庸置疑，时机抉择问题实质上纯粹是技 术性的。广泛商品价格平均指数用得较少 股票平均价格指数的变化是极为引人注目的，比如道·琼斯工业股票指数或者标准普尔氏 500 种股票指数。实际上这是所有股市分析的起点。期货市场一般并非如此。尽管也有一些代表商品市场总体价格方向的指数，比如商品研究局期货价格指数(CRB)也广受注意，但它们没有股票指数那样显要。广泛性技术信号在期货市场用得较少股市分析中广泛性技术信号很重要，例如涨跌线、新高新低指数、空头动向比等，但它们在期货市场不流行。 这倒不是因为它们的理论和实践压根不适合期货，也许有一天期货种类大为增加，就有必要借助这些广泛性指标来 判断市场总体运动了，只是迄今为止还用不着它们。具体的技术工具大多数起源于股市分析的技术工具也能适用在商品市场，不过用法不完全一样。举个例子，期货的图表形态往往不象在股市里那样走得那么完整，移动平均线的天数也少得多，传统的点数图 也用得不广泛。这是因为很难获得每天的价格数据的细节，所以主要是场内交易商使用点数图。本书后面还将进一 步讨论上述分别以及其余用法上的差别。最后我们谈谈股市同期货之间另一个重要区别。在进行股市技术分析时，非常看重情绪指数和资金动向。情绪 指数用来跟踪显示散户、共同基金、场内交易商等各个群体的表现。根据“真理往往在少数人一边”的原则，情绪 指数是判断市场在总体上看好或看淡的极为重要的依据。资金动向用来考察不同群体的现金头寸情况，比如共同基 金或大机构交易商的帐户。它的基本理论是现金头寸越大，就越有购买股票的潜力。就技术分析本身而言，两者都 属于辅助性质，但股市分析者对它们的重视程度比对传统的市场分析要大些。在我个人看来，期货市场中的技术分析是更为纯粹的价格研究。虽然相反意见理论在一定范围内不无长处，但 基本趋势分析和传统技术指标的应用更为关键。技术分析的一些反面意见在讨论技术分析时，常常出现一些大同小异的疑问。所谓“预言自我应验”就听得不少。还有“到底能否用过 去的价格资料来预测下一步价格方向?”等等。反对者总是强调。图表记录了市场价格的来龙，却说不出它的去脉。 很显然，如果您不会读图，当然从图表上看不出门道来。这一点姑且不论。随机行走理论认为价格毫无趋势可言， 言下之意是什么样的预测技术也不比简简单单地“买了拿在手里等着”这一招高明。这就值得理论理论。 “一语成谶”论“一语成谶”论也可以说成“预言自我应验”。是不是真管用?这个问题问得太多了，说明很多人心存疑惑。这 种说法肯定不是无中生有，不过大可不必如此耿耿于怀。下面我们引用一段话，也是讨论期货交易的，从几个方面 批评了图表形态，这也许是表述上述问题的最好方法。a.近年来绝大部分图表形态流传广泛。许多交易商把它们牢记于心，常常根据图形不约而同地行动。于是乎每 当图形发出“看涨”或“看跌”的信号时，买者或卖者一涌而上，结果产生了“预言自我应验”的现象……b.图表形态的辩认几乎纯粹出自主观判断。迄今没有任何图形可以用数学方法科学地定量研究。要说它们是读 图者心中的臆想，一点也不夸张……(理查德·J·塔韦尔斯，查尔斯·V·哈洛，赫伯特·L·斯通，《商品期货游 戏》，p.176，麦格劳—希尔出版社，1971 年)。上面两段批评自相矛盾，后语抹杀了前言。既然图表形态“出自主观判断”，是“读图者心中的臆想”，那么许 多人在同时看出同样的信号这事就实在不可思议了，而这恰恰是“自我应验”论的基础。看来批评家们只好割爱， 不可以一边说图表形态是板上钉钉，既客观又容易判定，每个人都能同时看出同样的图形，采取同样的行动，使图 表形态自动应验；一边又批评图表分析过分地主观、人见人殊。 事实上图表形态很客观，而研读图表是门艺术(或者说是“技巧”更恰当)。图表形态几乎从来没有清楚得能让 有经验的分析师们意见一致的时候。疑虑重重、困惑不解或者仁者见仁智者见智才是家常便饭。正如本书将要说明 的那样，技术分析有许多种选择，各种选择相互之间经常合不上榫。有条条大路，但不全通罗马。 即便大多数分析者预测一致，所见略同，他们也不一定在同时以同样的方式入市。有些也许预计到图表信号将 会出现便“先下手为强”。还有人也许等到图形或指标突破后在市场回撤时才下手。有些交易商大胆积极，有些人谨 慎保守。有些人在入市时同时发出止损指令，有些则留下预定水平指令或限价交易指令做交易。因此所有人在同一时刻以同一方式入市的可能性甚微。 即使“预言自我应验”果有其事，那么它天生也会“自我修正”。换句话说，在交易商们不谋而合的行为扭曲市 场之前，大家都仰仗图表，而一旦“自我应验”发生之后，他们要么把图表扔到一边，要么更改交易策略。比如他 们可能力图在众人之前或者等到市场进一步证实时才作反应。就这样，即使短时间内预言自动应验现象惹出问题，这种机制本身也将自动地修正自己。 请记住，唯有供求规律才能决定牛市或熊市的发生、发展。技术分析师势单力薄，绝不能凭白无故地靠他们自 己的买进或者卖出引发市场的重要变化。要是他们能做到这一点，早就该发大财了。 一些规模庞大的交易商越来越多地借助计算机化的自动交易系统，它们带来的问题其实比图表分析师招惹的麻 烦重大得多。设计这些系统都是为了辨识和顺应大趋势，本质上属于“因势利导”。十多年来在期货行业中，置于职 业化管理之下的资金急剧膨胀，公共和私人基金动辄上亿美元地买卖。它们又大多采用此类技术性系统，结果是庞 大的资金高度集中，在为数不多的几个趋势性市场“追势逐利”。因为期货市场总的容量尚有限，这些系统短期内对 价格产生破坏性影响的危险性与日俱增。然而哪怕万一出现了这种偏差，也注定为时短暂，不会引起重要的运动。 我们再次强调，甚至由于高度集中的巨额资金采用技术性系统引致的问题也会自我修正。如果所有的系统同时 做同样的操作，交易商就会调整系统，使之更迟钝或更灵敏。我们一般把预言自我应验论看成是对图表分析的反对意见，其实说它是赞誉或许更为恰当。要是有哪种预测技 术如此广受欢迎，以致于能够影响市场，那它非得出类拔萃不行。您不妨琢磨琢磨，为什么提起基础分析时，很少有人会顾虑它也出现自我应验的问题呢? 过去能否预测未来? 用过去的价格资料能否有效地预测未来，这是另一个引起争议的问题。很奇怪为什么反对技术分析的人总是拿 出这个法宝来，大家都明白，每一种预测方法，从气象预报到基础分析，都是建筑在对历史资料的研究之上的。除此之外，还有什么资料可供选择呢? 统计学理论划分成描述统计学和推导统计学两部分。描述统计学指用图表达资料数据，比如用一张标准的线图 来展示价格历史。推导统计学则指从资料推导出概括的、预测的或推延性的结论。所以价格图表属于前者的范畴， 而针对价格图表进行的技术分析则属于推导统计学的范畴。 正如一本统计学教科书所说:“商业或经济预测的第一个步聚就是搜集历史观测资料”(约翰-E·弗罗因德和弗 兰克·J·威廉斯，《现代商用统计学》，p.383，普伦蒂斯一霍尔出版社，1969 年)。图表分析只是时间序列分析的 一种形式，正如所有的时间序列分析一样，也是以历史为依据的。无论谁，唯一能获得的资料或者数据，只是过去 的记录。只有把过去的经历投影到未来，我们才能估计未来。再从这本书中引用一段:人口预测、工业预测等等，在很大程度上是基于对过去发生的事物的研究。正如在日常生活中一样，在商业和 科学上，我们也都是依靠过击的经验展望难以捉摸的未来的(《现代商用统计学》，p.383)。综合起来，技术分析以过去的价格数据预测未来，有充分的统计学根据。要有人执意怀疑技术分析在这个方面 的立足点，那么他只好把所有以过去研究未来的学问一古脑儿推翻，当然其中免不了所有的经济分析、基础分析。 随机行走理论 随机行走理论原本在高知识阶层发端并流行。它认为价格变化在顺序上互相独立，因而价格历史并不是未来价格方向的可靠线索。简而言之，价格变化是随机而不可预测的。这个理论借着《股票市场的随机行走特点》一书到 处“行走”，名噪一时。该书编者是保罗·H·库特纳，由麻省理工学院出版社 1964 年出版。从此赞成和反对两派纷 纷著书立说，论战不休。该理论根据有效市场假定，认为价格在内在价值上下随机波动。同时还推论，最好的市场 策略就是简简单单地“买了等着”，反对“战胜市场”的企图。 所有的市场确实都具备一定的随机性，或者说“噪音”，但以为所有价格变化都是随机而来却并非实情。断这个 官司恐怕凭经验和实践更靠得住，而复杂高深的统计学方法要么似乎能证明研究者预先设想的一切，要么什么也否 定不了。满目随机其实只是无力辩识系统性价格变化形态的代名词，您不妨把这话记在心里浒多学者没有能力揭示 价格形态，可这并不能证明价格形态不存在(见图 1.4)。 图 1.4 请看这张瑞士法朗的图表，如果“随机行走论”者在这张图面前楞 想兜售“市场上根本无趋势可言”的论调的话，恐怕免不了要碰一鼻子灰当市场趋势明朗时，趋势对一般的市场分析人员或实际交易人员到底有无价值呢?学院派争论不休。要是您对 这一点也有疑惑，随便翻翻哪本图表书(随机地挑出来)，就可以很直观地看到趋势确实客观存在。如果价格变化前 后无关，也就等于昨天或者上星期的事儿在今天或明天全无痕迹，那么试问随机行走派诸君，如何解释触目可见的 趋势呢?不少顺应趋势系统在现实交易中战果辉煌，利润丰厚，又该作何解释呢?在期货市场选择时机是个关键，“买 了等着”如何行得通呢?应该在熊市中拿着这些头寸坐等吗?要是前后价格相互无关，价格变化既没有趋势也无从 预测，交易商如何能知道牛市和熊市的分别呢?事实上“买了等着”就等于是个上升趋势。那么熊市如何能存在呢? 统计学证据能否最终肯定或彻底推翻随机行走理论，天晓得，不过随机理论在技术分析界毫无市场。如果市场 果真随机，那么没有什么预测技术靠得住。有效市场假定恰恰同技术分析的前提之一“市场包容消化一切”异曲同 工，而不是否定了技术分析的可靠性。学院派也发觉市场很快地消化一切信息，想靠消息灵通来发财没门儿。在这 里他们总算摸着技术分析理论基础的一点边，即重要的市场信息在其广为人知之前，早已为市场价格所包容消化。 学院派弄巧成拙，反而清清楚楚地证明了密切关注价格变化的重要性，试图利用基础性情报渔利至少对短时期而言是缘木求鱼。 最后我们必须承认，要是不理解具体的过程进行规则，任何过程都会显得杂乱无章。比方说一张心电图，在外行看来，活象一长串杂乱无章的噪音，可在一个训练有素的医生眼中，其中每个小波折都充满了意义，肯定不是随 机而来。对没有花功夫研究期货市场行为规律的人来说，市场动作也可能是随机的。随着读图技能的提高，随机的 错觉逐渐消失。相信读者在逐步深入学习本书各章节的过程中，会亲身体验这种现象。 如果有兴趣进一步了解随机行走理论，这儿有一份自从70年代早期以来商品期货市场研究的摘要，名为《期货市场问题——一份调查报告》。卡玛拉摘录了几份认为期货价格具有连续性、反对随机理论的文章，也选入了另一派的意见，使学院派的这场争论有来有去。这些出版物学究气很浓。其它讨论随机理论 的文章偶尔可见。另一本书叫《在华尔街上随机走走》。 下面，我想引用市场技术分析师协会会员大会上的“主席致辞”，来结束对随机行走理论的讨论。这次会议是应学院派研究者为增进同各行业技术分析业者的交流的要求而召开的。 我注意到学院派研究者有一个重要的转变。他们现在终于意识到，尽管近年来学院派出版物上各种批评不绝于耳，分析家和投资者们依然非常成功(弗雷德·迪克森，协会主席，市场枝术分析师协会通讯，1984 年 2 月)。 结论现在我们已经为技术分析打好了理论基础，也澄清了一些有关技术分析的常见疑问，可以言归正传了。我们选择源远流长的最著名的技术分析理论—道氏理论作起点。]]></content>
      <categories>
        <category>期货</category>
      </categories>
      <tags>
        <tag>期货市场技术分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[既然有HTTP请求，为什么还要用RPC调用？]]></title>
    <url>%2F2020%2F11%2F25%2F%E6%97%A2%E7%84%B6%E6%9C%89HTTP%E8%AF%B7%E6%B1%82%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8RPC%E8%B0%83%E7%94%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 问：既然有 HTTP 请求，为什么还要用 RPC 调用？ 首先 RPC 框架配置复杂，如果走 HTTP 请求同样也能做到相同功能，而且配置可以几乎为零配置。项目也不用引用太多的包。虽然如果单纯用 RPC，可以不用类似于 Servlet 的 Web 标准。 首先，实名赞扬题主的问题。这个问题非常好。 其次，实名反对各个上来就讲RPC好而HTTP不好的答案。因为，题主的观点非常对。 HTTP协议，以其中的Restful规范为代表，其优势很大。它可读性好，且可以得到防火墙的支持、跨语言的支持。而且，在去年的报告中，Restful大有超过RPC的趋势。 本想引用下报告内容，无奈最近由于某些原因，KeXueShangWang被Qiang了。等我日后出墙时，再做补充。 但是HTTP也有其缺点，这是与其优点相对应的。首先是有用信息占比少，毕竟HTTP工作在第七层，包含了大量的HTTP头等信息。其次是效率低，还是因为第七层的缘故。还有，其可读性似乎没有必要，因为我们可以引入网关增加可读性。此外，使用HTTP协议调用远程方法比较复杂，要封装各种参数名和参数值。 而RPC则与HTTP互补，我们详细介绍下。看完这篇回答，能让你对RPC的产生、原理、实现代码都有着清晰的了解。这样，也能在业务系统中，在RPC和HTTP之间做好抉择。 但需要再说一句，不是说RPC好，也不是说HTTP好，两者各有千秋，还在比拼中。 要问我站谁？我根据业务场景，灵活站位…… RPC的英文全称是Remote Procedure Call，翻译为中文叫“远程过程调用”。其中稍显晦涩的其实就是“过程”，过程其实就是方法。所以，可以把RPC理解为“远程方法调用”。 要了解远程过程调用，那先理解过程调用。非常简单，如下图，就是调用一个方法。这太常见了，不多解释。 而在分布式系统中，因为每个服务的边界都很小，很有可能调用别的服务提供的方法。这就出现了服务A调用服务B中方法的需求，即远程过程调用。 要想让服务A调用服务B中的方法，最先想到的就是通过HTTP请求实现。是的，这是很常见的，例如服务B暴露Restful接口，然后让服务A调用它的接口。基于Restful的调用方式因为可读性好（服务B暴露出的是Restful接口，可读性当然好）而且HTTP请求可以通过各种防火墙，因此非常不错。 然而，如前面所述，基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。 服务A调用服务B的过程是应用间的内部过程，牺牲可读性提升效率、易用性是可取的。基于这种思路，RPC产生了。 通常，RPC要求在调用方中放置被调用的方法的接口。调用方只要调用了这些接口，就相当于调用了被调用方的实际方法，十分易用。于是，调用方可以像调用内部接口一样调用远程的方法，而不用封装参数名和参数值等操作。 那要想实现这个过程该怎么办呢？别急，咱们一步一步来。 首先，调用方调用的是接口，必须得为接口构造一个假的实现。显然，要使用动态代理。这样，调用方的调用就被动态代理接收到了。 第二，动态代理接收到调用后，应该想办法调用远程的实际实现。这包括下面几步： 识别具体要调用的远程方法的IP、端口 将调用方法的入参进行序列化 通过通信将请求发送到远程的方法中 这样，远程的服务就接收到了调用方的请求。它应该： 反序列化各个调用参数 定位到实际要调用的方法，然后输入参数，执行方法 按照调用的路径返回调用的结果 整个过程如下所示。 这样，RPC操作就完成了。 调用方调用内部的一个方法，但是被RPC框架偷梁换柱为远程的一个方法。之间的通信数据可读性不需要好，只需要RPC框架能读懂即可，因此效率可以更高。通常使用UDP或者TCP作为通讯协议，当然也可以使用HTTP。例如下面的示例中，为了保证实现最简单，就用了HTTP进行通信。 讲到这里，RPC的产生原因、原理应该清楚了。为了让大家真的明白，我写了一个真的是最最简单的RPC实现。把它放到了： https://github.com/yeecode/EasyRPC 它包含一个客户端，一个服务端。客户端只要调用自身内部的接口，就通过这个小的RPC实现调用到了服务端的方法。 下面是客户端的代码，看着类有点多，其实代码不长。其中的RPC代码完成完成动态代理、远程调用参数序列化、远程调用发起、远程调用结果反序列化的工作。 RPC客户端下面是服务端的代码，代码更少，完成远程调用接收、调用参数反序列化、调用实际触发、调用结果序列化的工作。 RPC服务端这样，一个RPC小框架就做完了，并不复杂。 所以，不要被RPC吓到，它就是让一个应用调用另一个应用中方法的一种实现方式。与调用远程接口区别不大，条条大路通罗马。 再说一次，不是说RPC好，也不是说HTTP好，两者各有千秋。本质上，两者是可读性和效率之间的抉择，通用性和易用性之间的抉择。最终谁能发展更好，很难说。 要问我站谁？我根据业务场景，灵活站位……]]></content>
      <categories>
        <category>HTTP</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 进行历史回测]]></title>
    <url>%2F2020%2F11%2F25%2F%E7%AC%AC4%E7%AB%A0-%E8%BF%9B%E8%A1%8C%E5%8E%86%E5%8F%B2%E5%9B%9E%E6%B5%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么程序交易要进行历史回测？或许对于一些市场上的主观的交易老手而言，量化交易并不管用，也无须进行历史回测；但对于经验不够丰富的交易人来说，历史回测或许能帮助他们更快地找到稳定获利的机会。对于程序交易者而言，历史回测是否必要？答案是“是”。因为量化交易程序放大了数据的重要性，这与人的本能相违背，许多数据一闪即逝，也有许多数据实际存在但总被人忽略。这些情况在量化回测中都是必须被正视的话题，本章将会讲述构建历史回测的细节，让大家快速投入量化回测的世界。 认识历史回测当我们在市场上交易，对于当前市场的趋势变动没有把握时，就需要历史回测来验证自己的想法是否可行。历史回测不仅仅只是数学量化模型的计算，同时也包含了量化模型以外的市场行为分析。 以往大家没有完整的历史数据时，只能依赖网络上散播的统计信息、盘后数据，没有办法准确地进行历史回测，而现在是大数据时代，量化回测已经成为一门不可或缺的技术。 回测的意思就是使用历史数据回溯测试。当我们有一个交易的想法时，首先会将规则明确列出并写成具体的代码，接着就会拿出历史数据加以验证，看看我们的想法在之前的交易日中具体成效如何。这时如果拥有足够多的历史数据，就能更准确地了解可用性，并在未来的预测中提供更准确的依据。 回测算法架构期货交易，简单来说就是一买一卖，赚取价差。算法的目的在于将投资人的交易行为量化转化为代码。程序化交易中的回测算法与实盘交易算法有不同的编写方式，所以本书才会对回测和实盘分别进行介绍。 回测算法就是通过历史数据，模拟真实的开盘环境，进行数据解读、计算、判断，决定是否建仓、平仓，获取成交信息。 量化回测的必要步骤： (1) 读取历史数据； (2) 转换回测指标； (3) 历史算法设计； (4) 历史回测回传明细格式设计； (5) 绩效计算。 建立回测流程1、读取历史数据 本技巧要介绍的“读取历史数据”不仅仅是通过函数去取得数据，还要去运用数据。 (1) 获取数据函数 算法程序必须先获取交易指标数据或历史报价。 (2) 运用历史数据方式 在读取数据后，如何运用这些数据才是重点，因为交易所历史数据的种类是属于按时间顺序的数据，而交易算法与时间字段也息息相关，所以从某个程度上来说时间格式的掌握是相当重要的。1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; I020 = [ line for line in open('Futures_20170815_I020.csv')]&gt;&gt;&gt;&gt;&gt;&gt; I020[0:5] ['INFO_TIME,MATCH_TIME,PROD,ITEM,PRICE,QTY,AMOUNT,MATCH_BUY_CNT,MATCH_SELL_CNT\n', '8450010,8450009,TXFH7,128,10310,732,732,202,349\n', 8450011,8450010,TXFH7,128, 10309,4,736,206,350\n', '8450011,8450010,TXFH7,128,10309,1,737,207,351\n','8450011,8450010,TXFH7,128,10310,1,738,208,352\n']&gt;&gt;&gt; I020a = [ line.strip("\n") for line in I020[1:] ]&gt;&gt;&gt; I020a[0:5]['8450010,8450009,TXFH7,128,10310,732,732,202,349', '8450011,8450010,TXFH7,128, 10309,4,736,206,350', '8450011,8450010,TXFH7,128,10309,1,737,207,351', '8450011, 8450010,TXFH7,128,10310,1,738,208,352', '8450011,8450010,TXFH7,128,10310,1,739, 209,353']&gt;&gt;&gt; I020b = [ line.split(",") for line in I020a ]&gt;&gt;&gt; I020b[0:5][['8450010', '8450009', 'TXFH7', '128', '10310', '732', '732', '202', '349'], ['8450011', '8450010', 'TXFH7', '128', '10309', '4', '736', '206', '350'], ['8450011', '8450010', 'TXFH7', '128', '10309', '1', '737', '207', '351'], ['8450011', '8450010', 'TXFH7', '128', '10310', '1', '738', '208', '352'], ['8450011', '8450010', 'TXFH7', '128', '10310', '1', '739', '209', '353']]&gt;&gt;&gt; I020c = [ line for line in I020b if int(line[0]) &gt; 9000000 ]&gt;&gt;&gt; I020c[0:5][['9000006', '8595997', 'TXFH7', '128', '10311', '2', '12906', '6457', '6827'], ['9000006', '9000000', 'TXFH7', '128', '10311', '1', '12907', '6458', '6828'],['9000018', '9000010', 'TXFH7', '128', '10311', '1', '12908', '6459', '6829'],['9000018', '9000012', 'TXFH7', '128', '10311', '4', '12912', '6461', '6830'],['9000031', '9000024', 'TXFH7', '129', '10311', '1', '12914', '6463', '6831']] 两种方式各有优缺点，假如要依照时间序列判断目前是否锁定收益出场，可以通过for循环来逐笔判断;若要获取特定时期的价格高低点，则会直接通过Python的list搭配max、min来完成。 2.转换回测指标 “转换回测指标”就是将现有的历史数据进一步转换成指标，而每个交易者对于指标的定义都不尽相同，所以必须明确定义指标。 以下提供常见的交易指标，供读者参考。 (1)移动平均价 假如在期货交易市场上的交易算法是通过移动平均（MA）为主要的交易指标，那就会定义移动平均的周期以及长度。假设是10分MA，周期就是分钟，长度就是10，而显示出来的信息也就是由10分钟的每分钟收盘价所计算的指标。 若10分MA通过前10分钟的收盘价计算，那就只能看到上一分钟的状态，无法掌控最新的市场价格动态。若获取tick数据，也就是逐笔信息，就能够依照最新的价格来进行计算，也就是说，从原本的10分钟收盘价变为9分钟的每笔收盘价加上当前的tick计算， 可以即时地反映最新的市场动态。 在技巧24中，详细地介绍过如何动态计算移动平均价，可至第2章参考。 (2)当日价格高低点 回测指标所指的是当日的高低点，并非是直接通过历史数据获取当天的最高价和当天的最低价，而是回测时逐笔地去计算当日最高价和最低价。若回测当前时间为09:50:35，则目前的最高价和最低价就是09:50:35以前的最高价和最低价。 若直接取得当日高低点，可能会造成程序逻辑上的错误，所以在定义指标前必须先厘清观念。 动态计算当日最高点和当日最低点，代码如下： 文件名：42-1.py 1234567891011121314151617# -*- coding: UTF-8 -*-# 取I020，依照逗号分隔，并将分隔符号去除I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_I020.csv')][1:]# 定义变量初始值high=int(I020[0][4])low=int(I020[0][4])# 开始计算高低点for i in I020[1:]: price = int(i[4]) if price &gt; high: high=price if price &lt; low: low=price print("Time:",i[0]," Price:",price," High:",high," Low:",low) 若要将指标存成新文件，可以将上面示例程序中的print函数改为write函数。写入文件的细节请参考技巧11。 通过CMD执行Python指令，输出如下： 1234567891011121314151617&gt; python 42-1.pyTime: 8450011 Price: 10309 High: 10310 Low: 10309 Time: 8450011 Price: 10309 High: 10310 Low: 10309 Time: 8450011 Price: 10310 High: 10310 Low: 10309 Time: 8450011 Price: 10310 High: 10310 Low: 10309 Time: 8450011 Price: 10309 High: 10310 Low: 10309 Time: 8450011 Price: 10309 High: 10310 Low: 10309 ...Time: 8450043 Price: 10312 High: 10312 Low: 10309 Time: 8450043 Price: 10312 High: 10312 Low: 10309 Time: 8450056 Price: 10310 High: 10312 Low: 10309 Time: 8450056 Price: 10313 High: 10313 Low: 10308 Time: 8450056 Price: 10313 High: 10313 Low: 10308 Time: 8450056 Price: 10310 High: 10313 Low: 10308 Time: 8450056 Price: 10313 High: 10313 Low: 10308 Time: 8450056 Price: 10313 High: 10313 Low: 10308 (3)内外盘量 内外盘是大家常用的指标之一，一般的计算方式为下一笔成交价落在上一档价（卖方价格）还是下一档价（买方价格），若价格落在上一档价时，则为“外盘价”;落在下一档价时，则为“内盘价”。 内外盘还有另外一种算法，就是当成交价大于上一笔成交价时，则为“外盘量”；反之，则为“内盘量”。 计算内外盘量的总和可以用来判断目前的多空方趋势：若外盘量较多，则多方趋势较空方趋势重，价格往上的概率较高；反之，若内盘量较多，则空方趋势较多方趋势重，价格往下的概率较高。动态计算当天的内外盘量，预测当天的多空趋势，代码如下： 文件名：42-2.py 123456789101112131415161718# -*- coding: UTF-8 -*-I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_I020.csv')][1:]lastPrice=int(I020[0][4])outDesk=0inDesk=0# 开始计算内外盘for i in I020[1:]: price = int(i[4]) qty = int(i[5]) if price &gt; lastPrice: outDesk+=qty if price &lt; lastPrice: inDesk+=qty print("Time:",i[0]," Price:",price," OutDesk:",outDesk," InDesk:",inDesk) lastPrice = price 若要将指标存成新文件，可以将上面示例程序中的print函数改为write函数。写入文件的细节请参考技巧11。 本示例是通过单纯的成交价比对计算的，若要通过上下五档价来做内外盘判断计算， 则需要搭配I080数据计算。 通过CMD执行Python指令，输出如下：1234567891011121314151617&gt; python 42-2.pyTime: 8450011 Price: 10309 OutDesk: 0 InDesk: 4 Time: 8450011 Price: 10309 OutDesk: 0 InDesk: 5 Time: 8450011 Price: 10310 OutDesk: 0 InDesk: 5 Time: 8450011 Price: 10310 OutDesk: 0 InDesk: 5 Time: 8450011 Price: 10309 OutDesk: 0 InDesk: 7 Time: 8450011 Price: 10309 OutDesk: 0 InDesk: 8...Time: 8450456 Price: 10308 OutDesk: 513 InDesk: 91 Time: 8450468 Price: 10309 OutDesk: 513 InDesk: 93 Time: 8450468 Price: 10309 OutDesk: 513 InDesk: 97 Time: 8450468 Price: 10308 OutDesk: 513 InDesk: 98 Time: 8450481 Price: 10309 OutDesk: 513 InDesk: 99 Time: 8450481 Price: 10308 OutDesk: 513 InDesk: 100 Time: 8450481 Price: 10309 OutDesk: 513 InDesk: 104 (4)委托手数差值 委托手数差值是通过委托信息来计算的，会将委托的买方手数以及委托的卖方手数相减。若值为负数，则代表目前委托买方手数较少，代表目前市场委托趋势较偏向空方;反之，若值为正数，则代表卖方手数较少，代表目前市场委托趋势较偏向多方。 (5)委托比重 委托比重指标是从委托信息计算而来的，会将委托的买卖方分别用手数除以笔数来计 算买卖方的平均单笔手数，进而通过比重的方式计算该指标。假设委托的买方为100手、50笔，卖方为80手、20笔，则委托的买方平均手数为2手，卖方平均手数为 4 手，进而 计算出多方委托比重为 33.33%，空方委托比重为 66.67%。 这个指标与委托手数差值指标最大的不同在于委托比重不会受到手数绝对的影响，就 算买方的手数相当多，但笔数也相对多，还是有可能被空方趋势胜过。 (6)成交买卖单笔数 成交买卖单笔数是由成交信息获取的，通常交易者会根据成交买卖笔数来做趋势的判断，因为对于累积成交量，买卖方是相等的，所以当成交买笔数小于成交卖笔数时，代表成交买方平均手数大于卖方平均手数，这时就可以判断买方趋势大于卖方趋势。 3.历史算法设计 由于回测算法获取的是历史数据，因此在编写回测算法时可以依照需求去撷取需要的部分信息。假设交易算法只操作当日开盘的第二个小时，那么通过子集合的函数去获取那一段期间的数据即可，不必再从文件的开始读取到结尾。 回测算法也是交易算法，所以依照流程会有趋势判断、进场、出场和止损等相关步骤。下面会通过简单的程序流程来帮助大家了解如何操作。 42-3.py 1234567891011121314151617181920# -*- coding: UTF-8 -*-I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_I020.csv')][1:]#起始時間至結束時間I020a= [ line for line in I020 if int(line[0])&gt;9000000 and int(line[0])&lt;11000000]#初始倉位index=0for i in I020a: if index==0: if 进场条件: OrderTime=i[0] #下單時間紀錄 OrderPrice=i[4] #下單價格紀錄 elif index!=0: if 出场条件: OrderTime=i[0] #下單時間紀錄 OrderPrice=i[4] #下單價格紀錄 该策略仅展示用途，并没有实际用意，要编写回测算法，可以通过上述概念来进行， 但实际上还是有许多细节需要注意。 4.历史回测回传明细格式设计 回测交易格式的设计，是希望完整地保存回测交易记录，并且真实地表达交易事件的细节，最后让这些记录能够被适度地分析，让回测的效益最佳化。 以下是交易事件回传格式: 选项 作用 交易序列号 SerialNumber 交易商品 Good 开仓日期 ODate 开仓时间 OTime 开仓价格 OPrice 买卖 BorS 数量 Number 平仓日期 CDate 平仓时间 CTime 平仓价格 CPrice 注记 Comment 税金 Tax 手续费 Fee 策略编号 PID 交易者编号 ID 读者看到这里，或许会好奇，为什么没有盈亏字段呢?首先，通过原有的数据字段就可以计算出盈亏，为了避免表格字段过于冗长，所以不另外设置字段。另外，若要观察回测的效益，盈亏也并非绝对标准。怎么说呢?就好比一个回测程序虽然说一个月的总盈亏是−1000，但它并不代表就是一个不好的策略，或许买方的头寸净利是3000，卖方的头寸净利是−4000，只要将这个策略设置为只做买方，就会是一个赚钱的策略。除了盈亏，也有很多角度可以分析策略的好坏，例如：交易时间、持仓时间等。除盈亏以外的分析对于交易而言也是相当重要的，后面会有介绍。 每个字段都具有存在的价值，而第一个字段交易序列号代表唯一值，所以每笔数据并 不会发生重复的现象。上述交易回传格式不一定符合每种交易类型的需求，可以依照自己 的需求做更改。 以下是开盘买、收盘卖的策略，做一个基础的交易回传明细: 文件名：42-4.py 12345678910111213# -*- coding: UTF-8 -*-I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_I020.csv')][1:]OrderTime=I020[0][0] #下單時間紀錄OrderPrice=int(I020[0][4]) #下單價格紀錄CoverTime=I020[-1][0] #平倉時間紀錄CoverPrice=int(I020[-1][4]) #平倉時間紀錄print("Buy OrderTime:",OrderTime," OrderPrice:",OrderPrice,)print (" CoverTime:",CoverTime," CoverPrice:",CoverPrice," Profit:",CoverPrice-OrderPrice) 执行回测后，输出如下： 1234567&gt; python 42-4.pyBuy OrderTime: 8450010 OrderPrice: 10310 CoverTime: 13450006 CoverPrice: 10309 Profit: -1 5.绩效计算 读取交易记录后，就可以依照交易回传的数据去加以计算分析。绩效不仅可以从盈亏去观察，也可以从买卖、交易次数、交易时间点来进行分析。本节提供的绩效分析示例虽不多，但主要是让读者熟悉系统分析命令的用法。 某些策略会符合某些时期的趋势条件，但不代表那些策略会符合长期市场的走势，毕竟交易市场是瞬息万变的，若要调试出一个长期稳定获利的策略，必须要经过长期回测的测试。 绩效计算不一定是从获利盈余的数字上来看，以下提供其他参考绩效的方向让读者参考： (1)交易次数胜率； (2)买卖个别成交结果。 即时算法回放回测回测程序与即时算法程序的编写方式不同:回测程序的目的在于验证投资人的交易逻辑能 否在真实市场中获利;而即时算法则是将交易人的逻辑通过程序在真实市场上进行运作。 本概念要阐述的是，即时算法与回测算法对于真实市场的反应是有差异的，所以当一个量化交易回测者要真正落实即时程序化交易时，总是会充满不确定性，这时就要通过轮播机制来验证即时算法的正确性，以预防即时算法程序错误导致亏损。 时间单位不同的差异在网络上获取的信息与交易所实际揭示的信息，往往最大的差异是来自时间的字段。 在交易所揭示的成交信息中，会有撮合时间和报价时间。其中，撮合时间是交易主机将买卖方的相同数量委托单进行撮合时的时间，而报价时间是交易所揭示报价时的时间。 除了时间字段以外，还有数据密度。如果交易所原本揭示的时间字段密度到百分之一秒，但网络数据只揭示到秒，那么对于手动交易的投资人而言可能没有太大差异，但对于程序而言就会发现同一个时间点产生了许多笔交易信息。 例如，原本数据是 9 点 10 分 10.03 秒与 9 点 10 分 10.55 秒，对于程序而言两笔数据时 间不一样，但对于网络上免费的数据可能两笔都是 9 点 10 分 10 秒，这对于回测来说就没 那么精准了。 下面提供几个不同的时间单位所绘制出的图形，比较其差异。 (1)由数据密度为30秒所绘出的K线图，如图4-1所示。 图 4-1 (2)由数据密度为分所绘出的K线图，如图4-2所示。 图 4-2 (3)5分钟密度的 K 线图，如图4-3所示。 图 4-3 (4)15 分钟密度的 K 线图，如图4-4所示。 图 4-4 由这4张图我们发现：虽然整体的涨跌趋势十分类似，但时间单位越小的图形可以让我们更快速地发现量能的变化，提前得知趋势的动向，掌握更多的下单机会。 固定时间买进卖出回测本技巧介绍固定时间买卖进出策略，是策略的初版模型，让大家初步了解回测构建。 本技巧仅介绍策略构建，而该策略的完整性是不足的。若在建构策略时没有设置止损， 可能会导致损失，更严重的是仓位亏损至被爆仓时期货公司会自动将我们的仓位平仓。此时若策略没有判断条件，则会与现实账务产生差异。这些都是量化回测必须关注的情况，而这些情况都是可以通过程序来解决的，只要想得更周全、细腻，就可以预防这些事情发 生，甚至可以提早做出比人为操作更有效的解决方案。 技巧45【程序】固定时间买进卖出回测 97 以下提供的是固定时间点买卖，此策略是在开盘时间 9:00 买入一手，接着在 11:00 时平仓。 45-1.py 12345678910111213141516# -*- coding: UTF-8 -*-I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_I020.csv')][1:]#起始時間至結束時間I020a= [ line for line in I020 if int(line[0])&gt;9000000 and int(line[0])&lt;11000000]OrderTime=I020a[0][0] #下單時間紀錄OrderPrice=int(I020a[0][4]) #下單價格紀錄CoverTime=I020a[-1][0] #平倉時間紀錄CoverPrice=int(I020a[-1][4]) #平倉時間紀錄print("Buy OrderTime:",OrderTime," OrderPrice:",OrderPrice,)print(" CoverTime:",CoverTime," CoverPrice:",CoverPrice," Profit:",CoverPrice-OrderPrice) 执行回测后，输出如下: 该策略内容要让大家初步了解 Python 中的算法结构，以及如何运用数据，通过预先的 数据筛选，可以省去许多步骤。 在前面也提到了止损的重要性，所以接着介绍止损机制的策略，由上一个策略来进行 优化。这个策略会持续地侦测是否止损，直到设置的交易时间结束。 本策略是判断当前价低于进场价的 10 点平仓止损，代码如下: 45-2.py 1234567891011121314151617181920212223# -*- coding: UTF-8 -*-I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_I020.csv')][1:]#起始時間至結束時間I020a= [ line for line in I020 if int(line[0])&gt;9000000 and int(line[0])&lt;11000000]OrderTime=I020a[0][0] #下單時間紀錄OrderPrice=int(I020a[0][4]) #下單價格紀錄for i in range(1,len(I020a)): price=int(I020a[i][4]) if price &lt;= OrderPrice-10: CoverTime=I020a[i][0] #平倉時間紀錄 CoverPrice=int(I020a[i][4]) #平倉時間紀錄 break elif i == len(I020a)-1: CoverTime=I020a[i][0] #平倉時間紀錄 CoverPrice=int(I020a[i][4]) #平倉時間紀錄print("Buy OrderTime:",OrderTime," OrderPrice:",OrderPrice,)print(" CoverTime:",CoverTime," CoverPrice:",CoverPrice," Profit:",CoverPrice-OrderPrice) 通过 CMD 执行 Python 指令，展示如下: 顺势交易回测顺势交易策略，这边所指的顺势策略就是俗称的“海龟策略”，代表价格向上突破某个区间的高点，顺势买进;或是在价格向下突破某个区间的低点时，顺势卖出。 上述是进场的部分，对于出场条件的设置，本示例所提供的是设置固定止损获利点，以买方为例，止损点为进场成交价的下降10点，获利点为进场成交价的上升20点。 本示例所设置的高低点区间期间为8:45~9:00，以及进出场的时间区段为9:00~11:00。顺势交易的代码如下： 46.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253# -*- coding: UTF-8 -*-#取I020，依照逗點分隔，並將分隔符號去除I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_I020.csv')][1:]#起始時間至結束時間I020a= [ int(line[4]) for line in I020 if int(line[0])&lt;=9000000 ]I020b= [ line for line in I020 if int(line[0])&gt;9000000 and int(line[0])&lt;11000000 ]#定義上下界ceil=max(I020a)floor=min(I020a)#倉位為0index=0for i in range(len(I020b)): price=int(I020b[i][4]) #進場判斷 if index==0: if price&gt;ceil: OrderTime=I020b[i][0] #新倉時間紀錄 OrderPrice=price #新倉價格紀錄 index=1 print("Buy OrderTime:",OrderTime," OrderPrice:",OrderPrice,) elif price&lt;floor: OrderTime=I020b[i][0] #新倉時間紀錄 OrderPrice=price #新倉價格紀錄 index=-1 print("Sell OrderTime:",OrderTime," OrderPrice:",OrderPrice,) elif i == len(I020b)-1: print("No Trade" ) break #出場判斷 elif index!=0: if index==1: if OrderPrice+20&lt;=price or OrderPrice-10&gt;=price: CoverTime=I020b[i][0] #平倉時間紀錄 CoverPrice=int(I020b[i][4]) #平倉時間紀錄 print(" CoverTime:",CoverTime," CoverPrice:",CoverPrice," Profit:",CoverPrice-OrderPrice) break elif i == len(I020b)-1: CoverTime=I020b[i][0] #平倉時間紀錄 CoverPrice=int(I020b[i][4]) #平倉時間紀錄 print(" CoverTime:",CoverTime," CoverPrice:",CoverPrice," Profit:",CoverPrice-OrderPrice) elif index==-1: if price&lt;=OrderPrice-20 or price&gt;=OrderPrice+10: CoverTime=I020b[i][0] #平倉時間紀錄 CoverPrice=int(I020b[i][4]) #平倉時間紀錄 print(" CoverTime:",CoverTime," CoverPrice:",CoverPrice," Profit:",OrderPrice-CoverPrice) break elif i == len(I020b)-1: CoverTime=I020b[i][0] #平倉時間紀錄 CoverPrice=int(I020b[i][4]) #平倉時間紀錄 print(" CoverTime:",CoverTime," CoverPrice:",CoverPrice," Profit:",OrderPrice-CoverPrice) 1234567&gt; python 46.pyBuy OrderTime: 9043318 OrderPrice: 10316 CoverTime: 9120668 CoverPrice: 10306 Profit: -10 技巧47 【程序】MA交叉买进卖出回测MA在交易市场中是常见的交易指标，而相关的策略也是五花八门，通常MA的策略都会通过两个基准来做比较，通过基准彼此之间的关系来做好进出场的判断，例如12MA进行历史回测(快线)与24MA(慢线)的配合。 之前在技巧25中有单独计算MA指标的程序，读者可以通过计算指标后的数据来结合I020成交信息共同编写程序，此举将会降低策略同时计算MA与判断进场条件的运算负载，但整体来说，计算完整天的MA再进行策略判断，还是会增加回测的运算时间。 本技巧介绍的策略判断是通过成交价与108MA来进行计算的，当前价向上穿越MA，则买进；当前价向下穿越MA，则卖出。出场条件则是设置固定价位止损获利(10点)。 本示例将通过成交价格来计算，同时计算MA值，并同时做该策略的判断。这样做后代码会比较复杂，也可以将MA计算完成后(参考技巧24)再进行策略判断。 程序代码如下： 47.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677# -*- coding: UTF-8 -*-#時間轉數值def TimetoNumber(time): time=time.zfill(8) sec=int(time[:2])*360000+int(time[2:4])*6000+int(time[4:6])*100+int(time[6:8]) return sec#取I020，依照逗點分隔，並將分隔符號去除I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_I020.csv')][1:]#定義相關變數MAarray = []MAValue = 0STime = TimetoNumber('08450000')Cycle = 6000MAlen = 10#定義上一筆值，提供給策略判斷lastMAValue=0lastPrice=0#倉位為0index=0#開始進行MA計算for i in I020: time=i[0] price=int(i[4]) if len(MAarray)==0: MAarray+=[price] else: if TimetoNumber(time)&lt;STime+Cycle: MAarray[-1]=price else: if len(MAarray)==MAlen: MAarray=MAarray[1:]+[price] else: MAarray+=[price] STime = STime+Cycle #到達第10分鐘後，開始進行策略判斷 if len(MAarray)==MAlen: MAValue=float(sum(MAarray))/len(MAarray) if lastMAValue==0 or lastPrice==0: lastMAValue=MAValue lastPrice=price continue if index==0: if MAValue&lt;price and lastMAValue&gt;=lastPrice: OrderTime=time #新倉時間紀錄 OrderPrice=price #新倉價格紀錄 index=1 print("Buy OrderTime:",OrderTime," OrderPrice:",OrderPrice,) elif MAValue&gt; price and lastMAValue&lt;=lastPrice: OrderTime=time #新倉時間紀錄 OrderPrice=price #新倉價格紀錄 index=-1 print("Sell OrderTime:",OrderTime," OrderPrice:",OrderPrice,) elif index!=0: if index==1: if price&gt;=OrderPrice+10 or price&lt;=OrderPrice-10: CoverTime=time #平倉時間紀錄 CoverPrice=price #平倉時間紀錄 print(" CoverTime:",CoverTime," CoverPrice:",CoverPrice," Profit:",CoverPrice-OrderPrice) break elif i == len(I020)-1: CoverTime=time #平倉時間紀錄 CoverPrice=price #平倉時間紀錄 print(" CoverTime:",CoverTime," CoverPrice:",CoverPrice," Profit:",CoverPrice-OrderPrice) if index==-1: if price&lt;=OrderPrice-10 or price&gt;=OrderPrice+10: CoverTime=time #平倉時間紀錄 CoverPrice=price #平倉時間紀錄 print(" CoverTime:",CoverTime," CoverPrice:",CoverPrice," Profit:",OrderPrice-CoverPrice) break elif i == len(I020)-1: CoverTime=time #平倉時間紀錄 CoverPrice=price #平倉時間紀錄 print(" CoverTime:",CoverTime," CoverPrice:",CoverPrice," Profit:",OrderPrice-CoverPrice) 技巧 48 【程序】绘制价格走势图并标上买卖点当我们进行回测时，往往都只有数据上的呈现，而进场出场点并不能够很明确地得知当日的市场价格走势。所以我们可以绘制价格走势图，并且搭配自己的买卖点，这样就可以了解到当日的走势以及自己的策略动向。 本示例所提供的代码适用于大多数的回测程序，只要取得成交信息与进场、出场的时 间及价格，就可以正确绘制出此图。技巧45~技巧47都可以运用该技巧来绘制价格线图并加上买卖点，只要在执行完策略时补上下方程序代码，就可以绘制出当天的图形。 48.py 1234567891011121314151617181920212223242526272829303132333435363738394041424344#載入相關套件及函數import matplotlib.pyplot as pltimport matplotlib.dates as mdatesimport datetime#取得轉換時間字串至時間格式Time = [ datetime.datetime.strptime(line[0],"%H%M%S%f") for line in I020 ]#將datetime時間格式轉換為繪圖專用的時間格式，透過mdates.date2num函數Time1 = [ mdates.date2num(line) for line in Time ]#價格由字串轉數值Price = [ int(line[4]) for line in I020 ]#將買賣點時間字串轉為時間格式OrderTime1=mdates.date2num(datetime.datetime.strptime(OrderTime,"%H%M%S%f"))CoverTime1=mdates.date2num(datetime.datetime.strptime(CoverTime,"%H%M%S%f"))#定義圖表物件ax = plt.figure(1) #第一張圖片 ax = plt.subplot(111) #該張圖片僅一個圖案#定義titleplt.title('Price Line')plt.xlabel('Time')plt.ylabel('Price')#繪製圖案#plot_date(X軸物件, Y軸物件, 線風格)ax.plot_date(Time1, Price, 'k-')ax.plot_date(OrderTime1, OrderPrice, 'r.',markersize='20')ax.plot_date(CoverTime1, CoverPrice, 'g.',markersize='20')#定義x軸hfmt = mdates.DateFormatter('%H:%M:%S')ax.xaxis.set_major_formatter(hfmt)#儲存圖片#plt.savefig('foo.png')#顯示繪製圖表plt.show() 通过技巧47来绘制价格走势图并标上买卖点，只要执行技巧47的时候将技巧48的代码附加至47.py后方，就能够绘制出图片，如图4-5所示。 图4-5 可以将图片另存成文件，比如存成 PNG 格式，代码如下:1plt.savefig('test.png') 在代码的最后部分，在show函数之前加上以上代码，即可保存成图片。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python期货量化交易实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 建立自己的工具函数]]></title>
    <url>%2F2020%2F11%2F24%2F%E7%AC%AC2%E7%AB%A0-%E5%BB%BA%E7%AB%8B%E8%87%AA%E5%B7%B1%E7%9A%84%E5%B7%A5%E5%85%B7%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 技巧22 【程序】固定时间内的高开低收量在策略开发中，将常用的功能做成函数，在之后的编写程序中就能够减少许多麻烦。计算固定时间的高开低收量能够应用在许多方面，比如计算K线值、取当前的高开低收等。 现在我们就试着思考应该如何在庞大的数据量中取得高开低收量。首先必须把固定时间区段数据取出，接着我们会通过循环来进行数据筛选，然后会将固定时间区段数据进行处理，取得高开低收量。以下通过示例来介绍如何获取固定时间区段内的高开低收量。 以下程序代码通过列表来进行数据获取，在Python中可以通过该方式直接对列表对象做条件判断，有点类似于获取子集合的概念。 22.py 123456# 取I020，依照逗号分隔，并将分隔符号去除I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_I020.csv')][1:]# 取得特定时间的价格数据p= [int(line[4]) for line in I020 if int(line[0])&gt;8590000 and int(line[0])&lt;9000000] # 取得特定时间的总量数据q= [int(line[6]) for line in I020 if int(line[0])&gt;8590000 and int(line[0])&lt;9000000] # 列出高开低收量print (p[0],p[-1],min(p),max(p),q[-1]-q[0]) 执行过程如下:12345678&gt;&gt;&gt; I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_ I020.csv')][1:]&gt;&gt;&gt;&gt;&gt;&gt; p= [int(line[4]) for line in I020 if int(line[0])&gt;8590000 and int(line[0]) &lt;9000000]&gt;&gt;&gt; q= [int(line[6]) for line in I020 if int(line[0])&gt;8590000 and int(line[0]) &lt;9000000]&gt;&gt;&gt;&gt;&gt;&gt; print (p[0],p[-1],min(p),max(p),q[-1]-q[0])10309 10312 10308 10313 905&gt;&gt;&gt; 技巧23 【程序】获取指定时间的价格与数量在过去的金融数据中，要获取某个时间点的当前价量，只通过单一时间的条件判断很可能会产生错误。因为并不是每个时间点都会有成交信息，所以在获取当前价格时必须去获取当前时间以前最新的一笔数据。举个例子：要获取9点整的当前价量，就要获取时间“9000000”当下的值，因为这个时间可能不会有成交信息，所以必须取时间“9000000”以前的数据，并且读取该区段最新的一笔数据。 本例将获取9点整的最新成交价，所以程序会取9点整以前的数据，并且取得最后一笔数据作为当前最新的成交价，程序如下： 23.py 12345678# 取I020，依照逗号分隔，并将分隔符号去除I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_I020.csv')][1:] # 取得特定时间前的价格数据p= [int(line[4]) for line in I020 if int(line[0])&lt;9000000]# 取得特定时间前的总量数据q= [int(line[6]) for line in I020 if int(line[0])&lt;9000000]print (p[-1],q[-1]) 12345678&gt;&gt;&gt; I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_I020. csv')][1:]&gt;&gt;&gt;&gt;&gt;&gt; p= [int(line[4]) for line in I020 if int(line[0])&lt;9000000]&gt;&gt;&gt; q= [int(line[6]) for line in I020 if int(line[0])&lt;9000000] &gt;&gt;&gt;&gt;&gt;&gt; print (p[-1],q[-1]) #9点整的最新当前价和当前总量10312 12904 技巧24 【程序】计算移动平均价格对于金融交易者来说，MA是常使用的指标，而计算MA也就成了必备的一项技能。 要计算我们所提供的逐笔数据格式，就必须自己计算MA才能绘制出配合MA线的图表。另外，在回测、即时的算法程序中也都必须自行计算MA值。 在计算MA值以前，必须先定义周期（周期就是计算的时间区段，如时、分、秒），接着定义长度。常用的MA长度为5/10/20等。MA长度越长，MA线的波动度越低。 以往我们看到的MA都是依据分K线图来搭配绘制，但是本书提供的示例为逐笔撮合数据，所以计算的方式会依据前n−1分钟的收盘价加上最新的一笔成交价做计算。 定义完成后，就可以开始通过Python计算MA值了。以10分钟MA为例，程序代码如下： 24.py 1234567891011121314151617181920212223242526272829303132333435# 时间转数值def TimetoNumber(time): time=time.zfill(8) sec=int(time[:2])*360000+int(time[2:4])*6000+int(time[4:6])*100+int(time[6:8]) return sec# 取I020，依照逗号分隔，并将分隔符号去除I020 = [ line.strip('\n').split(",") for line in open('Futures_20170815_I020.csv')][1:] # 定义相关变量MAarray = []MA = []MAValue = 0 STime = TimetoNumber('08450000')Cycle = 6000MAlen = 10# 开始进行MA计算 for i in I020: time=i[0] price=int(i[4]) if len(MAarray)==0: MAarray+=[price] else: if TimetoNumber(time)&lt;STime+Cycle: MAarray[-1]=price else: if len(MAarray)==MAlen: MAarray=MAarray[1:]+[price] else: MAarray+=[price] STime = STime+Cycle MAValue=float(sum(MAarray))/len(MAarray) MA.extend([[time,MAValue]]) print (time,MAValue) 执行过程如下： 12345678910111213141516&gt;&gt;&gt;python 24.py 8471781 10302.0 8471781 10302.0 8471793 10302.0 8471843 10302.0 8471843 10302.3333333 8471856 10302.3333333 8471868 10302.3333333 8471881 10302.3333333 8471906 10302.3333333 8471931 10302.3333333 8471943 10302.6666667 8471943 10302.6666667 8471981 10302.3333333 8471981 10302.3333333 8471981 10302.0 若直接进入Python逐行执行该技巧程序，则执行完成后可以通过MA对象查看数据， 操作如下： 1234567891011&gt;&gt;&gt; MA[0:10][['8450010', 10310.0], ['8450011', 10309.0], ['8450011', 10309.0], ['8450011', 10310.0], ['8450011', 10310.0], ['8450011', 10309.0], ['8450011', 10309.0], ['8450013', 10310.0], ['8450013', 10310.0], ['8450013', 10310.0]]]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python期货量化交易实战</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[谈谈redis的热key问题如何解决]]></title>
    <url>%2F2020%2F11%2F24%2F%E8%B0%88%E8%B0%88redis%E7%9A%84%E7%83%ADkey%E9%97%AE%E9%A2%98%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 引言讲了几天的数据库系列的文章，大家一定看烦了，其实还没讲完。。。(以下省略一万字)。今天我们换换口味，来写redis方面的内容，谈谈热key问题如何解决。其实热key问题说来也很简单，就是瞬间有几十万的请求去访问redis上某个固定的key，从而压垮缓存服务的情情况。其实生活中也是有不少这样的例子。比如XX明星结婚。那么关于XX明星的Key就会瞬间增大，就会出现热数据问题。ps:hot key和big key问题，大家一定要有所了解。本文预计分为如下几个部分 热key问题 如何发现 业内方案 正文热Key问题上面提到，所谓热key问题就是，突然有几十万的请求去访问redis上的某个特定key。那么，这样会造成流量过于集中，达到物理网卡上限，从而导致这台redis的服务器宕机。那接下来这个key的请求，就会直接怼到你的数据库上，导致你的服务不可用。 怎么发现热key方法一:凭借业务经验，进行预估哪些是热key其实这个方法还是挺有可行性的。比如某商品在做秒杀，那这个商品的key就可以判断出是热key。缺点很明显，并非所有业务都能预估出哪些key是热key。方法二:在客户端进行收集这个方式就是在操作redis之前，加入一行代码进行数据统计。那么这个数据统计的方式有很多种，也可以是给外部的通讯系统发送一个通知信息。缺点就是对客户端代码造成入侵。方法三:在Proxy层做收集有些集群架构是下面这样的，Proxy可以是Twemproxy，是统一的入口。可以在Proxy层做收集上报，但是缺点很明显，并非所有的redis集群架构都有proxy。 方法四:用redis自带命令(1)monitor命令，该命令可以实时抓取出redis服务器接收到的命令，然后写代码统计出热key是啥。当然，也有现成的分析工具可以给你使用，比如redis-faina。但是该命令在高并发的条件下，有内存增暴增的隐患，还会降低redis的性能。(2)hotkeys参数，redis 4.0.3提供了redis-cli的热点key发现功能，执行redis-cli时加上–hotkeys选项即可。但是该参数在执行的时候，如果key比较多，执行起来比较慢。方法五:自己抓包评估Redis客户端使用TCP协议与服务端进行交互，通信协议采用的是RESP。自己写程序监听端口，按照RESP协议规则解析数据，进行分析。缺点就是开发成本高，维护困难，有丢包可能性。以上五种方案，各有优缺点。根据自己业务场景进行抉择即可。那么发现热key后，如何解决呢？ 如何解决目前业内的方案有两种(1)利用二级缓存比如利用ehcache，或者一个HashMap都可以。在你发现热key以后，把热key加载到系统的JVM中。针对这种热key请求，会直接从jvm中取，而不会走到redis层。假设此时有十万个针对同一个key的请求过来,如果没有本地缓存，这十万个请求就直接怼到同一台redis上了。现在假设，你的应用层有50台机器，OK，你也有jvm缓存了。这十万个请求平均分散开来，每个机器有2000个请求，会从JVM中取到value值，然后返回数据。避免了十万个请求怼到同一台redis上的情形。(2)备份热key这个方案也很简单。不要让key走到同一台redis上不就行了。我们把这个key，在多个redis上都存一份不就好了。接下来，有热key请求进来的时候，我们就在有备份的redis上随机选取一台，进行访问取值，返回数据。假设redis的集群数量为N，步骤如下图所示 注:不一定是2N，你想取3N，4N都可以，看要求。12345678910const M = N * 2//生成随机数random = GenRandom(0, M)//构造备份新keybakHotKey = hotKey + “_” + randomdata = redis.GET(bakHotKey)if data == NULL &#123; data = GetFromDB() redis.SET(bakHotKey, expireTime + GenRandom(0,5))&#125; 业内方案OK，其实看完上面的内容，大家可能会有一个疑问。 烟哥，有办法在项目运行过程中，自动发现热key，然后程序自动处理么？ 嗯，好问题，那我们来讲讲业内怎么做的。其实只有两步(1)监控热key(2)通知系统做处理正巧，前几天有赞出了一篇《有赞透明多级缓存解决方案（TMC）》，里头也有提到热点key问题，我们刚好借此说明(1)监控热key在监控热key方面，有赞用的是方式二：在客户端进行收集。在《有赞透明多级缓存解决方案（TMC）》中有一句话提到 TMC 对原生jedis包的JedisPool和Jedis类做了改造，在JedisPool初始化过程中集成TMC“热点发现”+“本地缓存”功能Hermes-SDK包的初始化逻辑。 也就说人家改写了jedis原生的jar包，加入了Hermes-SDK包。那Hermes-SDK包用来干嘛？OK，就是做热点发现和本地缓存。从监控的角度看，该包对于Jedis-Client的每次key值访问请求，Hermes-SDK 都会通过其通信模块将key访问事件异步上报给Hermes服务端集群，以便其根据上报数据进行“热点探测”。 当然，这只是其中一种方式，有的公司在监控方面用的是方式五:自己抓包评估具体是这么做的，先利用flink搭建一套流式计算系统。然后自己写一个抓包程序抓redis监听端口的数据，抓到数据后往kafka里丢。接下来，流式计算系统消费kafka里的数据，进行数据统计即可，也能达到监控热key的目的。 (2)通知系统做处理在这个角度，有赞用的是上面的解决方案一:利用二级缓存进行处理。有赞在监控到热key后，Hermes服务端集群会通过各种手段通知各业务系统里的Hermes-SDK，告诉他们:”老弟，这个key是热key，记得做本地缓存。”于是Hermes-SDK就会将该key缓存在本地，对于后面的请求。Hermes-SDK发现这个是一个热key，直接从本地中拿，而不会去访问集群。 除了这种通知方式以外。我们也可以这么做，比如你的流式计算系统监控到热key了，往zookeeper里头的某个节点里写。然后你的业务系统监听该节点，发现节点数据变化了，就代表发现热key。最后往本地缓存里写，也是可以的。 通知方式各种各样，大家可以自由发挥。本文只是提供一个思路。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis数据结构-跳跃表]]></title>
    <url>%2F2020%2F11%2F24%2FRedis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E8%B7%B3%E8%B7%83%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 原文地址 前言跳跃表是一种有序的数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的。这么说，我们可能很难理解，我们可以先回忆一下链表。 跳跃表什么是跳跃表对于一个单链表来讲，即便链表中存储的数据是有序的，如果我们要想在其中查找某个数据，也只能从头到尾遍历链表。这样查找效率就会很低，时间复杂度会很高，是O(n)。 如果我们想要提高其查找效率，可以考虑在链表上建索引的方式。每两个结点提取一个结点到上一级，我们把抽出来的那一级叫作索引。 这个时候，我们假设要查找节点8，我们可以先在索引层遍历，当遍历到索引层中值为7的结点时，发现下一个节点是9，那么要查找的节点8肯定就在这两个节点之间。我们下降到链表层继续遍历就找到了8这个节点。原先我们在单链表中找到8这个节点要遍历8个节点，而现在有了一级索引后只需要遍历五个节点。 从这个例子里，我们看出，加了一层索引之后，查找一个结点需要遍历的结点个数减少了，也就是说查找效率提高了，同理再加一级索引。 从图中我们可以看出，查找效率又有提升。在例子中我们的数据很少，当有大量的数据时，我们可以增加多级索引，其查找效率可以得到明显提升。 像这种链表加多级索引的结构，就是跳跃表！ Redis跳跃表Redis使用跳跃表作为有序集合键的底层实现之一，如果一个有序集合包含的元素数量比较多，又或者有序集合中元素的成员是比较长的字符串时，Redis就会使用跳跃表来作为有序集合键的底层实现。 这里我们需要思考一个问题——为什么元素数量比较多或者成员是比较长的字符串的时候Redis要使用跳跃表来实现？ 从上面我们可以知道，跳跃表在链表的基础上增加了多级索引以提升查找的效率，但其是一个空间换时间的方案，必然会带来一个问题——索引是占内存的。原始链表中存储的有可能是很大的对象，而索引结点只需要存储关键值和几个指针，并不需要存储对象，因此当节点本身比较大或者元素数量比较多的时候，其优势必然会被放大，而缺点则可以忽略。 Redis中跳跃表的实现Redis的跳跃表由zskiplistNode和zskiplist两个结构定义，其中zskiplistNode结构用于表示跳跃表节点，而zskiplist结构则用于保存跳跃表节点的相关信息，比如节点的数量，以及指向表头节点和表尾节点的指针等等。 上图展示了一个跳跃表示例，其中最左边的是skiplist结构，该结构包含以下属性。 header：指向跳跃表的表头节点，通过这个指针程序定位表头节点的时间复杂度就为O(1) tail：指向跳跃表的表尾节点,通过这个指针程序定位表尾节点的时间复杂度就为O(1) level：记录目前跳跃表内,层数最大的那个节点的层数（表头节点的层数不计算在内），通过这个属性可以再O(1)的时间复杂度内获取层高最好的节点的层数。 length：记录跳跃表的长度,也即是,跳跃表目前包含节点的数量（表头节点不计算在内），通过这个属性，程序可以再O(1)的时间复杂度内返回跳跃表的长度。 结构右方的是四个zskiplistNode结构，该结构包含以下属性： 层（level）： 节点中用1、2、L3等字样标记节点的各个层，L1代表第一层，L代表第二层，以此类推。 每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离（跨度越大、距离越远）。在上图中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。 每次创建一个新跳跃表节点的时候,程序都根据幂次定律（powerlaw，越大的数出现的概率越小）随机生成一个介于1和32之间的值作为level数组的大小，这个大小就是层的“高度”。 后退（backward）指针： 节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。与前进指针所不同的是每个节点只有一个后退指针，因此每次只能后退一个节点。 分值（score）： 各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。 成员对象（oj）： 各个节点中的o1、o2和o3是节点所保存的成员对象。在同一个跳跃表中，各个节点保存的成员对象必须是唯一的，但是多个节点保存的分值却可以是相同的:分值相同的节点将按照成员对象在字典序中的大小来进行排序，成员对象较小的节点会排在前面（靠近表头的方向），而成员对象较大的节点则会排在后面（靠近表尾的方向）。 Redis跳跃表常用操作的时间复杂度 操作 时间复杂度 创建一个跳跃表 O(1) 释放给定跳跃表以及其中包含的节点 O(N) 添加给定成员和分值的新节点 平均O(logN)，最坏O(logN)（N为跳跃表的长度） 删除除跳跃表中包含给定成员和分值的节点 平均O(logN)，最坏O(logN)（N为跳跃表的长度） 返回给定成员和分值的节点再表中的排位 平均O(logN)，最坏O(logN)（N为跳跃表的长度） 返回在给定排位上的节点 平均O(logN)，最坏O(logN)（N为跳跃表的长度） 给定一个分值范围，返回跳跃表中第一个符合这个范围的节点 O(1) 给定一个分值范围，返回跳跃表中最后一个符合这个范围的节点 平均O(logN)，最坏O(logN)（N为跳跃表的长度） 给定一个分值范围，除跳跃表中所有在这个范围之内的节点 平均O(logN)，最坏O(logN)（N为跳跃表的长度） 给定一个排位范围，鼎除跳跃表中所有在这个范围之内的节点 O(N)，N为被除节点数量 给定一个分值范围（range），比如0到15，20到28，诸如此类，如果跳氏表中有至少一个节点的分值在这个范間之内，那么返回1，否则返回0 O(N)，N为被除节点数量 本文重点 跳跃表基于单链表加索引的方式实现。 跳跃表以空间换时间的方式提升了查找速度。 Redis有序集合在节点元素较大或者元素数量较多时使用跳跃表实现。 Redis的跳跃表实现由zskiplist和zskiplistNode两个结构组成，其中zskiplist用于保存跳跃表信息（比如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。 Redis每个跳跃表节点的层高都是1至32之间的随机数。 在同一个跳跃表中，多个节点可以包含相同的分值，但每个节点的成员对象必须是唯一的跳跃表中的节点按照分值大小进行排序，当分值相同时，节点按照成员对象的大小进行排序。]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中的ArrayAccess用法详解]]></title>
    <url>%2F2020%2F11%2F04%2FPHP%E4%B8%AD%E7%9A%84ArrayAccess%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在Laravel的源码当中，作者多次使用到了PHP SPL中的ArrayAccess接口，那么这个ArrayAccess接口到底有什么作用呢？我会用一个简单的例子跟大家说明。 请看下面的这段代码，Foo类实现了ArrayAccess接口中的四个方法，请仔细看这些方法内部的实现代码。看到了吗？这些代码是干什么用的，回答就是这些代码没有用，随便你怎么写，你想写什么就写什么。接口中这四个方法的内部的实现跟方法名字其实没有任何关系。啊！这。。。实际的作用是取决于你的调用。 12345678910111213141516171819202122class Foo implements ArrayAccess&#123; public function offsetExists( $offset ) &#123; echo "这里是 offsetExists() 方法 你输入的参数是 &#123;$offset&#125;"; &#125; public function offsetGet( $offset ) &#123; echo "这里是 offsetGet() 方法 你输入的参数是 $offset"; &#125; public function offsetSet( $offset, $value ) &#123; echo "这里是 offsetSet() 方法 你输入的 &#123;$offset&#125;=&#123;$value&#125;"; &#125; public function offsetUnset( $offset ) &#123; echo "这里是 offsetUnset() 方法 你输入的参数是 &#123;$offset&#125;"; &#125;&#125; 好，我们调用一下看看。 我们使用isset这个函数去调用$foo[‘how’]，那么实际上是调用了offsetExists这个方法，也就是说$foo[‘xxxx’]这种结构去调用哪个ArrayAccess的方法是取决于你是如何调用的$foo[‘xxxx’]。而方法内部的实现代码你想怎么写就怎么写。在这里一旦你使用isset去调用了这种结构，系统就会去调用offsetExists这个方法，在本例中方法里面有什么，仅仅是echo了一句话。为什么var_dump($t); 会输出false呢？因为在我们实现的这个offsetExists方法里面，没有任何的返回值，没有返回值当然就是null了，也就是false了。123$foo = new Foo();$t = isset($foo['how']);// 输出: 这里是 offsetExists() 方法 你输入的参数是 howvar_dump($t);// 输出: boolean false 接着看看这种$foo[‘xxxx’]结构还可以怎样被调用，不如我们这次直接使用$foo[‘xxxx’]看看。原来直接使用$foo[‘xxxx’]这种结构也可以调用一个方法啊，从输出当中得知调用了offsetGet方法，同样也获取到了参数。12$foo = new Foo();$foo['what'];// 输出: 这里是 offsetGet() 方法 你输入的参数是 what 继续看还能怎么调用到其他的方法，我们给这个结构赋值看看，果然赋值的操作当然是调用offsetSet方法了，同样的方法内部的实现代码仍然还是你想写什么就写什么。12$foo = new Foo();$foo['when'] = 'today';// 输出: 这里是 offsetSet() 方法 你输入的 when=today 最后一个了，看方法名字也知道是通过unset方法才能被调用了。 $foo = new Foo(); unset($foo[&#39;wow&#39;]);// 输出: 这里是 offsetUnset() 方法 你输入的参数是 wow 总结好了，总结一下吧： 如果你的类实现了ArrayAccess接口，那么这个类的对象就可以使用$foo[‘xxx’]这种结构了。 $foo[‘xxx’] 对应调用offsetGet方法。 $foo[‘xxx’] = ‘yyy’ 对应调用offsetSet方法。 isset($foo[‘xxx’]) 对应调用offsetExists方法。 unset($foo[‘xxx’]) 对应调用offsetUnset方法。 再次强调，方法的实现代码，你想怎么写就怎么写。（当然代码的功能最好是贴近方法名啦）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Redis分布式锁解决超卖问题]]></title>
    <url>%2F2020%2F07%2F30%2FRedis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E8%A7%A3%E5%86%B3%E8%B6%85%E5%8D%96%E9%97%AE%E9%A2%98%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Redis的multi命令是什么意思？ watch要在multi前面吗？ Redis事务Redis事务介绍 1.redis事务可以一次执行多个命令，本质是一组命令的集合。 2.一个事务中的所有命令都会序列化，按顺序串行化的执行而不会被其他命令插入。 作用：一个队列中，一次性、顺序性、排他性的执行一系列命令。 multi指令的使用 1.下面指令演示了一个完整的事务过程，所有指令在exec前不执行，而是缓存在服务器的一个事务队列中。 2.服务器一旦收到exec指令才开始执行事务队列，执行完毕后一次性返回所有结果。 3.因为redis是单线程的，所以不必担心自己在执行队列时被打断，可以保证“原子性”。 注：Redis事务在遇到指令失败后，后面的指令会继续执行。 1234567# Multi命令用于标记一个事务块的开始# 事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由EXEC命令原子性（atomic）的执行&gt; multi #（开始一个redis事务）incr booksincr books&gt; exec #（执行事务）&gt; discard #（丢弃事务） 12345678910111213141516def multi_test(): r = redis.Redis(host='127.0.0.1') pipe = r.pipeline() pipe.multi() # 开启事务 pipe.set('key2', 400) # 存储子命令 pipe.execute() # 执行事务 print("第一次事务提交后的结果" + r.get('key2').decode("utf-8")) pipe.multi() # 开启事务 pipe.set('key2', 100) # 存储子命令 print("第二次未提交事务的结果" + r.get("key2").decode("utf-8"))#第一次事务提交后的结果400#第二次未提交事务的结果400 注：mysql的rollback与redis的discard的区别 1.mysql回滚为sql全部成功才执行，一条sql失败则全部失败，执行rollback后所有语句造成的影响消失。 2.redis的discard只是结束本次事务，正确命令造成的影响仍然还在。 1）redis如果在一个事务中的命令出现错误，那么所有的命令都不会执行； 2）redis如果在一个事务中出现运行错误，那么正确的命令会被执行。 watch指令作用 1.watch其实就是redis提供的一种乐观锁，可以解决并发修改问题。 2.watch会在事务开始前盯住一个或多个关键变量，当服务器收到exec指令要顺序执行缓存中的事务队列时，redis会检查关键变量自watch后是否被修改。 3.watch只会在数据被其他客户端抢先修改了的情况下通知执行命令的这个客户端（通过WatchError异常），但不会阻止其他客户端对数据的修改。 watch+multi实现乐观锁 setnx指令（redis的分布式锁） 1.分布式锁本质是占一个坑，当别的进程也要来占坑时发现已经被占，就会放弃或者稍后重试。 2.占坑一般使用setnx（set if not exists）指令，只允许一个客户端占坑。 3.先来先占，用完了在调用del指令释放坑。 123&gt; setnx lock:codehole true.... do something critical ....&gt; del lock:codehole 4.但是这样有一个问题，如果逻辑执行到中间出现异常，可能导致del指令没有被调用，这样就会陷入死锁，锁永远无法释放。 5.为了解决死锁问题，我们拿到锁时可以加上一个expire过期时间，这样即使出现异常，当到达过期时间也会自动释放锁。 1234&gt; setnx lock:codehole true&gt; expire lock:codehole 5.... do something critical ....&gt; del lock:codehole 6.这样又有一个问题，setnx和expire是两条指令而不是原子指令，如果两条指令之间进程挂掉依然会出现死锁。 7.为了治理上面乱象，在redis2.8中加入了set指令的扩展参数，使setnx和expire指令可以一起执行。 123&gt; set lock:codehole true ex 5 nx''' do something '''&gt; del lock:codehole Redis解决超卖问题使用Redis的watch+multi指令实现1234567891011121314151617181920212223242526#! /usr/bin/env python# -*- coding: utf-8 -*-import redisdef sale(rs): while True: with rs.pipeline() as p: try: p.watch('apple') # 监听key值为apple的数据数量改变 count = int(rs.get('apple')) print('拿取到了苹果的数量: %d' % count) p.multi() # 事务开始 if count&gt; 0 : # 如果此时还有库存 p.set('apple', count - 1) p.execute() # 执行事务 p.unwatch() break # 当库存成功减一或没有库存时跳出执行循环 except Exception as e: # 当出现watch监听值出现修改时，WatchError异常抛出 print('[Error]: %s' % e) continue # 继续尝试执行rs = redis.Redis(host='127.0.0.1', port=6379) # 连接redisrs.set('apple',1000) # 首先在redis中设置某商品apple对应数量value值为1000sale(rs) 1）原理 1.当用户购买时，通过WATCH监听用户库存，如果库存在watch监听后发生改变，就会捕获异常而放弃对库存减一操作； 2.如果库存没有监听到变化并且数量大于1，则库存数量减一，并执行任务。 2）弊端 1.Redis在尝试完成一个事务的时候，可能会因为事务的失败而重复尝试重新执行。 2.保证商品的库存量正确是一件很重要的事情，但是单纯的使用WATCH这样的机制对服务器压力过大。 使用Redis的watch+multi+setnx指令实现1）为什么要自己构建锁 1.虽然有类似的SETNX命令可以实现Redis中的锁的功能，但他锁提供的机制并不完整。 2.并且setnx也不具备分布式锁的一些高级特性，还是得通过我们手动构建。 2）创建一个redis锁 1.在Redis中，可以通过使用SETNX命令来构建锁：rs.setnx(lock_name, uuid值)。 2.而锁要做的事情就是将一个随机生成的128位UUID设置位键的值，防止该锁被其他进程获取。 3）释放锁 1.锁的删除操作很简单，只需要将对应锁的key值获取到的uuid结果进行判断验证； 2.符合条件（判断uuid值）通过delete在redis中删除即可，rs.delete(lockname)； 3.此外当其他用户持有同名锁时，由于uuid的不同，经过验证后不会错误释放掉别人的锁。 4）解决锁无法释放问题 1.在之前的锁中，还出现这样的问题，比如某个进程持有锁之后突然程序崩溃，那么会导致锁无法释放； 2.而其他进程无法持有锁继续工作，为了解决这样的问题，可以在获取锁的时候加上锁的超时功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109import redisimport uuidimport time# 1.初始化连接函数def get_conn(host,port=6379): rs = redis.Redis(host=host, port=port) return rs# 2. 构建redis锁def acquire_lock(rs, lock_name, expire_time=10): ''' rs: 连接对象 lock_name: 锁标识 acquire_time: 过期超时时间 return -&gt; False 获锁失败 or True 获锁成功 ''' identifier = str(uuid.uuid4()) end = time.time() + expire_time while time.time() &lt; end: # 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False if rs.setnx(lock_name, identifier): # 尝试取得锁 return identifier # time.sleep(.001) return False# 3. 释放锁def release_lock(rs, lockname, identifier): ''' rs: 连接对象 lockname: 锁标识 identifier: 锁的value值，用来校验 ''' if rs.get(lockname).decode() == identifier: # 防止其他进程同名锁被误删 rs.delete(lockname) return True # 删除锁 else: return False # 删除失败#有过期时间的锁def acquire_expire_lock(rs, lock_name, expire_time=10, locked_time=10): ''' rs: 连接对象 lock_name: 锁标识 acquire_time: 过期超时时间 locked_time: 锁的有效时间 return -&gt; False 获锁失败 or True 获锁成功 ''' identifier = str(uuid.uuid4()) end = time.time() + expire_time while time.time() &lt; end: # 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False if rs.setnx(lock_name, identifier): # 尝试取得锁 # print('锁已设置: %s' % identifier) rs.expire(lock_name, locked_time) return identifier time.sleep(.001) return False'''在业务函数中使用上面的锁'''def sale(rs): start = time.time() # 程序启动时间 with rs.pipeline() as p: ''' 通过管道方式进行连接 多条命令执行结束，一次性获取结果 ''' while 1: lock = acquire_lock(rs, 'lock') if not lock: # 持锁失败 continue #开始监测"lock" p.watch("lock") try: #开启事务 p.multi() count = int(rs.get('apple')) # 取量 p.set('apple', count-1) # 减量 # time.sleep(5) #提交事务 p.execute() print('当前库存量: %s' % count) #成功则跳出循环 break except: #事务失败对应处理 print("修改数据失败") #无论成功与否最终都需要释放锁 finally: res = release_lock(rs, 'lock', lock) #释放锁成功， if res: print("删除锁成功") #释放锁失败，强制删除 else: print("删除锁失败,强制删除锁") res = rs.delete('lock') print(res) print('[time]: %.2f' % (time.time() - start))rs = redis.Redis(host='127.0.0.1', port=6379) # 连接redis# rs.set('apple',1000) # # 首先在redis中设置某商品apple 对应数量value值为1000sale(rs) 优化锁无法释放的问题，为锁添加过期时间 def acquire_expire_lock(rs, lock_name, expire_time=10, locked_time=10): &#39;&#39;&#39; rs: 连接对象 lock_name: 锁标识 acquire_time: 过期超时时间 locked_time: 锁的有效时间 return -&gt; False 获锁失败 or True 获锁成功 &#39;&#39;&#39; identifier = str(uuid.uuid4()) end = time.time() + expire_time while time.time() &lt; end: # 当获取锁的行为超过有效时间，则退出循环，本次取锁失败，返回False if rs.setnx(lock_name, identifier): # 尝试取得锁 # print(&#39;锁已设置: %s&#39; % identifier) rs.expire(lock_name, locked_time) return identifier time.sleep(.001) return False]]></content>
      <categories>
        <category>Redis</category>
      </categories>
      <tags>
        <tag>Redis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Lock]]></title>
    <url>%2F2020%2F07%2F29%2FLaravel-Lock%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 使用创建锁 12345678910use Illuminate\Support\Facades\Cache;$lock = Cache::lock('foo', 10);if ($lock-&gt;get()) &#123; // 处理业务逻辑 sleep(3); $lock-&gt;release();&#125; 获取无限期锁并自动释放 get方法可以接收一个闭包。在闭包执行之后，Laravel将会自动释放锁。 123Cache::lock('foo')-&gt;get(function () &#123; // 获取无限期锁并自动释放...&#125;); 在指定时间内获取锁 123456789101112use Illuminate\Contracts\Cache\LockTimeoutException;$lock = Cache::lock('foo', 10);try &#123; $lock-&gt;block(5); echo "5秒时间内成功获取锁...";&#125; catch (LockTimeoutException $e) &#123; echo "5秒时间内获取锁失败...";&#125; finally &#123; optional($lock)-&gt;release();&#125; 另一种写法：123Cache::lock('foo', 10)-&gt;block(5, function () &#123; echo "5秒时间内成功获取锁...";&#125;); 无视拥有者强制释放锁 1Cache::lock('foo')-&gt;forceRelease(); 跨进程管理锁 1234567// 控制器中...$podcast = Podcast::find($id);$lock = Cache::lock('foo', 120);if ($result = $lock-&gt;get()) &#123; ProcessPodcast::dispatch($podcast, $lock-&gt;owner());&#125; 123// 队列任务中...// 使用锁名称和拥有者重新获取锁实例后再释放Cache::restoreLock('foo', $this-&gt;owner)-&gt;release(); 源码接口 Illuminate\Contracts\Cache\Lock.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpnamespace Illuminate\Contracts\Cache;interface Lock&#123; /** * 尝试获取锁。 * * @param callable|null $callback * @return mixed */ public function get($callback = null); /** * 尝试获取给定秒数的锁。 * * @param int $seconds * @param callable|null $callback * @return bool */ public function block($seconds, $callback = null); /** * Release the lock. * * @return void */ public function release(); /** * Returns the current owner of the lock. * * @return string */ public function owner(); /** * Releases this lock in disregard of ownership. * * @return void */ public function forceRelease();&#125; 首先是锁的抽象类，定义了继承的类必须实现加锁、释放锁、返回锁拥有者的方法。 Illuminate\Cache\Lock.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167&lt;?phpnamespace Illuminate\Cache;use Illuminate\Contracts\Cache\Lock as LockContract;use Illuminate\Contracts\Cache\LockTimeoutException;use Illuminate\Support\InteractsWithTime;use Illuminate\Support\Str;abstract class Lock implements LockContract&#123; use InteractsWithTime; /** * 锁的名称 * * @var string */ protected $name; /** * 锁的时长 * * @var int */ protected $seconds; /** * 当前操作锁的拥有者 * * @var string */ protected $owner; /** * 获取锁失败时，重新获取锁需要等待的毫秒数 * * @var int */ protected $sleepMilliseconds = 250; /** * 构造函数 * * @param string $name * @param int $seconds * @param string|null $owner * @return void */ public function __construct($name, $seconds, $owner = null) &#123; if (is_null($owner)) &#123; $owner = Str::random(); &#125; $this-&gt;name = $name; $this-&gt;owner = $owner; $this-&gt;seconds = $seconds; &#125; /** * 加锁 * * @return bool */ abstract public function acquire(); /** * 释放锁 * * @return bool */ abstract public function release(); /** * 获取锁中保存的拥有者信息 * * @return string */ abstract protected function getCurrentOwner(); /** * 尝试获取锁，获取成功后执行一个回调函数，执行完成后自动释放锁 * * @param callable|null $callback * @return mixed */ public function get($callback = null) &#123; $result = $this-&gt;acquire(); if ($result &amp;&amp; is_callable($callback)) &#123; try &#123; return $callback(); &#125; finally &#123; $this-&gt;release(); &#125; &#125; return $result; &#125; /** * 尝试在指定的时间内获取锁，超时则失败抛出异常 * * @param int $seconds * @param callable|null $callback * @return bool * * @throws \Illuminate\Contracts\Cache\LockTimeoutException */ public function block($seconds, $callback = null) &#123; $starting = $this-&gt;currentTime(); while (! $this-&gt;acquire()) &#123; usleep($this-&gt;sleepMilliseconds * 1000); if ($this-&gt;currentTime() - $seconds &gt;= $starting) &#123; throw new LockTimeoutException; &#125; &#125; if (is_callable($callback)) &#123; try &#123; return $callback(); &#125; finally &#123; $this-&gt;release(); &#125; &#125; return true; &#125; /** * 返回当前操作锁的拥有者 * * @return string */ public function owner() &#123; return $this-&gt;owner; &#125; /** * 判断当前操作的拥有者是否为锁中保存的拥有者 * * @return bool */ protected function isOwnedByCurrentProcess() &#123; return $this-&gt;getCurrentOwner() === $this-&gt;owner; &#125; /** * 设置重试获取锁需要等待的毫秒数 * * @param int $milliseconds * @return $this */ public function betweenBlockedAttemptsSleepFor($milliseconds) &#123; $this-&gt;sleepMilliseconds = $milliseconds; return $this; &#125;&#125; Illuminate\Contracts\Cache\LockTimeoutException.php 12345678910&lt;?phpnamespace Illuminate\Contracts\Cache;use Exception;class LockTimeoutException extends Exception&#123; //&#125; Redis锁实现类，增加了强制删除锁的方法。 Illuminate\Cache\RedisLock.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phpnamespace Illuminate\Cache;class RedisLock extends Lock&#123; /** * Redis对象 * * @var \Illuminate\Redis\Connections\Connection */ protected $redis; /** * Create a new lock instance. * * @param \Illuminate\Redis\Connections\Connection $redis * @param string $name * @param int $seconds * @param string|null $owner * @return void */ public function __construct($redis, $name, $seconds, $owner = null) &#123; parent::__construct($name, $seconds, $owner); $this-&gt;redis = $redis; &#125; /** * Attempt to acquire the lock. * * @return bool */ public function acquire() &#123; if ($this-&gt;seconds &gt; 0) &#123; return $this-&gt;redis-&gt;set($this-&gt;name, $this-&gt;owner, 'EX', $this-&gt;seconds, 'NX') == true; &#125; else &#123; return $this-&gt;redis-&gt;setnx($this-&gt;name, $this-&gt;owner) === 1; &#125; &#125; /** * Release the lock. * * @return bool */ public function release() &#123; return (bool) $this-&gt;redis-&gt;eval(LuaScripts::releaseLock(), 1, $this-&gt;name, $this-&gt;owner); &#125; /** * 无视锁的拥有者强制删除锁 * * @return void */ public function forceRelease() &#123; $this-&gt;redis-&gt;del($this-&gt;name); &#125; /** * 返回锁中保存的拥有者信息 * * @return string */ protected function getCurrentOwner() &#123; return $this-&gt;redis-&gt;get($this-&gt;name); &#125;&#125; 原子性释放锁的Lua脚本。 12345678910111213141516171819202122232425&lt;?phpnamespace Illuminate\Cache;class LuaScripts&#123; /** * 使用Lua脚本原子性地释放锁. * * KEYS[1] - 锁的名称 * ARGV[1] - 锁的拥有者，只有是该锁的拥有者才允许释放 * * @return string */ public static function releaseLock() &#123; return &lt;&lt;&lt;'LUA'if redis.call("get",KEYS[1]) == ARGV[1] then return redis.call("del",KEYS[1])else return 0endLUA; &#125;&#125; 总结 1.可以通过get()方法直接获取锁并传入回调函数在成功时执行。 2.可以通过block()方法在指定时间内不断获取锁，知道成功或超时为止，成功时会执行传入的回调函数。 3.Redis通过set()命令设置一个值为“拥有者”的字符串来作为锁。 4.set()通过NX参数来实现排他锁（只在键不存在时，才对键进行设置）。 5.set()通过EX参数来控制锁的生存时间（防止程序意外终止发生死锁）。 6.不能使用set()+expire()来代替set()，防止网络延迟或其他故障导致死锁。 7.Redis通过Lua脚本来达到原子性删除锁。 8.Lua脚本中会判断字符串的内容是否与参数中的拥有者一致，一致才执行删除操作。防止当前锁被其他进程误删除，或者误删除了其他进程的锁。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP使用Redis锁限制并发访问类]]></title>
    <url>%2F2020%2F07%2F29%2FPHP%E4%BD%BF%E7%94%A8Redis%E9%94%81%E9%99%90%E5%88%B6%E5%B9%B6%E5%8F%91%E8%AE%BF%E9%97%AE%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 1.并发访问限制问题对于一些需要限制同一个用户并发访问的场景，如果用户并发请求多次，而服务器处理没有加锁限制，用户则可以多次请求成功。 例如换领优惠券，如果用户同一时间并发提交换领码，在没有加锁限制的情况下，用户则可以使用同一个换领码同时兑换到多张优惠券。 伪代码如下：1234if A(可以换领) B(执行换领) C(更新为已换领)D(结束) 如果用户并发提交换领码，都能通过可以换领(A)的判断，因为必须有一个执行换领(B)后，才会更新为已换领(C)。因此如果用户在有一个更新为已换领之前，有多少次请求，这些请求都可以执行成功。 2.并发访问限制方法本文将使用Redis的setnx方法实现分布式锁功能。setnx即Set it Not eXists。 当键值不存在时，插入成功（获取锁成功），如果键值已经存在，则插入失败（获取锁失败）。 RedisLock.class.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?phpclass RedisLock &#123; private $_config; private $_redis; /** * 初始化 * * @param Array $config redis连接设定 */ public function __construct($config=[]) &#123; $this-&gt;_config = $config; $this-&gt;_redis = $this-&gt;connect(); &#125; /** * 获取锁 * * @param String $key 锁标识 * @param Int $expire 锁过期时间 * @return Boolean */ public function lock($key, $expire=5) &#123; $is_lock = $this-&gt;_redis-&gt;setnx($key, time()+$expire); // 已经设置了，不能获取锁 if(!$is_lock) &#123; // 判断锁是否过期 $lock_time = $this-&gt;_redis-&gt;get($key); // 锁已过期，删除锁，重新获取 if(time() &gt; $lock_time) &#123; $this-&gt;unlock($key); $is_lock = $this-&gt;_redis-&gt;setnx($key, time()+$expire); &#125; &#125; return $is_lock ? true : false; &#125; /** * 释放锁 * * @param String $key 锁标识 * @return Boolean */ public function unlock($key) &#123; return $this-&gt;_redis-&gt;del($key); &#125; /** * 创建redis连接 * * @return Link */ private function connect() &#123; try &#123; $redis = new Redis(); $redis-&gt;connect( $this-&gt;_config['host'], $this-&gt;_config['port'], $this-&gt;_config['timeout'], $this-&gt;_config['reserved'], $this-&gt;_config['retry_interval'] ); if(!empty($this-&gt;_config['auth'])) &#123; $redis-&gt;auth($this-&gt;_config['auth']); &#125; $redis-&gt;select($this-&gt;_config['index']); &#125;catch(RedisException $e) &#123; throw new Exception($e-&gt;getMessage()); &#125; return $redis; &#125;&#125; demo.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire 'RedisLock.class.php';$config = [ 'host' =&gt; 'localhost', 'port' =&gt; 6379, 'index' =&gt; 0, 'auth' =&gt; '', 'timeout' =&gt; 1, 'reserved' =&gt; NULL, 'retry_interval' =&gt; 100,];// 创建redislock对象$oRedisLock = new RedisLock($config);// 定义锁标识$key = 'mylock';// 获取锁$is_lock = $oRedisLock-&gt;lock($key, 10);if($is_lock)&#123; echo 'get lock success&lt;br&gt;'; echo 'do sth..&lt;br&gt;'; sleep(5); echo 'success&lt;br&gt;'; $oRedisLock-&gt;unlock($key);// 获取锁失败&#125;else&#123; echo 'request too frequently&lt;br&gt;';&#125; 测试方法： 打开两个不同的浏览器,同时在A,B中访问demo.php，先访问的会获取到锁。 输出：123get lock successdo sth..success 另一个获取锁失败则会输出：1request too frequently 保证同一时间只有一个访问有效，有效限制并发访问。 为了避免系统突然出错导致死锁，所以在获取锁的时候增加一个过期时间，如果已超过过期时间，即使是锁定状态都会释放锁，避免死锁导致的问题。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP在大并发下Redis锁实现]]></title>
    <url>%2F2020%2F07%2F29%2FPHP%E5%9C%A8%E5%A4%A7%E5%B9%B6%E5%8F%91%E4%B8%8BRedis%E9%94%81%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在现如今电商盛行的时期，会出现很多促销活动，最为常见的就是秒杀。在秒杀系统中最为常见的问题就是会出现超卖的情况，那么如何来杜绝超卖的情形了，在业务逻辑层面可以使用缓存以及加锁的手法来避免超卖的情形。 现如今nosql已经非常流行和稳定了，在此我将通过redis和php来说明如何实现锁机制。当然我使用redis加锁并不是我的秒杀系统，而是最近做的一个项目有个用户提现，初期没有考虑到会有人恶意刷新接口，而导致用户无限制提现。经过查看nginx日志，发现用户在同一时间段，通过刷接口的方法超额提现，导致亏损 起初的提现代码如下：]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则]]></title>
    <url>%2F2020%2F06%2F16%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段。怎么理解？ 为什么在对每一个模式进行优缺点评价时都会将开闭原则作为一个重要的评价依据？ 为什么在程序中尽量使用基类类型对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象？ 为什么用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情？ 为什么在程序中应该尽量使用抽象层进行编程而将具体类写在配置文件中？ 为什么接口应该尽量细化，同时接口中的方法应该尽量少？ 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类。这种复用名词是什么？ 什么是“黑箱”复用？ **本章导学** 对于面向对象软件系统设计而言，在支持可维护性的同时，提高系统的可复用性是一个至关重要的问题，如何同时提高一个软件系统的可维护性和可复用性是面向对象设计需要解决的核心问题之一。在面向对象设计中，可维护性的复用是以设计原则为基础的，每一个原则都蕴含一些面向对象设计的思想，可以从不同的角度提升一个软件结构的设计水平。 本章将学习7个重要的面向对象设计原则，结合实例分析7个原则的特点，这7个原则分别是单一职责原则、开闭原则、里氏代换原则、依赖倒转原则、接口隔离原则、合成复用原则和迪米特法则。 快速跳转 单一职责原则 开闭原则 里氏代换原则 依赖倒转原则 接口隔离原则 合成复用原则 迪米特法则 面向对象设计原则概述软件的可维护性（Maintainability）和可复用性（Reusability）是两个非常重要的用于衡量软件质量的质量属性，软件的可维护性是指软件能够被理解、改正、适应及扩展的难易程度，软件的可复用性是指软件能够被重复使用的难易程度。 面向对象设计的目标之一在于支持可维护性复用，一方面需要实现设计方案或者源代码的复用，另一方面要确保系统能够易于扩展和修改，具有良好的可维护性。面向对象设计原则为支持可维护性复用而诞生，这些原则蕴含在很多设计模式中，它们是从许多设计方案中总结出的指导性原则，但并不是强制性的。 面向对象设计原则也是后续学习设计模式的基础，每一个设计模式都符合一个或多个面向对象设计原则，面向对象设计原则是用于评价一个设计模式的使用效果的重要指标之一。通过在软件开发中使用这些原则可以提高软件的可维护性和可复用性，以便设计出兼具良好的可维护性和可复用性的软件系统，实现可维护性复用的目标。 最常见的7个面向对象设计原则如表1所示。 表1 7个常用的面向对象设计原则 **设计原则名称** **定 义** **使用频率** 单一职责原则（Single Responsibility Principle， SRP） 一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中 ★★★★☆ 开闭原则（Open-Closed Principle， OCP） 软件实体应当对扩展开放，对修改关闭 ★★★★★ 里氏代换原则（Liskov Substitution Principle， LSP） 所有引用基类的地方必须能透明地使用其子类的对象 ★★★★★ 依赖倒转原则（Dependence Inversion Principle， DIP） 高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象 ★★★★★ 接口隔离原则（Interface Segregation Principle， ISP） 客户端不应该依赖那些它不需要的接口 ★★☆☆☆ 合成复用原则（Composite Reuse Principle， CRP） 优先使用对象组合，而不是继承来达到复用的目的 ★★★★☆ 迪米特法则（Law of Demeter， LoD） 每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位 ★★★☆☆ 单一职责原则&lt;/span&gt;单一职责原则是最简单的面向对象设计原则，用于控制类的粒度大小。 单一职责原则的定义如下：1一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。 单一职责原则的另一种定义方法：1就一个类而言，应该仅有一个引起它变化的原因。 软件系统中，一个类（大到模块，小到方法）承担的职责越多，它被复用的可能性就越小，而且一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。因此，要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可以将它们封装在同一类中。 单一职责原则是实现高内聚、低耦合的指导方针，是最简单却最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关实践经验。 下面通过一个简单实例来进一步分析单一职责原则： 某软件公司开发人员针对CRM（Customer Relationship Management，客户关系管理）系统中的客户信息图表统计模块提出了如图1所示的初始设计方案。图1 初始设计方案结构图在图1中，GetConnection()方法用于连接数据库，FindCustomers()方法用于查询所有的客户信息，CreateChart()方法用于创建图表，DisplayChart()方法用于显示图表。现使用单一职责原则对其进行重构。 在图1中，CustomerDataChart类承担了太多的职责，既包含与数据库相关的方法，又包含与图表生成和显示相关的方法。如果在其他类中也需要连接数据库或者使用FindCustomers()方法查询客户信息，则难以实现代码的重用。无论是修改数据库连接方式还是修改图表显示方式都需要修改该类，它拥有不止一个引起变化的原因，违背了单一职责原则。因此，需要对该类进行拆分，使其满足单一职责原则，CustomerDataChart类可拆分为以下3个类。 (1)DBUtil：负责连接数据库，包含数据库连接方法GetConnection()。 (2)CustomerDAO：负责操作数据库中的Customer表，包含对Customer表的增、删、改、查等方法，例如FindCustomers()。 (3)CustomerDataChart：负责图表的生成和显示，包含方法CreateChart()和DisplayChart()。 使用单一职责原则重构后的结构如图2所示。 图2 重构后的结构图 开闭原则&lt;/span&gt;开闭原则是面向对象的可复用设计的第一块基石，是最重要的面向对象设计原则。 开闭原则的定义如下：1软件实体应当对扩展开放，对修改关闭。 在开闭原则的定义中，软件实体可以是一个软件模块、一个由多个类组成的局部结构或一个独立的类。开闭原则是指软件实体应尽量在不修改原有代码的情况下进行扩展。 任何软件都需要面临一个很重要的问题，即它们的需求会随时间的推移而发生变化。当软件系统需要面对新的需求时，应该尽量保证系统的设计框架是稳定的。如果一个软件设计符合开闭原则，那么可以非常方便地对系统进行扩展，而且在扩展时无须修改现有代码，使得软件系统在拥有适应性和灵活性的同时具备较好的稳定性和延续性。随着软件规模越来越大，软件寿命越来越长，软件维护成本越来越高，设计满足开闭原则的软件系统也变得越来越重要。 为了满足开闭原则，需要对系统进行抽象化设计，抽象化是开闭原则的关键。在C#、Java等编程语言中，可以为系统定义一个相对稳定的抽象层，而将不同的实现行为移至具体的实现层中完成。在很多面向对象编程语言中都提供了接口、抽象类等机制，可以通过它们定义系统的抽象层，再通过具体类来进行扩展。如果需要修改系统的行为，无须对抽象层进行任何改动，只需要增加新的具体类来实现新的业务，实现在不修改已有代码的基础上扩展系统的功能，达到开闭原则的要求。 在GoF23种设计模式中，大部分设计模式都符合开闭原则，在对每一个模式进行优缺点评价时都会将开闭原则作为一个重要的评价依据，以判断基于该模式设计的系统是否具备良好的灵活性和可扩展性。 里氏替换原则&lt;/span&gt;里氏代换原则的严格表述为：1如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换o2时，程序P的行为没有变化，那么类型S是类型T的子类型。 这个原始的定义不太容易理解，因此，一般使用它的通俗版定义：1所有引用基类的地方必须能透明地使用其子类的对象。 里氏代换原则表明，在软件中将一个基类对象替换成它的子类对象，程序将不会产生任何错误和异常，反过来则不成立。如果一个软件实体使用的是一个子类对象，那么它不一定能够使用基类对象。例如，我喜欢动物，那我一定喜欢狗，因为狗是动物的子类；但是我喜欢狗，不能据此断定我喜欢所有的动物。 里氏代换原则是实现开闭原则的基础，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 在运用里氏代换原则时，应该将父类设计为抽象类或者接口，让子类继承父类或实现父接口，并实现在父类中声明的方法。运行时，子类实例替换父类实例，可以很方便地扩展系统的功能，无须修改原有子类的代码，增加新的功能可以通过增加一个新的子类来实现。 依赖倒转原则&lt;/span&gt;如果说开闭原则是面向对象设计的目标，那么依赖倒转原则就是面向对象设计的主要实现机制之一，它是系统抽象化的具体实现。依赖倒转原则的定义如下：1高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 简单来说，依赖倒转原则要求:1要针对接口编程，不要针对实现编程。 依赖倒转原则要求，在程序代码中传递参数时或在关联关系中尽量引用层次高的抽象层类，即使用接口和抽象类进行变量类型声明、参数类型声明、方法返回类型声明，以及数据类型的转换等，而不要用具体类来做这些事情。为了确保该原则的应用，一个具体类应当只实现接口或抽象类中声明过的方法，而不要给出多余的方法，否则将无法调用到在子类中增加的新方法。 在引入抽象层后，系统将具有很好的灵活性，在程序中应该尽量使用抽象层进行编程而将具体类写在配置文件中。这样一来，如果系统行为发生变化，只需要对抽象层进行扩展，并修改配置文件，而无须修改原有系统的源代码，在不修改的情况下来扩展系统的功能，满足开闭原则的要求。 在实现依赖倒转原则时，需要针对抽象层进行编程，而将具体类的对象通过依赖注入（Dependency Injection，DI）的方式注入其他对象中。依赖注入是指当一个对象要与其他对象发生依赖关系时，通过方法参数来注入所依赖的对象。常用的注入方式有3种，分别是构造注入、设值（Setter）注入和接口注入。构造注入是指通过构造函数来传入具体类的对象，设值注入是指通过Setter方法来传入具体类的对象，而接口注入是指通过在接口中声明的业务方法来传入具体类的对象。这些方法在定义时使用的是抽象类型，在运行时再传入具体类型的对象，由子类对象来覆盖父类对象。 下面通过一个简单实例来加深对开闭原则、里氏代换原则和依赖倒转原则的理解： 某软件公司开发人员在开发CRM系统时发现：该系统经常需要将存储在TXT或Excel文件中的客户信息转存到数据库中，因此需要进行数据格式转换。在客户数据操作类CustomerDAO中将调用数据格式转换类的方法来实现格式转换，初始设计方案结构如图3所示。图3 初始设计方案结构图在编码实现图3所示的结构时，该软件公司开发人员发现该设计方案存在一个非常严重的问题，由于每次转换数据时数据来源不一定相同，因此需要经常更换数据转换类。例如有时候需要将TXTDataConvertor改为ExcelDataConvertor，此时，需要修改CustomerDAO的源代码，而且在引入并使用新的数据转换类时也不得不修改CustomerDAO的源代码，系统扩展性较差，违背了开闭原则，需要对该方案进行重构。 在本实例中，由于CustomerDAO针对具体数据转换类编程，所以在增加新的数据转换类或者更换数据转换类时不得不修改CustomerDAO的源代码。可以通过引入抽象数据转换类解决该问题，在引入抽象数据转换类DataConvertor之后，CustomerDAO针对抽象类DataConvertor编程，而将具体数据转换类名存储在配置文件中，符合依赖倒转原则。根据里氏代换原则，程序运行时，具体数据转换类对象将替换DataConvertor类型的对象，程序不会产生任何异常。更换具体数据转换类时无须修改源代码，只需要修改配置文件；如果需要增加新的具体数据转换类，只要将新增数据转换类作为DataConvertor的子类并修改配置文件即可，原有代码无须做任何修改，满足开闭原则。重构后的结构如图4所示。 图4 重构后的结构图 在上述重构过程中，同时使用了开闭原则、里氏代换原则和依赖倒转原则。在大多数情况下，这3个设计原则会同时出现，开闭原则是目标，里氏代换原则是基础，依赖倒转原则是手段，它们相辅相成，相互补充，目标一致，只是分析问题时所站角度不同而已。 接口隔离原则&lt;/span&gt;接口隔离原则的定义如下：1客户端不应该依赖那些它不需要的接口。 根据接口隔离原则，当一个接口太大时，需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。每一个接口应该承担一种相对独立的角色，不干不该干的事，该干的事都要干。这里的“接口”往往有两种不同的含义：一种是指一个类型所具有的方法特征的集合，仅仅是一种逻辑上的抽象；另外一种是指某种语言具体的“接口”，有严格的定义和结构，例如C#和Java语言中的interface。对于这两种不同的含义，ISP的表达方式以及含义也有所不同。 (1)当把“接口”理解成一个类型所提供的所有方法特征的集合的时候，这就是一种逻辑上的概念，接口的划分将直接带来类型的划分。可以把接口理解成角色，一个接口只能代表一个角色，每个角色都有它特定的一个接口，此时，这个原则可以称为“角色隔离原则”。 (2)如果把“接口”理解成狭义的特定语言的接口，那么ISP表达的意思是指接口仅仅提供客户端需要的行为，对于客户端不需要的行为则隐藏起来，应当为客户端提供尽可能小的单独的接口，而不要提供大的总接口。在面向对象编程语言中，实现一个接口就需要实现该接口中定义的所有方法，因此大的总接口使用起来不一定很方便，为了使接口的职责单一，需要将大接口中的方法根据其职责分别放在不同的小接口中，以确保每个接口用起来都较为方便，并都承担某一单一角色。接口应该尽量细化，同时接口中的方法应该尽量少，每个接口中只包含一个客户端（如子模块或业务逻辑类）所需的方法即可，这种机制也称为“定制服务”，即为不同的客户端提供宽窄不同的接口。 下面通过一个简单实例来加深对接口隔离原则的理解： 某软件公司开发人员针对CRM系统的客户数据显示模块设计了图5所示的接口，其中，方法DataRead()用于从文件中读取数据，方法TransformToXML()用于将数据转换成XML格式，方法CreateChart()用于创建图表，方法DisplayChart()用于显示图表，方法CreateReport()用于创建文字报表，方法DisplayReport()用于显示文字报表。图5 初始设计方案结构图在实际使用过程中开发人员发现该接口很不灵活，例如，一个具体的数据显示类无须进行数据转换（源文件本身就是XML格式），但由于实现了该接口，不得不实现其中声明的TransformToXML()方法（至少需要提供一个空实现）；如果需要创建和显示图表，除了需要实现与图表相关的方法外，还需要实现创建和显示文字报表的方法，否则程序在编译时将报错。现使用接口隔离原则对其进行重构。 在图5中，由于在接口CustomerDataDisplay中定义了太多方法，即该接口承担了太多职责，一方面导致该接口的实现类很庞大，在不同的实现类中不得不实现接口中定义的所有方法，灵活性较差，如果出现大量的空方法，将导致系统中产生大量的无用代码，影响代码质量；另一方面由于客户端针对大接口编程，将在一定程度上破坏程序的封装性，客户端看到了不应该看到的方法，没有为客户端定制接口。因此，需要将该接口按照接口隔离原则和单一职责原则进行重构，将其中的一些方法封装在不同的小接口中，确保每一个接口使用起来都较为方便，并都承担某一单一角色，每个接口中只包含一个客户端所需的方法即可。 通过使用接口隔离原则，本实例重构后的结构如图6所示。 图6 重构后的结构图 在使用接口隔离原则时，需要注意控制接口的粒度，接口不能太小，如果太小会导致系统中接口泛滥，不利于维护；接口也不能太大，太大的接口将违背接口隔离原则，灵活性较差，使用起来很不方便。一般而言，接口中仅包含为某一类用户定制的方法即可，不应该强迫客户依赖于那些他们不用的方法。 合成复用原则&lt;/span&gt;合成复用原则又称为组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP），其定义如下：1优先使用对象组合，而不是继承来达到复用的目的。 合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用功能的目的。简而言之，复用时要尽量使用组合/聚合关系（关联关系），少用继承。 在面向对象设计中，可以通过两种方法在不同的环境中复用已有的设计和实现，即通过组合/聚合关系或通过继承，但首先应该考虑使用组合/聚合，因为组合/聚合可以使系统更加灵活，降低类与类之间的耦合度，一个类的变化对其他类造成的影响相对较少；其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此开发人员需要慎重使用继承复用。 通过继承来进行复用的主要问题在于继承复用会破坏系统的封装性，因为继承会将基类的实现细节暴露给子类，由于基类的某些内部细节对子类来说是可见的，所以这种复用又称为“白箱”复用，如果基类发生改变，那么子类的实现也不得不发生改变；从基类继承而来是静态的，不可能在运行时发生改变，没有足够的灵活性；而且继承只能在有限的环境中使用（如类没有声明为不能被继承）。 由于组合或聚合关系可以将已有的对象（也可称为成员对象）纳入到新对象中，使之成为新对象的一部分，因此新对象可以调用已有对象的功能，这样做可以使成员对象的内部实现细节对于新对象不可见，所以这种复用又称为“黑箱”复用。相对继承关系而言，其耦合度相对较低，成员对象的变化对新对象的影响不大，可以在新对象中根据实际需要有选择性地调用成员对象的操作；合成复用可以在运行时动态进行，新对象可以动态地引用与成员对象类型相同的其他对象。 一般而言，如果两个类之间是“Has-A”关系应使用组合或聚合，如果是“Is-A”关系可使用继承。“Is-A”是严格的分类学意义上的定义，意思是一个类是另一个类的一种；而“Has-A”则不同，它表示某一个角色具有某一项责任。 下面通过一个简单实例来加深对合成复用原则的理解： 某软件公司开发人员在初期的CRM系统设计中，考虑到客户数量不多，系统采用Access作为数据库，与数据库操作有关的类，例如CustomerDAO类等都需要连接数据库，连接数据库的方法GetConnection()封装在DBUtil类中，由于需要重用DBUtil类的GetConnection()方法，设计人员将CustomerDAO作为DBUtil类的子类，初始设计方案结构如图7所示。图7 初始设计方案结构图随着客户数量的增加，系统决定升级为Oracle数据库，因此需要增加一个新的OracleDBUtil类来连接Oracle数据库，由于在初始设计方案中CustomerDAO和DBUtil之间是继承关系，因此在更换数据库连接方式时需要修改CustomerDAO类的源代码，将CustomerDAO作为OracleDBUtil的子类，这将违背开闭原则。当然也可以直接修改DBUtil类的源代码，这同样也违背了开闭原则。现使用合成复用原则对其进行重构。 根据合成复用原则，在实现复用时应该多用关联，少用继承。因此在本实例中可以使用关联复用来取代继承复用，重构后的结构如图8所示。 图8 重构后的结构图 在图8中，CustomerDAO和DBUtil之间的关系由继承关系变为关联关系，采用依赖注入的方式将DBUtil对象注入到CustomerDAO中，可以使用构造注入，也可以使用设值注入。如果需要对DBUtil的功能进行扩展，可以通过其子类来实现，例如通过子类OracleDBUtil来连接Oracle数据库。由于CustomerDAO针对DBUtil编程，根据里氏代换原则，DBUtil子类的对象可以覆盖DBUtil对象，只需在CustomerDAO中注入子类对象即可使用子类所扩展的方法。例如在CustomerDAO中注入OracleDBUtil对象，即可实现Oracle数据库连接，原有代码无须修改，而且还可以很灵活地增加新的数据库连接方式，符合开闭原则。 迪米特法则&lt;/span&gt;迪米特法则又称为最少知识原则（Least Knowledge Principle，LKP），其定义如下：1每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。 迪米特法则要求一个软件实体应当尽可能少地与其他实体发生相互作用。如果一个系统符合迪米特法则，那么当其中某一个模块发生修改时，就会尽量少地影响其他模块，扩展会相对容易，这是对软件实体之间通信的限制，迪米特法则要求限制软件实体之间通信的宽度和深度。应用迪米特法则可降低系统的耦合度，使类与类之间保持松散的耦合关系。 迪米特法则还有几种定义形式，包括不要和“陌生人”说话（Don’t talk to strangers）、只与你的直接朋友通信（Talk only to your immediate friends）等，在迪米特法则中，对于一个对象，其朋友包括以下几类： (1)当前对象本身（this）。 (2)以参数形式传入到当前对象方法中的对象。 (3)当前对象的成员对象。 (4)如果当前对象的成员对象是一个集合，那么集合中的元素也都是朋友。 (5)当前对象所创建的对象。 任何一个对象，如果满足上面的条件之一，就是当前对象的“朋友”，否则就是“陌生人”。在应用迪米特法则时，一个对象只能与直接朋友发生交互，不要和“陌生人”发生直接交互，这样做可以降低系统的耦合度，一个对象的改变不会给太多其他对象带来影响。 迪米特法则要求在设计系统时，应该尽量减少对象之间的交互，如果两个对象之间不必彼此直接通信，那么这两个对象就不应该发生任何直接的相互作用，如果其中一个对象需要调用另一个对象的方法，可以通过“第三者”转发这个调用。简而言之，就是通过引入一个合理的“第三者”来降低现有对象之间的耦合度。 在将迪米特法则运用到系统设计中时，要注意几点：在类的划分上，应当尽量创建松耦合的类，类之间的耦合度越低，越有利于复用，一个处在松耦合中的类一旦被修改，不会对关联的类造成太大影响；在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；在类的设计上，只要有可能，一个类型应当设计成不变类；在对其他类的引用上，一个对象对其他对象的引用应当降到最低。 下面通过一个简单实例来加深对迪米特法则的理解： 某软件公司所开发的CRM系统包含很多业务操作窗口，在这些窗口中，某些界面控件之间存在复杂的交互关系，一个控件事件的触发将导致多个其他界面控件产生响应。例如，当一个按钮（Button）被单击时，对应的列表框（List）、组合框（ComboBox）、文本框（TextBox）、文本标签（Label）等都将发生改变，在初始设计方案中，界面控件之间的交互关系可以简化为图9所示的结构。图9 初始设计方案结构图在图9中，由于界面控件之间的交互关系复杂，导致在该窗口中增加新的界面控件时需要修改与之交互的其他控件的源代码，系统扩展性较差，也不便于增加和删除控件。现使用迪米特法则对其进行重构。 在本实例中，可以通过引入一个专门用于控制界面控件交互的中间类（Mediator）来降低界面控件之间的耦合度。引入中间类之后，界面控件之间不再发生直接引用，而是将请求先转发给中间类，再由中间类来完成对其他控件的调用。当需要增加或删除新的控件时，只需修改中间类即可，无须修改新增控件或已有控件的源代码，重构后的结构如图10所示。 图10 重构后的结构图 在图10中，省略了中间类以及控件的属性和方法定义，在中介者模式中将进一步对该实例进行讲解，详细说明中间类Mediator的设计和实现。 本章小结(1)在软件开发中使用面向对象设计原则可以提高软件的可维护性和可复用性，以便设计出兼具良好的可维护性和可复用性的软件系统，实现可维护性复用的目标。 (2)单一职责原则要求在软件系统中，一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。 (3)开闭原则要求软件实体应当对扩展开放，对修改关闭。 (4)里氏代换原则可以通俗地表述为：在软件中所有引用基类的地方必须能透明地使用其子类的对象。 (5)依赖倒转原则要求高层模块不应该依赖低层模块，它们都应该依赖抽象。抽象不应该依赖于细节，细节应该依赖于抽象。 (6)接口隔离原则要求客户端不应该依赖那些它不需要的接口。 (7)合成复用原则要求优先使用对象组合，而不是继承来达到复用的目的。 (8)迪米特法则要求每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Database-Eloquent Model源码分析（下）]]></title>
    <url>%2F2020%2F06%2F11%2FLaravel-Database-Eloquent-Model%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 获取模型get函数 1234567891011121314151617public function get($columns = ['*'])&#123; $builder = $this-&gt;applyScopes(); if (count($models = $builder-&gt;getModels($columns)) &gt; 0) &#123; $models = $builder-&gt;eagerLoadRelations($models); &#125; return $builder-&gt;getModel()-&gt;newCollection($models);&#125;public function getModels($columns = ['*'])&#123; return $this-&gt;model-&gt;hydrate( $this-&gt;query-&gt;get($columns)-&gt;all() )-&gt;all();&#125; get 函数会将QueryBuilder所获取的数据进一步包装hydrate。hydrate函数会将数据库取回来的数据打包成数据库模型对象EloquentModel，如果可以获取到数据，还会利用函数eagerLoadRelations来预加载关系模型。12345678public function hydrate(array $items)&#123; $instance = $this-&gt;newModelInstance(); return $instance-&gt;newCollection(array_map(function ($item) use ($instance) &#123; return $instance-&gt;newFromBuilder($item); &#125;, $items));&#125; newModelInstance函数创建了一个新的数据库模型对象，重要的是这个函数为新的数据库模型对象赋予了connection：123456public function newModelInstance($attributes = [])&#123; return $this-&gt;model-&gt;newInstance($attributes)-&gt;setConnection( $this-&gt;query-&gt;getConnection()-&gt;getName() );&#125; newFromBuilder函数会将所有数据库数据存入另一个新的Eloquent Model的attributes中：123456789101112public function newFromBuilder($attributes = [], $connection = null)&#123; $model = $this-&gt;newInstance([], true); $model-&gt;setRawAttributes((array) $attributes, true); $model-&gt;setConnection($connection ?: $this-&gt;getConnectionName()); $model-&gt;fireModelEvent('retrieved', false); return $model;&#125; newInstance函数专用于创建新的数据库对象模型：123456789101112public function newInstance($attributes = [], $exists = false)&#123; $model = new static((array) $attributes); $model-&gt;exists = $exists; $model-&gt;setConnection( $this-&gt;getConnectionName() ); return $model;&#125; 值得注意的是newInstance将exist设置为true，意味着当前这个数据库模型对象是从数据库中获取而来，并非是手动新建的，这个exist为真，我们才能对这个数据库对象进行update。 setRawAttributes函数为新的数据库对象赋予属性值，并且进行sync，标志着对象的原始状态：1234567891011121314151617public function setRawAttributes(array $attributes, $sync = false)&#123; $this-&gt;attributes = $attributes; if ($sync) &#123; $this-&gt;syncOriginal(); &#125; return $this;&#125;public function syncOriginal()&#123; $this-&gt;original = $this-&gt;attributes; return $this;&#125; 这个原始状态的记录十分重要，原因是save函数就是利用原始值original与属性值attributes 的差异来决定更新的字段。 find函数 find函数用于利用主键id来查询数据，find函数也可以传入数组，查询多个数据1234567891011121314151617public function find($id, $columns = ['*'])&#123; if (is_array($id) || $id instanceof Arrayable) &#123; return $this-&gt;findMany($id, $columns); &#125; return $this-&gt;whereKey($id)-&gt;first($columns);&#125;public function findMany($ids, $columns = ['*'])&#123; if (empty($ids)) &#123; return $this-&gt;model-&gt;newCollection(); &#125; return $this-&gt;whereKey($ids)-&gt;get($columns);&#125; findOrFail laravel 还提供 findOrFail 函数，一般用于 controller，在未找到记录的时候会抛出异常。12345678910111213141516public function findOrFail($id, $columns = ['*'])&#123; $result = $this-&gt;find($id, $columns); if (is_array($id)) &#123; if (count($result) == count(array_unique($id))) &#123; return $result; &#125; &#125; elseif (! is_null($result)) &#123; return $result; &#125; throw (new ModelNotFoundException)-&gt;setModel( get_class($this-&gt;model), $id );&#125; 其他查询与数据获取方法 所用 Query Builder支持的查询方法，例如select、selectSub、whereDate、whereBetween等等，都可以直接对Eloquent Model直接使用，程序会通过魔术方法调用Query Builder的相关方法：1234567891011121314151617protected $passthru = [ 'insert', 'insertGetId', 'getBindings', 'toSql', 'exists', 'count', 'min', 'max', 'avg', 'sum', 'getConnection',];public function __call($method, $parameters)&#123; ... if (in_array($method, $this-&gt;passthru)) &#123; return $this-&gt;toBase()-&gt;&#123;$method&#125;(...$parameters); &#125; $this-&gt;query-&gt;&#123;$method&#125;(...$parameters); return $this;&#125; passthru 中的各个函数在调用前需要加载查询作用域，原因是这些操作基本上是aggregate的，需要添加搜索条件才能更加符合预期：12345678910111213141516171819202122232425262728293031323334353637383940public function toBase()&#123; return $this-&gt;applyScopes()-&gt;getQuery();&#125;``` 添加和更新模型save 函数在Eloquent Model中，添加与更新模型可以统一用save函数。在添加模型的时候需要事先为model属性赋值，可以单个手动赋值，也可以批量赋值。在更新模型的时候，需要事先从数据库中取出模型，然后修改模型属性，最后执行 save 更新操作。官方文档：添加和更新模型```phppublic function save(array $options = [])&#123; $query = $this-&gt;newQueryWithoutScopes(); if ($this-&gt;fireModelEvent('saving') === false) &#123; return false; &#125; if ($this-&gt;exists) &#123; $saved = $this-&gt;isDirty() ? $this-&gt;performUpdate($query) : true; &#125; else &#123; $saved = $this-&gt;performInsert($query); if (! $this-&gt;getConnectionName() &amp;&amp; $connection = $query-&gt;getConnection()) &#123; $this-&gt;setConnection($connection-&gt;getName()); &#125; &#125; if ($saved) &#123; $this-&gt;finishSave($options); &#125; return $saved;&#125; save函数不会加载全局作用域，原因是凡是利用save函数进行的插入或者更新的操作都不会存在where条件，仅仅利用自身的主键属性来进行更新。如果需要where条件可以使用query\builder的update函数，我们在下面会详细介绍：1234567891011121314151617public function newQueryWithoutScopes()&#123; $builder = $this-&gt;newEloquentBuilder($this-&gt;newBaseQueryBuilder()); return $builder-&gt;setModel($this) -&gt;with($this-&gt;with) -&gt;withCount($this-&gt;withCount);&#125;protected function newBaseQueryBuilder()&#123; $connection = $this-&gt;getConnection(); return new QueryBuilder( $connection, $connection-&gt;getQueryGrammar(), $connection-&gt;getPostProcessor() );&#125; newQueryWithoutScopes函数创建新的没有任何其他条件的Eloquent\builder类，而Eloquent\builder 类需要 Query\builder 类作为底层查询构造器。 performUpdate函数 如果当前的数据库模型对象是从数据库中取出的，也就是直接或间接的调用get()函数从数据库中获取到的数据库对象，那么其 exists 必然是 true12345678910111213141516171819public function isDirty($attributes = null)&#123; return $this-&gt;hasChanges( $this-&gt;getDirty(), is_array($attributes) ? $attributes : func_get_args() );&#125;public function getDirty()&#123; $dirty = []; foreach ($this-&gt;getAttributes() as $key =&gt; $value) &#123; if (! $this-&gt;originalIsEquivalent($key, $value)) &#123; $dirty[$key] = $value; &#125; &#125; return $dirty;&#125; getDirty函数可以获取所有与原始值不同的属性值，也就是需要更新的数据库字段。关键函数在于originalIsEquivalent：1234567891011121314151617181920212223protected function originalIsEquivalent($key, $current)&#123; if (! array_key_exists($key, $this-&gt;original)) &#123; return false; &#125; $original = $this-&gt;getOriginal($key); if ($current === $original) &#123; return true; &#125; elseif (is_null($current)) &#123; return false; &#125; elseif ($this-&gt;isDateAttribute($key)) &#123; return $this-&gt;fromDateTime($current) === $this-&gt;fromDateTime($original); &#125; elseif ($this-&gt;hasCast($key)) &#123; return $this-&gt;castAttribute($key, $current) === $this-&gt;castAttribute($key, $original); &#125; return is_numeric($current) &amp;&amp; is_numeric($original) &amp;&amp; strcmp((string) $current, (string) $original) === 0;&#125; 可以看到，对于数据库可以转化的属性都要先进行转化，然后再开始对比。比较出的结果，就是我们需要 update 的字段。 执行更新的时候，除了 getDirty 函数获得的待更新字段，还会有 UPDATED_AT 这个字段：1234567891011121314151617181920212223242526272829303132333435protected function performUpdate(Builder $query)&#123; if ($this-&gt;fireModelEvent('updating') === false) &#123; return false; &#125; if ($this-&gt;usesTimestamps()) &#123; $this-&gt;updateTimestamps(); &#125; $dirty = $this-&gt;getDirty(); if (count($dirty) &gt; 0) &#123; $this-&gt;setKeysForSaveQuery($query)-&gt;update($dirty); $this-&gt;fireModelEvent('updated', false); $this-&gt;syncChanges(); &#125; return true;&#125;protected function updateTimestamps()&#123; $time = $this-&gt;freshTimestamp(); if (! is_null(static::UPDATED_AT) &amp;&amp; ! $this-&gt;isDirty(static::UPDATED_AT)) &#123; $this-&gt;setUpdatedAt($time); &#125; if (! $this-&gt;exists &amp;&amp; ! $this-&gt;isDirty(static::CREATED_AT)) &#123; $this-&gt;setCreatedAt($time); &#125;&#125; 执行更新的时候，where 条件只有一个，那就是主键 id：1234567891011121314151617protected function setKeysForSaveQuery(Builder $query)&#123; $query-&gt;where($this-&gt;getKeyName(), '=', $this-&gt;getKeyForSaveQuery()); return $query;&#125;protected function getKeyForSaveQuery()&#123; return $this-&gt;original[$this-&gt;getKeyName()] ?? $this-&gt;getKey();&#125;public function getKey()&#123; return $this-&gt;getAttribute($this-&gt;getKeyName());&#125; 最后会调用 EloquentBuilder 的 update 函数：12345678910111213141516171819202122232425262728public function update(array $values)&#123; return $this-&gt;toBase()-&gt;update($this-&gt;addUpdatedAtColumn($values));&#125;protected function addUpdatedAtColumn(array $values)&#123; if (! $this-&gt;model-&gt;usesTimestamps()) &#123; return $values; &#125; return Arr::add( $values, $this-&gt;model-&gt;getUpdatedAtColumn(), $this-&gt;model-&gt;freshTimestampString() );&#125;public function freshTimestampString()&#123; return $this-&gt;fromDateTime($this-&gt;freshTimestamp());&#125;public function fromDateTime($value)&#123; return is_null($value) ? $value : $this-&gt;asDateTime($value)-&gt;format( $this-&gt;getDateFormat() );&#125; performInsert 关于数据库对象的插入，如果数据库的主键被设置为increment，也就是自增的话，程序会调用 insertAndSetId，这个时候不需要给数据库模型对象手动赋值主键id。若果数据库的主键并不支持自增，那么就需要在插入前，为数据库对象的主键 id 赋值，否则数据库会报错。12345678910111213141516171819202122232425262728293031protected function performInsert(Builder $query)&#123; if ($this-&gt;fireModelEvent('creating') === false) &#123; return false; &#125; if ($this-&gt;usesTimestamps()) &#123; $this-&gt;updateTimestamps(); &#125; $attributes = $this-&gt;attributes; if ($this-&gt;getIncrementing()) &#123; $this-&gt;insertAndSetId($query, $attributes); &#125; else &#123; if (empty($attributes)) &#123; return true; &#125; $query-&gt;insert($attributes); &#125; $this-&gt;exists = true; $this-&gt;wasRecentlyCreated = true; $this-&gt;fireModelEvent('created', false); return true;&#125; laravel 默认数据库的主键支持自增属性，程序调用的也是函数 insertAndSetId 函数：123456protected function insertAndSetId(Builder $query, $attributes)&#123; $id = $query-&gt;insertGetId($attributes, $keyName = $this-&gt;getKeyName()); $this-&gt;setAttribute($keyName, $id);&#125; 插入后，会将插入后得到的主键 id 返回，并赋值到模型的属性当中。 如果数据库主键不支持自增，那么我们在数据库类中要设置：1public $incrementing = false; 每次进行插入数据的时候，需要手动给主键赋值。 update 函数save 函数仅仅支持手动的属性赋值，无法批量赋值。laravel 的 Eloquent Model 还有一个函数: update 支持批量属性赋值。有意思的是，Eloquent Builder 也有函数 update，那个是上一小节提到的 performUpdate 所调用的函数。 两个 update 功能一致，只是 Model 的 update 函数比较适用于更新从数据库取回的数据库对象：123$flight = App\Flight::find(1);$flight-&gt;update(['name' =&gt; 'New Flight Name','desc' =&gt; 'test']); 而 Builder 的 update 适用于多查询条件下的更新：12345678910111213141516App\Flight::where('active', 1) -&gt;where('destination', 'San Diego') -&gt;update(['delayed' =&gt; 1]);``` 无论哪一种，都会自动更新 updated_at 字段。Model 的 update 函数借助 fill 函数与 save 函数：```phppublic function update(array $attributes = [], array $options = [])&#123; if (! $this-&gt;exists) &#123; return false; &#125; return $this-&gt;fill($attributes)-&gt;save($options);&#125; make 函数同样的，save 的插入也仅仅支持手动属性赋值，如果想实现批量属性赋值的插入可以使用 make 函数：123$model = App\Flight::make(['name' =&gt; 'New Flight Name','desc' =&gt; 'test']);$model-&gt;save(); make 函数实际上仅仅是新建了一个 Eloquent Model，并批量赋予属性值：1234567891011public function make(array $attributes = [])&#123; return $this-&gt;newModelInstance($attributes);&#125;public function newModelInstance($attributes = [])&#123; return $this-&gt;model-&gt;newInstance($attributes)-&gt;setConnection( $this-&gt;query-&gt;getConnection()-&gt;getName() );&#125; create 函数如果想要一步到位，批量赋值属性与插入一起操作，可以使用 create 函数：1App\Flight::create(['name' =&gt; 'New Flight Name','desc' =&gt; 'test']); 相比较 make 函数，create 函数更进一步调用了 save 函数：123456public function create(array $attributes = [])&#123; return tap($this-&gt;newModelInstance($attributes), function ($instance) &#123; $instance-&gt;save(); &#125;);&#125; 实际上，属性值是否可以批量赋值需要受 fillable 或 guarded 来控制，如果我们想要强制批量赋值可以使用 forceCreate：123456public function forceCreate(array $attributes)&#123; return $this-&gt;model-&gt;unguarded(function () use ($attributes) &#123; return $this-&gt;newModelInstance()-&gt;create($attributes); &#125;);&#125; findOrNew 函数laravel 提供一种主键查询或者新建数据库对象的函数：findOrNew：12345678public function findOrNew($id, $columns = ['*'])&#123; if (! is_null($model = $this-&gt;find($id, $columns))) &#123; return $model; &#125; return $this-&gt;newModelInstance();&#125; 值得注意的是，当查询失败的时候，会返回一个全新的数据库对象，不含有任何 attributes。 firstOrNew 函数laravel 提供一种自定义查询或者新建数据库对象的函数：firstOrNew：12345678public function firstOrNew(array $attributes, array $values = [])&#123; if (! is_null($instance = $this-&gt;where($attributes)-&gt;first())) &#123; return $instance; &#125; return $this-&gt;newModelInstance($attributes + $values);&#125; 值得注意的是，如果查询失败，会返回一个含有 attributes 和 values 两者合并的属性的数据库对象。 firstOrCreate 函数类似于 firstOrNew 函数，firstOrCreate 函数也用于自定义查询或者新建数据库对象，不同的是，firstOrCreate 函数还进一步对数据进行了插入操作：12345678910public function firstOrCreate(array $attributes, array $values = [])&#123; if (! is_null($instance = $this-&gt;where($attributes)-&gt;first())) &#123; return $instance; &#125; return tap($this-&gt;newModelInstance($attributes + $values), function ($instance) &#123; $instance-&gt;save(); &#125;);&#125; updateOrCreate 函数在 firstOrCreate 函数基础上，除了对数据进行查询，还会对查询成功的数据利用 value 进行更新：123456public function updateOrCreate(array $attributes, array $values = [])&#123; return tap($this-&gt;firstOrNew($attributes), function ($instance) use ($values) &#123; $instance-&gt;fill($values)-&gt;save(); &#125;);&#125; firstOr 函数如果想要自定义查找失败后的操作，可以使用 firstOr 函数，该函数可以传入闭包函数，处理找不到数据的情况：1234567891011121314public function firstOr($columns = ['*'], Closure $callback = null)&#123; if ($columns instanceof Closure) &#123; $callback = $columns; $columns = ['*']; &#125; if (! is_null($model = $this-&gt;first($columns))) &#123; return $model; &#125; return call_user_func($callback);&#125; 删除模型删除模型也会分为两种，一种是针对 Eloquent Model 的删除，这种删除必须是从数据库中取出的对象。还有一种是 Eloquent Builder 的删除，这种删除一般会带有多个查询条件。我们这一小节主要讲 model 的删除：12345678910111213141516171819202122public function delete()&#123; if (is_null($this-&gt;getKeyName())) &#123; throw new Exception('No primary key defined on model.'); &#125; if (! $this-&gt;exists) &#123; return; &#125; if ($this-&gt;fireModelEvent('deleting') === false) &#123; return false; &#125; $this-&gt;touchOwners(); $this-&gt;performDeleteOnModel(); $this-&gt;fireModelEvent('deleted', false); return true;&#125; 删除模型时，模型对象必然要有主键。performDeleteOnModel 函数执行具体的删除操作：12345678910111213protected function performDeleteOnModel()&#123; $this-&gt;setKeysForSaveQuery($this-&gt;newQueryWithoutScopes())-&gt;delete(); $this-&gt;exists = false;&#125;protected function setKeysForSaveQuery(Builder $query)&#123; $query-&gt;where($this-&gt;getKeyName(), '=', $this-&gt;getKeyForSaveQuery()); return $query;&#125; 所以实际上，Model 调用的也是 builder 的 delete 函数。 软删除如果想要使用软删除，需要使用 Illuminate\Database\Eloquent\SoftDeletes 这个 trait。并且需要定义软删除字段，默认为 deleted_at，将软删除字段放入 dates 中，具体用法可参考官方文档: 软删除1234567891011class Flight extends Model&#123; use SoftDeletes; /** * 需要被转换成日期的属性。 * * @var array */ protected $dates = ['deleted_at'];&#125; 我们先看看这个 trait：12345678trait SoftDeletes &#123; public static function bootSoftDeletes() &#123; static::addGlobalScope(new SoftDeletingScope); &#125;&#125; 如果使用了软删除，在 model 的启动过程中，就会启动软删除的这个函数。可以看出来，软删除是需要查询作用域来合作发挥作用的。我们看看这个 SoftDeletingScope :123456789101112131415161718192021222324class SoftDeletingScope implements Scope&#123; protected $extensions = ['Restore', 'WithTrashed', 'WithoutTrashed', 'OnlyTrashed']; public function apply(Builder $builder, Model $model) &#123; $builder-&gt;whereNull($model-&gt;getQualifiedDeletedAtColumn()); &#125; public function extend(Builder $builder) &#123; foreach ($this-&gt;extensions as $extension) &#123; $this-&gt;&#123;"add&#123;$extension&#125;"&#125;($builder); &#125; $builder-&gt;onDelete(function (Builder $builder) &#123; $column = $this-&gt;getDeletedAtColumn($builder); return $builder-&gt;update([ $column =&gt; $builder-&gt;getModel()-&gt;freshTimestampString(), ]); &#125;); &#125;&#125; apply 函数是加载全局域调用的函数，每次进行查询的时候，调用 get 函数就会自动加载这个函数，whereNull 这个查询条件会被加载到具体的 where 条件中。deleted_at 字段一般被设置为 null，在执行软删除的时候，该字段会被赋予时间格式的值，标志着被删除的时间。 在加载全局作用域的时候，还会调用 extend 函数，extend 函数为 model 添加了四个函数： WithTrashed123456 protected function addWithTrashed(Builder $builder)&#123; $builder-&gt;macro('withTrashed', function (Builder $builder) &#123; return $builder-&gt;withoutGlobalScope($this); &#125;);&#125; withTrashed 函数取消了软删除的全局作用域，这样我们查询数据的时候就会查询到正常数据和被软删除的数据。 withoutTrashed123456789101112protected function addWithoutTrashed(Builder $builder)&#123; $builder-&gt;macro('withoutTrashed', function (Builder $builder) &#123; $model = $builder-&gt;getModel(); $builder-&gt;withoutGlobalScope($this)-&gt;whereNull( $model-&gt;getQualifiedDeletedAtColumn() ); return $builder; &#125;);&#125; withTrashed 函数着重强调了不要获取软删除的数据。 onlyTrashed123456789101112protected function addOnlyTrashed(Builder $builder)&#123; $builder-&gt;macro('onlyTrashed', function (Builder $builder) &#123; $model = $builder-&gt;getModel(); $builder-&gt;withoutGlobalScope($this)-&gt;whereNotNull( $model-&gt;getQualifiedDeletedAtColumn() ); return $builder; &#125;);&#125; 如果只想获取被软删除的数据，可以使用这个函数 onlyTrashed，可以看到，它使用了 whereNotNull。 restore12345678protected function addRestore(Builder $builder)&#123; $builder-&gt;macro('restore', function (Builder $builder) &#123; $builder-&gt;withTrashed(); return $builder-&gt;update([$builder-&gt;getModel()-&gt;getDeletedAtColumn() =&gt; null]); &#125;);&#125; 如果想要恢复被删除的数据，还可以使用 restore，重新将 deleted_at 数据恢复为 null。 performDeleteOnModelSoftDeletes 这个 trait 会重载 performDeleteOnModel 函数，它将不会调用 Eloquent Builder 的 delete 方法，而是采用更新操作：123456789101112131415161718192021222324252627protected function performDeleteOnModel()&#123; if ($this-&gt;forceDeleting) &#123; return $this-&gt;newQueryWithoutScopes()-&gt;where($this-&gt;getKeyName(), $this-&gt;getKey())-&gt;forceDelete(); &#125; return $this-&gt;runSoftDelete();&#125;protected function runSoftDelete()&#123; $query = $this-&gt;newQueryWithoutScopes()-&gt;where($this-&gt;getKeyName(), $this-&gt;getKey()); $time = $this-&gt;freshTimestamp(); $columns = [$this-&gt;getDeletedAtColumn() =&gt; $this-&gt;fromDateTime($time)]; $this-&gt;&#123;$this-&gt;getDeletedAtColumn()&#125; = $time; if ($this-&gt;timestamps) &#123; $this-&gt;&#123;$this-&gt;getUpdatedAtColumn()&#125; = $time; $columns[$this-&gt;getUpdatedAtColumn()] = $this-&gt;fromDateTime($time); &#125; $query-&gt;update($columns);&#125; 删除操作不仅更新了 deleted_at，还更新了 updated_at 字段。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Database-Eloquent Model源码分析（上）]]></title>
    <url>%2F2020%2F06%2F11%2FLaravel-Database-Eloquent-Model%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言前面几个博客向大家介绍了查询构造器的原理与源码，然而查询构造器更多是为Eloquent Model服务的，我们对数据库操作更加方便的是使用Eloquent Model。本篇文章将会大家介绍Model的一些特性原理。 Eloquent Model修改器简介当你在Eloquent模型实例中获取或设置某些属性值的时候，访问器和修改器允许你对Eloquent属性值进行格式化。例如，你可能需要使用Laravel加密器来加密保存在数据库中的值，而在使用Eloquent模型访问该属性的时候自动进行解密其值。 除了自定义访问器和修改器外，Eloquent也会自动将日期字段类型转换为Carbon实例，或将文本类型转换为JSON。 访问器&amp;修改器定义一个访问器若要定义一个访问器，则需在模型上创建一个getFooAttribute方法，要访问的Foo字段需使用「驼峰式」命名。在这个示例中，我们将为first_name属性定义一个访问器。当Eloquent尝试获取first_name属性时，将自动调用此访问器：12345678910111213141516171819&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 获取用户的姓名. * * @param string $value * @return string */ public function getFirstNameAttribute($value) &#123; return ucfirst($value); &#125;&#125; 如你所见，字段的原始值被传递到访问器中，允许你对它进行处理并返回结果。如果想获取被修改后的值，你可以在模型实例上访问first_name属性：123$user = App\User::find(1);$firstName = $user-&gt;first_name; 当然，你也可以通过已有的属性值，使用访问器返回新的计算值：123456789/** * 获取用户的姓名. * * @return string */public function getFullNameAttribute()&#123; return "&#123;$this-&gt;first_name&#125; &#123;$this-&gt;last_name&#125;";&#125; Tip：如果你需要将这些计算值添加到模型的数组/JSON中，你需要追加它们。 定义一个修改器若要定义一个修改器，则需在模型上面定义setFooAttribute方法。要访问的Foo字段使用「驼峰式」命名。让我们再来定义一个first_name属性的修改器。当我们尝试在模型上设置first_name属性值时，该修改器将被自动调用：12345678910111213141516171819&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 设置用户的姓名. * * @param string $value * @return void */ public function setFirstNameAttribute($value) &#123; $this-&gt;attributes['first_name'] = strtolower($value); &#125;&#125; 修改器会获取属性已经被设置的值，允许你修改并且将其值设置到Eloquent模型内部的$attributes属性上。举个例子，如果我们尝试将first_name属性的值设置为Sally：123$user = App\User::find(1);$user-&gt;first_name = 'Sally'; 在这个例子中，setFirstNameAttribute方法在调用的时候接受Sally这个值作为参数。接着修改器会应用strtolower函数并将处理的结果设置到内部的$attributes数组。 日期转换器默认情况下，Eloquent会将created_at和updated_at字段转换为Carbon实例，它继承了PHP原生的DateTime类并提供了各种有用的方法。你可以通过设置模型的$dates属性来添加其他日期属性：1234567891011121314151617&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 应该转换为日期格式的属性. * * @var array */ protected $dates = [ 'seen_at', ];&#125; Tip：你可以通过将模型的公有属性$timestamps值设置为false来禁用默认的created_at和updated_at时间戳。 当某个字段是日期格式时，你可以将值设置为一个UNIX时间戳，日期时间（Y-m-d）字符串，或者DateTime/Carbon实例。日期值会被正确格式化并保存到你的数据库中：12345$user = App\User::find(1);$user-&gt;deleted_at = now();$user-&gt;save(); 就如上面所说，当获取到的属性包含在$dates属性中时，都会自动转换为Carbon实例，允许你在属性上使用任意的Carbon方法：123$user = App\User::find(1);return $user-&gt;deleted_at-&gt;getTimestamp(); 日期格式 默认情况下，时间戳都将以’Y-m-d Hs’形式格式化。如果你需要自定义时间戳格式，可在模型中设置$dateFormat属性。这个属性决定了日期属性将以何种形式保存在数据库中，以及当模型序列化成数组或JSON时的格式：123456789101112131415&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class Flight extends Model&#123; /** * 模型日期字段的保存格式. * * @var string */ protected $dateFormat = 'U';&#125; 属性类型转换 模型中的$casts属性提供了一个便利的方法来将属性转换为常见的数据类型。$casts属性应是一个数组，且数组的键是那些需要被转换的属性名称，值则是你希望转换的数据类型。支持转换的数据类型有：integer，real，float，double，decimal:\，string，boolean，object，array，collection，date，datetime和timestamp。当需要转换为decimal类型时，你需要定义小数位的个数，如：decimal:2。 示例，让我们把以整数（0或1）形式存储在数据库中的is_admin属性转成布尔值：1234567891011121314151617&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 这个属性应该被转换为原生类型. * * @var array */ protected $casts = [ 'is_admin' =&gt; 'boolean', ];&#125; 现在当你访问is_admin属性时，虽然保存在数据库里的值是一个整数类型，但是返回值总是会被转换成布尔值类型：12345$user = App\User::find(1);if ($user-&gt;is_admin) &#123; //&#125; 数组&amp;JSON转换 当你在数据库存储序列化的JSON的数据时，array类型的转换非常有用。比如：如果你的数据库具有被序列化为JSON的JSON或TEXT字段类型，并且在Eloquent模型中加入了array类型转换，那么当你访问的时候就会自动被转换为PHP数组：1234567891011121314151617181920212223242526272829 &lt;?php namespace App; use Illuminate\Database\Eloquent\Model; class User extends Model &#123; /** * 这个属性应该被转换为原生类型. * * @var array */ protected $casts = [ 'options' =&gt; 'array', ]; &#125;``` 一旦定义了转换，你访问options属性时他会自动从JSON类型反序列化为PHP数组。当你设置了options属性的值时，给定的数组也会自动序列化为JSON类型存储：```php $user = App\User::find(1); $options = $user-&gt;options; $options['key'] = 'value'; $user-&gt;options = $options; $user-&gt;save(); Date转换 当使用date或datetime属性时，可以指定日期的格式。这种格式会被用在模型序列化为数组或者JSON：12345678/** * 这个属性应该被转化为原生类型. * * @var array */protected $casts = [ 'created_at' =&gt; 'datetime:Y-m-d',]; 源码当我们在Eloquent模型实例中设置某些属性值的时候，修改器允许对Eloquent属性值进行格式化。 下面先看看修改器的原理：1234567891011121314151617181920212223242526272829public function offsetSet($offset, $value)&#123; $this-&gt;setAttribute($offset, $value);&#125;public function setAttribute($key, $value)&#123; if ($this-&gt;hasSetMutator($key)) &#123; $method = 'set'.Str::studly($key).'Attribute'; return $this-&gt;&#123;$method&#125;($value); &#125; elseif ($value &amp;&amp; $this-&gt;isDateAttribute($key)) &#123; $value = $this-&gt;fromDateTime($value); &#125; if ($this-&gt;isJsonCastable($key) &amp;&amp; ! is_null($value)) &#123; $value = $this-&gt;castAttributeAsJson($key, $value); &#125; if (Str::contains($key, '-&gt;')) &#123; return $this-&gt;fillJsonAttribute($key, $value); &#125; $this-&gt;attributes[$key] = $value; return $this;&#125; 自定义修改器 当我们为model的成员变量赋值的时候，就会调用offsetSet函数，进而运行setAttribute函数，在这个函数中第一个检查的就是是否存在预处理函数：1234public function hasSetMutator($key)&#123; return method_exists($this, 'set'.Str::studly($key).'Attribute');&#125; 如果存在该函数，就会直接调用自定义修改器。 日期转换器 接着如果没有自定义修改器的话，还会检查当前更新的成员变量是否是日期属性：12345678910111213141516171819protected function isDateAttribute($key)&#123; return in_array($key, $this-&gt;getDates()) || $this-&gt;isDateCastable($key);&#125;public function getDates()&#123; $defaults = [static::CREATED_AT, static::UPDATED_AT]; return $this-&gt;usesTimestamps() ? array_unique(array_merge($this-&gt;dates, $defaults)) : $this-&gt;dates;&#125;protected function isDateCastable($key)&#123; return $this-&gt;hasCast($key, ['date', 'datetime']);&#125; 字段的时间属性有两种设置方法，一种是设置$dates属性：1protected $dates = ['date_attr']; 还有一种方法是设置 cast 数组：1protected $casts = ['date_attr' =&gt; 'date']; 只要是时间属性的字段，无论是什么类型的值，Laravel都会自动将其转化为数据库的时间格式。数据库的时间格式设置是dateFormat成员变量，不设置的时候，默认的时间格式为’Y-m-d H:i:s’:123protected $dateFormat = ['U'];protected $dateFormat = ['Y-m-d H:i:s']; 当数据库对应的字段是时间类型时，为其赋值就可以非常灵活。我们可以赋值Carbon类型、DateTime类型、数字类型、字符串等等：12345678910111213141516171819202122232425262728293031public function fromDateTime($value)&#123; return is_null($value) ? $value : $this-&gt;asDateTime($value)-&gt;format( $this-&gt;getDateFormat() );&#125;protected function asDateTime($value)&#123; if ($value instanceof Carbon) &#123; return $value; &#125; if ($value instanceof DateTimeInterface) &#123; return new Carbon( $value-&gt;format('Y-m-d H:i:s.u'), $value-&gt;getTimezone() ); &#125; if (is_numeric($value)) &#123; return Carbon::createFromTimestamp($value); &#125; if ($this-&gt;isStandardDateFormat($value)) &#123; return Carbon::createFromFormat('Y-m-d', $value)-&gt;startOfDay(); &#125; return Carbon::createFromFormat( $this-&gt;getDateFormat(), $value );&#125; json转换器 接下来，如果该变量被设置为array、json等属性，那么其将会转化为json类型。123456789protected function isJsonCastable($key)&#123; return $this-&gt;hasCast($key, ['array', 'json', 'object', 'collection']);&#125;protected function asJson($value)&#123; return json_encode($value);&#125; Eloquent Model 访问器 相比较修改器来说，访问器的适用情景会更加多。例如，我们经常把一些关于类型的字段设置为 1、2、3等等，例如用户数据表中用户性别字段，1代表男，2代表女，很多时候我们取出这些值之后必然要经过转换，然后再显示出来。这时候就需要定义访问器。 访问器的源码：1234567891011121314151617public function getAttribute($key)&#123; if (! $key) &#123; return; &#125; if (array_key_exists($key, $this-&gt;attributes) || $this-&gt;hasGetMutator($key)) &#123; return $this-&gt;getAttributeValue($key); &#125; if (method_exists(self::class, $key)) &#123; return; &#125; return $this-&gt;getRelationValue($key);&#125; 可以看到，当我们访问数据库对象的成员变量的时候，大致可以分为两类：属性值与关系对象。关系对象我们以后再详细来说，本文中先说关于属性的访问。12345678910111213141516171819public function getAttributeValue($key)&#123; $value = $this-&gt;getAttributeFromArray($key); if ($this-&gt;hasGetMutator($key)) &#123; return $this-&gt;mutateAttribute($key, $value); &#125; if ($this-&gt;hasCast($key)) &#123; return $this-&gt;castAttribute($key, $value); &#125; if (in_array($key, $this-&gt;getDates()) &amp;&amp; ! is_null($value)) &#123; return $this-&gt;asDateTime($value); &#125; return $value;&#125; 与修改器类似，访问器也由三部分构成：自定义访问器、日期访问器、类型访问器。 获取原始值 访问器的第一步就是从成员变量attributes中获取原始的字段值，一般指的是存在数据库的值。有的时候，我们要取的属性并不在attributes中，这时候就会返回null。123456protected function getAttributeFromArray($key)&#123; if (isset($this-&gt;attributes[$key])) &#123; return $this-&gt;attributes[$key]; &#125;&#125; 自定义访问器 如果定义了访问器，那么就会调用访问器，获取返回值：123456789public function hasGetMutator($key)&#123; return method_exists($this, 'get'.Str::studly($key).'Attribute');&#125;protected function mutateAttribute($key, $value)&#123; return $this-&gt;&#123;'get'.Str::studly($key).'Attribute'&#125;($value);&#125; 类型转换 若我们在成员变量 $casts 数组中为属性定义了类型转换，那么就要进行类型转换：123456789101112131415161718192021222324252627282930313233343536373839404142434445public function hasCast($key, $types = null)&#123; if (array_key_exists($key, $this-&gt;getCasts())) &#123; return $types ? in_array($this-&gt;getCastType($key), (array) $types, true) : true; &#125; return false;&#125;protected function castAttribute($key, $value)&#123; if (is_null($value)) &#123; return $value; &#125; switch ($this-&gt;getCastType($key)) &#123; case 'int': case 'integer': return (int) $value; case 'real': case 'float': case 'double': return (float) $value; case 'string': return (string) $value; case 'bool': case 'boolean': return (bool) $value; case 'object': return $this-&gt;fromJson($value, true); case 'array': case 'json': return $this-&gt;fromJson($value); case 'collection': return new BaseCollection($this-&gt;fromJson($value)); case 'date': return $this-&gt;asDate($value); case 'datetime': return $this-&gt;asDateTime($value); case 'timestamp': return $this-&gt;asTimestamp($value); default: return $value; &#125;&#125; 日期转换 若当前属性是CREATED_AT、UPDATED_AT或者被存入成员变量dates中，那么就要进行日期转换。日期转换函数asDateTime可以查看上一节中的内容。 Eloquent Model数组转化 在使用数据库对象中，我们经常使用toArray函数，它可以将从数据库中取出的所有属性和关系模型转化为数组：1234public function toArray()&#123; return array_merge($this-&gt;attributesToArray(), $this-&gt;relationsToArray());&#125; 本文中只介绍属性转化为数组的部分：1234567891011121314151617181920public function attributesToArray()&#123; $attributes = $this-&gt;addDateAttributesToArray( $attributes = $this-&gt;getArrayableAttributes() ); $attributes = $this-&gt;addMutatedAttributesToArray( $attributes, $mutatedAttributes = $this-&gt;getMutatedAttributes() ); $attributes = $this-&gt;addCastAttributesToArray( $attributes, $mutatedAttributes ); foreach ($this-&gt;getArrayableAppends() as $key) &#123; $attributes[$key] = $this-&gt;mutateAttributeForArray($key, null); &#125; return $attributes;&#125; 与访问器与修改器类似，需要转为数组的元素有日期类型、自定义访问器、类型转换，我们接下来一个个看： getArrayableAttributes 原始值获取 首先我们要从成员变量 attributes 数组中获取原始值：1234567891011121314151617protected function getArrayableAttributes()&#123; return $this-&gt;getArrayableItems($this-&gt;attributes);&#125;protected function getArrayableItems(array $values)&#123; if (count($this-&gt;getVisible()) &gt; 0) &#123; $values = array_intersect_key($values, array_flip($this-&gt;getVisible())); &#125; if (count($this-&gt;getHidden()) &gt; 0) &#123; $values = array_diff_key($values, array_flip($this-&gt;getHidden())); &#125; return $values;&#125; 我们还可以为数据库对象设置可见元素$visible与隐藏元素$hidden，这两个变量会控制toArray可转化的元素属性。 日期转换12345678910111213141516171819protected function addDateAttributesToArray(array $attributes)&#123; foreach ($this-&gt;getDates() as $key) &#123; if (! isset($attributes[$key])) &#123; continue; &#125; $attributes[$key] = $this-&gt;serializeDate( $this-&gt;asDateTime($attributes[$key]) ); &#125; return $attributes;&#125;protected function serializeDate(DateTimeInterface $date)&#123; return $date-&gt;format($this-&gt;getDateFormat());&#125; 自定义访问器转换 定义了自定义访问器的属性，会调用访问器函数来覆盖原有的属性值，首先我们需要获取所有的自定义访问器变量：123456789101112131415161718192021222324public function getMutatedAttributes()&#123; $class = static::class; if (! isset(static::$mutatorCache[$class])) &#123; static::cacheMutatedAttributes($class); &#125; return static::$mutatorCache[$class];&#125;public static function cacheMutatedAttributes($class)&#123; static::$mutatorCache[$class] = collect(static::getMutatorMethods($class))-&gt;map(function ($match) &#123; return lcfirst(static::$snakeAttributes ? Str::snake($match) : $match); &#125;)-&gt;all();&#125;protected static function getMutatorMethods($class)&#123; preg_match_all('/(?&lt;=^|;)get([^;]+?)Attribute(;|$)/', implode(';', get_class_methods($class)), $matches); return $matches[1];&#125; 可以看到，函数用get_class_methods获取类内所有的函数，并筛选出符合get…Attribute的函数，获得自定义的访问器变量，并缓存到mutatorCache中。 接着将会利用自定义访问器变量替换原始值：123456789101112131415161718192021protected function addMutatedAttributesToArray(array $attributes, array $mutatedAttributes)&#123; foreach ($mutatedAttributes as $key) &#123; if (! array_key_exists($key, $attributes)) &#123; continue; &#125; $attributes[$key] = $this-&gt;mutateAttributeForArray( $key, $attributes[$key] ); &#125; return $attributes;&#125;protected function mutateAttributeForArray($key, $value)&#123; $value = $this-&gt;mutateAttribute($key, $value); return $value instanceof Arrayable ? $value-&gt;toArray() : $value;&#125; cast 类型转换 被定义在cast数组中的变量也要进行数组转换，调用的方法和访问器相同，也是castAttribute，如果是时间类型，还要按照时间格式来转换：12345678910111213141516171819protected function addCastAttributesToArray(array $attributes, array $mutatedAttributes)&#123; foreach ($this-&gt;getCasts() as $key =&gt; $value) &#123; if (! array_key_exists($key, $attributes) || in_array($key, $mutatedAttributes)) &#123; continue; &#125; $attributes[$key] = $this-&gt;castAttribute( $key, $attributes[$key] ); if ($attributes[$key] &amp;&amp; ($value === 'date' || $value === 'datetime')) &#123; $attributes[$key] = $this-&gt;serializeDate($attributes[$key]); &#125; &#125; return $attributes;&#125; appends 额外属性添加 toArray()还会将我们定义在appends变量中的属性一起进行数组转换，但是注意被放入appends成员变量数组中的属性需要有自定义访问器函数：12345678910111213141516171819202122232425262728293031323334353637383940414243444546protected function getArrayableAppends()&#123; if (! count($this-&gt;appends)) &#123; return []; &#125; return $this-&gt;getArrayableItems( array_combine($this-&gt;appends, $this-&gt;appends) );&#125;``` ## 查询作用域查询作用域分为全局作用域与本地作用域。全局作用域不需要手动调用，由程序在每次的查询中自动加载，本地作用域需要在查询的时候进行手动调用。### 全局作用域全局作用域可以给模型的查询都添加上约束。Laravel的软删除功能就是利用此特性从数据库中获取「未删除」的模型。你可以编写你自己的全局作用域，很简单、方便的为每个模型查询都加上约束条件：**编写全局作用域**编写全局作用域很简单。定义一个实现Illuminate\Database\Eloquent\Scope接口的类，并实现apply这个方法。根据你的需求，在apply方法中加入查询的where条件：```php&lt;?phpnamespace App\Scopes;use Illuminate\Database\Eloquent\Scope;use Illuminate\Database\Eloquent\Model;use Illuminate\Database\Eloquent\Builder;class AgeScope implements Scope&#123; /** * 把约束加到Eloquent查询构造中。 * * @param \Illuminate\Database\Eloquent\Builder $builder * @param \Illuminate\Database\Eloquent\Model $model * @return void */ public function apply(Builder $builder, Model $model) &#123; $builder-&gt;where('age', '&gt;', 200); &#125;&#125; 提示：如果你需要在select语句里添加字段，应使用addSelect方法，而不是select方法。这将有效防止无意中替换现有select语句的情况。 应用全局作用域 要将全局作用域分配给模型，需要重写模型的boot方法并使用addGlobalScope方法：123456789101112131415161718192021&lt;?phpnamespace App;use App\Scopes\AgeScope;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 模型的「启动」方法 * * @return void */ protected static function boot() &#123; parent::boot(); static::addGlobalScope(new AgeScope); &#125;&#125; 添加作用域后，对User::all()的查询会生成以下SQL查询语句：1select * from `users` where `age` &gt; 200 匿名全局作用域 Eloquent同样允许使用闭包定义全局作用域，这样就不需要为一个简单的作用域而编写一个单独的类：1234567891011121314151617181920212223&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;use Illuminate\Database\Eloquent\Builder;class User extends Model&#123; /** * 模型的「启动」方法 * * @return void */ protected static function boot() &#123; parent::boot(); static::addGlobalScope('age', function (Builder $builder) &#123; $builder-&gt;where('age', '&gt;', 200); &#125;); &#125;&#125; 取消全局作用域 如果需要对当前查询取消全局作用域，需要使用withoutGlobalScope方法。该方法仅接受全局作用域类名作为它唯一的参数：1User::withoutGlobalScope(AgeScope::class)-&gt;get(); 或者，如果使用闭包定义全局作用域的话：1User::withoutGlobalScope('age')-&gt;get(); 如果你需要取消部分或者全部的全局作用域的话，需要使用withoutGlobalScopes方法：1234567// 取消所有的全局作用域...User::withoutGlobalScopes()-&gt;get();// 取消部分全局作用域...User::withoutGlobalScopes([ FirstScope::class, SecondScope::class])-&gt;get(); 我们先看看源码：123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace Illuminate\Database\Eloquent\Concerns;use Closure;use Illuminate\Database\Eloquent\Scope;use Illuminate\Support\Arr;use InvalidArgumentException;trait HasGlobalScopes&#123; /** * Register a new global scope on the model. * * @param \Illuminate\Database\Eloquent\Scope|\Closure|string $scope * @param \Closure|null $implementation * @return mixed * * @throws \InvalidArgumentException */ public static function addGlobalScope($scope, Closure $implementation = null) &#123; if (is_string($scope) &amp;&amp; ! is_null($implementation)) &#123; return static::$globalScopes[static::class][$scope] = $implementation; &#125; elseif ($scope instanceof Closure) &#123; return static::$globalScopes[static::class][spl_object_hash($scope)] = $scope; &#125; elseif ($scope instanceof Scope) &#123; return static::$globalScopes[static::class][get_class($scope)] = $scope; &#125; throw new InvalidArgumentException('Global scope must be an instance of Closure or Scope.'); &#125;&#125; 可以看到，全局作用域使用的是全局的静态变量globalScopes，该变量保存着所有数据库对象的全局作用域。 Eloquent\Model类并不负责查询功能，相关功能由Eloquent\Builder负责，因此每次查询都会间接调用Eloquent\Builder类。1234567891011121314151617181920abstract class Model&#123; use ForwardsCalls; /** * Handle dynamic method calls into the model. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; if (in_array($method, ['increment', 'decrement'])) &#123; return $this-&gt;$method(...$parameters); &#125; return $this-&gt;forwardCallTo($this-&gt;newQuery(), $method, $parameters); &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace Illuminate\Support\Traits;use BadMethodCallException;use Error;trait ForwardsCalls&#123; /** * Forward a method call to the given object. * * @param mixed $object * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ protected function forwardCallTo($object, $method, $parameters) &#123; try &#123; return $object-&gt;&#123;$method&#125;(...$parameters); &#125; catch (Error | BadMethodCallException $e) &#123; $pattern = '~^Call to undefined method (?P&lt;class&gt;[^:]+)::(?P&lt;method&gt;[^\(]+)\(\)$~'; if (! preg_match($pattern, $e-&gt;getMessage(), $matches)) &#123; throw $e; &#125; if ($matches['class'] != get_class($object) || $matches['method'] != $method) &#123; throw $e; &#125; static::throwBadMethodCallException($method); &#125; &#125;&#125; 创建新的Eloquent\Builder类需要newQuery函数：1234567891011121314151617181920212223242526public function newQuery()&#123; $builder = $this-&gt;newQueryWithoutScopes(); foreach ($this-&gt;getGlobalScopes() as $identifier =&gt; $scope) &#123; $builder-&gt;withGlobalScope($identifier, $scope); &#125; return $builder;&#125;public function getGlobalScopes()&#123; return Arr::get(static::$globalScopes, static::class, []);&#125;public function withGlobalScope($identifier, $scope)&#123; $this-&gt;scopes[$identifier] = $scope; if (method_exists($scope, 'extend')) &#123; $scope-&gt;extend($this); &#125; return $this;&#125; newQuery函数为Eloquent\builder加载全局作用域，这样静态变量globalScopes的值就会被赋到Eloquent\builder的scopes成员变量中。 当我们使用get()函数获取数据库数据的时候，也需要借助魔术方法调用Illuminate\Database\Eloquent\Builder类的get函数：12345678910public function get($columns = ['*'])&#123; $builder = $this-&gt;applyScopes(); if (count($models = $builder-&gt;getModels($columns)) &gt; 0) &#123; $models = $builder-&gt;eagerLoadRelations($models); &#125; return $builder-&gt;getModel()-&gt;newCollection($models);&#125; 调用applyScopes函数加载所有的全局作用域：1234567891011121314151617181920212223242526public function applyScopes()&#123; if (! $this-&gt;scopes) &#123; return $this; &#125; $builder = clone $this; foreach ($this-&gt;scopes as $identifier =&gt; $scope) &#123; if (! isset($builder-&gt;scopes[$identifier])) &#123; continue; &#125; $builder-&gt;callScope(function (Builder $builder) use ($scope) &#123; if ($scope instanceof Closure) &#123; $scope($builder); &#125; if ($scope instanceof Scope) &#123; $scope-&gt;apply($builder, $this-&gt;getModel()); &#125; &#125;); &#125; return $builder;&#125; 可以看到，builder查询类会通过callScope加载全局作用域的查询条件。1234567891011121314151617protected function callScope(callable $scope, $parameters = [])&#123; array_unshift($parameters, $this); $query = $this-&gt;getQuery(); $originalWhereCount = is_null($query-&gt;wheres) ? 0 : count($query-&gt;wheres); $result = $scope(...array_values($parameters)) ?? $this; if (count((array) $query-&gt;wheres) &gt; $originalWhereCount) &#123; $this-&gt;addNewWheresWithinGroup($query, $originalWhereCount); &#125; return $result;&#125; callScope函数首先会获取更加底层的Query\builder，更新query\bulid的where条件。 addNewWheresWithinGroup这个函数很重要，它为Query\builder提供nest类型的where条件：123456789101112131415161718192021222324252627282930313233343536protected function addNewWheresWithinGroup(QueryBuilder $query, $originalWhereCount)&#123; $allWheres = $query-&gt;wheres; $query-&gt;wheres = []; $this-&gt;groupWhereSliceForScope( $query, array_slice($allWheres, 0, $originalWhereCount) ); $this-&gt;groupWhereSliceForScope( $query, array_slice($allWheres, $originalWhereCount) );&#125;protected function groupWhereSliceForScope(QueryBuilder $query, $whereSlice)&#123; $whereBooleans = collect($whereSlice)-&gt;pluck('boolean'); if ($whereBooleans-&gt;contains('or')) &#123; $query-&gt;wheres[] = $this-&gt;createNestedWhere( $whereSlice, $whereBooleans-&gt;first() ); &#125; else &#123; $query-&gt;wheres = array_merge($query-&gt;wheres, $whereSlice); &#125;&#125;protected function createNestedWhere($whereSlice, $boolean = 'and')&#123; $whereGroup = $this-&gt;getQuery()-&gt;forNestedWhere(); $whereGroup-&gt;wheres = $whereSlice; return ['type' =&gt; 'Nested', 'query' =&gt; $whereGroup, 'boolean' =&gt; $boolean];&#125; 当我们在查询作用域中，所有的查询条件连接符都是and的时候，可以直接合并到where中。 如果我们在查询作用域中或者原查询条件写下了orWhere、orWhereColumn等等连接符为or的查询条件，那么就会利用createNestedWhere函数创建nest类型的where条件。这个where条件会包含查询作用域的所有查询条件，或者原查询的所有查询条件。 本地作用域全局作用域会自动加载到所有的查询条件当中，Laravel中还有本地作用域，只有在查询时调用才会生效。 本地作用域允许定义通用的约束集合以便在应用程序中重复使用。例如，你可能经常需要获取所有「流行」的用户。要定义这样一个范围，只需要在对应的Eloquent模型方法前添加scope前缀。 作用域总是返回一个查询构造器实例： 123456789101112131415161718192021222324252627282930&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 只查询受欢迎的用户的作用域 * * @param \Illuminate\Database\Eloquent\Builder $query * @return \Illuminate\Database\Eloquent\Builder */ public function scopePopular($query) &#123; return $query-&gt;where('votes', '&gt;', 100); &#125; /** * 只查询active用户的作用域 * * @param \Illuminate\Database\Eloquent\Builder $query * @return \Illuminate\Database\Eloquent\Builder */ public function scopeActive($query) &#123; return $query-&gt;where('active', 1); &#125;&#125; 使用本地作用域 一旦定义了作用域，就可以在查询该模型时调用作用域方法。不过，在调用这些方法时不必包含scope前缀。甚至可以链式调用多个作用域，例如：1$users = App\User::popular()-&gt;active()-&gt;orderBy('created_at')-&gt;get(); 借助or查询运行符整合多个Eloquent模型，可能需要使用闭包回调：123$users = App\User::popular()-&gt;orWhere(function (Builder $query) &#123; $query-&gt;active();&#125;)-&gt;get(); 因为这样可能会有点麻烦，Laravel提供了「更高阶的」orWhere方法，它允许你在链式调用作用域时不使用闭包：1$users = App\User::popular()-&gt;orWhere-&gt;active()-&gt;get(); 动态作用域 有时可能地希望定义一个可以接受参数的作用域。把额外参数传递给作用域就可以达到此目的。作用域参数要放在$query参数之后：1234567891011121314151617181920&lt;?phpnamespace App;use Illuminate\Database\Eloquent\Model;class User extends Model&#123; /** * 将查询作用域限制为仅包含给定类型的用户 * * @param \Illuminate\Database\Eloquent\Builder $query * @param mixed $type * @return \Illuminate\Database\Eloquent\Builder */ public function scopeOfType($query, $type) &#123; return $query-&gt;where('type', $type); &#125;&#125; 这样就可以在调用作用域时传递参数了：1$users = App\User::ofType('admin')-&gt;get(); 本地作用域是由魔术方法__call实现的：12345678910111213141516public function __call($method, $parameters)&#123; ... if (method_exists($this-&gt;model, $scope = 'scope'.ucfirst($method))) &#123; return $this-&gt;callScope([$this-&gt;model, $scope], $parameters); &#125; if (in_array($method, $this-&gt;passthru)) &#123; return $this-&gt;toBase()-&gt;&#123;$method&#125;(...$parameters); &#125; $this-&gt;query-&gt;&#123;$method&#125;(...$parameters); return $this;&#125; 批量调用本地作用域 Laravel还提供一个方法可以一次性调用多个本地作用域：1234567$scopes = [ 'published', 'category' =&gt; 'Laravel', 'framework' =&gt; ['Laravel', '5.3'],];(new EloquentModelStub)-&gt;scopes($scopes); 上面的写法会调用三个本地作用域，它们的参数是$scopes的值。1234567891011121314151617181920212223242526272829303132333435363738394041public function scopes(array $scopes)&#123; $builder = $this; foreach ($scopes as $scope =&gt; $parameters) &#123; if (is_int($scope)) &#123; list($scope, $parameters) = [$parameters, []]; &#125; $builder = $builder-&gt;callScope( [$this-&gt;model, 'scope'.ucfirst($scope)], (array) $parameters ); &#125; return $builder;&#125;``` fill批量赋值Eloquent Model默认只能一个一个的设置数据库对象的属性，这是为了保护数据库。但是有的时候，字段过多会造成代码很繁琐。因此，Laravel提供属性批量赋值的功能，fill函数，相关的官方文档：批量赋值fill函数```phppublic function fill(array $attributes)&#123; $totallyGuarded = $this-&gt;totallyGuarded(); foreach ($this-&gt;fillableFromArray($attributes) as $key =&gt; $value) &#123; $key = $this-&gt;removeTableFromKey($key); if ($this-&gt;isFillable($key)) &#123; $this-&gt;setAttribute($key, $value); &#125; elseif ($totallyGuarded) &#123; throw new MassAssignmentException($key); &#125; &#125; return $this;&#125; fill函数会从参数attributes中选取可以批量赋值的属性。所谓的可以批量赋值的属性，是指被fillable或guarded成员变量设置的参数。被放入fillable的属性允许批量赋值的属性，被放入guarded的属性禁止批量赋值。 获取可批量赋值的属性：12345678910111213protected function fillableFromArray(array $attributes)&#123; if (count($this-&gt;getFillable()) &gt; 0 &amp;&amp; ! static::$unguarded) &#123; return array_intersect_key($attributes, array_flip($this-&gt;getFillable())); &#125; return $attributes;&#125;public function getFillable()&#123; return $this-&gt;fillable;&#125; 可以看到，若想要实现批量赋值，需要将属性设置在fillable成员数组中。 在Laravel中，有一种数据库对象关系是morph，也就是多态关系，这种关系也会调用fill函数，这个时候传入的参数attributes会带有数据库前缀。接下来，就要调用removeTableFromKey函数来去除数据库前缀：1234protected function removeTableFromKey($key)&#123; return Str::contains($key, '.') ? last(explode('.', $key)) : $key;&#125; 下一步，还要进一步验证属性的fillable：1234567891011121314151617public function isFillable($key)&#123; if (static::$unguarded) &#123; return true; &#125; if (in_array($key, $this-&gt;getFillable())) &#123; return true; &#125; if ($this-&gt;isGuarded($key)) &#123; return false; &#125; return empty($this-&gt;getFillable()) &amp;&amp; ! Str::startsWith($key, '_');&#125; 如果当前unguarded开启，也就是不会保护任何属性，那么直接返回true。如果当前属性在fillable中，也会返回true。如果当前属性在guarded中，返回false。最后，如果fillable是空数组，也会返回true。 forceFill如果不想受fillable或者guarded等的影响，还可以使用forceFill强制来批量赋值。123456789101112131415161718192021public function forceFill(array $attributes)&#123; return static::unguarded(function () use ($attributes) &#123; return $this-&gt;fill($attributes); &#125;);&#125;public static function unguarded(callable $callback)&#123; if (static::$unguarded) &#123; return $callback(); &#125; static::unguard(); try &#123; return $callback(); &#125; finally &#123; static::reguard(); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第11章 接下来如何做]]></title>
    <url>%2F2020%2F06%2F03%2F%E7%AC%AC11%E7%AB%A0-%E6%8E%A5%E4%B8%8B%E6%9D%A5%E5%A6%82%E4%BD%95%E5%81%9A%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 概述本书未介绍的10种算法以及它们很有用的原因。 如何根据兴趣选择接下来要阅读的内容。 树在前面的二分查找示例中，每当用户登录Facebook时，Facebook都必须在一个庞大的数组中查找，核实其中是否包含指定的用户名。前面说过，在这种数组中查找时，最快的方式是二分查找，但问题是每当有新用户注册时，都必须将其用户名插入该数组并重新排序，因为二分查找仅在数组有序时才管用。如果能将用户名插入到数组的正确位置就好了，这样就无需在插入后再排序。为此，有人设计了一种名为二叉查找树（binary search tree）的数据结构。 二叉查找树类似于下面这样。 对于其中的每个节点，左子节点的值都比它小，而右子节点的值都比它大。 假设你要查找Maggie。为此，你首先检查根节点。 Maggie排在David的后面，因此你往右边找。 Maggie排在Manning前面，因此你往左边找。 终于找到了Maggie！这几乎与二分查找一样！在二叉查找树中查找节点时，平均运行时间为O(log n)，但在最糟的情况下所需时间为O(n)；而在有序数组中查找时，即便是在最糟情况下所需的时间也只有O(log n)，因此你可能认为有序数组比二叉查找树更佳。然而，二叉查找树的插入和删除操作的速度要快得多。 二叉查找树也存在一些缺点，例如，不能随机访问，就像不能这么说：“给我第五个元素。”在二叉查找树处于平衡状态时，平均访问时间也为O(log n)。假设二叉查找树像下面这样处于不平衡状态。 注意，这棵树是向右倾斜的，因此性能不佳。也有一些处于平衡状态的特殊二叉查找树，如红黑树。 那在什么情况下使用二叉查找树呢？B树是一种特殊的二叉树，数据库常用它来存储数据。 如果你对数据库或高级数据结构感兴趣，请研究如下数据结构：B树，红黑树，堆，伸展树。 反向索引这里非常简单地说说搜索引擎的工作原理。假设你有三个网页，内容如下。 我们根据这些内容创建一个散列表。 这个散列表的键为单词，值为包含指定单词的页面。现在假设有用户搜索hi，在这种情况下，搜索引擎需要检查哪些页面包含hi。 搜索引擎发现页面A和B包含hi，因此将这些页面作为搜索结果呈现给用户。现在假设用户搜索there。你知道，页面A和C包含它。非常简单，不是吗？这是一种很有用的数据结构：一个散列表，将单词映射到包含它的页面。这种数据结构被称为反向索引（inverted index），常用于创建搜索引擎。如果你对搜索感兴趣，从反向索引着手研究是不错的选择。 傅里叶变换绝妙、优雅且应用广泛的算法少之又少，傅里叶变换算是一个。Better Explained是一个杰出的网站，致力于以通俗易懂的语言阐释数学，它就傅里叶变换做了一个绝佳的比喻：给它一杯冰沙，它能告诉你其中包含哪些成分。换言之，给定一首歌曲，傅里叶变换能够将其中的各种频率分离出来。 这种理念虽然简单，应用却极其广泛。例如，如果能够将歌曲分解为不同的频率，就可强化你关心的部分，如强化低音并隐藏高音。傅里叶变换非常适合用于处理信号，可使用它来压缩音乐。为此，首先需要将音频文件分解为音符。傅里叶变换能够准确地指出各个音符对整个歌曲的贡献，让你能够将不重要的音符删除。这就是MP3格式的工作原理！ 数字信号并非只有音乐一种类型。JPG也是一种压缩格式，也采用了刚才说的工作原理。傅里叶变换还被用来地震预测和DNA分析。 使用傅里叶变换可创建类似于Shazam这样的音乐识别软件。傅里叶变换的用途极其广泛，你遇到它的可能性极高！ 并行算法接下来的三个主题都与可扩展性和海量数据处理相关。我们身处一个处理器速度越来越快的时代，如果你要提高算法的速度，可等上几个月，届时计算机本身的速度就会更快。但这个时代已接近尾声，因此笔记本电脑和台式机转而采用多核处理器。为提高算法的速度，你需要让它们能够在多个内核中并行地执行！ 来看一个简单的例子。在最佳情况下，排序算法的速度大致为O(n log n)。众所周知，对数组进行排序时，除非使用并行算法，否则运行时间不可能为O(n)！对数组进行排序时，快速排序的并行版本所需的时间为O(n)。 并行算法设计起来很难，要确保它们能够正确地工作并实现期望的速度提升也很难。有一点是确定的，那就是速度的提升并非线性的，因此即便你的笔记本电脑装备了两个而不是一个内核，算法的速度也不可能提高一倍，其中的原因有两个。 并行性管理开销。假设你要对一个包含1000个元素的数组进行排序，如何在两个内核之间分配这项任务呢？如果让每个内核对其中500个元素进行排序，再将两个排好序的数组合并成一个有序数组，那么合并也是需要时间的。 负载均衡。假设你需要完成10个任务，因此你给每个内核都分配5个任务。但分配给内核A的任务都很容易，10秒钟就完成了，而分配给内核B的任务都很难，1分钟才完成。这意味着有那么50秒，内核B在忙死忙活，而内核A却闲得很！你如何均匀地分配工作，让两个内核都一样忙呢？ 要改善性能和可扩展性，并行算法可能是不错的选择！ MapReduce有一种特殊的并行算法正越来越流行，它就是分布式算法。在并行算法只需两到四个内核时，完全可以在笔记本电脑上运行它，但如果需要数百个内核呢？在这种情况下，可让算法在多台计算机上运行。MapReduce是一种流行的分布式算法，你可通过流行的开源工具Apache Hadoop来使用它。 分布式算法为何很有用假设你有一个数据库表，包含数十亿乃至数万亿行，需要对其执行复杂的SQL查询。在这种情况下，你不能使用MySQL，因为数据表的行数超过数十亿后，它处理起来将很吃力。相反，你需要通过Hadoop来使用MapReduce！ 又假设你需要处理一个很长的清单，其中包含100万个职位，而每个职位处理起来需要10秒。 如果使用一台计算机来处理，将耗时数月！如果使用100台计算机来处理，可能几天就能完工。 分布式算法非常适合用于在短时间内完成海量工作，其中的MapReduce基于两个简单的理念：映射（map）函数和归并（reduce）函数。 映射函数映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理。例如，下面的映射函数将数组的每个元素翻倍。 123&gt;&gt;&gt; arr1 = [1, 2, 3, 4, 5]&gt;&gt;&gt; arr2 = map(lambda x: 2 * x, arr1)[2, 4, 6, 8, 10] arr2包含[2, 4, 6, 8, 10]：将数组arr1的每个元素都翻倍！将元素翻倍的速度非常快，但如果要执行的操作需要更长的时间呢？请看下面的伪代码。 12&gt;&gt;&gt; arr1 = # A list of URLs&gt;&gt;&gt; arr2 = map(download_page, arr1) 在这个示例中，你有一个URL清单，需要下载每个URL指向的页面并将这些内容存储在数组arr2中。对于每个URL，处理起来都可能需要几秒钟。如果总共有1000个URL，可能耗时几小时！ 如果有100台计算机，而 map 能够自动将工作分配给这些计算机去完成就好了。这样就可同时下载100个页面，下载速度将快得多！这就是MapReduce中“映射”部分基于的理念。 归并函数归并函数可能令人迷惑，其理念是将很多项归并为一项。映射是将一个数组转换为另一个数组。 而归并是将一个数组转换为一个元素。 下面是一个示例。123&gt;&gt;&gt; arr1 = [1, 2, 3, 4, 5]&gt;&gt;&gt; reduce(lambda x,y: x+y, arr1)15 在这个示例中，你将数组中的所有元素相加：1 + 2 + 3 + 4 + 5 = 15！这里不深入介绍归并，网上有很多这方面的教程。 MapReduce使用这两个简单概念在多台计算机上执行数据查询。数据集很大，包含数十亿行时，使用MapReduce只需几分钟就可获得查询结果，而传统数据库可能要耗费数小时。 布隆过滤器和HyperLogLog假设你管理着网站Reddit。每当有人发布链接时，你都要检查它以前是否发布过，因为之前未发布过的故事更有价值。 又假设你在Google负责搜集网页，但只想搜集新出现的网页，因此需要判断网页是否搜集过。 在假设你管理着提供网址缩短服务的bit.ly，要避免将用户重定向到恶意网站。你有一个清单，其中记录了恶意网站的URL。你需要确定要将用户重定向到的URL是否在这个清单中。 这些都是同一种类型的问题，涉及庞大的集合。 给定一个元素，你需要判断它是否包含在这个集合中。为快速做出这种判断，可使用散列表。例如，Google可能有一个庞大的散列表，其中的键是已搜集的网页。 要判断是否已搜集adit.io，可在这个散列表中查找它。 adit.io是这个散列表中的一个键，这说明已搜集它。散列表的平均查找时间为O(1)，即查找时间是固定的，非常好！ 只是Google需要建立数万亿个网页的索引，因此这个散列表非常大，需要占用大量的存储空间。Reddit和bit.ly也面临着这样的问题。面临海量数据，你需要创造性的解决方案！ 布隆过滤器布隆过滤器提供了解决之道。布隆过滤器是一种概率型数据结构，它提供的答案有可能不对，但很可能是正确的。为判断网页以前是否已搜集，可不使用散列表，而使用布隆过滤器。使用散列表时，答案绝对可靠，而使用布隆过滤器时，答案却是很可能是正确的。 可能出现错报的情况，即Google可能指出“这个网站已搜集”，但实际上并没有搜集。 不可能出现漏报的情况，即如果布隆过滤器说“这个网站未搜集”，就肯定未搜集。 布隆过滤器的优点在于占用的存储空间很少。使用散列表时，必须存储Google搜集过的所有URL，但使用布隆过滤器时不用这样做。布隆过滤器非常适合用于不要求答案绝对准确的情况，前面所有的示例都是这样的。对bit.ly而言，这样说完全可行：“我们认为这个网站可能是恶意的，请倍加小心。” HyperLogLogHyperLogLog是一种类似于布隆过滤器的算法。如果Google要计算用户执行的不同搜索的数量，或者Amazon要计算当天用户浏览的不同商品的数量，要回答这些问题，需要耗用大量的空间！对Google来说，必须有一个日志，其中包含用户执行的不同搜索。有用户执行搜索时，Google必须判断该搜索是否包含在日志中：如果答案是否定的，就必须将其加入到日志中。即便只记录一天的搜索，这种日志也大得不得了！ HyperLogLog近似地计算集合中不同的元素数，与布隆过滤器一样，它不能给出准确的答案，但也八九不离十，而占用的内存空间却少得多。 面临海量数据且只要求答案八九不离十时，可考虑使用概率型算法！ SHA算法还记得第5章介绍的散列算法吗？我们回顾一下，假设你有一个键，需要将其相关联的值放到数组中。 你使用散列函数来确定应将这个值放在数组的什么地方。 你将值放在这个地方。 这样查找时间是固定的。当你想要知道指定键对应的值时，可再次执行散列函数，它将告诉你这个值存储在什么地方，需要的时间为O(1)。 在这个示例中，你希望散列函数的结果是均匀分布的。散列函数接受一个字符串，并返回一个索引号。 比较文件另一种散列函数是安全散列算法（secure hash algorithm，SHA）函数。给定一个字符串，SHA返回其散列值。 这里的术语有点令人迷惑。SHA是一个散列函数，它生成一个散列值——一个较短的字符串。用于创建散列表的散列函数根据字符串生成数组索引，而SHA根据字符串生成另一个字符串。 对于每个不同的字符串，SHA生成的散列值都不同。 说 明SHA生成的散列值很长，这里截短了。 你可使用SHA来判断两个文件是否相同，这在比较超大型文件时很有用。假设你有一个4GB的文件，并要检查朋友是否也有这个大型文件。为此，你不用通过电子邮件将这个大型文件发送给朋友，而可计算它们的SHA散列值，再对结果进行比较。 检查密码SHA还让你能在不知道原始字符串的情况下对其进行比较。例如，假设Gmail遭到攻击，攻击者窃取了所有的密码！你的密码暴露了吗？没有，因为Google存储的并非密码，而是密码的SHA散列值！你输入密码时，Google计算其散列值，并将结果同其数据库中的散列值进行比较。 Google只是比较散列值，因此不必存储你的密码！SHA被广泛用于计算密码的散列值。这种散列算法是单向的。你可根据字符串计算出散列值。 但你无法根据散列值推断出原始字符串。 这意味着计算攻击者窃取了Gmail的SHA散列值，也无法据此推断出原始密码！你可将密码转换为散列值，但反过来不行。 SHA实际上是一系列算法：SHA-0、SHA-1、SHA-2和SHA-3。本书编写期间，SHA-0和SHA-1已被发现存在一些缺陷。如果你要使用SHA算法来计算密码的散列值，请使用SHA-2或SHA-3。 当前，最安全的密码散列函数是bcrypt，但没有任何东西是万无一失的。 局部敏感的散列算法SHA还有一个重要特征，那就是局部不敏感的。假设你有一个字符串，并计算了其散列值。 如果你修改其中的一个字符，再计算其散列值，结果将截然不同！ 这很好，让攻击者无法通过比较散列值是否类似来破解密码。 有时候，你希望结果相反，即希望散列函数是局部敏感的。在这种情况下，可使用Simhash。如果你对字符串做细微的修改，Simhash生成的散列值也只存在细微的差别。这让你能够通过比较散列值来判断两个字符串的相似程度，这很有用！ Google使用Simhash来判断网页是否已搜集。 老师可以使用Simhash来判断学生的论文是否是从网上抄的。 Scribd允许用户上传文档或图书，以便与人分享，但不希望用户上传有版权的内容！这个网站可使用Simhash来检查上传的内容是否与小说《哈利·波特》类似，如果类似，就自动拒绝。 需要检查两项内容的相似程度时，Simhash很有用。 Diffie-Hellman密钥交换这里有必要提一提Diffie-Hellman算法，它以优雅的方式解决了一个古老的问题：如何对消息进行加密，以便只有收件人才能看懂呢？ 最简单的方式是设计一种加密算法，如将a转换为1，b转换为2，以此类推。这样，如果我给你发送消息“4,15,7”，你就可将其转换为“d,o,g”。但我们必须就加密算法达成一致，这种方式才可行。我们不能通过电子邮件来协商，因为可能有人拦截电子邮件，获悉加密算法，进而破译消息。即便通过会面来协商，这种加密算法也可能被猜出来——它并不复杂。因此，我们每天都得修改加密算法，但这样我们每天都得会面！ 即便我们能够每天修改，像这样简单的加密算法也很容易使用蛮力攻击破解。假设我看到消息“9,6,13,13,16 24,16,19,13,5”，如果使用加密算法a = 1、b = 2等，转换结果将如下。 结果是一堆乱码。我们来尝试加密算法a = 2、b = 3等。 结果对了！像这样的简单加密算法很容易破解。在二战期间，德国人使用的加密算法比这复杂得多，但还是被破解了。Diffie-Hellman算法解决了如下两个问题。 双方无需知道加密算法。他们不必会面协商要使用的加密算法。 要破解加密的消息比登天还难。 Diffie-Hellman使用两个密钥：公钥和私钥。顾名思义，公钥就是公开的，可将其发布到网站上，通过电子邮件发送给朋友，或使用其他任何方式来发布。你不必将它藏着掖着。有人要向你发送消息时，他使用公钥对其进行加密。加密后的消息只有使用私钥才能解密。只要只有你知道私钥，就只有你才能解密消息！ Diffie-Hellman算法及其替代者RSA依然被广泛使用。如果你对加密感兴趣，先着手研究Diffie-Hellman算法是不错的选择：它既优雅又不难理解。 线性规划最好的东西留到最后介绍。线性规划是我知道的最酷的算法之一。 线性规划用于在给定约束条件下最大限度地改善指定的指标。例如，假设你所在的公司生产两种产品：衬衫和手提袋。衬衫每件利润2美元，需要消耗1米布料和5粒扣子；手提袋每个利润3美元，需要消耗2米布料和2粒扣子。你有11米布料和20粒扣子，为最大限度地提高利润，该生产多少件衬衫、多少个手提袋呢？ 在这个例子中，目标是利润最大化，而约束条件是拥有的原材料数量。 再举一个例子。你是个政客，要尽可能多地获得支持票。你经过研究发现，平均而言，对于每张支持票，在旧金山需要付出1小时的劳动（宣传、研究等）和2美元的开销，而在芝加哥需要付出1.5小时的劳动和1美元的开销。在旧金山和芝加哥，你至少需要分别获得500和300张支持票。你有50天的时间，总预算为1500美元。请问你最多可从这两个地方获得多少支持票？ 这里的目标是支持票数最大化，而约束条件是时间和预算。 你可能在想，本书花了很大的篇幅讨论最优化，这与线性规划有何关系？所有的图算法都可使用线性规划来实现。线性规划是一个宽泛得多的框架，图问题只是其中的一个子集。但愿你听到这一点后心潮澎湃！ 线性规划使用Simplex算法，这个算法很复杂，因此本书没有介绍。如果你对最优化感兴趣，就研究研究线性规划吧！ 结语本章简要地介绍了10个算法，唯愿这让你知道还有很多地方等待你去探索。在我看来，最佳的学习方式是找到感兴趣的主题，然后一头扎进去，而本书便为你这样做打下了坚实的基础。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10章 K最近邻算法]]></title>
    <url>%2F2020%2F06%2F02%2F%E7%AC%AC10%E7%AB%A0-K%E6%9C%80%E8%BF%91%E9%82%BB%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 学习使用K最近邻算法创建分类系统。 学习特征抽取。 学习回归，即预测数值，如明天的股价或用户对某部电影的喜欢程度。 学习K最近邻算法的应用案例和局限性。 橙子还是柚子请看下面的水果，是橙子还是柚子呢？我知道，柚子通常比橙子更大、更红。 我的思维过程类似于这样：我脑子里有个图表。 一般而言，柚子更大、更红。这个水果又大又红，因此很可能是柚子。但下面这样的水果呢？ 如果判断这个水果是橙子还是柚子呢？一种办法是看它的邻居。来看看离它最近的三个邻居。 在这三个邻居中，橙子比柚子多，因此这个水果很可能是橙子。祝贺你，你刚才就是使用K最近邻（k-nearest neighbours，KNN）算法进行了分类！这个算法非常简单。 KNN算法虽然简单却很有用！要对东西进行分类时，可首先尝试这种算法。下面来看一个更真实的例子。 创建推荐系统假设你是Netflix，要为用户创建一个电影推荐系统。从本质上说，这类似于前面的水果问题！ 你可以将所有用户都放入一个图表中。 这些用户在图表中的位置取决于其喜好，因此喜好相似的用户距离较近。假设你要向Priyanka推荐电影，可以找出五位与他最接近的用户。 假设在对电影的喜好方面，Justin、JC、Joey、Lance和Chris都与Priyanka差不多，因此他们喜欢的电影很可能Priyanka也喜欢！ 有了这样的图表以后，创建推荐系统就将易如反掌：只要是Justin喜欢的电影，就将其推荐给Priyanka。 但还有一个重要的问题没有解决。在前面的图表中，相似的用户相距较近，但如何确定两位用户的相似程度呢？ 特征抽取在前面的水果示例中，你根据个头和颜色来比较水果，换言之，你比较的特征是个头和颜色。现在假设有三个水果，你可抽取它们的特征。 再根据这些特征绘图。 从上图可知，水果A和B比较像。下面来度量它们有多像。要计算两点的距离，可使用毕达哥拉斯公式。 例如，A和B的距离如下。 A和B的距离为1。你还可计算其他水果之间的距离。 这个距离公式印证了你的直觉：A和B很像。 假设你要比较的是Netflix用户，就需要以某种方式将他们放到图表中。因此，你需要将每位用户都转换为一组坐标，就像前面对水果所做的那样。 在能够将用户放入图表后，你就可以计算他们之间的距离了。 下面是一种将用户转换为一组数字的方式。用户注册时，要求他们指出对各种电影的喜欢程度。这样，对于每位用户，都将获得一组数字！ Priyanka和Justin都喜欢爱情片且都讨厌恐怖片。Morpheus喜欢动作片，但讨厌爱情片（他讨厌好好的动作电影毁于浪漫的桥段）。前面判断水果是橙子还是柚子时，每种水果都用2个数字表示，你还记得吗？在这里，每位用户都用5个数字表示。 在数学家看来，这里计算的是五维（而不是二维）空间中的距离，但计算公式不变。 这个公式包含5个而不是2个数字。 这个距离公式很灵活，即便涉及很多个数字，依然可以使用它来计算距离。你可能会问，涉及5个数字时，距离意味着什么呢？这种距离指出了两组数字之间的相似程度。 这是Priyanka和Justin的距离。 Priyanka和Justin很像。Priyanka和Morpheus的差别有多大呢？请计算他们之间的距离，再接着往下读。 Priyanka和Morpheus的距离为24，你算对了吗？上述距离表明，Priyanka的喜好更接近于Justin而不是Morpheus。 太好了！现在要向Priyanka推荐电影将易如反掌：只要是Justin喜欢的电影，就将其推荐给Priyanka，反之亦然。你这就创建了一个电影推荐系统！ 如果你是Netflix用户，Netflix将不断提醒你：多给电影评分吧，你评论的电影越多，给你的推荐就越准确。现在你明白了其中的原因：你评论的电影越多，Netflix就越能准确地判断出你与哪些用户类似。 练习 1、在Netflix示例中，你使用距离公式计算两位用户的距离，但给电影打分时，每位用户的标准并不都相同。假设你有两位用户——Yogi和Pinky，他们欣赏电影的品味相同，但Yogi给喜欢的电影都打5分，而Pinky更挑剔，只给特别好的电影打5分。他们的品味一致，但根据距离算法，他们并非邻居。如何将这种评分方式的差异考虑进来呢？ 2、假设Netflix指定了一组意见领袖。例如，Quentin Tarantino和Wes Anderson就是Netflix的意见领袖，因此他们的评分比普通用户更重要。请问你该如何修改推荐系统，使其偏重于意见领袖的评分呢？ 回归假设你不仅要向Priyanka推荐电影，还要预测她将给这部电影打多少分。为此，先找出与她最近的5个人。 顺便说一句，我老说最近的5个人，其实并非一定要选择5个最近的邻居，也可选择2个、10个或10 000个。这就是这种算法名为K最近邻而不是5最近邻的原因！ 假设你要预测Priyanka会给电影Pitch Perfect打多少分。Justin、JC、Joey、Lance和Chris都给它打了多少分呢？ 你求这些人打的分的平均值，结果为4.2。这就是回归（regression）。你将使用KNN来做两项基本工作——分类和回归： 分类就是编组； 回归就是预测结果（如一个数字）。 回归很有用。假设你在伯克利开个小小的面包店，每天都做新鲜面包，需要根据如下一组特征预测当天该烤多少条面包： 天气指数1～5（1表示天气很糟，5表示天气非常好）； 是不是周末或节假日（周末或节假日为1，否则为0）； 有没有活动（1表示有，0表示没有）。 你还有一些历史数据，记录了在各种不同的日子里售出的面包数量。 今天是周末，天气不错。根据这些数据，预测你今天能售出多少条面包呢？我们来使用KNN算法，其中的K为4。首先，找出与今天最接近的4个邻居。 距离如下，因此最近的邻居为A、B、D和E。 将这些天售出的面包数平均，结果为218.75。这就是你今天要烤的面包数！ 余弦相似度前面计算两位用户的距离时，使用的都是距离公式。还有更合适的公式吗？在实际工作中，经常使用余弦相似度（cosine similarity）。假设有两位品味类似的用户，但其中一位打分时更保守。他们都很喜欢Manmohan Desai的电影Amar Akbar Anthony，但Paul给了5星，而Rowan只给4星。如果你使用距离公式，这两位用户可能不是邻居，虽然他们的品味非常接近。余弦相似度不计算两个矢量的距离，而比较它们的角度，因此更适合处理前面所说的情况。本书不讨论余弦相似度，但如果你要使用KNN，就一定要研究研究它！ 挑选合适的特征为推荐电影，你让用户指出他对各类电影的喜好程度。如果你是让用户给一系列小猫图片打分呢？在这种情况下，你找出的是对小猫图片的欣赏品味类似的用户。对电影推荐系统来说，这很可能是一个糟糕的推荐引擎，因为你选择的特征与电影欣赏品味没多大关系。 又假设你只让用户给《玩具总动员》《玩具总动员2》和《玩具总动员3》打分。这将难以让用户的电影欣赏品味显现出来！使用KNN时，挑选合适的特征进行比较至关重要。所谓合适的特征，就是： 与要推荐的电影紧密相关的特征； 不偏不倚的特征（例如，如果只让用户给喜剧片打分，就无法判断他们是否喜欢动作片）。 你认为评分是不错的电影推荐指标吗？我给The Wire的评分可能比House Hunters高，但实际上我观看House Hunters的时间更长。该如何改进Netflix的推荐系统呢？ 回到面包店的例子：对于面包店，你能找出两个不错和糟糕的特征吗？在报纸上打广告后，你可能需要烤制更多的面包；或者每周一你都需要烤制更多的面包。 在挑选合适的特征方面，没有放之四海皆准的法则，你必须考虑到各种需要考虑的因素。 练习 3、Netflix的用户数以百万计，前面创建推荐系统时只考虑了5个最近的邻居，这是太多还是太少了呢？ 机器学习简介KNN算法真的是很有用，堪称你进入神奇的机器学习领域的领路人！机器学习旨在让计算机更聪明。你见过一个机器学习的例子：创建推荐系统。下面再来看看其他一些例子。 OCROCR指的是光学字符识别（optical character recognition），这意味着你可拍摄印刷页面的照片，计算机将自动识别出其中的文字。Google使用OCR来实现图书数字化。OCR是如何工作的呢？我们来看一个例子。请看下面的数字。 如何自动识别出这个数字是什么呢？可使用KNN。 (1) 浏览大量的数字图像，将这些数字的特征提取出来。 (2) 遇到新图像时，你提取该图像的特征，再找出它最近的邻居都是谁！ 这与前面判断水果是橙子还是柚子时一样。一般而言，OCR算法提取线段、点和曲线等特征。 遇到新字符时，可从中提取同样的特征。 与前面的水果示例相比，OCR中的特征提取要复杂得多，但再复杂的技术也是基于KNN等简单理念的。这些理念也可用于语音识别和人脸识别。你将照片上传到Facebook时，它有时候能够自动标出照片中的人物，这是机器学习在发挥作用！ OCR的第一步是查看大量的数字图像并提取特征，这被称为训练（training）。大多数机器学习算法都包含训练的步骤：要让计算机完成任务，必须先训练它。下一个示例是垃圾邮件过滤器，其中也包含训练的步骤。 创建垃圾邮件过滤器垃圾邮件过滤器使用一种简单算法——朴素贝叶斯分类器（Naive Bayes classifier），你首先需要使用一些数据对这个分类器进行训练。 假设你收到一封主题为“collect your million dollars now!”的邮件，这是垃圾邮件吗？你可研究这个句子中的每个单词，看看它在垃圾邮件中出现的概率是多少。例如，使用这个非常简单的模型时，发现只有单词million在垃圾邮件中出现过。朴素贝叶斯分类器能计算出邮件为垃圾邮件的概率，其应用领域与KNN相似。 例如，你可使用朴素贝叶斯分类器来对水果进行分类：假设有一个又大又红的水果，它是柚子的概率是多少呢？朴素贝叶斯分类器也是一种简单而极其有效的算法。我们钟爱这样的算法！ 预测股票市场使用机器学习来预测股票市场的涨跌真的很难。对于股票市场，如何挑选合适的特征呢？股票昨天涨了，今天也会涨，这样的特征合适吗？又或者每年五月份股票市场都以绿盘报收，这样的预测可行吗？在根据以往的数据来预测未来方面，没有万无一失的方法。未来很难预测，由于涉及的变数太多，这几乎是不可能完成的任务。 小结但愿通过阅读本章，你对KNN和机器学习的各种用途能有大致的认识！机器学习是个很有趣的领域，只要下定决心，你就能很深入地了解它。 KNN用于分类和回归，需要考虑最近的邻居。 分类就是编组。 回归就是预测结果（如数字）。 特征抽取意味着将物品（如水果或用户）转换为一系列可比较的数字。 能否挑选合适的特征事关KNN算法的成败。 答案10.1 可使用归一化（normalization）。你可计算每位用户的平均评分，并据此来调整用户的评分。例如，你可能发现Pinky的平均评分为星3，而Yogi的平均评分为3.5星。因此，你稍微调高Pinky的评分，使其平均评分也为3.5星。这样就能基于同样的标准比较他们的评分了。 10.2 可在使用KNN时给意见领袖的评分更大权重。假设有3个邻居——Joe、Dave和意见领袖Wes Anderson，他们给Caddyshack的评分分别为3星、4星和5星。可不计算这些评分的平均值 (3 + 4 + 5) / 3 = 4星，而给Wes Anderson的评分更大权重：(3 + 4 + 5 + 5 + 5) / 5 = 4.4星。 10.3 太少了。如果考虑的邻居太少，结果很可能存在偏差。一个不错的经验规则是：如果有N位用户，应考虑sqrt(N)个邻居。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9章 动态规划]]></title>
    <url>%2F2020%2F06%2F02%2F%E7%AC%AC9%E7%AB%A0-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 学习动态规划，这是一种解决棘手问题的方法，它将问题分成小问题，并先着手解决这些小问题。 学习如何设计问题的动态规划解决方案。 背包问题我们再来看看第8章的背包问题。假设你是个小偷，背着一个可装4磅东西的背包。 你可盗窃的商品有如下3件。 物品 价格 重量 音响 3000美元 4磅 笔记本电脑 2000美元 3磅 吉他 1500美元 1磅 为了让盗窃的商品价值最高，你该选择哪些商品？ 简单算法最简单的算法如下：尝试各种可能的商品组合，并找出价值最高的组合。 这样可行，但速度非常慢。在有3件商品的情况下，你需要计算8个不同的集合；有4件商品时，你需要计算16个集合。每增加一件商品，需要计算的集合数都将翻倍！这种算法的运行时间为O(2n)，真的是慢如蜗牛。 只要商品数量多到一定程度，这种算法就行不通。在第8章，你学习了如何找到近似解，这接近最优解，但可能不是最优解。 那么如何找到最优解呢？ 动态规划答案是使用动态规划！下面来看看动态规划算法的工作原理。动态规划先解决子问题，再逐步解决大问题。 对于背包问题，你先解决小背包（子背包）问题，再逐步解决原来的问题。 动态规划是一个难以理解的概念，如果你没有立即搞懂，也不用担心，我们将研究很多示例。 先来演示这种算法的执行过程。看过执行过程后，你心里将有一大堆问题！我将竭尽所能解答这些问题。 每个动态规划算法都从一个网格开始，背包问题的网格如下。 网格的各行为商品，各列为不同容量（1～4磅）的背包。所有这些列你都需要，因为它们将帮助你计算子背包的价值。 网格最初是空的。你将填充其中的每个单元格，网格填满后，就找到了问题的答案！你一定要跟着做。请你创建网格，我们一起来填满它。 1.吉他行 后面将列出计算这个网格中单元格值的公式。我们先来一步一步做。首先来看第一行。 这是吉他行，意味着你将尝试将吉他装入背包。在每个单元格，都需要做一个简单的决定：偷不偷吉他？别忘了，你要找出一个价值最高的商品集合。 第一个单元格表示背包的容量为1磅。吉他的重量也是1磅，这意味着它能装入背包！因此这个单元格包含吉他，价值为1500美元。 下面来开始填充网格。 与这个单元格一样，每个单元格都将包含当前可装入背包的所有商品。 来看下一个单元格。这个单元格表示背包的容量为2磅，完全能够装下吉他！ 这行的其他单元格也一样。别忘了，这是第一行，只有吉他可供你选择。换言之，你假装现在还没法盗窃其他两件商品。 此时你很可能心存疑惑：原来的问题说的是4磅的背包，我们为何要考虑容量为1磅、2磅等的背包呢？前面说过，动态规划从小问题着手，逐步解决大问题。这里解决的子问题将帮助你解决大问题。请接着往下读，稍后你就会明白的。 此时网格应类似于下面这样。 别忘了，你要做的是让背包中商品的价值最大。这行表示的是当前的最大价值。它指出，如果你有一个容量4磅的背包，可在其中装入的商品的最大价值为1500美元。 你知道这不是最终的解。随着算法往下执行，你将逐步修改最大价值。 2.音响行 我们来填充下一行——音响行。你现在处于第二行，可偷的商品有吉他和音响。在每一行，可偷的商品都为当前行的商品以及之前各行的商品。因此，当前你还不能偷笔记本电脑，而只能偷音响和吉他。我们先来看第一个单元格，它表示容量为1磅的背包。在此之前，可装入1磅背包的商品的最大价值为1500美元。 该不该偷音响呢？ 背包的容量为1磅，能装下音响吗？音响太重了，装不下！由于容量1磅的背包装不下音响，因此最大价值依然是1500美元。 接下来的两个单元格的情况与此相同。在这些单元格中，背包的容量分别为2磅和3磅，而以前的最大价值为1500美元。 由于这些背包装不下音响，因此最大价值保持不变。 背包容量为4磅呢？终于能够装下音响了！原来的最大价值为1500美元，但如果在背包中装入音响而不是吉他，价值将为3000美元！因此还是偷音响吧。 你更新了最大价值！如果背包的容量为4磅，就能装入价值至少3000美元的商品。在这个网格中，你逐步地更新最大价值。 3.笔记本电脑行 下面以同样的方式处理笔记本电脑。笔记本电脑重3磅，没法将其装入容量为1磅或2磅的背包，因此前两个单元格的最大价值还是1500美元。 对于容量为3磅的背包，原来的最大价值为1500美元，但现在你可选择盗窃价值2000美元的笔记本电脑而不是吉他，这样新的最大价值将为2000美元！ 对于容量为4磅的背包，情况很有趣。这是非常重要的部分。当前的最大价值为3000美元，你可不偷音响，而偷笔记本电脑，但它只值2000美元。 价值没有原来高。但等一等，笔记本电脑的重量只有3磅，背包还有1磅的容量没用！ 在1磅的容量中，可装入的商品的最大价值是多少呢？你之前计算过。 根据之前计算的最大价值可知，在1磅的容量中可装入吉他，价值1500美元。因此，你需要做如下比较。 你可能始终心存疑惑：为何计算小背包可装入的商品的最大价值呢？但愿你现在明白了其中的原因！余下了空间时，你可根据这些子问题的答案来确定余下的空间可装入哪些商品。笔记本电脑和吉他的总价值为3500美元，因此偷它们是更好的选择。 最终的网格类似于下面这样。 答案如下：将吉他和笔记本电脑装入背包时价值最高，为3500美元。 你可能认为，计算最后一个单元格的价值时，我使用了不同的公式。那是因为填充之前的单元格时，我故意避开了一些复杂的因素。其实，计算每个单元格的价值时，使用的公式都相同。这个公式如下。 你可以使用这个公式来计算每个单元格的价值，最终的网格将与前一个网格相同。现在你明白了为何要求解子问题吧？你可以合并两个子问题的解来得到更大问题的解。 背包问题FAQ你可能还是觉得这像是变魔术。本节将回答一些常见的问题。 再增加一件商品将如何呢假设你发现还有第四件商品可偷——一个价值2000美元重量为1磅的iPhone！ 此时需要重新执行前面所做的计算吗？不需要。别忘了，动态规划逐步计算最大价值。到目前为止，计算出的最大价值如下。 这意味着背包容量为4磅时，你最多可偷价值3500美元的商品。但这是以前的情况，下面再添加表示iPhone的行。 最大价值可能发生变化！请尝试填充这个新增的行，再接着往下读。 我们从第一个单元格开始。iPhone可装入容量为1磅的背包。之前的最大价值为1500美元，但iPhone价值2000美元，因此该偷iPhone而不是吉他。 在下一个单元格中，你可装入iPhone和吉他。 对于第三个单元格，也没有比装入iPhone和吉他更好的选择了。 对于最后一个单元格，情况比较有趣。当前的最大价值为3500美元，但你可偷iPhone，这将余下3磅的容量。 3磅容量的最大价值为2000美元！再加上iPhone价值2000美元，总价值为4000美元。新的最大价值诞生了！ 最终的网格如下。 问题：沿着一列往下走时，最大价值有可能降低吗？ 请找出这个问题的答案，再接着往下读。 答案：不可能。每次迭代时，你都存储当前的最大价值。最大价值不可能比以前低！ 练习 1.假设你还可偷另外一件商品——MP3播放器，它重1磅，价值1000美元。你要偷吗？ 行的排列顺序发生变化时结果将如何答案会随之变化吗？假设你按如下顺序填充各行：音响、笔记本电脑、吉他。网格将会是什么样的？请自己动手填充这个网格，再接着往下读。 网格将类似于下面这样。 答案没有变化。也就是说，各行的排列顺序无关紧要。 可以逐列而不是逐行填充网格吗自己动手试试吧！就这个问题而言，这没有任何影响，但对于其他问题，可能有影响。 增加一件更小的商品将如何呢假设你还可以偷一条项链，它重0.5磅，价值1000美元。前面的网格都假设所有商品的重量为整数，但现在你决定把项链给偷了，因此余下的容量为3.5磅。在3.5磅的容量中，可装入的商品的最大价值是多少呢？不知道！因为你只计算了容量为1磅、2磅、3磅和4磅的背包可装下的商品的最大价值。现在，你需要知道容量为3.5磅的背包可装下的商品的最大价值。 由于项链的加入，你需要考虑的粒度更细，因此必须调整网格。 可以偷商品的一部分吗假设你在杂货店行窃，可偷成袋的扁豆和大米，但如果整袋装不下，可打开包装，再将背包倒满。在这种情况下，不再是要么偷要么不偷，而是可偷商品的一部分。如何使用动态规划来处理这种情形呢？ 答案是没法处理。使用动态规划时，要么考虑拿走整件商品，要么考虑不拿，而没法判断该不该拿走商品的一部分。 但使用贪婪算法可轻松地处理这种情况！首先，尽可能多地拿价值最高的商品；如果拿光了，再尽可能多地拿价值次高的商品，以此类推。 例如，假设有如下商品可供选择。 藜麦比其他商品都值钱，因此要尽量往背包中装藜麦！如果能够在背包中装满藜麦，结果就是最佳的。 如果藜麦装完后背包还没满，就接着装入下一种最值钱的商品，以此类推。 旅游行程最优化假设你要去伦敦度假，假期两天，但你想去游览的地方很多。你没法前往每个地方游览，因此你列个单子。 对于想去游览的每个名胜，都列出所需的时间以及你有多想去看看。根据这个清单，你能确定该去游览哪些名胜吗？ 这也是一个背包问题！但约束条件不是背包的容量，而是有限的时间；不是决定该装入哪些商品，而是决定该去游览哪些名胜。请根据这个清单绘制动态规划网格，再接着往下读。 网格类似于下面这样。 你画对了吗？请填充这个网格，决定该游览哪些名胜。答案如下。 处理相互依赖的情况假设你还想去巴黎，因此在前述清单中又添加了几项。 去这些地方游览需要很长时间，因为你先得从伦敦前往巴黎，这需要半天时间。如果这3个地方都去玩，是不是要4.5天呢？ 不是的，因为不是去每个地方都得先从伦敦到巴黎。到达巴黎后，每个地方都只需1天时间。因此玩这3个地方需要的总时间为3.5天（半天从伦敦到巴黎，每个地方1天），而不是4.5天。 将埃菲尔铁塔加入“背包”后，卢浮宫将更“便宜”：只要1天时间，而不是1.5天。如何使用动态规划对这种情况建模呢？ 没办法建模。动态规划功能强大，它能够解决子问题并使用这些答案来解决大问题。但仅当每个子问题都是离散的，即不依赖于其他子问题时，动态规划才管用。这意味着使用动态规划算法解决不了去巴黎玩的问题。 计算最终的解时会涉及两个以上的子背包吗为获得前述背包问题的最优解，可能需要偷两件以上的商品。但根据动态规划算法的设计，最多只需合并两个子背包，即根本不会涉及两个以上的子背包。不过这些子背包可能又包含子背包。 最优解可能导致背包没装满吗完全可能。假设你还可以偷一颗钻石。 这颗钻石非常大，重达3.5磅，价值100万美元，比其他商品都值钱得多。 你绝对应该把它给偷了！但当你这样做时，余下的容量只有0.5磅，别的什么都装不下。 练习 2.假设你要去野营。你有一个容量为6磅的背包，需要决定该携带下面的哪些东西。其中每样东西都有相应的价值，价值越大意味着越重要： 水（重3磅，价值10）； 书（重1磅，价值3） 食物（重2磅，价值9）； 夹克（重2磅，价值5）； 相机（重1磅，价值6）。 请问携带哪些东西时价值最高？ 最长公共子串通过前面的动态规划问题，你得到了哪些启示呢？ 动态规划可帮助你在给定约束条件下找到最优解。在背包问题中，你必须在背包容量给定的情况下，偷到价值最高的商品。 在问题可分解为彼此独立且离散的子问题时，就可使用动态规划来解决。 要设计出动态规划解决方案可能很难，这正是本节要介绍的。下面是一些通用的小贴士。 每种动态规划解决方案都涉及网格。 单元格中的值通常就是你要优化的值。在前面的背包问题中，单元格的值为商品的价值。 每个单元格都是一个子问题，因此你应考虑如何将问题分成子问题，这有助于你找出网格的坐标轴。 下面再来看一个例子。假设你管理着网站dictionary.com。用户在该网站输入单词时，你需要给出其定义。 但如果用户拼错了，你必须猜测他原本要输入的是什么单词。例如，Alex想查单词fish，但不小心输入了hish。在你的字典中，根本就没有这样的单词，但有几个类似的单词。 在这个例子中，只有两个类似的单词，真是太小儿科了。实际上，类似的单词很可能有数千个。 Alex输入了hish，那他原本要输入的是fish还是vista呢？ 绘制网格用于解决这个问题的网格是什么样的呢？要确定这一点，你得回答如下问题。 单元格中的值是什么？ 如何将这个问题划分为子问题？ 网格的坐标轴是什么？ 在动态规划中，你要将某个指标最大化。在这个例子中，你要找出两个单词的最长公共子串。hish和fish都包含的最长子串是什么呢？hish和vista呢？这就是你要计算的值。 别忘了，单元格中的值通常就是你要优化的值。在这个例子中，这很可能是一个数字：两个字符串都包含的最长子串的长度。 如何将这个问题划分为子问题呢？你可能需要比较子串：不是比较hish和fish，而是先比较his和fis。每个单元格都将包含这两个子串的最长公共子串的长度。这也给你提供了线索，让你觉得坐标轴很可能是这两个单词。因此，网格可能类似于下面这样。 如果这在你看来犹如巫术，也不用担心。这些内容很难懂，但这也正是我到现在才介绍它们的原因！本章后面有一个练习，到时你可以自己动手来进行动态规划。 填充网格现在，你很清楚网格应是什么样的。填充该网格的每个单元格时，该使用什么样的公式呢？由于你已经知道答案——hish和fish的最长公共子串为ish，因此可以作点弊。 即便如此，你还是不能确定该使用什么样的公式。计算机科学家有时会开玩笑说，那就使用费曼算法（Feynman algorithm）。这个算法是以著名物理学家理查德·费曼命名的，其步骤如下。 (1) 将问题写下来。(2) 好好思考。(3) 将答案写下来。 计算机科学家真是一群不按常理出牌的人啊！ 实际上，根本没有找出计算公式的简单办法，你必须通过尝试才能找出管用的公式。有些算法并非精确的解决步骤，而只是帮助你理清思路的框架。 请尝试为这个问题找到计算单元格值的公式。给你一点提示吧：下面是这个单元格的一部分。 其他单元格的值呢？别忘了，每个单元格都是一个子问题的值。为何单元格(3,3)的值为2呢？ 又为何单元格(3, 4)的值为0呢？ 请找出计算公式，再接着往下读。这样即便你没能找出正确的公式，后面的解释也将容易理解得多。 揭晓答案最终的网格如下。 我使用下面的公式来计算每个单元格的值。 实现这个公式的伪代码类似于下面这样。 1234if word_a[i] == word_b[j]: # 两个字母相同 cell[i][j] = cell[i-1][j-1] + 1else: # 两个字母不同 cell[i][j] = 0 查找单词hish和vista的最长公共子串时，网格如下。 需要注意的一点是，这个问题的最终答案并不在最后一个单元格中！对于前面的背包问题，最终答案总是在最后的单元格中。但对于最长公共子串问题，答案为网格中最大的数字——它可能并不位于最后的单元格中。 我们回到最初的问题：哪个单词与hish更像？hish和fish的最长公共子串包含三个字母，而hish和vista的最长公共子串包含两个字母。 因此Alex很可能原本要输入的是fish。 最长公共子序列假设Alex不小心输入了fosh，他原本想输入的是fish还是fort呢？ 我们使用最长公共子串公式来比较它们。 最长公共子串的长度相同，都包含两个字母！但fosh与fish更像。 这里比较的是最长公共子串，但其实应比较最长公共子序列：两个单词中都有的序列包含的字母数。如何计算最长公共子序列呢？ 下面是用于计算fish和fosh的最长公共子序列的网格的一部分。 你能找出填充这个网格时使用的公式吗？最长公共子序列与最长公共子串很像，计算公式也很像。请试着找出这个公式——答案稍后揭晓。 最长公共子序列之解决方案最终的网格如下。 下面是填写各个单元格时使用的公式。 伪代码如下。 1234if word_a[i] == word_b[j]: # 两个字母相同 cell[i][j] = cell[i-1][j-1] + 1else: # 两个字母不同 cell[i][j] = max(cell[i-1][j], cell[i][j-1]) 本章到这里就结束了！它绝对是本书最难理解的一章。动态规划都有哪些实际应用呢？ 生物学家根据最长公共序列来确定DNA链的相似性，进而判断度两种动物或疾病有多相似。最长公共序列还被用来寻找多发性硬化症治疗方案。 你使用过诸如git diff等命令吗？它们指出两个文件的差异，也是使用动态规划实现的。 前面讨论了字符串的相似程度。编辑距离（levenshtein distance）指出了两个字符串的相似程度，也是使用动态规划计算得到的。编辑距离算法的用途很多，从拼写检查到判断用户上传的资料是否是盗版，都在其中。 你使用过诸如Microsoft Word等具有断字功能的应用程序吗？它们如何确定在什么地方断字以确保行长一致呢？使用动态规划！ 练习 3.请绘制并填充用来计算blue和clues最长公共子串的网格。 小结 需要在给定约束条件下优化某种指标时，动态规划很有用。 问题可分解为离散子问题时，可使用动态规划来解决。 每种动态规划解决方案都涉及网格。 单元格中的值通常就是你要优化的值。 每个单元格都是一个子问题，因此你需要考虑如何将问题分解为子问题。 没有放之四海皆准的计算动态规划解决方案的公式。 答案9.1 要。在这种情况下，你可偷来MP3播放器和iPhone和吉他，总价值为4500美元。 9.2 你应携带水、食物和相机。 9.3]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8章 贪婪算法]]></title>
    <url>%2F2020%2F06%2F02%2F%E7%AC%AC8%E7%AB%A0-%E8%B4%AA%E5%A9%AA%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 贪婪算法很简单：每步都采取最优的做法。怎么理解？ 你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。 本章内容 学习如何处理不可能完成的任务：没有快速算法的问题（NP完全问题）。 学习识别NP完全问题，以免浪费时间去寻找解决它们的快速算法。 学习近似算法，使用它们可快速找到NP完全问题的近似解。 学习贪婪策略——一种非常简单的问题解决策略。 教室调度问题假设有如下课程表，你希望将尽可能多的课程安排在某间教室上。 你没法让这些课都在这间教室上，因为有些课的上课时间有冲突。 你希望在这间教室上尽可能多的课。如何选出尽可能多且时间不冲突的课程呢？ 这个问题好像很难，不是吗？实际上，算法可能简单得让你大吃一惊。具体做法如下。 (1) 选出结束最早的课，它就是要在这间教室上的第一堂课。 (2) 接下来，必须选择第一堂课结束后才开始的课。同样，你选择结束最早的课，这将是要在这间教室上的第二堂课。 重复这样做就能找出答案！下面来试一试。美术课的结束时间最早，为10:00 a.m.，因此它就是第一堂课。 接下来的课必须在10:00 a.m.后开始，且结束得最早。 英语课不行，因为它的时间与美术课冲突，但数学课满足条件。最后，计算机课与数学课的时间是冲突的，但音乐课可以。 因此将在这间教室上如下三堂课。 很多人都跟我说，这个算法太容易、太显而易见，肯定不对。但这正是贪婪算法的优点——简单易行！贪婪算法很简单：每步都采取最优的做法。在这个示例中，你每次都选择结束最早的课。用专业术语说，就是你每步都选择局部最优解，最终得到的就是全局最优解。信不信由你，对于这个调度问题，上述简单算法找到的就是最优解！ 显然，贪婪算法并非在任何情况下都行之有效，但它易于实现！下面再来看一个例子。 背包问题假设你是个贪婪的小偷，背着可装35磅（1磅≈0.45千克）重东西的背包，在商场伺机盗窃各种可装入背包的商品。 你力图往背包中装入价值最高的商品，你会使用哪种算法呢？ 同样，你采取贪婪策略，这非常简单。 (1) 盗窃可装入背包的最贵商品。 (2) 再盗窃还可装入背包的最贵商品，以此类推。 只是这次这种贪婪策略不好使了！例如，你可盗窃的商品有下面三种。 你的背包可装35磅的东西。音响最贵，你把它给偷了，但背包没有空间装其他东西了。 你偷到了价值3000美元的东西。且慢！如果不是偷音响，而是偷笔记本电脑和吉他，总价将为3500美元！ 在这里，贪婪策略显然不能获得最优解，但非常接近。下一章将介绍如何找出最优解。不过小偷去购物中心行窃时，不会强求所偷东西的总价最高，只要差不多就行了。 从这个示例你得到了如下启示：在有些情况下，完美是优秀的敌人。有时候，你只需找到一个能够大致解决问题的算法，此时贪婪算法正好可派上用场，因为它们实现起来很容易，得到的结果又与正确结果相当接近。 练习 1.你在一家家具公司工作，需要将家具发往全国各地，为此你需要将箱子装上卡车。每个箱子的尺寸各不相同，你需要尽可能利用每辆卡车的空间，为此你将如何选择要装上卡车的箱子呢？请设计一种贪婪算法。使用这种算法能得到最优解吗？ 2.你要去欧洲旅行，总行程为7天。对于每个旅游胜地，你都给它分配一个价值——表示你有多想去那里看看，并估算出需要多长时间。你如何将这次旅行的价值最大化？请设计一种贪婪算法。使用这种算法能得到最优解吗？ 下面来看最后一个例子。在这个例子中，你别无选择，只能使用贪婪算法。 集合覆盖问题假设你办了个广播节目，要让全美50个州的听众都收听得到。为此，你需要决定在哪些广播台播出。在每个广播台播出都需要支付费用，因此你力图在尽可能少的广播台播出。现有广播台名单如下。 每个广播台都覆盖特定的区域，不同广播台的覆盖区域可能重叠。 如何找出覆盖全美50个州的最小广播台集合呢？听起来很容易，但其实非常难。具体方法如下。 (1) 列出每个可能的广播台集合，这被称为幂集（power set）。可能的子集有2n个。 (2) 在这些集合中，选出覆盖全美50个州的最小集合。 问题是计算每个可能的广播台子集需要很长时间。由于可能的集合有2n个，因此运行时间为O(2n)。如果广播台不多，只有5～10个，这是可行的。但如果广播台很多，结果将如何呢？随着广播台的增多，需要的时间将激增。假设你每秒可计算10个子集，所需的时间将如下。 没有任何算法可以足够快地解决这个问题！怎么办呢？ 近似算法 贪婪算法可化解危机！使用下面的贪婪算法可得到非常接近的解。 (1) 选出这样一个广播台，即它覆盖了最多的未覆盖州。即便这个广播台覆盖了一些已覆盖的州，也没有关系。 (2) 重复第一步，直到覆盖了所有的州。 这是一种近似算法（approximation algorithm）。在获得精确解需要的时间太长时，可使用近似算法。判断近似算法优劣的标准如下： 速度有多快； 得到的近似解与最优解的接近程度。 贪婪算法是不错的选择，它们不仅简单，而且通常运行速度很快。在这个例子中，贪婪算法的运行时间为O(n2)，其中n为广播台数量。 下面来看看解决这个问题的代码。 1.准备工作 出于简化考虑，这里假设要覆盖的州没有那么多，广播台也没有那么多。 首先，创建一个列表，其中包含要覆盖的州。1states_needed = set(["mt", "wa", "or", "id", "nv", "ut", "ca", "az"]) #你传入一个数组，它被转换为集合 我使用集合来表示要覆盖的州。集合类似于列表，只是同样的元素只能出现一次，即集合不能包含重复的元素。例如，假设你有如下列表。1&gt;&gt;&gt; arr = [1, 2, 2, 3, 3, 3] 并且你将其转换为集合。12&gt;&gt;&gt; set(arr)set([1, 2, 3]) 在这个集合中，1、2和3都只出现一次。 还需要有可供选择的广播台清单，我选择使用散列表来表示它。 123456stations = &#123;&#125;stations["kone"] = set(["id", "nv", "ut"])stations["ktwo"] = set(["wa", "id", "mt"])stations["kthree"] = set(["or", "nv", "ca"])stations["kfour"] = set(["nv", "ut"])stations["kfive"] = set(["ca", "az"]) 其中的键为广播台的名称，值为广播台覆盖的州。在该示例中，广播台kone覆盖了爱达荷州、内达华州和犹他州。所有的值都是集合。你马上将看到，使用集合来表示一切可以简化工作。 最后，需要使用一个集合来存储最终选择的广播台。1final_stations = set() 2.计算答案 接下来需要计算要使用哪些广播台。根据下面的示意图，你能确定应使用哪些广播台吗？ 正确的解可能有多个。你需要遍历所有的广播台，从中选择覆盖了最多的未覆盖州的广播台。我将这个广播台存储在best_station中。123best_station = Nonestates_covered = set()for station, states_for_station in stations.items(): states_covered是一个集合，包含该广播台覆盖的所有未覆盖的州。for循环迭代每个广播台，并确定它是否是最佳的广播台。下面来看看这个for循环的循环体。1234covered = states_needed &amp; states_for_stationif len(covered) &gt; len(states_covered): # 你没见过的语法！它计算交集 best_station = station states_covered = covered 其中有一行代码看起来很有趣。1covered = states_needed &amp; states_for_station 它是做什么的呢？ 3.集合 假设你有一个水果集合。 还有一个蔬菜集合。 有这两个集合后，你就可以使用它们来做些有趣的事情。 下面是你可以对集合执行的一些操作。 并集意味着将集合合并。 交集意味着找出两个集合中都有的元素（在这里，只有西红柿符合条件）。 差集意味着将从一个集合中剔除出现在另一个集合中的元素。 下面是一个例子。 123456789&gt;&gt;&gt; fruits = set(["avocado", "tomato", "banana"])&gt;&gt;&gt; vegetables = set(["beets", "carrots", "tomato"])&gt;&gt;&gt; fruits | vegetables # 并集set(["avocado", "beets", "carrots", "tomato", "banana"])&gt;&gt;&gt; fruits &amp; vegetables # 交集set(["tomato"])&gt;&gt;&gt; fruits – vegetables # 差集set(["avocado", "banana"])&gt;&gt;&gt; vegetables – fruits # 你觉得这行代码是做什么的呢？ 这里小结一下： 集合类似于列表，只是不能包含重复的元素； 你可执行一些有趣的集合运算，如并集、交集和差集。 4.回到代码 回到前面的示例。 下面的代码计算交集。 1covered = states_needed &amp; states_for_station covered 是一个集合，包含同时出现在states_needed和states_for_station中的州；换言之，它包含当前广播台覆盖的一系列还未覆盖的州！接下来，你检查该广播台覆盖的州是否比best_station多。 123if len(covered) &gt; len(states_covered): best_station = station states_covered = covered 如果是这样的，就将best_station设置为当前广播台。最后，你在for循环结束后将best_station添加到最终的广播台列表中。 1final_stations.add(best_station) 你还需更新states_needed。由于该广播台覆盖了一些州，因此不用再覆盖这些州。 1states_needed -= states_covered 你不断地循环，直到states_needed为空。这个循环的完整代码如下。 12345678910111213while states_needed: best_station = None states_covered = set() for station, states in stations.items(): covered = states_needed &amp; states if len(covered) &gt; len(states_covered): best_station = station states_covered = coveredstates_needed -= states_coveredfinal_stations.add(best_station) 最后，你打印final_stations，结果类似于下面这样。 12&gt;&gt;&gt; print final_stationsset(['ktwo', 'kthree', 'kone', 'kfive']) 结果符合你的预期吗？选择的广播台可能是2、3、4和5，而不是预期的1、2、3和5。下面来比较一下贪婪算法和精确算法的运行时间。 练习 下面各种算法是否是贪婪算法。 3.快速排序。 4.广度优先搜索。 5.狄克斯特拉算法。 NP完全问题为解决集合覆盖问题，你必须计算每个可能的集合。 这可能让你想起了第1章介绍的旅行商问题。在这个问题中，旅行商需要前往5个不同的城市。 他需要找出前往这5个城市的最短路径，为此，必须计算每条可能的路径。 前往5个城市时，可能的路径有多少条呢？ 旅行商问题详解我们从城市数较少的情况着手。假设只涉及两个城市，因此可供选择的路线有两条。 这两条路线相同还是不同你可能认为这两条路线相同，难道从旧金山到马林的距离与从马林到旧金山的距离不同吗？不一定。有些城市（如旧金山）有很多单行线，因此你无法按原路返回。你可能需要离开原路行驶一两英里才能找到上高速的匝道。因此，这两条路线不一定相同。 你可能心存疑惑：在旅行商问题中，必须从特定的城市出发吗？例如，假设我是旅行商。我居住在旧金山，需要前往其他4个城市，因此我将从旧金山出发。 但有时候，不确定要从哪个城市出发。假设联邦快递将包裹从芝加哥发往湾区，包裹将通过航运发送到联邦快递在湾区的50个集散点之一，再装上经过不同配送点的卡车。该通过航运发送到哪个集散点呢？在这个例子中，起点就是未知的。因此，你需要通过计算为旅行商找出起点和最佳路线。 在这两种情况下，运行时间是相同的。但出发城市未定时更容易处理，因此这里以这种情况为例。 涉及两个城市时，可能的路线有两条。 1、3个城市 现在假设再增加一个城市，可能的路线有多少条呢？ 如果从伯克利出发，就需前往另外两个城市。 从每个城市出发时，都有两条不同的路线，因此总共有6条路线。 因此涉及3个城市时，可能的路线有6条。 2、4个城市 我们再增加一个城市——弗里蒙特。现在假设从弗里蒙特出发。 从弗里蒙特出发时，有6条可能的路线。这些路线与前面只有3个城市时计算的6条路线很像，只是现在所有的路线都多了一个城市——弗里蒙特！这里有一个规律。假设有4个城市，你选择一个出发城市——弗里蒙特后，还余下3个城市。而你知道，涉及3个城市时，可能的路线有6条。 从弗里蒙特出发时，有6条可能的路线，但还可以从其他任何一个城市出发。 可能的出发城市有4个，从每个城市出发时都有6条可能的路线，因此可能的路线有4 × 6 = 24条。 你看出规律了吗？每增加一个城市，需要计算的路线数都将增加。 涉及6个城市时，可能的路线有多少条呢？如果你说720条，那就对了。7个城市为5040条，8个城市为40 320条。 这被称为阶乘函数（factorial function），第3章介绍过。5! = 120。假设有10个城市，可能的路线有多少条呢？10! = 3 628 800。换句话说，涉及10个城市时，需要计算的可能路线超过300万条。正如你看到的，可能的路线数增加得非常快！因此，如果涉及的城市很多，根本就无法找出旅行商问题的正确解。 旅行商问题和集合覆盖问题有一些共同之处：你需要计算所有的解，并从中选出最小/最短的那个。这两个问题都属于NP完全问题。 近似求解对旅行商问题来说，什么样的近似算法不错呢？能找到较短路径的算法就算不错。在继续往下阅读前，看看你能设计出这样的算法吗？我会采取这样的做法：随便选择出发城市，然后每次选择要去的下一个城市时，都选择还没去的最近的城市。假设旅行商从马林出发。总旅程为71英里。这条路径可能不是最短的，但也相当短了。 NP完全问题的简单定义是，以难解著称的问题，如旅行商问题和集合覆盖问题。很多非常聪明的人都认为，根本不可能编写出可快速解决这些问题的算法。 如何识别NP完全问题Jonah正为其虚构的橄榄球队挑选队员。他列了一个清单，指出了对球队的要求：优秀的四分卫，优秀的跑卫，擅长雨中作战，以及能承受压力等。他有一个候选球员名单，其中每个球员都满足某些要求。 Jonah需要组建一个满足所有这些要求的球队，可名额有限。等等，Jonah突然间意识到，这不就是一个集合覆盖问题吗！ Jonah可使用前面介绍的近似算法来组建球队。 (1) 找出符合最多要求的球员。 (2) 不断重复这个过程，直到球队满足要求（或球队名额已满）。 NP完全问题无处不在！如果能够判断出要解决的问题属于NP完全问题就好了，这样就不用去寻找完美的解决方案，而是使用近似算法即可。但要判断问题是不是NP完全问题很难，易于解决的问题和NP完全问题的差别通常很小。例如，前一章深入讨论了最短路径，你知道如何找出从A点到B点的最短路径。 但如果要找出经由指定几个点的的最短路径，就是旅行商问题——NP完全问题。简言之，没办法判断问题是不是NP完全问题，但还是有一些蛛丝马迹可循的。 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。 涉及“所有组合”的问题通常是NP完全问题。 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。 练习 6.有个邮递员负责给20个家庭送信，需要找出经过这20个家庭的最短路径。请问这是一个NP完全问题吗？ 7.在一堆人中找出最大的朋友圈（即其中任何两个人都相识）是NP完全问题吗？ 8.你要制作美国地图，需要用不同的颜色标出相邻的州。为此，你需要确定最少需要使用多少种颜色，才能确保任何两个相邻州的颜色都不同。请问这是NP完全问题吗？ 小结 贪婪算法寻找局部最优解，企图以这种方式获得全局最优解。 对于NP完全问题，还没有找到快速解决方案。 面临NP完全问题时，最佳的做法是使用近似算法。 贪婪算法易于实现、运行速度快，是不错的近似算法。 答案8.1 一种贪婪策略是，选择可装入卡车剩余空间内的最大箱子，并重复这个过程，直到不能再装入箱子为止。使用这种算法不能得到最优解。 8.2 不断地挑选可在余下的时间内完成的价值最大的活动，直到余下的时间不够完成任何活动为止。使用这种算法不能得到最优解。 8.3 不是。8.4 是。8.5 是。8.6 是。8.7 是。8.8 是。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章 狄克斯特拉算法]]></title>
    <url>%2F2020%2F06%2F01%2F%E7%AC%AC7%E7%AB%A0-%E7%8B%84%E5%85%8B%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 继续图的讨论，介绍加权图——提高或降低某些边的权重。 介绍狄克斯特拉算法，让你能够找出加权图中前往X的最短路径。 介绍图中的环，它导致狄克斯特拉算法不管用。 在前一章，你找出了从A点到B点的路径。 这是最短路径，因为段数最少——只有三段，但不一定是最快路径。如果给这些路段加上时间，你将发现有更快的路径。 你在前一章使用了广度优先搜索，它找出的是段数最少的路径（如第一个图所示）。如果你要找出最快的路径（如第二个图所示），该如何办呢？为此，可使用另一种算法——狄克斯特拉算法（Dijkstra’s algorithm）。 使用狄克斯特拉算法下面来看看如何对下面的图使用这种算法。 其中每个数字表示的都是时间，单位分钟。为找出从起点到终点耗时最短的路径，你将使用狄克斯特拉算法。 如果你使用广度优先搜索，将得到下面这条段数最少的路径。 这条路径耗时7分钟。下面来看看能否找到耗时更短的路径！狄克斯特拉算法包含4个步骤。 (1) 找出“最便宜”的节点，即可在最短时间内到达的节点。 (2) 更新该节点的邻居的开销，其含义将稍后介绍。 (3) 重复这个过程，直到对图中的每个节点都这样做了。 (4) 计算最终路径。 第一步：找出最便宜的节点。你站在起点，不知道该前往节点A还是前往节点B。前往这两个节点都要多长时间呢？ 前往节点A需要6分钟，而前往节点B需要2分钟。至于前往其他节点，你还不知道需要多长时间。 由于你还不知道前往终点需要多长时间，因此你假设为无穷大（这样做的原因你马上就会明白）。节点B是最近的——2分钟就能达到。 第二步：计算经节点B前往其各个邻居所需的时间。 你刚找到了一条前往节点A的更短路径！直接前往节点A需要6分钟。 但经由节点B前往节点A只需5分钟！ 对于节点B的邻居，如果找到前往它的更短路径，就更新其开销。在这里，你找到了： 前往节点A的更短路径（时间从6分钟缩短到5分钟）； 前往终点的更短路径（时间从无穷大缩短到7分钟）。 第三步：重复！ 重复第一步：找出可在最短时间内前往的节点。你对节点B执行了第二步，除节点B外，可在最短时间内前往的节点是节点A。 重复第二步：更新节点A的所有邻居的开销。 你发现前往终点的时间为6分钟！ 你对每个节点都运行了狄克斯特拉算法（无需对终点这样做）。现在，你知道： 前往节点B需要2分钟； 前往节点A需要5分钟； 前往终点需要6分钟。 最后一步——计算最终路径将留到下一节去介绍，这里先直接将最终路径告诉你。 如果使用广度优先搜索，找到的最短路径将不是这条，因为这条路径包含3段，而有一条从起点到终点的路径只有两段。 在前一章，你使用了广度优先搜索来查找两点之间的最短路径，那时“最短路径”的意思是段数最少。在狄克斯特拉算法中，你给每段都分配了一个数字或权重，因此狄克斯特拉算法找出的是总权重最小的路径。 这里重述一下，狄克斯特拉算法包含4个步骤。 (1) 找出最便宜的节点，即可在最短时间内前往的节点。 (2) 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。 (3) 重复这个过程，直到对图中的每个节点都这样做了。 (4) 计算最终路径。（下一节再介绍！） 术语介绍其他狄克斯特拉算法使用示例前，先来澄清一些术语。 狄克斯特拉算法用于每条边都有关联数字的图，这些数字称为权重（weight）。 带权重的图称为加权图（weighted graph），不带权重的图称为非加权图（unweighted graph）。 要计算非加权图中的最短路径，可使用广度优先搜索。要计算加权图中的最短路径，可使用狄克斯特拉算法。图还可能有环，而环类似右面这样。 这意味着你可从一个节点出发，走一圈后又回到这个节点。假设在下面这个带环的图中，你要找出从起点到终点的最短路径。 绕环前行是否合理呢？你可以选择避开环的路径。 也可选择包含环的路径。 这两条路径都可到达终点，但环增加了权重。如果你愿意，甚至可绕环两次。 但每绕环一次，总权重都增加8。因此，绕环的路径不可能是最短的路径。 最后，还记得第6章对有向图和无向图的讨论吗？ 无向图意味着两个节点彼此指向对方，其实就是环！ 在无向图中，每条边都是一个环。狄克斯特拉算法只适用于有向无环图（directed acyclic graph，DAG）。 换钢琴术语介绍得差不多了，我们再来看一个例子！这是Rama，想拿一本乐谱换架钢琴。 Alex说：“这是我最喜欢的乐队Destroyer的海报，我愿意拿它换你的乐谱。如果你再加5美元，还可拿乐谱换我这张稀有的Rick Astley黑胶唱片。”Amy说：“哇，我听说这张黑胶唱片里有首非常好听的歌曲，我愿意拿我的吉他或架子鼓换这张海报或黑胶唱片。” Beethoven惊呼：“我一直想要吉他，我愿意拿我的钢琴换Amy的吉他或架子鼓。” 太好了！只要再花一点点钱，Rama就能拿乐谱换架钢琴。现在他需要确定的是，如何花最少的钱实现这个目标。我们来绘制一个图，列出大家的交换意愿。 这个图中的节点是大家愿意拿出来交换的东西，边的权重是交换时需要额外加多少钱。拿海报换吉他需要额外加30美元，拿黑胶唱片换吉他需要额外加15美元。Rama需要确定采用哪种路径将乐谱换成钢琴时需要支付的额外费用最少。为此，可以使用狄克斯特拉算法！别忘了，狄克斯特拉算法包含四个步骤。在这个示例中，你将完成所有这些步骤，因此你也将计算最终路径。 动手之前，你需要做些准备工作：创建一个表格，在其中列出每个节点的开销。这里的开销指的是达到节点需要额外支付多少钱。 在执行狄克斯特拉算法的过程中，你将不断更新这个表。为计算最终路径，还需在这个表中添加表示父节点的列。 这列的作用将稍后介绍。我们开始执行算法吧。 第一步：找出最便宜的节点。在这里，换海报最便宜，不需要支付额外的费用。还有更便宜的换海报的途径吗？这一点非常重要，你一定要想一想。Rama能够通过一系列交换得到海报，还能额外得到钱吗？想清楚后接着往下读。答案是不能，因为海报是Rama能够到达的最便宜的节点，没法再便宜了。下面提供了另一种思考角度。假设你要从家里去单位。 如果你走经过学校的路，到学校需要2分钟。如果你走经过停车场的路，到停车场需要6分钟。如果经停车场前往学校，能不能将时间缩短到少于2分钟呢？不可能，因为只前往停车场就超过2分钟了。另一方面，有没有能更快到达停车场的路呢？有。 这就是狄克斯特拉算法背后的关键理念：找出图中最便宜的节点，并确保没有到该节点的更便宜的路径！ 回到换钢琴的例子。换海报需要支付的额外费用最少。 第二步：计算前往该节点的各个邻居的开销。 现在的表中包含低音吉他和架子鼓的开销。这些开销是用海报交换它们时需要支付的额外费用，因此父节点为海报。这意味着，要到达低音吉他，需要沿从海报出发的边前行，对架子鼓来说亦如此。 再次执行第一步：下一个最便宜的节点是黑胶唱片——需要额外支付5美元。 再次执行第二步：更新黑胶唱片的各个邻居的开销。 你更新了架子鼓和吉他的开销！这意味着经“黑胶唱片”前往“架子鼓”和“吉他”的开销更低，因此你将这些乐器的父节点改为黑胶唱片。 下一个最便宜的是吉他，因此更新其邻居的开销。 你终于计算出了用吉他换钢琴的开销，于是你将其父节点设置为吉他。最后，对最后一个节点——架子鼓，做同样的处理。 如果用架子鼓换钢琴，Rama需要额外支付的费用更少。因此，采用最便宜的交换路径时，Rama需要额外支付35美元。 现在来兑现前面的承诺，确定最终的路径。当前，我们知道最短路径的开销为35美元，但如何确定这条路径呢？为此，先找出钢琴的父节点。 钢琴的父节点为架子鼓，这意味着Rama需要用架子鼓来换钢琴。因此你就沿着这一边。 我们来看看需要沿哪些边前行。钢琴的父节点为架子鼓。 架子鼓的父节点为黑胶唱片。 因此Rama需要用黑胶唱片了换架子鼓。显然，他需要用乐谱来换黑胶唱片。通过沿父节点回溯，便得到了完整的交换路径。 下面是Rama需要做的一系列交换。 本章前面使用的都是术语最短路径的字面意思：计算两点或两人之间的最短路径。但希望这个示例让你明白：最短路径指的并不一定是物理距离，也可能是让某种度量指标最小。在这个示例中，最短路径指的是Rama想要额外支付的费用最少。这都要归功于狄克斯特拉！ 负权边在前面的交换示例中，Alex提供了两种可用乐谱交换的东西。 假设黑胶唱片不是Alex的，而是Sarah的，且Sarah愿意用黑胶唱片和7美元换海报。换句话说，换得Alex的海报后，Rama用它来换Sarah的黑胶唱片时，不但不用支付额外的费用，还可得7美元。对于这种情况，如何在图中表示出来呢？ 从黑胶唱片到海报的边的权重为负！即这种交换让Rama能够得到7美元。现在，Rama有两种获得海报的方式。 第二种方式更划算——Rama可赚2美元！你可能还记得，Rama可以用海报换架子鼓，但现在有两种换得架子鼓的方式。 第二种方式的开销少2美元，他应采取这种方式。然而，如果你对这个图运行狄克斯特拉算法，Rama将选择错误的路径——更长的那条路径。如果有负权边，就不能使用狄克斯特拉算法。因为负权边会导致这种算法不管用。下面来看看对这个图执行狄克斯特拉算法的情况。首先，创建开销表。 接下来，找出开销最低的节点，并更新其邻居的开销。在这里，开销最低的节点是海报。根据狄克斯特拉算法，没有比不支付任何费用获得海报更便宜的方式。（你知道这并不对！）无论如何，我们来更新其邻居的开销。 现在，架子鼓的开销变成了35美元。 我们来找出最便宜的未处理节点。 更新其邻居的开销。 海报节点已处理过，这里却更新了它的开销。这是一个危险信号。节点一旦被处理，就意味着没有前往该节点的更便宜途径，但你刚才却找到了前往海报节点的更便宜途径！架子鼓没有任何邻居，因此算法到此结束，最终开销如下。 换得架子鼓的开销为35美元。你知道有一种交换方式只需33美元，但狄克斯特拉算法没有找到。这是因为狄克斯特拉算法这样假设：对于处理过的海报节点，没有前往该节点的更短路径。这种假设仅在没有负权边时才成立。因此，不能将狄克斯特拉算法用于包含负权边的图。在包含负权边的图中，要找出最短路径，可使用另一种算法——贝尔曼福德算法（Bellman-Ford algorithm）。本书不介绍这种算法，你可以在网上找到其详尽的说明。 实现下面来看看如何使用代码来实现狄克斯特拉算法，这里以下面的图为例。 要编写解决这个问题的代码，需要三个散列表。 随着算法的进行，你将不断更新散列表costs和parents。首先，需要实现这个图，为此可像第6章那样使用一个散列表。1graph = &#123;&#125; 在前一章中，你像下面这样将节点的所有邻居都存储在散列表中。1graph["you"] = ["alice", "bob", "claire"] 但这里需要同时存储邻居和前往邻居的开销。例如，起点有两个邻居——A和B。 如何表示这些边的权重呢？为何不使用另一个散列表呢？123graph["start"] = &#123;&#125;graph["start"]["a"] = 6graph["start"]["b"] = 2 因此 graph[“start”] 是一个散列表。要获取起点的所有邻居，可像下面这样做。12&gt;&gt;&gt; print graph["start"].keys()["a", "b"] 有一条从起点到A的边，还有一条从起点到B的边。要获悉这些边的权重，该如何办呢？1234&gt;&gt;&gt; print graph["start"]["a"]2&gt;&gt;&gt; print graph["start"]["b"]6 下面来添加其他节点及其邻居。123456graph["a"] = &#123;&#125;graph["a"]["fin"] = 1graph["b"] = &#123;&#125;graph["b"]["a"] = 3graph["b"]["fin"] = 5graph["fin"] = &#123;&#125; # 终点没有任何邻居 表示整个图的散列表类似于下面这样。 接下来，需要用一个散列表来存储每个节点的开销。 节点的开销指的是从起点出发前往该节点需要多长时间。你知道的，从起点到节点B需要2分钟，从起点到节点A需要6分钟（但你可能会找到所需时间更短的路径）。你不知道到终点需要多长时间。对于还不知道的开销，你将其设置为无穷大。在Python中能够表示无穷大吗？你可以这样做：1infinity = float("inf") 创建开销表的代码如下：12345infinity = float("inf")costs = &#123;&#125;costs["a"] = 6costs["b"] = 2costs["fin"] = infinity 还需要一个存储父节点的散列表： 创建这个散列表的代码如下：1234parents = &#123;&#125;parents["a"] = "start"parents["b"] = "start"parents["fin"] = None 最后，你需要一个数组，用于记录处理过的节点，因为对于同一个节点，你不用处理多次。1processed = [] 准备工作做好了，下面来看看算法。 我先列出代码，然后再详细介绍。代码如下。123456789101112node = find_lowest_cost_node(costs) # 在未处理的节点中找出开销最小的节点while node is not None: # 这个while循环在所有节点都被处理过后结束 cost = costs[node] neighbors = graph[node] for n in neighbors.keys(): # 遍历当前节点的所有邻居 new_cost = cost + neighbors[n] if costs[n] &gt; new_cost: # 如果经当前节点前往该邻居更近 costs[n] = new_cost # 就更新该邻居的开销 parents[n] = node # 同时将该邻居的父节点设置为当前节点 processed.append(node) # 将当前节点标记为处理过 node = find_lowest_cost_node(costs) # 找出接下来要处理的节点，并循环 这就是实现狄克斯特拉算法的Python代码！函数find_lowest_cost_node的代码稍后列出，我们先来看看这些代码的执行过程。 找出开销最低的节点。 获取该节点的开销和邻居。 遍历邻居。 每个节点都有开销。开销指的是从起点前往该节点需要多长时间。在这里，你计算从起点出发，经节点B前往节点A（而不是直接前往节点A）需要多长时间。 接下来对新旧开销进行比较。 找到了一条前往节点A的更短路径！因此更新节点A的开销。 这条新路径经由节点B，因此节点A的父节点改为节点B。 现在回到了for循环开头。下一个邻居是终点节点。 经节点B前往终点需要多长时间呢？ 需要7分钟。终点原来的开销为无穷大，比7分钟长。 设置终点节点的开销和父节点。 你更新了节点B的所有邻居的开销。现在，将节点B标记为处理过。 找出接下来要处理的节点。 获取节点A的开销和邻居。 节点A只有一个邻居：终点节点。 当前，前往终点需要7分钟。如果经节点A前往终点，需要多长时间呢？ 经节点A前往终点所需的时间更短！因此更新终点的开销和父节点。 处理所有的节点后，这个算法就结束了。希望前面对执行过程的详细介绍让你对这个算法有更深入的认识。函数 find_lowest_cost_node找出开销最低的节点，其代码非常简单，如下所示。12345678910def find_lowest_cost_node(costs): lowest_cost = float("inf") lowest_cost_node = None for node in costs: # 遍历所有的节点 cost = costs[node] if cost &lt; lowest_cost and node not in processed: # 如果当前节点的开销更低且未处理过， lowest_cost = cost # 就将其视为开销最低的节点 lowest_cost_node = node return lowest_cost_node 练习 1.在下面的各个图中，从起点到终点的最短路径的总权重分别是多少？ 小结 广度优先搜索用于在非加权图中查找最短路径。 狄克斯特拉算法用于在加权图中查找最短路径。 仅当权重为正时狄克斯特拉算法才管用。 如果图中包含负权边，请使用贝尔曼福德算法。 答案7.1 A为8；B为60；C使用狄克斯特拉算法无法找出最短路径，因为存在负权边。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 广度优先搜索]]></title>
    <url>%2F2020%2F06%2F01%2F%E7%AC%AC6%E7%AB%A0-%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 学习使用新的数据结构图来建立网络模型。 学习广度优先搜索，你可对图使用这种算法回答诸如“到X的最短路径是什么”等问题。 学习有向图和无向图。 学习拓扑排序，这种排序算法指出了节点之间的依赖关系。 本章将介绍图。首先，我将说说什么是图（它们不涉及X轴和Y轴），再介绍第一种图算法——广度优先搜索（breadth-first search，BFS）。 广度优先搜索让你能够找出两样东西之间的最短距离，不过最短距离的含义有很多！使用广度优先搜索可以： 编写国际跳棋AI，计算最少走多少步就可获胜； 编写拼写检查器，计算最少编辑多少个地方就可将错拼的单词改成正确的单词，如将READED改为READER需要编辑一个地方； 根据你的人际关系网络找到关系最近的医生。 在我所知道的算法中，图算法应该是最有用的。请务必仔细阅读接下来的几章，这些算法你将经常用到。 图简介假设你居住在旧金山，要从双子峰前往金门大桥。你想乘公交车前往，并希望换乘最少。可乘坐的公交车如下。 为找出换乘最少的乘车路线，你将使用什么样的算法？ 一步就能到达金门大桥吗？下面突出了所有一步就能到达的地方。 金门大桥未突出，因此一步无法到达那里。两步能吗？ 金门大桥也未突出，因此两步也到不了。三步呢？ 金门大桥突出了！因此从双子峰出发，可沿下面的路线三步到达金门大桥。 还有其他前往金门大桥的路线，但它们更远（需要四步）。这个算法发现，前往金门大桥的最短路径需要三步。这种问题被称为最短路径问题（shorterst-path problem）。你经常要找出最短路径，这可能是前往朋友家的最短路径，也可能是国际象棋中把对方将死的最少步数。解决最短路径问题的算法被称为广度优先搜索。 要确定如何从双子峰前往金门大桥，需要两个步骤。 (1) 使用图来建立问题模型。 (2) 使用广度优先搜索解决问题。 下面介绍什么是图，然后再详细探讨广度优先搜索。 图是什么图模拟一组连接。例如，假设你与朋友玩牌，并要模拟谁欠谁钱，可像下面这样指出Alex欠Rama钱。 完整的欠钱图可能类似于下面这样。 指出谁欠谁钱的图 Alex欠Rama钱，Tom欠Adit钱，等等。图由节点（node）和边（edge）组成。 就这么简单！图由节点和边组成。一个节点可能与众多节点直接相连，这些节点被称为邻居。在前面的欠钱图中，Rama是Alex的邻居。Adit不是Alex的邻居，因为他们不直接相连。但Adit既是Rama的邻居，又是Tom的邻居。 图用于模拟不同的东西是如何相连的。下面来看看广度优先搜索。 广度优先搜索第1章介绍了一种查找算法——二分查找。广度优先搜索是一种用于图的查找算法，可帮助回答两类问题。 第一类问题：从节点A出发，有前往节点B的路径吗？ 第二类问题：从节点A出发，前往节点B的哪条路径最短？ 前面计算从双子峰前往金门大桥的最短路径时，你使用过广度优先搜索。这个问题属于第二类问题：哪条路径最短？下面来详细地研究这个算法，你将使用它来回答第一类问题：有路径吗？ 假设你经营着一个芒果农场，需要寻找芒果销售商，以便将芒果卖给他。在Facebook，你与芒果销售商有联系吗？为此，你可在朋友中查找。 这种查找很简单。首先，创建一个朋友名单。 然后，依次检查名单中的每个人，看看他是否是芒果销售商。 假设你没有朋友是芒果销售商，那么你就必须在朋友的朋友中查找。 检查名单中的每个人时，你都将其朋友加入名单。 这样一来，你不仅在朋友中查找，还在朋友的朋友中查找。别忘了，你的目标是在你的人际关系网中找到一位芒果销售商。因此，如果Alice不是芒果销售商，就将其朋友也加入到名单中。这意味着你将在她的朋友、朋友的朋友等中查找。使用这种算法将搜遍你的整个人际关系网，直到找到芒果销售商。这就是广度优先搜索算法。 查找最短路径再说一次，广度优先搜索可回答两类问题。 第一类问题：从节点A出发，有前往节点B的路径吗？（在你的人际关系网中，有芒果销售商吗？） 第二类问题：从节点A出发，前往节点B的哪条路径最短？（哪个芒果销售商与你的关系最近？） 刚才你看到了如何回答第一类问题，下面来尝试回答第二类问题——谁是关系最近的芒果销售商。例如，朋友是一度关系，朋友的朋友是二度关系。 在你看来，一度关系胜过二度关系，二度关系胜过三度关系，以此类推。因此，你应先在一度关系中搜索，确定其中没有芒果销售商后，才在二度关系中搜索。广度优先搜索就是这样做的！在广度优先搜索的执行过程中，搜索范围从起点开始逐渐向外延伸，即先检查一度关系，再检查二度关系。顺便问一句：将先检查Claire还是Anuj呢？Claire是一度关系，而Anuj是二度关系，因此将先检查Claire，后检查Anuj。 你也可以这样看，一度关系在二度关系之前加入查找名单。 你按顺序依次检查名单中的每个人，看看他是否是芒果销售商。这将先在一度关系中查找，再在二度关系中查找，因此找到的是关系最近的芒果销售商。广度优先搜索不仅查找从A到B的路径，而且找到的是最短的路径。 注意，只有按添加顺序查找时，才能实现这样的目的。换句话说，如果Claire先于Anuj加入名单，就需要先检查Claire，再检查Anuj。如果Claire和Anuj都是芒果销售商，而你先检查Anuj再检查Claire，结果将如何呢？找到的芒果销售商并非是与你关系最近的，因为Anuj是你朋友的朋友，而Claire是你的朋友。因此，你需要按添加顺序进行检查。有一个可实现这种目的的数据结构，那就是队列（queue）。 队列队列的工作原理与现实生活中的队列完全相同。假设你与朋友一起在公交车站排队，如果你排在他前面，你将先上车。队列的工作原理与此相同。队列类似于栈，你不能随机地访问队列中的元素。队列只支持两种操作：入队和出队。 如果你将两个元素加入队列，先加入的元素将在后加入的元素之前出队。因此，你可使用队列来表示查找名单！这样，先加入的人将先出队并先被检查。 队列是一种先进先出（First In First Out，FIFO）的数据结构，而栈是一种后进先出（Last In First Out，LIFO）的数据结构。 知道队列的工作原理后，我们来实现广度优先搜索！ 练习 对于下面的每个图，使用广度优先搜索算法来找出答案。 1.找出从起点到终点的最短路径的长度。 2.找出从cab到bat的最短路径的长度。 实现图首先，需要使用代码来实现图。图由多个节点组成。 每个节点都与邻近节点相连，如果表示类似于“你→Bob”这样的关系呢？好在你知道的一种结构让你能够表示这种关系，它就是散列表！ 记住，散列表让你能够将键映射到值。在这里，你要将节点映射到其所有邻居。 表示这种映射关系的Python代码如下。12graph = &#123;&#125;graph["you"] = ["alice", "bob", "claire"] 注意，“你”被映射到了一个数组，因此graph[“you”]是一个数组，其中包含了“你”的所有邻居。 图不过是一系列的节点和边，因此在Python中，只需使用上述代码就可表示一个图。那像下面这样更大的图呢？ 表示它的Python代码如下。 123456789graph = &#123;&#125;graph["you"] = ["alice", "bob", "claire"]graph["bob"] = ["anuj", "peggy"]graph["alice"] = ["peggy"]graph["claire"] = ["thom", "jonny"]graph["anuj"] = []graph["peggy"] = []graph["thom"] = []graph["jonny"] = [] 顺便问一句：键 — 值对的添加顺序重要吗？换言之，如果你这样编写代码：12graph["claire"] = ["thom", "jonny"]graph["anuj"] = [] 而不是这样编写代码：12graph["anuj"] = []graph["claire"] = ["thom", "jonny"] 对结果有影响吗？ 只要回顾一下前一章介绍的内容，你就知道没影响。散列表是无序的，因此添加键 — 值对的顺序无关紧要。 Anuj、Peggy、Thom和Jonny都没有邻居，这是因为虽然有指向他们的箭头，但没有从他们出发指向其他人的箭头。这被称为有向图（directed graph），其中的关系是单向的。因此，Anuj是Bob的邻居，但Bob不是Anuj的邻居。无向图（undirected graph）没有箭头，直接相连的节点互为邻居。例如，下面两个图是等价的。 实现算法先概述一下这种算法的工作原理。 说 明更新队列时，我使用术语“入队”和“出队”，但你也可能遇到术语“压入”和“弹出”。压入大致相当于入队，而弹出大致相当于出队。 首先，创建一个队列。在Python中，可使用函数deque来创建一个双端队列。1234from collections import dequesearch_queue = deque() # 创建一个队列search_queue += graph["you"] # 将你的邻居都加入到这个搜索队列中 别忘了，graph[“you”]是一个数组，其中包含你的所有邻居，如[“alice”,”bob”,”claire”] 。这些邻居都将加入到搜索队列中。 下面来看看其他的代码。123456789while search_queue: #只要队列不为空 person = search_queue.popleft() # 就取出其中的第一个人 if person_is_seller(person): # 检查这个人是否是芒果销售商 print person + " is a mango seller!" # 是芒果销售商 return True else: search_queue += graph[person] # 不是芒果销售商。将这个人的朋友都加入搜索队列return False # 如果到达了这里，就说明队列中没人是芒果销售商 最后，你还需编写函数 person_is_seller ，判断一个人是不是芒果销售商，如下所示。12def person_is_seller(name): return name[-1] == 'm' 这个函数检查人的姓名是否以m结尾：如果是，他就是芒果销售商。这种判断方法有点搞笑，但就这个示例而言是可行的。下面来看看广度优先搜索的执行过程。 这个算法将不断执行，直到满足以下条件之一： 找到一位芒果销售商； 队列变成空的，这意味着你的人际关系网中没有芒果销售商。 Peggy既是Alice的朋友又是Bob的朋友，因此她将被加入队列两次：一次是在添加Alice的朋友时，另一次是在添加Bob的朋友时。因此，搜索队列将包含两个Peggy。 但你只需检查Peggy一次，看她是不是芒果销售商。如果你检查两次，就做了无用功。因此，检查完一个人后，应将其标记为已检查，且不再检查他。 如果不这样做，就可能会导致无限循环。假设你的人际关系网类似于下面这样。 一开始，搜索队列包含你的所有邻居。 现在你检查Peggy。她不是芒果销售商，因此你将其所有邻居都加入搜索队列。 接下来，你检查自己。你不是芒果销售商，因此你将你的所有邻居都加入搜索队列。 以此类推。这将形成无限循环，因为搜索队列将在包含你和包含Peggy之间反复切换。 检查一个人之前，要确认之前没检查过他，这很重要。为此，你可使用一个列表来记录检查过的人。 考虑到这一点后，广度优先搜索的最终代码如下。1234567891011121314151617def search(name): search_queue = deque() search_queue += graph[name] searched = [] # 这个数组用于记录检查过的人 while search_queue: person = search_queue.popleft() if not person in searched: # 仅当这个人没检查过时才检查 if person_is_seller(person): print person + " is a mango seller!" return True else: search_queue += graph[person] searched.append(person) # 将这个人标记为检查过 return Falsesearch("you") 请尝试运行这些代码，看看其输出是否符合预期。你也许应该将函数person_is_seller改为更有意义的名称。 运行时间 如果你在你的整个人际关系网中搜索芒果销售商，就意味着你将沿每条边前行（记住，边是从一个人到另一个人的箭头或连接），因此运行时间至少为O(边数)。 你还使用了一个队列，其中包含要检查的每个人。将一个人添加到队列需要的时间是固定的，即为O(1)，因此对每个人都这样做需要的总时间为O(人数)。所以，广度优先搜索的运行时间为O(人数 + 边数)，这通常写作O(V + E)，其中V为顶点（vertice）数，E为边数。 练习 下面的小图说明了我早晨起床后要做的事情。 该图指出，我不能没刷牙就吃早餐，因此“吃早餐”依赖于“刷牙”。 另一方面，洗澡不依赖于刷牙，因为我可以先洗澡再刷牙。根据这个图，可创建一个列表，指出我需要按什么顺序完成早晨起床后要做的事情： (1) 起床(2) 洗澡(3) 刷牙(4) 吃早餐 请注意，“洗澡”可随便移动，因此下面的列表也可行： (1) 起床(2) 刷牙(3) 洗澡(4) 吃早餐 1.请问下面的三个列表哪些可行、哪些不可行？ 2.下面是一个更大的图，请根据它创建一个可行的列表。 从某种程度上说，这种列表是有序的。如果任务A依赖于任务B，在列表中任务A就必须在任务B后面。这被称为拓扑排序，使用它可根据图创建一个有序列表。假设你正在规划一场婚礼，并有一个很大的图，其中充斥着需要做的事情，但却不知道要从哪里开始。这时就可使用拓扑排序来创建一个有序的任务列表。 假设你有一个家谱。 这是一个图，因为它由节点（人）和边组成。其中的边从一个节点指向其父母，但所有的边都往下指。在家谱中，往上指的边不合情理！因为你父亲不可能是你祖父的父亲！ 这种图被称为树。树是一种特殊的图，其中没有往后指的边。 3.请问下面哪个图也是树？ 小结 广度优先搜索指出是否有从A到B的路径。 如果有，广度优先搜索将找出最短路径。 面临类似于寻找最短路径的问题时，可尝试使用图来建立模型，再使用广度优先搜索来解决问题。 有向图中的边为箭头，箭头的方向指定了关系的方向，例如，rama→adit表示rama欠adit钱。 无向图中的边不带箭头，其中的关系是双向的，例如，ross - rachel表示“ross与rachel约会，而rachel也与ross约会”。 队列是先进先出（FIFO）的。 栈是后进先出（LIFO）的。 你需要按加入顺序检查搜索列表中的人，否则找到的就不是最短路径，因此搜索列表必须是队列。 对于检查过的人，务必不要再去检查，否则可能导致无限循环。 答案6.1 最短路径的长度为2。 6.2 最短路径的长度为2。 6.3 A不可行，B可行，C不可行。 6.4 1—起床，2—锻炼，3—洗澡，4—刷牙，5—穿衣服，6—打包午餐，7—吃早餐。 6.5 A是树，B不是树，C是树。C是一棵横着的树。树是图的子集，因此树都是图，但图可能是树，也可能不是。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章 散列表]]></title>
    <url>%2F2020%2F06%2F01%2F%E7%AC%AC5%E7%AB%A0-%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 学习散列表——最有用的基本数据结构之一。散列表用途广泛，本章将介绍其常见的用途。 学习散列表的内部机制：实现、冲突和散列函数。这将帮助你理解如何分析散列表的性能。 假设你在一家杂货店上班。有顾客来买东西时，你得在一个本子中查找价格。如果本子的内容不是按字母顺序排列的，你可能为查找苹果（apple）的价格而浏览每一行，这需要很长的时间。此时你使用的是第1章介绍的简单查找，需要浏览每一行。还记得这需要多长时间吗？O(n)。如果本子的内容是按字母顺序排列的，可使用二分查找来找出苹果的价格，这需要的时间更短，为O(log n)。 需要提醒你的是，运行时间O(n)和O(log n)之间有天壤之别！假设你每秒能够看10行，使用简单查找和二分查找所需的时间将如下。 你知道，二分查找的速度非常快。但作为收银员，在本子中查找价格是件很痛苦的事情，哪怕本子的内容是有序的。在查找价格时，你都能感觉到顾客的怒气。看来真的需要一名能够记住所有商品价格的雇员，这样你就不用查找了：问她就能马上知道答案。 不管商品有多少，这位雇员（假设她的名字为Maggie）报出任何商品的价格的时间都为O(1)，速度比二分查找都快。 真是太厉害了！如何聘到这样的雇员呢？ 下面从数据结构的角度来看看。前面介绍了两种数据结构：数组和链表（其实还有栈，但栈并不能用于查找）。你可使用数组来实现记录商品价格的本子。 这种数组的每个元素包含两项内容：商品名和价格。如果将这个数组按商品名排序，就可使用二分查找在其中查找商品的价格。这样查找价格的时间将为O(log n)。然而，你希望查找商品价格的时间为O(1)，即你希望查找速度像Maggie那么快，这是散列函数的用武之地。 散列函数散列函数是这样的函数，即无论你给它什么数据，它都还你一个数字。 如果用专业术语来表达的话，我们会说，散列函数“将输入映射到数字”。你可能认为散列函数输出的数字没什么规律，但其实散列函数必须满足一些要求。 它必须是一致的。例如，假设你输入apple时得到的是4，那么每次输入apple时，得到的都必须为4。如果不是这样，散列表将毫无用处。 它应将不同的输入映射到不同的数字。例如，如果一个散列函数不管输入是什么都返回1，它就不是好的散列函数。最理想的情况是，将不同的输入映射到不同的数字。 散列函数将输入映射为数字，这有何用途呢？你可使用它来打造你的“Maggie”！ 为此，首先创建一个空数组。 你将在这个数组中存储商品的价格。下面来将苹果的价格加入到这个数组中。为此，将apple作为输入交给散列函数。 散列函数的输出为3，因此我们将苹果的价格存储到数组的索引3处。 下面将牛奶（milk）的价格存储到数组中。为此，将milk作为散列函数的输入。 散列函数的输出为0，因此我们将牛奶的价格存储在索引0处。 不断地重复这个过程，最终整个数组将填满价格。 现在假设需要知道鳄梨（avocado）的价格。你无需在数组中查找，只需将avocado作为输入交给散列函数。 它将告诉你鳄梨的价格存储在索引4处。果然，你在那里找到了。 散列函数准确地指出了价格的存储位置，你根本不用查找！之所以能够这样，具体原因如下。 散列函数总是将同样的输入映射到相同的索引。每次你输入avocado，得到的都是同一个数字。因此，你可首先使用它来确定将鳄梨的价格存储在什么地方，并在以后使用它来确定鳄梨的价格存储在什么地方。 散列函数将不同的输入映射到不同的索引。avocado映射到索引4，milk映射到索引0。每种商品都映射到数组的不同位置，让你能够将其价格存储到这里。 散列函数知道数组有多大，只返回有效的索引。如果数组包含5个元素，散列函数就不会返回无效索引100。 刚才你就打造了一个“Maggie”！你结合使用散列函数和数组创建了一种被称为散列表（hash table）的数据结构。散列表是你学习的第一种包含额外逻辑的数据结构。数组和链表都被直接映射到内存，但散列表更复杂，它使用散列函数来确定元素的存储位置。 在你将学习的复杂数据结构中，散列表可能是最有用的，也被称为散列映射、映射、字典和关联数组。散列表的速度很快！还记得第2章关于数组和链表的讨论吗？你可以立即获取数组中的元素，而散列表也使用数组来存储数据，因此其获取元素的速度与数组一样快。 你可能根本不需要自己去实现散列表，任一优秀的语言都提供了散列表实现。Python提供的散列表实现为字典，你可使用函数dict来创建散列表。1&gt;&gt;&gt; book = dict() # 一个空的散列表 创建散列表book后，在其中添加一些商品的价格。12345&gt;&gt;&gt; book["apple"] = 0.67 &gt;&gt;&gt; book["milk"] = 1.49&gt;&gt;&gt; book["avocado"] = 1.49&gt;&gt;&gt; print book&#123;'avocado': 1.49, 'apple': 0.67, 'milk': 1.49&#125; 非常简单！我们来查询鳄梨的价格。12&gt;&gt;&gt; print book["avocado"]1.49 散列表由键和值组成。在前面的散列表book中，键为商品名，值为商品价格。散列表将键映射到值。 在下一节中，你将看到一些散列表使用示例。 练习 对于同样的输入，散列表必须返回同样的输出，这一点很重要。如果不是这样的，就无法找到你在散列表中添加的元素！ 请问下面哪些散列函数是一致的？ 1.f(x) = 1 &lt;-无论输入是什么，都返回1 2.f(x) = rand() &lt;-每次都返回一个随机数 3.f(x) = next_empty_slot() &lt;-返回散列表中下一个空位置的索引 4.f(x) = len(x) &lt;-将字符串的长度用作索引 应用案例散列表用途广泛，本节将介绍几个应用案例。 将散列表用于查找手机都内置了方便的电话簿，其中每个姓名都有对应的电话号码。 假设你要创建一个类似这样的电话簿，将姓名映射到电话号码。该电话簿需要提供如下功能。 添加联系人及其电话号码。 通过输入联系人来获悉其电话号码。 这非常适合使用散列表来实现！在下述情况下，使用散列表是很不错的选择。 创建映射。 查找。 创建电话簿非常容易。首先，新建一个散列表。1&gt;&gt;&gt; phone_book = dict() 顺便说一句，Python提供了一种创建散列表的快捷方式——使用一对大括号。1&gt;&gt;&gt; phone_book = &#123;&#125; # 与phone_book = dict()等效 下面在这个电话簿中添加一些联系人的电话号码。12&gt;&gt;&gt; phone_book["jenny"] = 8675309&gt;&gt;&gt; phone_book["emergency"] = 911 这就成了！现在，假设你要查找Jenny的电话号码，为此只需向散列表传入相应的键。12&gt;&gt;&gt; print phone_book["jenny"]8675309 # Jenny的电话号码 如果要求你使用数组来创建电话簿，你将如何做呢？散列表让你能够轻松地模拟映射关系。 散列表被用于大海捞针式的查找。例如，你在访问像http://adit.io这样的网站时，计算机必须将adit.io转换为IP地址。 无论你访问哪个网站，其网址都必须转换为IP地址。 这不是将网址映射到IP地址吗？好像非常适合使用散列表啰！这个过程被称为DNS解析（DNS resolution），散列表是提供这种功能的方式之一。 防止重复假设你负责管理一个投票站。显然，每人只能投一票，但如何避免重复投票呢？有人来投票时，你询问他的全名，并将其与已投票者名单进行比对。 如果名字在名单中，就说明这个人投过票了，因此将他拒之门外！否则，就将他的姓名加入到名单中，并让他投票。现在假设有很多人来投过了票，因此名单非常长。 每次有人来投票时，你都得浏览这个长长的名单，以确定他是否投过票。但有一种更好的办法，那就是使用散列表！ 为此，首先创建一个散列表，用于记录已投票的人。1&gt;&gt;&gt; voted = &#123;&#125; 有人来投票时，检查他是否在散列表中。1&gt;&gt;&gt; value = voted.get("tom") 如果“tom”在散列表中，函数get将返回它；否则返回None。你可使用这个函数检查来投票的人是否投过票！ 代码如下。12345678voted = &#123;&#125;def check_voter(name): if voted.get(name): print "kick them out!" else: voted[name] = True print "let them vote!" 我们来测试几次。123456&gt;&gt;&gt; check_voter("tom")let them vote!&gt;&gt;&gt; check_voter("mike")let them vote!&gt;&gt;&gt; check_voter("mike")kick them out! 首先来投票的是Tom，上述代码打印let them vote!。接着Mike来投票，打印的也是let them vote!。然后，Mike又来投票，于是打印的就是kick them out!。 别忘了，如果你将已投票者的姓名存储在列表中，这个函数的速度终将变得非常慢，因为它必须使用简单查找搜索整个列表。但这里将它们存储在了散列表中，而散列表让你能够迅速知道来投票的人是否投过票。使用散列表来检查是否重复，速度非常快。 将散列表用作缓存来看最后一个应用案例：缓存。如果你在网站工作，可能听说过进行缓存是一种不错的做法。下面简要地介绍其中的原理。假设你访问网站facebook.com。 (1) 你向Facebook的服务器发出请求。 (2) 服务器做些处理，生成一个网页并将其发送给你。 (3) 你获得一个网页。 例如，Facebook的服务器可能搜集你朋友的最近活动，以便向你显示这些信息，这需要几秒钟的时间。作为用户的你，可能感觉这几秒钟很久，进而可能认为Facebook怎么这么慢！另一方面，Facebook的服务器必须为数以百万的用户提供服务，每个人的几秒钟累积起来就相当多了。为服务好所有用户，Facebook的服务器实际上在很努力地工作。有没有办法让Facebook的服务器少做些工作，从而提高Facebook网站的访问速度呢？ 假设你有个侄女，总是没完没了地问你有关星球的问题。火星离地球多远？月球呢？木星呢？每次你都得在Google搜索，再告诉她答案。这需要几分钟。现在假设她老问你月球离地球多远，很快你就记住了月球离地球238 900英里。因此不必再去Google搜索，你就可以直接告诉她答案。这就是缓存的工作原理：网站将数据记住，而不再重新计算。 如果你登录了Facebook，你看到的所有内容都是为你定制的。你每次访问facebook.com，其服务器都需考虑你感兴趣的是什么内容。但如果你没有登录，看到的将是登录页面。每个人看到的登录页面都相同。Facebook被反复要求做同样的事情：“当我注销时，请向我显示主页。”有鉴于此，它不让服务器去生成主页，而是将主页存储起来，并在需要时将其直接发送给用户。 这就是缓存，具有如下两个优点。 用户能够更快地看到网页，就像你记住了月球与地球之间的距离时一样。下次你侄女再问你时，你就不用再使用Google搜索，立刻就可以告诉她答案。 Facebook需要做的工作更少。 缓存是一种常用的加速方式，所有大型网站都使用缓存，而缓存的数据则存储在散列表中！ Facebook不仅缓存主页，还缓存About页面、Contact页面、Terms and Conditions页面等众多其他的页面。因此，它需要将页面URL映射到页面数据。 当你访问Facebook的页面时，它首先检查散列表中是否存储了该页面。 具体的代码如下。123456789cache = &#123;&#125;def get_page(url): if cache.get(url): return cache[url] # 返回缓存的数据 else: data = get_data_from_server(url) cache[url] = data # 先将数据保存到缓存中 return data 仅当URL不在缓存中时，你才让服务器做些处理，并将处理生成的数据存储到缓存中，再返回它。这样，当下次有人请求该URL时，你就可以直接发送缓存中的数据，而不用再让服务器进行处理了。 小结这里总结一下，散列表适合用于： 模拟映射关系； 防止重复； 缓存/记住数据，以免服务器再通过处理来生成它们。 冲突前面说过，大多数语言都提供了散列表实现，你不用知道如何实现它们。有鉴于此，我就不再过多地讨论散列表的内部原理，但你依然需要考虑性能！要明白散列表的性能，你得先搞清楚什么是冲突。本节和下一节将分别介绍冲突和性能。 首先，我撒了一个善意的谎。我之前告诉你的是，散列函数总是将不同的键映射到数组的不同位置。 实际上，几乎不可能编写出这样的散列函数。我们来看一个简单的示例。假设你有一个数组，它包含26个位置。 而你使用的散列函数非常简单，它按字母表顺序分配数组的位置。 你可能已经看出了问题。如果你要将苹果的价格存储到散列表中，分配给你的是第一个位置。 接下来，你要将香蕉的价格存储到散列表中，分配给你的是第二个位置。 一切顺利！但现在你要将鳄梨的价格存储到散列表中，分配给你的又是第一个位置。 不好，这个位置已经存储了苹果的价格！怎么办？这种情况被称为冲突（collision）：给两个键分配的位置相同。这是个问题。如果你将鳄梨的价格存储到这个位置，将覆盖苹果的价格，以后再查询苹果的价格时，得到的将是鳄梨的价格！冲突很糟糕，必须要避免。处理冲突的方式很多，最简单的办法如下：如果两个键映射到了同一个位置，就在这个位置存储一个链表。 在这个例子中，apple和avocado映射到了同一个位置，因此在这个位置存储一个链表。在需要查询香蕉的价格时，速度依然很快。但在需要查询苹果的价格时，速度要慢些：你必须在相应的链表中找到apple。如果这个链表很短，也没什么大不了——只需搜索三四个元素。但是，假设你工作的杂货店只销售名称以字母A打头的商品。 等等！除第一个位置外，整个散列表都是空的，而第一个位置包含一个很长的列表！换言之，这个散列表中的所有元素都在这个链表中，这与一开始就将所有元素存储到一个链表中一样糟糕：散列表的速度会很慢。 这里的经验教训有两个。 散列函数很重要。前面的散列函数将所有的键都映射到一个位置，而最理想的情况是，散列函数将键均匀地映射到散列表的不同位置。 如果散列表存储的链表很长，散列表的速度将急剧下降。然而，如果使用的散列函数很好，这些链表就不会很长！ 散列函数很重要，好的散列函数很少导致冲突。那么，如何选择好的散列函数呢？这将在下一节介绍！ 性能本章开头是假设你在杂货店工作。你想打造一个让你能够迅速获悉商品价格的工具，而散列表的速度确实很快。 在平均情况下，散列表执行各种操作的时间都为O(1)。O(1)被称为常量时间。你以前没有见过常量时间，它并不意味着马上，而是说不管散列表多大，所需的时间都相同。例如，你知道的，简单查找的运行时间为线性时间。 二分查找的速度更快，所需时间为对数时间。 在散列表中查找所花费的时间为常量时间。 一条水平线，看到了吧？这意味着无论散列表包含一个元素还是10亿个元素，从其中获取数据所需的时间都相同。实际上，你以前见过常量时间——从数组中获取一个元素所需的时间就是固定的：不管数组多大，从中获取一个元素所需的时间都是相同的。在平均情况下，散列表的速度确实很快。 在最糟情况下，散列表所有操作的运行时间都为O(n)——线性时间，这真的很慢。我们来将散列表同数组和链表比较一下。 在平均情况下，散列表的查找（获取给定索引处的值）速度与数组一样快，而插入和删除速度与链表一样快，因此它兼具两者的优点！但在最糟情况下，散列表的各种操作的速度都很慢。因此，在使用散列表时，避开最糟情况至关重要。为此，需要避免冲突。而要避免冲突，需要有： 较低的填装因子； 良好的散列函数。 说 明接下来的内容并非必读的，我将讨论如何实现散列表，但你根本就不需要这样做。不管你使用的是哪种编程语言，其中都内置了散列表实现。你可使用内置的散列表，并假定其性能良好。下面带你去看看幕后的情况。 填装因子散列表的填装因子很容易计算。 散列表使用数组来存储数据，因此你需要计算数组中被占用的位置数。例如，下述散列表的填装因子为2/5，即0.4。 下面这个散列表的填装因子为多少呢？ 如果你的答案为1/3，那就对了。填装因子度量的是散列表中有多少位置是空的。 假设你要在散列表中存储100种商品的价格，而该散列表包含100个位置。那么在最佳情况下，每个商品都将有自己的位置。 这个散列表的填装因子为1。如果这个散列表只有50个位置呢？填充因子将为2。不可能让每种商品都有自己的位置，因为没有足够的位置！填装因子大于1意味着商品数量超过了数组的位置数。一旦填装因子开始增大，你就需要在散列表中添加位置，这被称为调整长度（resizing）。例如，假设有一个像下面这样相当满的散列表。 你就需要调整它的长度。为此，你首先创建一个更长的新数组：通常将数组增长一倍。 接下来，你需要使用函数 hash 将所有的元素都插入到这个新的散列表中。 这个新散列表的填装因子为3/8，比原来低多了！填装因子越低，发生冲突的可能性越小，散列表的性能越高。一个不错的经验规则是：一旦填装因子大于0.7，就调整散列表的长度。 你可能在想，调整散列表长度的工作需要很长时间！你说得没错，调整长度的开销很大，因此你不会希望频繁地这样做。但平均而言，即便考虑到调整长度所需的时间，散列表操作所需的时间也为O(1)。 良好的散列函数良好的散列函数让数组中的值呈均匀分布。 糟糕的散列函数让值扎堆，导致大量的冲突。 什么样的散列函数是良好的呢？你根本不用操心——天塌下来有高个子顶着。如果你好奇，可研究一下SHA函数（本书最后一章做了简要的介绍）。你可将它用作散列函数。 练习 散列函数的结果必须是均匀分布的，这很重要。它们的映射范围必须尽可能大。最糟糕的散列函数莫过于将所有输入都映射到散列表的同一个位置。 假设你有四个处理字符串的散列函数。 A. 不管输入是什么，都返回1。 B. 将字符串的长度用作索引。 C. 将字符串的第一个字符用作索引。即将所有以a打头的字符串都映射到散列表的同一个位置，以此类推。 D. 将每个字符都映射到一个素数：a = 2，b = 3，c = 5，d = 7，e = 11，等等。对于给定的字符串，这个散列函数将其中每个字符对应的素数相加，再计算结果除以散列表长度的余数。例如，如果散列表的长度为10，字符串为 bag ，则索引为(3 + 2 + 17) % 10 = 22 % 10 = 2。 在下面的每个示例中，上述哪个散列函数可实现均匀分布？假设散列表的长度为10。 5.将姓名和电话号码分别作为键和值的电话簿，其中联系人姓名为Esther、Ben、Bob和Dan。 6.电池尺寸到功率的映射，其中电池尺寸为A、AA、AAA和AAAA。 6.书名到作者的映射，其中书名分别为Maus、Fun Home和Watchmen。 小结你几乎根本不用自己去实现散列表，因为你使用的编程语言提供了散列表实现。你可使用Python提供的散列表，并假定能够获得平均情况下的性能：常量时间。 散列表是一种功能强大的数据结构，其操作速度快，还能让你以不同的方式建立数据模型。 你可能很快会发现自己经常在使用它。 你可以结合散列函数和数组来创建散列表。 冲突很糟糕，你应使用可以最大限度减少冲突的散列函数。 散列表的查找、插入和删除速度都非常快。 散列表适合用于模拟映射关系。 一旦填装因子超过0.7，就该调整散列表的长度。 散列表可用于缓存数据（例如，在Web服务器上）。 散列表非常适合用于防止重复。 答案5.1 一致。5.2 不一致。5.3 不一致。5.4 一致。5.5 散列函数C和D可实现均匀分布。5.6 散列函数B和D可实现均匀分布。5.7 散列函数B、C和D可实现均匀分布。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章 快速排序]]></title>
    <url>%2F2020%2F05%2F31%2F%E7%AC%AC4%E7%AB%A0-%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章内容 学习分而治之。有时候，你可能会遇到使用任何已知的算法都无法解决的问题。优秀的算法学家遇到这种问题时，不会就此放弃，而是尝试使用掌握的各种问题解决方法来找出解决方案。分而治之是你学习的第一种通用的问题解决方法。 学习快速排序——一种常用的优雅的排序算法。快速排序使用分而治之的策略。 前一章深入介绍了递归，本章的重点是使用学到的新技能来解决问题。我们将探索分而治之（divide and conquer，D&amp;C）——一种著名的递归式问题解决方法。 本书将深入算法的核心。只能解决一种问题的算法毕竟用处有限，而D&amp;C提供了解决问题的思路，是另一个可供你使用的工具。面对新问题时，你不再束手无策，而是自问：“使用分而治之能解决吗？” 在本章末尾，你将学习第一个重要的D&amp;C算法——快速排序。快速排序是一种排序算法，速度比第2章介绍的选择排序快得多，实属优雅代码的典范。 分而治之D&amp;C并不那么容易掌握，我将通过三个示例来介绍。首先，介绍一个直观的示例；然后，介绍一个代码示例，它不那么好看，但可能更容易理解；最后，详细介绍快速排序——一种使用D&amp;C的排序算法。 假设你是农场主，有一小块土地。 你要将这块地均匀地分成方块，且分出的方块要尽可能大。显然，下面的分法都不符合要求。 如何将一块地均匀地分成方块，并确保分出的方块是最大的呢？使用D&amp;C策略！D&amp;C算法是递归的。使用D&amp;C解决问题的过程包括两个步骤。 (1) 找出基线条件，这种条件必须尽可能简单。 (2) 不断将问题分解（或者说缩小规模），直到符合基线条件。 下面就来使用D&amp;C找出前述问题的解决方案。可你能使用的最大方块有多大呢？ 首先，找出基线条件。最容易处理的情况是，一条边的长度是另一条边的整数倍。 如果一边长25m，另一边长50m，那么可使用的最大方块为25m×25m。换言之，可以将这块地分成两个这样的方块。 现在需要找出递归条件，这正是D&amp;C的用武之地。根据D&amp;C的定义，每次递归调用都必须缩小问题的规模。如何缩小前述问题的规模呢？我们首先找出这块地可容纳的最大方块。 你可以从这块地中划出两个640m×640m的方块，同时余下一小块地。现在是顿悟时刻：何不对余下的那一小块地使用相同的算法呢？ 最初要划分的土地尺寸为1680m×640m，而现在要划分的土地更小，为640m×400m。适用于这小块地的最大方块，也是适用于整块地的最大方块。换言之，你将均匀划分1680m×640m土地的问题，简化成了均匀划分640m×400m土地的问题！ 欧几里得算法前面说“适用于这小块地的最大方块，也是适用于整块地的最大方块”，如果你觉得这一点不好理解，也不用担心。这确实不好理解，但遗憾的是，要证明这一点，需要的篇幅有点长，在本书中无法这样做，因此你只能选择相信这种说法是正确的。如果你想搞明白其中的原因，可参阅欧几里得算法。 下面再次使用同样的算法。对于640m×400m的土地，可从中划出的最大方块为400m×400m。 这将余下一块更小的土地，其尺寸为400m×240m。 你可从这块土地中划出最大的方块，余下一块更小的土地，其尺寸为240m×160m。 接下来，从这块土地中划出最大的方块，余下一块更小的土地。 余下的这块土地满足基线条件，因为160是80的整数倍。将这块土地分成两个方块后，将不会余下任何土地！ 因此，对于最初的那片土地，适用的最大方块为80m×80m。 这里重申一下D&amp;C的工作原理： (1) 找出简单的基线条件； (2) 确定如何缩小问题的规模，使其符合基线条件。 D&amp;C并非可用于解决问题的算法，而是一种解决问题的思路。我们再来看一个例子。 给定一个数字数组。 你需要将这些数字相加，并返回结果。使用循环很容易完成这种任务。 1234567def sum(arr): total = 0 for x in arr: total += x return totalprint sum([1, 2, 3, 4]) 但如何使用递归函数来完成这种任务呢？ 第一步：找出基线条件。最简单的数组什么样呢？请想想这个问题，再接着往下读。如果数组不包含任何元素或只包含一个元素，计算总和将非常容易。 因此这就是基线条件。 第二步：每次递归调用都必须离空数组更近一步。如何缩小问题的规模呢？下面是一种办法。 这与下面的版本等效。 这两个版本的结果都为12，但在第二个版本中，给函数sum传递的数组更短。换言之，这缩小了问题的规模！ 函数sum的工作原理类似于下面这样。 这个函数的运行过程如下。 别忘了，递归记录了状态。 提 示 编写涉及数组的递归函数时，基线条件通常是数组为空或只包含一个元素。陷入困境时，请检查基线条件是不是这样的。 函数式编程一瞥 你可能想，既然使用循环可轻松地完成任务，为何还要使用递归方式呢？看看函数式编程你就明白了！诸如Haskell等函数式编程语言没有循环，因此你只能使用递归来编写这样的函数。如果你对递归有深入的认识，函数式编程语言学习起来将更容易。例如，使用Haskell时，你可能这样编写函数sum。12sum [] = 0 # 基线条件sum (x:xs) = x + (sum xs) # 递归条件 注意，这就像是你有函数的两个定义。符合基线条件时运行第一个定义，符合递归条件时运行第二个定义。也可以使用Haskell语言中的if语句来编写这个函数。123sum arr = if arr == [] then 0 else (head arr) + (sum (tail arr)) 但前一个版本更容易理解。Haskell大量使用了递归，因此它提供了各种方便实现递归的语法。如果你喜欢递归或想学习一门新语言，可以研究一下Haskell。 练习 1.请编写前述sum函数的代码。 2.编写一个递归函数来计算列表包含的元素数。 3.找出列表中最大的数字。 4.还记得第1章介绍的二分查找吗？它也是一种分而治之算法。你能找出二分查找算法的基线条件和递归条件吗？ 快速排序快速排序是一种常用的排序算法，比选择排序快得多。例如，C语言标准库中的函数qsort实现的就是快速排序。快速排序也使用了D&amp;C。 下面来使用快速排序对数组进行排序。对排序算法来说，最简单的数组什么样呢？还记得前一节的“提示”吗？就是根本不需要排序的数组。 因此，基线条件为数组为空或只包含一个元素。在这种情况下，只需原样返回数组——根本就不用排序。123def quicksort(array): if len(array) &lt; 2: return array 我们来看看更长的数组。对包含两个元素的数组进行排序也很容易。 包含三个元素的数组呢？ 别忘了，你要使用D&amp;C，因此需要将数组分解，直到满足基线条件。下面介绍快速排序的工作原理。首先，从数组中选择一个元素，这个元素被称为基准值（pivot）。 稍后再介绍如何选择合适的基准值。我们暂时将数组的第一个元素用作基准值。 接下来，找出比基准值小的元素以及比基准值大的元素。 这被称为分区（partitioning）。现在你有： 一个由所有小于基准值的数字组成的子数组； 基准值； 一个由所有大于基准值的数组组成的子数组。 这里只是进行了分区，得到的两个子数组是无序的。但如果这两个数组是有序的，对整个数组进行排序将非常容易。 如果子数组是有序的，就可以像下面这样合并得到一个有序的数组：左边的数组 + 基准值 +右边的数组。在这里，就是[10, 15] + [33] + []，结果为有序数组[10, 15, 33]。 如何对子数组进行排序呢？对于包含两个元素的数组（左边的子数组）以及空数组（右边的子数组），快速排序知道如何将它们排序，因此只要对这两个子数组进行快速排序，再合并结果，就能得到一个有序数组！12quicksort([15, 10]) + [33] + quicksort([])&gt; [10, 15, 33] # 一个有序数组 不管将哪个元素用作基准值，这都管用。假设你将15用作基准值。 这个子数组都只有一个元素，而你知道如何对这些数组进行排序。现在你就知道如何对包含三个元素的数组进行排序了，步骤如下。 (1) 选择基准值。 (2) 将数组分成两个子数组：小于基准值的元素和大于基准值的元素。 (3) 对这两个子数组进行快速排序。 包含四个元素的数组呢？ 假设你也将33用作基准值。 左边的子数组包含三个元素，而你知道如何对包含三个元素的数组进行排序：对其递归地调用快速排序。 因此你能够对包含四个元素的数组进行排序。如果能够对包含四个元素的数组进行排序，就能对包含五个元素的数组进行排序。为什么呢？假设有下面这样一个包含五个元素的数组。 根据选择的基准值，对这个数组进行分区的各种可能方式如下。 注意，这些子数组包含的元素数都在0～4内，而你已经知道如何使用快速排序对包含0～4个元素的数组进行排序！因此，不管如何选择基准值，你都可对划分得到的两个子数组递归地进行快速排序。 例如，假设你将3用作基准值，可对得到的子数组进行快速排序。 将子数组排序后，将它们合并，得到一个有序数组。即便你将5用作基准值，这也可行。 将任何元素用作基准值都可行，因此你能够对包含五个元素的数组进行排序。同理，你能够对包含六个元素的数组进行排序，以此类推。 归纳证明刚才你大致见识了归纳证明！归纳证明是一种证明算法行之有效的方式，它分两步：基线条件和归纳条件。是不是有点似曾相识的感觉？例如，假设我要证明我能爬到梯子的最上面。递归条件是这样的：如果我站在一个横档上，就能将脚放到下一个横档上。换言之，如果我站在第二个横档上，就能爬到第三个横档。这就是归纳条件。而基线条件是这样的，即我已经站在第一个横档上。因此，通过每次爬一个横档，我就能爬到梯子最顶端。对于快速排序，可使用类似的推理。在基线条件中，我证明这种算法对空数组或包含一个元素的数组管用。在归纳条件中，我证明如果快速排序对包含一个元素的数组管用，对包含两个元素的数组也将管用；如果它对包含两个元素的数组管用，对包含三个元素的数组也将管用，以此类推。因此，我可以说，快速排序对任何长度的数组都管用。这里不再深入讨论归纳证明，但它很有趣，并与D&amp;C协同发挥作用。 下面是快速排序的代码。123456789101112def quicksort(array): if len(array) &lt; 2: return array # 基线条件：为空或只包含一个元素的数组是“有序”的 else: pivot = array[0] # 递归条件 less = [i for i in array[1:] if i &lt;= pivot] # 由所有小于基准值的元素组成的子数组 greater = [i for i in array[1:] if i &gt; pivot] # 由所有大于基准值的元素组成的子数组 return quicksort(less) + [pivot] + quicksort(greater)print quicksort([10, 5, 2, 3]) 再谈大O表示法快速排序的独特之处在于，其速度取决于选择的基准值。在讨论快速排序的运行时间前，我们再来看看最常见的大O运行时间。 上述图表中的时间是基于每秒执行10次操作计算得到的。这些数据并不准确，这里提供它们只是想让你对这些运行时间的差别有大致认识。实际上，计算机每秒执行的操作远不止10次。 对于每种运行时间，本书还列出了相关的算法。来看看第2章介绍的选择排序，其运行时间为O(n2)，速度非常慢。 还有一种名为合并排序（merge sort）的排序算法，其运行时间为O(n log n)，比选择排序快得多！快速排序的情况比较棘手，在最糟情况下，其运行时间为O(n2)。 与选择排序一样慢！但这是最糟情况。在平均情况下，快速排序的运行时间为O(n log n)。你可能会有如下疑问。 这里说的最糟情况和平均情况是什么意思呢？ 若快速排序在平均情况下的运行时间为O(n log n)，而合并排序的运行时间总是O(n log n)，为何不使用合并排序？它不是更快吗？ 比较合并排序和快速排序假设有下面这样打印列表中每个元素的简单函数。123def print_items(list): for item in list: print item 这个函数遍历列表中的每个元素并将其打印出来。它迭代整个列表一次，因此运行时间为O(n)。现在假设你对这个函数进行修改，使其在打印每个元素前都休眠1秒钟。123456from time import sleepdef print_items2(list): for item in list: sleep(1) print item 它在打印每个元素前都暂停1秒钟。假设你使用这两个函数来打印一个包含5个元素的列表。 这两个函数都迭代整个列表一次，因此它们的运行时间都为O(n)。你认为哪个函数的速度更快呢？我认为print_items要快得多，因为它没有在每次打印元素前都暂停1秒钟。因此，虽然使用大O表示法表示时，这两个函数的速度相同，但实际上print_items的速度更快。在大O表示法O(n)中，n实际上指的是这样的。 c是算法所需的固定时间量，被称为常量。例如，print_items所需的时间可能是10毫秒*n，而print_items2所需的时间为1秒*n。 通常不考虑这个常量，因为如果两种算法的大O运行时间不同，这种常量将无关紧要。就拿二分查找和简单查找来举例说明。假设这两种算法的运行时间包含如下常量。 你可能认为，简单查找的常量为10毫秒，而二分查找的常量为1秒，因此简单查找的速度要快得多。现在假设你要在包含40亿个元素的列表中查找，所需时间将如下。 正如你看到的，二分查找的速度还是快得多，常量根本没有什么影响。 但有时候，常量的影响可能很大，对快速查找和合并查找来说就是如此。快速查找的常量比合并查找小，因此如果它们的运行时间都为O(n log n)，快速查找的速度将更快。实际上，快速查找的速度确实更快，因为相对于遇上最糟情况，它遇上平均情况的可能性要大得多。 此时你可能会问，何为平均情况，何为最糟情况呢？ 平均情况和最糟情况快速排序的性能高度依赖于你选择的基准值。假设你总是将第一个元素用作基准值，且要处理的数组是有序的。由于快速排序算法不检查输入数组是否有序，因此它依然尝试对其进行排序。 注意，数组并没有被分成两半，相反，其中一个子数组始终为空，这导致调用栈非常长。现在假设你总是将中间的元素用作基准值，在这种情况下，调用栈如下。 调用栈短得多！因为你每次都将数组分成两半，所以不需要那么多递归调用。你很快就到达了基线条件，因此调用栈短得多。 第一个示例展示的是最糟情况，而第二个示例展示的是最佳情况。在最糟情况下，栈长为O(n)，而在最佳情况下，栈长为O(log n)。 现在来看看栈的第一层。你将一个元素用作基准值，并将其他的元素划分到两个子数组中。这涉及数组中的全部8个元素，因此该操作的时间为O(n)。在调用栈的第一层，涉及全部8个元素，但实际上，在调用栈的每层都涉及O(n)个元素。 即便以不同的方式划分数组，每次也将涉及O(n)个元素。 因此，完成每层所需的时间都为O(n)。 在这个示例中，层数为O(log n)（用技术术语说，调用栈的高度为O(log n)），而每层需要的时间为O(n)。因此整个算法需要的时间为O(n) * O(log n) = O(n log n)。这就是最佳情况。 在最糟情况下，有O(n)层，因此该算法的运行时间为O(n) * O(n) = O(n2)。 知道吗？这里要告诉你的是，最佳情况也是平均情况。只要你每次都随机地选择一个数组元素作为基准值，快速排序的平均运行时间就将为O(n log n)。快速排序是最快的排序算法之一，也是D&amp;C典范。 练习 5.使用大O表示法时，下面各种操作都需要多长时间？ 6.打印数组中每个元素的值。 7.将数组中每个元素的值都乘以2。 8.只将数组中第一个元素的值乘以2。 9.根据数组包含的元素创建一个乘法表，即如果数组为[2, 3, 7, 8, 10]，首先将每个元素都乘以2，再将每个元素都乘以3，然后将每个元素都乘以7，以此类推。 小结 D&amp;C将问题逐步分解。使用D&amp;C处理列表时，基线条件很可能是空数组或只包含一个元素的数组。 实现快速排序时，请随机地选择用作基准值的元素。快速排序的平均运行时间为O(n log n)。 大O表示法中的常量有时候事关重大，这就是快速排序比合并排序快的原因所在。 比较简单查找和二分查找时，常量几乎无关紧要，因为列表很长时，O(log n)的速度比O(n)快得多。 答案4.11234def sum(list): if list == []: return 0 return list[0] + sum(list[1:]) 4.21234def count(list): if list == []: return 0 return 1 + count(list[1:]) 4.312345def max(list): if len(list) == 2: return list[0] if list[0] &gt; list[1] else list[1] sub_max = max(list[1:]) return list[0] if list[0] &gt; sub_max else sub_max 4.4 二分查找的基线条件是数组只包含一个元素。如果要查找的值与这个元素相同，就找到了！否则，就说明它不在数组中。 在二分查找的递归条件中，你把数组分成两半，将其中一半丢弃，并对另一半执行二分查找。 4.5 O(n)。4.6 O(n)。4.7 O(1)。4.8 O(n2)。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章 递归]]></title>
    <url>%2F2020%2F05%2F31%2F%E7%AC%AC3%E7%AB%A0-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。怎么理解？ 本章内容 学习递归。递归是很多算法都使用的一种编程方法。 学习如何将问题分成基线条件和递归条件。第4章将介绍的分而治之策略使用这种简单的概念来解决棘手的问题。 递归假设你发现了一个上锁的神秘手提箱。这个盒子里有盒子，而盒子里的盒子又有盒子。钥匙就在某个盒子中。为找到钥匙，你将使用什么算法？先想想这个问题，再接着往下看。 下面是一种方法。 (1) 创建一个要查找的盒子堆。 (2) 从盒子堆取出一个盒子，在里面找。 (3) 如果找到的是盒子，就将其加入盒子堆中，以便以后再查找。 (4) 如果找到钥匙，则大功告成！ (5) 回到第二步。 下面是另一种方法。 (1) 检查盒子中的每样东西。 (2) 如果是盒子，就回到第一步。 (3) 如果是钥匙，就大功告成！ 在你看来，哪种方法更容易呢？第一种方法使用的是while循环：只要盒子堆不空，就从中取一个盒子，并在其中仔细查找。123456789def look_for_key(main_box): pile = main_box.make_a_pile_to_look_through() while pile is not empty: box = pile.grab_a_box() for item in box: if item.is_a_box(): pile.append(item) elif item.is_a_key(): print "found the key!" 第二种方法使用递归——函数调用自己，这种方法的伪代码如下。123456def look_for_key(box): for item in box: if item.is_a_box(): look_for_key(item) # 递归！ elif item.is_a_key(): print "found the key!" 这两种方法的作用相同，但在我看来，第二种方法更清晰。递归只是让解决方案更清晰，并没有性能上的优势。实际上，在有些情况下，使用循环的性能更好。我很喜欢Stack Overflow上的一句话：“如果使用循环，程序的性能可能更高；如果使用递归，程序可能更容易理解。如何选择要看什么对你来说更重要。” 基线条件和递归条件由于递归函数调用自己，因此编写这样的函数时很容易出错，进而导致无限循环。例如，假设你要编写一个像下面这样倒计时的函数。1&gt; 3...2...1 为此，你可以用递归的方式编写，如下所示。123def countdown(i): print i countdown(i-1) 如果你运行上述代码，将发现一个问题：这个函数运行起来没完没了！（要让脚本停止运行，可按Ctrl+C。）1&gt; 3...2...1...0...-1...-2... 编写递归函数时，必须告诉它何时停止递归。正因为如此，每个递归函数都有两部分：基线条件（base case）和递归条件（recursive case）。递归条件指的是函数调用自己，而基线条件则指的是函数不再调用自己，从而避免形成无限循环。 我们来给函数 countdown 添加基线条件。123456def countdown(i): print i if i &lt;= 0: # 基线条件 return else: # 递归条件 countdown(i-1) 现在，这个函数将像预期的那样运行。 栈本节将介绍一个重要的编程概念——调用栈（call stack）。调用栈不仅对编程来说很重要，使用递归时也必须理解这个概念。 假设你去野外烧烤，并为此创建了一个待办事项清单——一叠便条。 本书之前讨论数组和链表时，也有一个待办事项清单。你可将待办事项添加到该清单的任何地方，还可删除任何一个待办事项。一叠便条要简单得多：插入的待办事项放在清单的最前面；读取待办事项时，你只读取最上面的那个，并将其删除。因此这个待办事项清单只有两种操作：压入（插入）和弹出（删除并读取）。 下面来看看如何使用这个待办事项清单。 这种数据结构称为栈。栈是一种简单的数据结构，刚才我们一直在使用它，却没有意识到！ 调用栈计算机在内部使用被称为调用栈的栈。我们来看看计算机是如何使用调用栈的。下面是一个简单的函数。12345def greet(name): print "hello, " + name + "!" greet2(name) print "getting ready to say bye..." bye() 这个函数问候用户，再调用另外两个函数。这两个函数的代码如下。12345def greet2(name): print "how are you, " + name + "?"def bye(): print "ok bye!" 下面详细介绍调用函数时发生的情况。 说 明在Python中，print是一个函数，但出于简化考虑，这里假设它不是函数。你也这样假设就行了。 假设你调用greet(“maggie”)，计算机将首先为该函数调用分配一块内存。 我们来使用这些内存。变量name被设置为maggie，这需要存储到内存中。 每当你调用函数时，计算机都像这样将函数调用涉及的所有变量的值存储到内存中。接下来，你打印hello,maggie!，再调用greet2(“maggie”)。同样，计算机也为这个函数调用分配一块内存。 计算机使用一个栈来表示这些内存块，其中第二个内存块位于第一个内存块上面。你打印how are you, maggie?，然后从函数调用返回。此时，栈顶的内存块被弹出。 现在，栈顶的内存块是函数greet的，这意味着你返回到了函数greet。当你调用函数greet2时，函数greet只执行了一部分。这是本节的一个重要概念：调用另一个函数时，当前函数暂停并处于未完成状态。该函数的所有变量的值都还在内存中。执行完函数greet2后，你回到函数greet，并从离开的地方开始接着往下执行：首先打印getting ready to say bye…，再调用函数bye。 在栈顶添加了函数bye的内存块。然后，你打印ok bye!，并从这个函数返回。 现在你又回到了函数greet。由于没有别的事情要做，你就从函数greet返回。这个栈用于存储多个函数的变量，被称为调用栈。 练习 1.根据下面的调用栈，你可获得哪些信息？ 下面来看看递归函数的调用栈。 递归调用栈递归函数也使用调用栈！来看看递归函数factorial的调用栈。factorial(5)写作5!，其定义如下：5! = 5 * 4 * 3 * 2 * 1。同理， factorial(3) 为3 * 2 * 1。下面是计算阶乘的递归函数。12345def fact(x): if x == 1: return 1 else: return x * fact(x-1) 下面来详细分析调用fact(3)时调用栈是如何变化的。别忘了，栈顶的方框指出了当前执行到了什么地方。 注意，每个fact调用都有自己的x变量。在一个函数调用中不能访问另一个的x变量。 栈在递归中扮演着重要角色。在本章开头的示例中，有两种寻找钥匙的方法。下面再次列出了第一种方法。 使用这种方法时，你创建一个待查找的盒子堆，因此你始终知道还有哪些盒子需要查找。 但使用递归方法时，没有盒子堆。 既然没有盒子堆，那算法怎么知道还有哪些盒子需要查找呢？下面是一个例子。 此时，调用栈类似于下面这样。 原来“盒子堆”存储在了栈中！这个栈包含未完成的函数调用，每个函数调用都包含还未检查完的盒子。使用栈很方便，因为你无需自己跟踪盒子堆——栈替你这样做了。 使用栈虽然很方便，但是也要付出代价：存储详尽的信息可能占用大量的内存。每个函数调用都要占用一定的内存，如果栈很高，就意味着计算机存储了大量函数调用的信息。在这种情况下，你有两种选择。 重新编写代码，转而使用循环。 使用尾递归。这是一个高级递归主题，不在本书的讨论范围内。另外，并非所有的语言都支持尾递归。 练习 2.假设你编写了一个递归函数，但不小心导致它没完没了地运行。正如你看到的，对于每次函数调用，计算机都将为其在栈中分配内存。递归函数没完没了地运行时，将给栈带来什么影响？ 小结 递归指的是调用自己的函数。 每个递归函数都有两个条件：基线条件和递归条件。 栈有两种操作：压入和弹出。 所有函数调用都进入调用栈。 调用栈可能很长，这将占用大量的内存。 答案3.1 下面是一些你可获得的信息。 首先调用了函数greet，并将参数name的值指定为maggie。 接下来，函数greet调用了函数greet2 ，并将参数name的值指定为maggie。 此时函数greet处于未完成（挂起）状态。 当前的函数调用为函数greet2。 这个函数执行完毕后，函数greet将接着执行。 3.2 栈将不断地增大。每个程序可使用的调用栈空间都有限，程序用完这些空间（终将如此）后，将因栈溢出而终止。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章 选择排序]]></title>
    <url>%2F2020%2F05%2F31%2F%E7%AC%AC2%E7%AB%A0-%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 算法运行时间是从其增速的角度度量的。怎么理解？ 随机访问和顺序访问分别是什么数据结构的访问方式？ 链表的优势在插入元素方面， 本章内容 学习两种最基本的数据结构——数组和链表，它们无处不在。第1章使用了数组，其他各章几乎也都将用到数组。数组是个重要的主题，一定要高度重视！但在有些情况下，使用链表比使用数组更合适。本章阐述数组和链表的优缺点，让你能够根据要实现的算法选择合适的一个。 学习第一种排序算法。很多算法仅在数据经过排序后才管用。还记得二分查找吗？它只能用于有序元素列表。本章将介绍选择排序。很多语言都内置了排序算法，因此你基本上不用从头开始编写自己的版本。但选择排序是下一章将介绍的快速排序的基石。快速排序是一种重要的算法，如果你熟悉其他排序算法，理解起来将更容易。 内存的工作原理假设你去看演出，需要将东西寄存。寄存处有一个柜子，柜子有很多抽屉。每个抽屉可放一样东西，你有两样东西要寄存，因此要了两个抽屉。你将两样东西存放在这里。现在你可以去看演出了！这大致就是计算机内存的工作原理。计算机就像是很多抽屉的集合体，每个抽屉都有地址。 fe0ffeeb是一个内存单元的地址。 需要将数据存储到内存时，你请求计算机提供存储空间，计算机给你一个存储地址。需要存储多项数据时，有两种基本方式——数组和链表。但它们并非都适用于所有的情形，因此知道它们的差别很重要。接下来介绍数组和链表以及它们的优缺点。 数组和链表有时候，需要在内存中存储一系列元素。假设你要编写一个管理待办事项的应用程序，为此需要将这些待办事项存储在内存中。 应使用数组还是链表呢？鉴于数组更容易掌握，我们先将待办事项存储在数组中。使用数组意味着所有待办事项在内存中都是相连的（紧靠在一起的）。 现在假设你要添加第四个待办事项，但后面的那个抽屉放着别人的东西！ 这就像你与朋友去看电影，找到地方就坐后又来了一位朋友，但原来坐的地方没有空位置，只得再找一个可坐下所有人的地方。在这种情况下，你需要请求计算机重新分配一块可容纳4个待办事项的内存，再将所有待办事项都移到那里。 如果又来了一位朋友，而当前坐的地方也没有空位，你们就得再次转移！真是太麻烦了。同样，在数组中添加新元素也可能很麻烦。如果没有了空间，就得移到内存的其他地方，因此添加新元素的速度会很慢。一种解决之道是“预留座位”：即便当前只有3个待办事项，也请计算机提供10个位置，以防需要添加待办事项。这样，只要待办事项不超过10个，就无需转移。这是一个不错的权变措施，但你应该明白，它存在如下两个缺点。 你额外请求的位置可能根本用不上，这将浪费内存。你没有使用，别人也用不了。 待办事项超过10个后，你还得转移。 因此，这种权宜措施虽然不错，但绝非完美的解决方案。对于这种问题，可使用链表来解决。 链表链表中的元素可存储在内存的任何地方。 链表的每个元素都存储了下一个元素的地址，从而使一系列随机的内存地址串在一起。 串在一起的内存地址 这犹如寻宝游戏。你前往第一个地址，那里有一张纸条写着“下一个元素的地址为123”。因此，你前往地址123，那里又有一张纸条，写着“下一个元素的地址为847”，以此类推。在链表中添加元素很容易：只需将其放入内存，并将其地址存储到前一个元素中。 使用链表时，根本就不需要移动元素。这还可避免另一个问题。假设你与五位朋友去看一部很火的电影。你们六人想坐在一起，但看电影的人较多，没有六个在一起的座位。使用数组时有时就会遇到这样的情况。假设你要为数组分配10 000个位置，内存中有10 000个位置，但不都靠在一起。在这种情况下，你将无法为该数组分配内存！链表相当于说“我们分开来坐”，因此，只要有足够的内存空间，就能为链表分配内存。 链表的优势在插入元素方面，那数组的优势又是什么呢？ 数组排行榜网站使用卑鄙的手段来增加页面浏览量。它们不在一个页面中显示整个排行榜，而将排行榜的每项内容都放在一个页面中，并让你单击Next来查看下一项内容。例如，显示十大电视反派时，不在一个页面中显示整个排行榜，而是先显示第十大反派（Newman）。你必须在每个页面中单击Next，才能看到第一大反派（Gustavo Fring）。这让网站能够在10个页面中显示广告，但用户需要单击Next九次才能看到第一个，真的是很烦。如果整个排行榜都显示在一个页面中，将方便得多。这样，用户可单击排行榜中的人名来获得更详细的信息。 链表存在类似的问题。在需要读取链表的最后一个元素时，你不能直接读取，因为你不知道它所处的地址，必须先访问元素#1，从中获取元素#2的地址，再访问元素#2并从中获取元素#3的地址，以此类推，直到访问最后一个元素。需要同时读取所有元素时，链表的效率很高：你读取第一个元素，根据其中的地址再读取第二个元素，以此类推。但如果你需要跳跃，链表的效率真的很低。 数组与此不同：你知道其中每个元素的地址。例如，假设有一个数组，它包含五个元素，起始地址为00，那么元素#5的地址是多少呢？ 只需执行简单的数学运算就知道：04。需要随机地读取元素时，数组的效率很高，因为可迅速找到数组的任何元素。在链表中，元素并非靠在一起的，你无法迅速计算出第五个元素的内存地址，而必须先访问第一个元素以获取第二个元素的地址，再访问第二个元素以获取第三个元素的地址，以此类推，直到访问第五个元素。 术语数组的元素带编号，编号从0而不是1开始。例如，在下面的数组中，元素20的位置为1。 而元素10的位置为0。这通常会让新手晕头转向。从0开始让基于数组的代码编写起来更容易，因此程序员始终坚持这样做。几乎所有的编程语言都从0开始对数组元素进行编号。你很快就会习惯这种做法。 元素的位置称为索引。因此，不说“元素20的位置为1”，而说“元素20位于索引1处”。本书将使用索引来表示位置。 下面列出了常见的数组和链表操作的运行时间。 问题：在数组中插入元素时，为何运行时间为O(n)呢？假设要在数组开头插入一个元素，你将如何做？这需要多长时间？请阅读下一节，找出这些问题的答案！ 练习 1.假设你要编写一个记账的应用程序。 你每天都将所有的支出记录下来，并在月底统计支出，算算当月花了多少钱。因此，你执行的插入操作很多，但读取操作很少。该使用数组还是链表呢？ 在中间插入假设你要让待办事项按日期排列。之前，你在清单末尾添加了待办事项。 但现在你要根据新增待办事项的日期将其插入到正确的位置。 需要在中间插入元素时，数组和链表哪个更好呢？使用链表时，插入元素很简单，只需修改它前面的那个元素指向的地址。 而使用数组时，则必须将后面的元素都向后移。 如果没有足够的空间，可能还得将整个数组复制到其他地方！因此，当需要在中间插入元素时，链表是更好的选择。 删除如果你要删除元素呢？链表也是更好的选择，因为只需修改前一个元素指向的地址即可。而使用数组时，删除元素后，必须将后面的元素都向前移。 不同于插入，删除元素总能成功。如果内存中没有足够的空间，插入操作可能失败，但在任何情况下都能够将元素删除。 下面是常见数组和链表操作的运行时间。 需要指出的是，仅当能够立即访问要删除的元素时，删除操作的运行时间才为O(1)。通常我们都记录了链表的第一个元素和最后一个元素，因此删除这些元素时运行时间为O(1)。查找并删除还是O(n)，因为要查找。 数组和链表哪个用得更多呢？显然要看情况。但数组用得很多，因为它支持随机访问。有两种访问方式：随机访问和顺序访问。顺序访问意味着从第一个元素开始逐个地读取元素。链表只能顺序访问：要读取链表的第十个元素，得先读取前九个元素，并沿链接找到第十个元素。随机访问意味着可直接跳到第十个元素。本书经常说数组的读取速度更快，这是因为它们支持随机访问。很多情况都要求能够随机访问，因此数组用得很多。数组和链表还被用来实现其他数据结构，这将在本书后面介绍。 练习 2.假设你要为饭店创建一个接受顾客点菜单的应用程序。这个应用程序存储一系列点菜单。服务员添加点菜单，而厨师取出点菜单并制作菜肴。这是一个点菜单队列：服务员在队尾添加点菜单，厨师取出队列开头的点菜单并制作菜肴。 你使用数组还是链表来实现这个队列呢？（提示：链表擅长插入和删除，而数组擅长随机访问。在这个应用程序中，你要执行的是哪些操作呢？） 3.我们来做一个思考实验。假设Facebook记录一系列用户名，每当有用户试图登录Facebook时，都查找其用户名，如果找到就允许用户登录。由于经常有用户登录Facebook，因此需要执行大量的用户名查找操作。假设Facebook使用二分查找算法，而这种算法要求能够随机访问——立即获取中间的用户名。考虑到这一点，应使用数组还是链表来存储用户名呢？ 4.经常有用户在Facebook注册。假设你已决定使用数组来存储用户名，在插入方面数组有何缺点呢？具体地说，在数组中添加新用户将出现什么情况？ 5.实际上，Facebook存储用户信息时使用的既不是数组也不是链表。假设Facebook使用的是一种混合数据：链表数组。这个数组包含26个元素，每个元素都指向一个链表。例如，该数组的第一个元素指向的链表包含所有以A打头的用户名，第二个元素指向的链表包含所有以B打头的用户名，以此类推。 假设Adit B在Facebook注册，而你需要将其加入前述数据结构中。因此，你访问数组的第一个元素，再访问该元素指向的链表，并将Adit B添加到这个链表末尾。现在假设你要查找Zakhir H。因此你访问第26个元素，再在它指向的链表（该链表包含所有以z打头的用户名）中查找Zakhir H。 请问，相比于数组和链表，这种混合数据结构的查找和插入速度更慢还是更快？你不必给出大O运行时间，只需指出这种新数据结构的查找和插入速度更快还是更慢。 选择排序有了前面的知识，你就可以学习第二种算法——选择排序了。要理解本节的内容，你必须熟悉数组、链表和大O表示法。 假设你的计算机存储了很多乐曲。对于每个乐队，你都记录了其作品被播放的次数。 你要将这个列表按播放次数从多到少的顺序排列，从而将你喜欢的乐队排序。该如何做呢？ 一种办法是遍历这个列表，找出作品播放次数最多的乐队，并将该乐队添加到一个新列表中。 再次这样做，找出播放次数第二多的乐队。 继续这样做，你将得到一个有序列表。 下面从计算机科学的角度出发，看看这需要多长时间。别忘了，O(n)时间意味着查看列表中的每个元素一次。例如，对乐队列表进行简单查找时，意味着每个乐队都要查看一次。 要找出播放次数最多的乐队，必须检查列表中的每个元素。正如你刚才看到的，这需要的时间为O(n)。因此对于这种时间为O(n)的操作，你需要执行n次。 需要的总时间为O(n×n)，即O(n2)。 排序算法很有用。你现在可以对如下内容进行排序： 电话簿中的人名 旅行日期 电子邮件（从新到旧） 需要检查的元素数越来越少随着排序的进行，每次需要检查的元素数在逐渐减少，最后一次需要检查的元素都只有一个。既然如此，运行时间怎么还是O(n2)呢？这个问题问得好，这与大O表示法中的常数相关。第4章将详细解释，这里只简单地说一说。你说得没错，并非每次都需要检查n个元素。第一次需要检查n个元素，但随后检查的元素数依次为n-1, n-2, …, 2和1。平均每次检查的元素数为1/2×n，因此运行时间为O(n× 1/2×n)。但大O表示法省略诸如1/2这样的常数（有关这方面的完整讨论，请参阅第4章），因此简单地写作O(n×n)或O(n2)。 选择排序是一种灵巧的算法，但其速度不是很快。快速排序是一种更快的排序算法，其运行时间为O(n log n)，这将在下一章介绍。 示例代码 前面没有列出对乐队进行排序的代码，但下述代码提供了类似的功能：将数组元素按从小到大的顺序排列。先编写一个用于找出数组中最小元素的函数。 123456789def findSmallest(arr): smallest = arr[0] # 存储最小的值 smallest_index = 0 # 存储最小元素的索引 for i in range(1, len(arr)): if arr[i] &lt; smallest: smallest = arr[i] smallest_index = i return smallest_index 现在可以使用这个函数来编写选择排序算法了。12345678def selectionSort(arr): # 对数组进行排序 newArr = [] for i in range(len(arr)): smallest = findSmallest(arr) # 找出数组中最小的元素，并将其加入到新数组中 newArr.append(arr.pop(smallest))return newArrprint selectionSort([5, 3, 6, 2, 10]) 小结 计算机内存犹如一大堆抽屉。 需要存储多个元素时，可使用数组或链表。 数组的元素都在一起。 链表的元素是分开的，其中每个元素都存储了下一个元素的地址。 数组的读取速度很快。 链表的插入和删除速度很快。 在同一个数组中，所有元素的类型都必须相同（都为int、double等）。 答案2.1 在这里，你每天都在列表中添加支出项，但每月只读取支出一次。数组的读取速度快，而插入速度慢；链表的读取速度慢，而插入速度快。由于你执行的插入操作比读取操作多，因此使用链表更合适。另外，仅当你要随机访问元素时，链表的读取速度才慢。鉴于你要读取所有的元素，在这种情况下，链表的读取速度也不慢。因此，对这个问题来说，使用链表是不错的解决方案。 2.2 使用链表。经常要执行插入操作（服务员添加点菜单），而这正是链表擅长的。不需要执行（数组擅长的）查找和随机访问操作，因为厨师总是从队列中取出第一个点菜单。 2.3 有序数组。数组让你能够随机访问——立即获取数组中间的元素，而使用链表无法这样做。要获取链表中间的元素，你必须从第一个元素开始，沿链接逐渐找到这个元素。 2.4 数组的插入速度很慢。另外，要使用二分查找算法来查找用户名，数组必须是有序的。假设有一个名为Adit B的用户在Facebook注册，其用户名将插入到数组末尾，因此每次插入用户名后，你都必须对数组进行排序！ 2.5 查找时，其速度比数组慢，但比链表快；而插入时，其速度比数组快，但与链表相当。因此，其查找速度比数组慢，但在各方面都不比链表慢。本书后面将介绍另一种混合数据结构——散列表。这个练习应该能让你对如何使用简单数据结构创建复杂的数据结构有大致了解。 Facebook实际使用的是什么呢？很可能是十多个数据库，它们基于众多不同的数据结构：散列表、B树等。数组和链表是这些更复杂的数据结构的基石。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Kernel]]></title>
    <url>%2F2020%2F05%2F28%2FLaravel-Kernel%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 接口 \Illuminate\Contracts\Http\Kernel.php 1234567891011121314151617181920212223242526272829303132333435namespace Illuminate\Contracts\Http;interface Kernel&#123; /** * Bootstrap the application for HTTP requests. * * @return void */ public function bootstrap(); /** * Handle an incoming HTTP request. * * @param \Symfony\Component\HttpFoundation\Request $request * @return \Symfony\Component\HttpFoundation\Response */ public function handle($request); /** * 在请求生命周期中执行所有最终操作。 * * @param \Symfony\Component\HttpFoundation\Request $request * @param \Symfony\Component\HttpFoundation\Response $response * @return void */ public function terminate($request, $response); /** * Get the Laravel application instance. * * @return \Illuminate\Contracts\Foundation\Application */ public function getApplication();&#125; KernelFoundation 地基 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051namespace Illuminate\Foundation\Http;use Illuminate\Contracts\Debug\ExceptionHandler;use Illuminate\Contracts\Foundation\Application;use Illuminate\Contracts\Http\Kernel as KernelContract;use Illuminate\Foundation\Http\Events\RequestHandled;use Illuminate\Routing\Pipeline;use Illuminate\Routing\Router;use Illuminate\Support\Facades\Facade;use InvalidArgumentException;use Throwable;class Kernel implements KernelContract&#123; protected $app; protected $route; protected $bootstrappers = [ \Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class, \Illuminate\Foundation\Bootstrap\LoadConfiguration::class, \Illuminate\Foundation\Bootstrap\HandleExceptions::class, \Illuminate\Foundation\Bootstrap\RegisterFacades::class, \Illuminate\Foundation\Bootstrap\RegisterProviders::class, \Illuminate\Foundation\Bootstrap\BootProviders::class, ]; protected $middleware = []; protected $middlewareGroups = []; protected $routeMiddleware = []; protected $middlewarePriority = [ \Illuminate\Session\Middleware\StartSession::class, \Illuminate\View\Middleware\ShareErrorsFromSession::class, \Illuminate\Contracts\Auth\Middleware\AuthenticatesRequests::class, \Illuminate\Routing\Middleware\ThrottleRequests::class, \Illuminate\Session\Middleware\AuthenticateSession::class, \Illuminate\Routing\Middleware\SubstituteBindings::class, \Illuminate\Auth\Middleware\Authorize::class, ]; public function __construct(Application $app, Router $router) &#123; $this-&gt;app = $app; $this-&gt;router = $router; $this-&gt;syncMiddlewareToRouter(); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Database-Eloquent Model模型关系加载与查询]]></title>
    <url>%2F2020%2F05%2F28%2FLaravel-Database-Eloquent-Model%E6%A8%A1%E5%9E%8B%E5%85%B3%E7%B3%BB%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%9F%A5%E8%AF%A2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言我们在上一篇文章中介绍了模型关系的定义初始化，我们可以看到，在初始化的过程中Laravel已经为各种关联关系的模型预先插入了初始的where条件。本文将会进一步介绍如何添加自定义的查询条件，如何加载、预加载关联模型。 关联模型的加载当我们定义关联模型后： 12345678910class User extends Model&#123; /** * 获得与用户关联的电话记录。 */ public function phone() &#123; $this-&gt;hasOne('App\Phone', 'user_id', 'id'); &#125;&#125; 我们可以像成员变量一样来获取与之关联的模型：123456$user = App\User::find(1);foreach ($user-&gt;posts as $post) &#123; //&#125; 实际上，模型的属性获取函数的确可以加载关联模型：12345678910public function getAttribute($key)&#123; if (! $key) &#123; return; &#125; ... return $this-&gt;getRelationValue($key);&#125; getRelationValue函数专用于加载我们之前定义的关联模型：123456789101112131415161718192021222324252627282930313233/** * Get a relationship. * * @param string $key * @return mixed */public function getRelationValue($key)&#123; // If the key already exists in the relationships array, it just means the // relationship has already been loaded, so we'll just return it out of // here because there is no need to query within the relations twice. if ($this-&gt;relationLoaded($key)) &#123; return $this-&gt;relations[$key]; &#125; // If the "attribute" exists as a method on the model, we will just assume // it is a relationship and will load and return results from the query // and hydrate the relationship's value on the "relationships" array. if (method_exists($this, $key)) &#123; return $this-&gt;getRelationshipFromMethod($key); &#125;&#125;/** * Determine if the given relation is loaded. * * @param string $key * @return bool */public function relationLoaded($key)&#123; return array_key_exists($key, $this-&gt;relations);&#125; 可以看到，关联的加载带有缓存，Laravel首先会验证当前关联关系是否已经被加载，如果加载过，那么直接返回缓存结果。12345678910111213141516171819202122232425262728/** * Get a relationship value from a method. * * @param string $method * @return mixed * * @throws \LogicException */protected function getRelationshipFromMethod($method)&#123; $relation = $this-&gt;$method(); if (! $relation instanceof Relation) &#123; if (is_null($relation)) &#123; throw new LogicException(sprintf( '%s::%s must return a relationship instance, but "null" was returned. Was the "return" keyword used?', static::class, $method )); &#125; throw new LogicException(sprintf( '%s::%s must return a relationship instance.', static::class, $method )); &#125; return tap($relation-&gt;getResults(), function ($results) use ($method) &#123; $this-&gt;setRelation($method, $results); &#125;);&#125; 当我们调用$user-&gt;posts语句的时候，Laravel会调用posts函数，该函数开始定义关联关系，并且返回hasOne对象，在这里将会调用getResults函数来加载关联模型：12345678910111213/** * Get the results of the relationship. * * @return mixed */public function getResults()&#123; if (is_null($this-&gt;getParentKey())) &#123; return $this-&gt;getDefaultFor($this-&gt;parent); &#125; return $this-&gt;query-&gt;first() ?: $this-&gt;getDefaultFor($this-&gt;parent);&#125; getDefaultFor函数用于在未查询到任何关联模型时的情况。我们在定义关联的时候，可以提供默认的方法来控制返回的结果：12345678910111213141516public function user()&#123; return $this-&gt;belongsTo('App\User')-&gt;withDefault();&#125;public function user()&#123; return $this-&gt;belongsTo('App\User')-&gt;withDefault(['name' =&gt; '游客',]);&#125;public function user()&#123; return $this-&gt;belongsTo('App\User')-&gt;withDefault(function ($user) &#123; $user-&gt;name = '游客'; &#125;);&#125; withDefault可以提供空值、数组、闭包函数等等选项，getDefaultFor函数在关联没有查询到结果的时候，按要求返回一个模型：12345678910111213141516171819202122232425262728293031323334353637/** * Return a new model instance in case the relationship does not exist. * * @param \Closure|array|bool $callback * @return $this */public function withDefault($callback = true)&#123; $this-&gt;withDefault = $callback; return $this;&#125;/** * Get the default value for this relation. * * @param \Illuminate\Database\Eloquent\Model $parent * @return \Illuminate\Database\Eloquent\Model|null */protected function getDefaultFor(Model $parent)&#123; if (! $this-&gt;withDefault) &#123; return; &#125; $instance = $this-&gt;newRelatedInstanceFor($parent); if (is_callable($this-&gt;withDefault)) &#123; return call_user_func($this-&gt;withDefault, $instance, $parent) ?: $instance; &#125; if (is_array($this-&gt;withDefault)) &#123; $instance-&gt;forceFill($this-&gt;withDefault); &#125; return $instance;&#125; 获取到关联模型后，就要放入缓存当中，以备后续情况使用：12345678910111213/** * Set the given relationship on the model. * * @param string $relation * @param mixed $value * @return $this */public function setRelation($relation, $value)&#123; $this-&gt;relations[$relation] = $value; return $this;&#125; 多对多关系的加载多对多关系的加载与一对多等关系的加载有所不同，原因是不仅要加载related模型，还要加载中间表模型：123456789101112131415161718192021222324252627282930313233343536373839404142/** * Get the results of the relationship. * * @return mixed */public function getResults()&#123; return ! is_null($this-&gt;parent-&gt;&#123;$this-&gt;parentKey&#125;) ? $this-&gt;get() : $this-&gt;related-&gt;newCollection();&#125;/** * Execute the query as a "select" statement. * * @param array $columns * @return \Illuminate\Database\Eloquent\Collection */public function get($columns = ['*'])&#123; // First we'll add the proper select columns onto the query so it is run with // the proper columns. Then, we will get the results and hydrate out pivot // models with the result of those columns as a separate model relation. $builder = $this-&gt;query-&gt;applyScopes(); $columns = $builder-&gt;getQuery()-&gt;columns ? [] : $columns; $models = $builder-&gt;addSelect( $this-&gt;shouldSelect($columns) )-&gt;getModels(); $this-&gt;hydratePivotRelation($models); // If we actually found models we will also eager load any relationships that // have been specified as needing to be eager loaded. This will solve the // n + 1 query problem for the developer and also increase performance. if (count($models) &gt; 0) &#123; $models = $builder-&gt;eagerLoadRelations($models); &#125; return $this-&gt;related-&gt;newCollection($models);&#125; shouldSelect函数加载了中间表的字段属性：123456789101112131415161718192021222324252627282930/** * Set the select clause for the relation query. * * @param array $columns * @return array */protected function shouldSelect(array $columns = ['*'])&#123; if ($columns == ['*']) &#123; $columns = [$this-&gt;related-&gt;getTable().'.*']; &#125; return array_merge($columns, [$this-&gt;getQualifiedFirstKeyName().' as laravel_through_key']);&#125;/** * Get the pivot columns for the relation. * * "pivot_" is prefixed ot each column for easy removal later. * * @return array */protected function aliasedPivotColumns()&#123; $defaults = [$this-&gt;foreignPivotKey, $this-&gt;relatedPivotKey]; return collect(array_merge($defaults, $this-&gt;pivotColumns))-&gt;map(function ($column) &#123; return $this-&gt;table.'.'.$column.' as pivot_'.$column; &#125;)-&gt;unique()-&gt;all();&#125; 可以看到，这个时候，中间表的属性会被放入related模型中，并且会被赋予别名前缀pivot_。 接着hydratePivotRelation会将这些中间表属性加载到中间表模型中：1234567891011121314151617181920212223242526272829303132333435363738394041/** * Hydrate the pivot table relationship on the models. * * @param array $models * @return void */protected function hydratePivotRelation(array $models)&#123; // To hydrate the pivot relationship, we will just gather the pivot attributes // and create a new Pivot model, which is basically a dynamic model that we // will set the attributes, table, and connections on it so it will work. foreach ($models as $model) &#123; $model-&gt;setRelation($this-&gt;accessor, $this-&gt;newExistingPivot( $this-&gt;migratePivotAttributes($model) )); &#125;&#125;/** * Get the pivot attributes from a model. * * @param \Illuminate\Database\Eloquent\Model $model * @return array */protected function migratePivotAttributes(Model $model)&#123; $values = []; foreach ($model-&gt;getAttributes() as $key =&gt; $value) &#123; // To get the pivots attributes we will just take any of the attributes which // begin with "pivot_" and add those to this arrays, as well as unsetting // them from the parent's models since they exist in a different table. if (strpos($key, 'pivot_') === 0) &#123; $values[substr($key, 6)] = $value; unset($model-&gt;$key); &#125; &#125; return $values;&#125; accessor默认值为pivot，我们也可以在定义多对多的时候使用as函数为它取别名：1return $this-&gt;belongsToMany('App\Role')-&gt;as(‘role_user’); 源码：123456789101112/** * Specify the custom pivot accessor to use for the relationship. * * @param string $accessor * @return $this */public function as($accessor)&#123; $this-&gt;accessor = $accessor; return $this;&#125; 关联模型的预加载with函数当作为属性访问Eloquent关联时，关联数据是「懒加载」的。意味着在你第一次访问该属性时，才会加载关联数据。不过，当你查询父模型时，Eloquent还可以进行「预加载」关联数据。预加载避免了N + 1查询问题。 预加载可以一次操作中预加载关联模型并且自定义用于select的列，可以预加载几个不同的关联，还可以预加载嵌套关联，预加载关联数据的时候，为查询指定额外的约束条件： 1234567$books = App\Book::with(['author:id,name'])-&gt;get();$books = App\Book::with(['author', 'publisher'])-&gt;get();$books = App\Book::with('author.contacts')-&gt;get();$users = App\User::with(['posts' =&gt; function ($query) &#123; $query-&gt;where('title', 'like', '%first%');&#125;])-&gt;get(); 我们来看看with函数：123456789101112/** * Begin querying a model with eager loading. * * @param array|string $relations * @return \Illuminate\Database\Eloquent\Builder */public static function with($relations)&#123; return static::query()-&gt;with( is_string($relations) ? func_get_args() : $relations );&#125; 预加载调用Eloquent/builder的with函数： 1234567891011121314/** * Set the relationships that should be eager loaded. * * @param mixed $relations * @return $this */public function with($relations)&#123; $eagerLoad = $this-&gt;parseWithRelations(is_string($relations) ? func_get_args() : $relations); $this-&gt;eagerLoad = array_merge($this-&gt;eagerLoad, $eagerLoad); return $this;&#125; eagerLoad成员变量用于存放预加载的关联关系，parseWithRelations用于解析关联关系：12345678910111213141516171819202122232425262728293031323334/** * Parse a list of relations into individuals. * * @param array $relations * @return array */protected function parseWithRelations(array $relations)&#123; $results = []; foreach ($relations as $name =&gt; $constraints) &#123; // If the "name" value is a numeric key, we can assume that no constraints // have been specified. We will just put an empty Closure there so that // we can treat these all the same while we are looping through them. if (is_numeric($name)) &#123; $name = $constraints; [$name, $constraints] = Str::contains($name, ':') ? $this-&gt;createSelectWithConstraint($name) : [$name, static function () &#123; // &#125;]; &#125; // We need to separate out any nested includes, which allows the developers // to load deep relationships using "dots" without stating each level of // the relationship with its own key in the array of eager-load names. $results = $this-&gt;addNestedWiths($name, $results); $results[$name] = $constraints; &#125; return $results;&#125; 当我们在模型关系中写入:符合的时候，说明我们不想select *，而是想要只查询特定的字段，createSelectWithConstraint：123456789101112/** * Create a constraint to select the given columns for the relation. * * @param string $name * @return array */protected function createSelectWithConstraint($name)&#123; return [explode(':', $name)[0], static function ($query) use ($name) &#123; $query-&gt;select(explode(',', explode(':', $name)[1])); &#125;];&#125; 也就是为关联关系添加select条件。 当我们想要进行嵌套查询的时候，需要在关联关系中写下“.”，addNestedWiths： 1234567891011121314151617181920212223242526/** * Parse the nested relationships in a relation. * * @param string $name * @param array $results * @return array */protected function addNestedWiths($name, $results)&#123; $progress = []; // If the relation has already been set on the result array, we will not set it // again, since that would override any constraints that were already placed // on the relationships. We will only set the ones that are not specified. foreach (explode('.', $name) as $segment) &#123; $progress[] = $segment; if (! isset($results[$last = implode('.', $progress)])) &#123; $results[$last] = static function () &#123; // &#125;; &#125; &#125; return $results;&#125; 可以看到，addNestedWiths为嵌套的模型关系赋予默认的空闭包函数，例如a.b.c，addNestedWiths返回的results数组中会有三个成员:a、a.b、a.b.c，这三个变量的闭包函数都是空。 接下来，parseWithRelations为a.b.c的闭包函数重新赋值，将用户定义的约束条件赋予给a.b.c。 get函数预加载with函数为Laravel提供了需要预加载的关联关系，get函数在从数据库中获取父模型的数据后，会将需要预加载的模型也一并取出来：12345678910public function get($columns = ['*'])&#123; $builder = $this-&gt;applyScopes(); if (count($models = $builder-&gt;getModels($columns)) &gt; 0) &#123; $models = $builder-&gt;eagerLoadRelations($models); &#125; return $builder-&gt;getModel()-&gt;newCollection($models);&#125; 顾名思义eagerLoadRelations函数就是获取预加载模型的的函数：12345678910111213public function eagerLoadRelations(array $models)&#123; foreach ($this-&gt;eagerLoad as $name =&gt; $constraints) &#123; // For nested eager loads we'll skip loading them here and they will be set as an // eager load on the query to retrieve the relation so that they will be eager // loaded on that query, because that is where they gethydrated as models. if (strpos($name, '.') === false) &#123; $models = $this-&gt;eagerLoadRelation($models, $name, $constraints); &#125; &#125; return $models;&#125; 在这里，很让人费解的是if条件，这个条件语句看起来排除了嵌套预加载关系。例如上面的a.b.c，eagerLoadRelations 只会加载a这个关联关系。 其实原因是： 1// For nested eager loads we&apos;ll skip loading them here and they will be set as an eager load on the query to retrieve the relation so that they will be eager loaded on that query, because that is where they get hydrated as models. 翻译过来就是说，嵌套预加载要一步一步的来，第一次只加载a，获得了a的关联模型之后，第二次再加载b，最后加载c。这里看不懂没关系，答案在下面的代码中：1234567891011protected function eagerLoadRelation(array $models, $name, Closure $constraints)&#123; $relation = $this-&gt;getRelation($name); $relation-&gt;addEagerConstraints($models); $constraints($relation); return $relation-&gt;match( $relation-&gt;initRelation($models, $name), $relation-&gt;getEager(), $name );&#125; eagerLoadRelation 是预加载关联关系的核心，我们可以看到加载关联模型关系主要有四个步骤： 通过关系名来调用hasOne等函数来加载模型关系relation 利用models来为模型关系添加约束条件 调用with函数附带的约束条件 从数据库获取关联模型并匹配到各个父模型中，作为父模型的属性 我们先从调用关联函数getRelation来说： getRelation123456789101112131415161718public function getRelation($name)&#123; $relation = Relation::noConstraints(function () use ($name)&#123; try &#123; return $this-&gt;getModel()-&gt;&#123;$name&#125;(); &#125; catch (BadMethodCallException $e) &#123; throw RelationNotFoundException::make($this-&gt;getModel(), $name); &#125; &#125;); $nested = $this-&gt;relationsNestedUnder($name); if (count($nested) &gt; 0) &#123; $relation-&gt;getQuery()-&gt;with($nested); &#125; return $relation;&#125; 我们在上一个文章说过， hasOne 等函数会自动加约束条件例如：select phone where phone.user_id = user.id但是这个约束条件并不适用于预加载，因为预加载的父模型通常不只只一个。因此需要调用函数 noConstraints 来避免加载约束条件:12345678910public static function noConstraints(Closure $callback)&#123; $previous = static::$constraints; static::$constraints = false; try &#123; return call_user_func($callback); &#125; finally &#123; static::$constraints = $previous; &#125;&#125; 接下来，就要调用定义关联的函数：return $this-&gt;getModel()-&gt;{$name}();下面的 relationsNestedUnder 函数用于加载嵌套的预加载关联关系：123456789101112131415protected function relationsNestedUnder($relation)&#123; $nested = []; foreach ($this-&gt;eagerLoad as $name =&gt; $constraints) &#123; if ($this-&gt;isNestedUnder($relation, $name)) &#123; $nested[substr($name, strlen($relation.'.'))] = $constraints; &#125; &#125; return $nested;&#125;protected function isNestedUnder($relation, $name)&#123; return Str::contains($name, '.') &amp;&amp; Str::startsWith($name, $relation.'.');&#125; 从代码上可以看出来，如果当前的模型关系是 a ， relationsNestedUnder函数会把其嵌套的关系都检测出来： a.b 、 a.b.c ，并且放入 nested 数组中： nested[b]、nested[b.c] 。接下来：123if (count($nested) &gt; 0) &#123; $relation-&gt;getQuery()-&gt;with($nested);&#125; 就会继续递归预加载关联关系。关联关系预加载约束条件获得关联关系之后，就要加载各个关联关系自己的预加载约束条件：123456public function addEagerConstraints(array $models)&#123; $this-&gt;query-&gt;whereIn( $this-&gt;foreignKey, $this-&gt;getKeys($models, $this-&gt;localKey) );&#125; 也就是从父模型的外键来为关联模型添加 where 条件。当然各个关联关系不同，这个函数也有一定的区别。with 预加载约束条件接下来还有加载 with 函数的约束条件 ：$constraints($relation);匹配父模型当关联关系的约束条件都设置完毕后，就要从数据库中来获取关联模型：123456789$relation-&gt;match( $relation-&gt;initRelation($models, $name), $relation-&gt;getEager(), $name);public function getEager()&#123; return $this-&gt;get();&#125; initRelation 会为父模型设置默认的关联模型：1234567public function initRelation(array $models, $relation)&#123;foreach ($models as $model) &#123;$model-&gt;setRelation($relation, $this-&gt;getDefaultFor($model));&#125;return $models;&#125; 两步都做好了，接下来就要为父模型和子模型进行匹配了：1234567891011121314151617181920212223public function match(array $models, Collection $results, $relation)&#123; return $this-&gt;matchOne($models, $results, $relation);&#125;public function matchOne(array $models, Collection $results, $relation)&#123; return $this-&gt;matchOneOrMany($models, $results, $relation, 'one');&#125;protected function matchOneOrMany(array $models, Collection $results, $relation, $type)&#123; $dictionary = $this-&gt;buildDictionary($results); foreach ($models as $model) &#123; if (isset($dictionary[$key = $model-&gt;getAttribute($this-&gt;localKey)])) &#123; $model-&gt;setRelation( $relation, $this-&gt;getRelationValue($dictionary, $key, $type) ); &#125; &#125; return $models;&#125; 匹配的过程分为两步：创建目录 buildDictionary 和设置子模型setRelation ：123456789protected function buildDictionary(Collection $results)&#123; $dictionary = []; $foreign = $this-&gt;getForeignKeyName(); foreach ($results as $result) &#123; $dictionary[$result-&gt;&#123;$foreign&#125;][] = $result; &#125; return $dictionary;&#125; 创建目录buildDictionary函数根据子模型的外键foreign将子模型进行分类，拥有同一外键的子模型放入同一个数组中。接下来，为父模型设置子模型： 12345678910111213foreach ($models as $model) &#123; if (isset($dictionary[$key = $model-&gt;getAttribute($this-&gt;localKey)])) &#123; $model-&gt;setRelation( $relation, $this-&gt;getRelationValue($dictionary, $key, $type) ); &#125;&#125;protected function getRelationValue(array $dictionary, $key, $type)&#123; $value = $dictionary[$key]; return $type == 'one' ? reset($value) : $this-&gt;related-&gt;newCollection($value);&#125; 如果目录dictionary中存在父模型的主键，就会从目录中取出对应的子模型数组，并利用setRelation来为父模型设置关联模型。 关联模型的关联查询基于存在的关联查询官方样例：12345678910// 获得所有至少有一条评论的文章...$posts = App\Post::has('comments')-&gt;get();// 获得所有有三条或三条以上评论的文章...$posts = Post::has('comments', '&gt;=', 3)-&gt;get();// 获得所有至少有一条获赞评论的文章...$posts = Post::has('comments.votes')-&gt;get();// 获得所有至少有一条评论内容满足 foo% 条件的文章$posts = Post::whereHas('comments', function ($query) &#123;$query-&gt;where('content', 'like', 'foo%');&#125;)-&gt;get(); has 函数用于基于存在的关联查询：123456789101112131415161718public function has($relation, $operator = '&gt;=', $count = 1, $boolean = 'and', Closure $callback = null)&#123;if (strpos($relation, '.') !== false) &#123;return $this-&gt;hasNested($relation, $operator, $count, $boolean, $callback);&#125;$relation = $this-&gt;getRelationWithoutConstraints($relation);$method = $this-&gt;canUseExistsForExistenceCheck($operator, $count)? 'getRelationExistenceQuery': 'getRelationExistenceCountQuery';$hasQuery = $relation-&gt;&#123;$method&#125;($relation-&gt;getRelated()-&gt;newQuery(), $this);if ($callback) &#123;$hasQuery-&gt;callScope($callback);&#125;return $this-&gt;addHasWhere($hasQuery, $relation, $operator, $count, $boolean);&#125; has函数的步骤： 获取无约束的关联关系 为关联关系添加existence约束 为关联关系添加has外部约束 将关联关系添加到where条件中 无约束的关联关系123456protected function getRelationWithoutConstraints($relation)&#123;return Relation::noConstraints(function () use ($relation) &#123;return $this-&gt;getModel()-&gt;&#123;$relation&#125;();&#125;);&#125; 这个不用多说，和预加载的原理一样。existence 约束关系模型的 existence 约束条件很简单：select * from post where user.id = post.user_idLaravel 还考虑一种特殊情况，那就是自己关联自己，这个时候就会为模型命名一个新的 hash ：1select * from user as wedfklk where user.id = wedfklk.foreignKey 源代码比较简单：123456789101112131415161718192021222324252627public function getRelationExistenceQuery(Builder $query, Builder $parentQuery, $columns = ['*'])&#123;if ($query-&gt;getQuery()-&gt;from == $parentQuery-&gt;getQuery()-&gt;from) &#123;return $this-&gt;getRelationExistenceQueryForSelfRelation($query, $parentQuery, $columns);&#125;return parent::getRelationExistenceQuery($query, $parentQuery, $columns);&#125;public function getRelationExistenceQueryForSelfRelation(Builder$query, Builder $parentQuery, $columns = ['*'])&#123;$query-&gt;from($query-&gt;getModel()-&gt;getTable().' as '.$hash = $this-&gt;getRelationCountHash());$query-&gt;getModel()-&gt;setTable($hash);return $query-&gt;select($columns)-&gt;whereColumn($this-&gt;getQualifiedParentKeyName(), '=', $hash.'.'.$this-&gt;getForeignKeyName());&#125;public function getRelationExistenceQuery(Builder $query, Builder $parentQuery, $columns = ['*'])&#123;return $query-&gt;select($columns)-&gt;whereColumn($this-&gt;getQualifiedParentKeyName(), '=', $this-&gt;getExistenceCompareKey());&#125;public function getExistenceCompareKey()&#123;return $this-&gt;getQualifiedForeignKeyName();&#125; ExistenceCount 约束ExistenceCount 约束只是 select 变成了 select count(\) :1234567select count(\*) from post where user.id = post.user_id源代码：```phppublic function getRelationExistenceCountQuery(Builder $query, Builder $parentQuery)&#123; return $this-&gt;getRelationExistenceQuery($query, $parentQuery, new Expression('count(*)'));&#125; 关联关系添加到 where 条件当关联关系的 存在 约束设置完毕后，就要加载到父模型的 where 条件中，一般会作为父模型的子查询：123456789101112131415161718192021222324protected function addHasWhere(Builder $hasQuery, Relation $relation, $operator, $count, $boolean)&#123; $hasQuery-&gt;mergeConstraintsFrom($relation-&gt;getQuery()); return $this-&gt;canUseExistsForExistenceCheck($operator, $count) ? $this-&gt;addWhereExistsQuery($hasQuery-&gt;toBase(), $boolean, $operator === '&lt;' &amp;&amp; $count === 1) : $this-&gt;addWhereCountQuery($hasQuery-&gt;toBase(), $operator, $count, $boolean);&#125;public function addWhereExistsQuery(Builder $query, $boolean = 'and', $not = false)&#123; $type = $not ? 'NotExists' : 'Exists'; $this-&gt;wheres[] = compact('type', 'operator', 'query', 'boolean'); $this-&gt;addBinding($query-&gt;getBindings(), 'where'); return $this;&#125;protected function addWhereCountQuery(QueryBuilder $query, $operator = '&gt;=', $count = 1, $boolean = 'and')&#123; $this-&gt;query-&gt;addBinding($query-&gt;getBindings(), 'where'); return $this-&gt;where(new Expression('('.$query-&gt;toSql().')'),$operator,is_numeric($count) ? new Expression($count) : $count,$boolean );&#125; existence 约束最后条件：1select * from user where exists (select * from phone where phone.user_id=user.id) ExistenceCount 约束:1select * from user where (select count(*) from phone where phone.user_id=user.id) &gt;= 3 嵌套查询嵌套查询需要进行递归来调用has函数：12345678910111213141516protected function hasNested($relations, $operator = '&gt;=', $count = 1, $boolean = 'and', $callback = null)&#123;$relations = explode('.', $relations);$closure = function ($q) use (&amp;$closure, &amp;$relations, $operator, $count, $callback) &#123;count($relations) &gt; 1? $q-&gt;whereHas(array_shift($relations), $closure): $q-&gt;has(array_shift($relations), $operator, $count, 'and', $callback);&#125;;return $this-&gt;has(array_shift($relations), '&gt;=', 1, $boolean, $closure);&#125;public function whereHas($relation, Closure $callback = null, $operator = '&gt;=', $count = 1)&#123;return $this-&gt;has($relation, $operator, $count, 'and', $callback);&#125; 例如1$posts = Post::has('comments.votes')-&gt;get(); 首先 hasNested 会返回：1234$this-&gt;has('comments', '&gt;=', 1, 'and', function ($q) use (&amp;$closure, ‘votes’, '&gt;=', 1, $callback) &#123;$q-&gt;has(‘votes’, '&gt;=', 1, 'and', $callback);&#125;); 生成的sql：1select * from post where exist (select * from comment where comment.post_id=post.id and where exist (select * from vote where vote.comment_id=comment.id)) 基于不存在的关联查询基于不存在的关联查询只是基于存在的关联查询123456789101112131415161718192021222324/** * Add a relationship count / exists condition to the query. * * @param string $relation * @param string $boolean * @param \Closure|null $callback * @return \Illuminate\Database\Eloquent\Builder|static */public function doesntHave($relation, $boolean = 'and', Closure $callback = null)&#123; return $this-&gt;has($relation, '&lt;', 1, $boolean, $callback);&#125;/** * Add a relationship count / exists condition to the query with where clauses. * * @param string $relation * @param \Closure|null $callback * @return \Illuminate\Database\Eloquent\Builder|static */public function whereDoesntHave($relation, Closure $callback = null)&#123; return $this-&gt;doesntHave($relation, 'and', $callback);&#125; 关联数据计数 如果您只想统计结果数而不需要加载实际数据，那么可以使用 withCount 方法，此方法会在您的结果集模型中添加一个 {关联名}_count 字段。例如：1234567891011121314151617181920212223$posts = App\Post::withCount('comments')-&gt;get();//select *,(select count(*) from comment where comment.post_id=post.id) as comments_count from postforeach ($posts as $post) &#123; echo $post-&gt;comments_count;&#125;//多个关联数据「计数」，并为其查询添加约束条件：$posts = Post::withCount(['votes', 'comments' =&gt; function ($query) &#123; $query-&gt;where('content', 'like', 'foo%');&#125;])-&gt;get();//select *,(select count(*) from comment where comment.post_id=post.id and content like 'foo%') as comments_count,(select count(*) from votes where vote.post_id=post.id) as votes_count from postecho $posts[0]-&gt;votes_count;echo $posts[0]-&gt;comments_count;//可以为关联数据计数结果起别名，允许在同一个关联上多次计数：$posts = Post::withCount(['comments','comments as pending_comments_count' =&gt; function ($query) &#123; $query-&gt;where('approved', false);&#125;])-&gt;get();//select *,(select count(*) from comment where comment.post_id=post.id) as comments_count,(select count(*) from comment where comment.post_id=post.id and approved=false) as pending_comments_count from postecho $posts[0]-&gt;comments_count;echo $posts[0]-&gt;pending_comments_count; withCount的源代码与has的代码高度相似：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Add subselect queries to count the relations. * * @param mixed $relations * @return $this */public function withCount($relations)&#123; if (empty($relations)) &#123; return $this; &#125; if (is_null($this-&gt;query-&gt;columns)) &#123; $this-&gt;query-&gt;select([$this-&gt;query-&gt;from.'.*']); &#125; $relations = is_array($relations) ? $relations : func_get_args(); foreach ($this-&gt;parseWithRelations($relations) as $name =&gt; $constraints) &#123; // First we will determine if the name has been aliased using an "as" clause on the name // and if it has we will extract the actual relationship name and the desired name of // the resulting column. This allows multiple counts on the same relationship name. $segments = explode(' ', $name); unset($alias); if (count($segments) === 3 &amp;&amp; Str::lower($segments[1]) === 'as') &#123; [$name, $alias] = [$segments[0], $segments[2]]; &#125; $relation = $this-&gt;getRelationWithoutConstraints($name); // Here we will get the relationship count query and prepare to add it to the main query // as a sub-select. First, we'll get the "has" query and use that to get the relation // count query. We will normalize the relation name then append _count as the name. $query = $relation-&gt;getRelationExistenceCountQuery( $relation-&gt;getRelated()-&gt;newQuery(), $this ); $query-&gt;callScope($constraints); $query = $query-&gt;mergeConstraintsFrom($relation-&gt;getQuery())-&gt;toBase(); $query-&gt;orders = null; $query-&gt;setBindings([], 'order'); if (count($query-&gt;columns) &gt; 1) &#123; $query-&gt;columns = [$query-&gt;columns[0]]; $query-&gt;bindings['select'] = []; &#125; // Finally we will add the proper result column alias to the query and run the subselect // statement against the query builder. Then we will return the builder instance back // to the developer for further constraint chaining that needs to take place on it. $column = $alias ?? Str::snake($name.'_count'); $this-&gt;selectSub($query, $column); &#125; return $this;&#125; 解析关联关系名称 获取无约束的关联关系 为关联关系添加existenceCount约束 为关联关系添加with外部约束 将关联关系添加到where条件中 设置alias别名 创建select子查询 多对多关系的中间表查询12345678910111213141516171819202122232425262728293031323334return $this-&gt;belongsToMany('App\Role')-&gt;wherePivot('approved', 1);return $this-&gt;belongsToMany('App\Role')-&gt;wherePivotIn('priority', [1, 2]);/** * Set a where clause for a pivot table column. * * @param string $column * @param string|null $operator * @param mixed $value * @param string $boolean * @return $this */public function wherePivot($column, $operator = null, $value = null, $boolean = 'and')&#123; $this-&gt;pivotWheres[] = func_get_args(); return $this-&gt;where($this-&gt;table.'.'.$column, $operator, $value, $boolean);&#125;/** * Set a "where in" clause for a pivot table column. * * @param string $column * @param mixed $values * @param string $boolean * @param bool $not * @return $this */public function wherePivotIn($column, $values, $boolean = 'and', $not = false)&#123; $this-&gt;pivotWhereIns[] = func_get_args(); return $this-&gt;whereIn($this-&gt;table.'.'.$column, $values, $boolean, $not);&#125; 注意这里的pivotWheres与pivotWheres变量，这个变量在对中间表的加载中会被使用：12345678910111213141516171819/** * Create a new query builder for the pivot table. * * @return \Illuminate\Database\Query\Builder */public function newPivotQuery()&#123; $query = $this-&gt;newPivotStatement(); foreach ($this-&gt;pivotWheres as $arguments) &#123; call_user_func_array([$query, 'where'], $arguments); &#125; foreach ($this-&gt;pivotWhereIns as $arguments) &#123; call_user_func_array([$query, 'whereIn'], $arguments); &#125; return $query-&gt;where($this-&gt;foreignPivotKey, $this-&gt;parent-&gt;&#123;$this-&gt;parentKey&#125;);&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的B+树索引的概念、使用、优化及使用场景]]></title>
    <url>%2F2020%2F05%2F28%2FMySQL%E7%9A%84B-%E6%A0%91%E7%B4%A2%E5%BC%95%E7%9A%84%E6%A6%82%E5%BF%B5%E3%80%81%E4%BD%BF%E7%94%A8%E3%80%81%E4%BC%98%E5%8C%96%E5%8F%8A%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 索引的管理索引有很多种类型：普通索引、唯一索引、主键索引、组合索引、全文索引。 使用SHOW INDEX命令查看索引信息 如果想要查看表中的索引信息，可以使用命令SHOW INDEX，下面的例子，我们查看表table_index的索引信息。 1SHOW INDEX FROM table_index\G; 得到上面的信息，上面的信息什么意思呢？我们逐一介绍！ 字段 解释 Table 索引所在的表 Non_unique 非唯一索引，如果是0，代表唯一的，也就是说如果该列索引中不包括重复的值则为0，否则为1 Key_name 索引的名字，如果是主键的话，则为PRIMARY Seq_in_index 索引中该列的位置，从1开始，如果是组合索引，那么按照字段在建立索引时的顺序排列 Collation 列是以什么方式存储在索引中的。可以是A或者NULL，B+树索引总是A，排序的 Sub_part 是否列的部分被索引，如果只是前100行索引，就显示100，如果是整列，就显示NULL Packed 关键字是否被压缩，如果没有，为NULL Index_type 索引的类型，对于InnoDB只支持B+树索引，所以都是显示BTREE Cardinality关键字解析在上面介绍了那么多个关键字的意思，但是Cardinality这个关键字非常的关键，优化器会根据这个值来判断是否使用这个索引。在B+树索引中，只有高选择性的字段才是有意义的，高选择性就是这个字段的取值范围很广，比如姓名字段，会有很多的名字，可选择性就高了。 一般来说，判断是否需要使用索引，就可以通过Cardinality关键字来判断，如果非常接近1，说明有必要使用，如果非常小，那么就要考虑是否使用索引了。 需要注意的一个问题是，这个关键字不是及时更新的，需要更新的话，需要使用ANALYZE TABLE，例如 1analyze table table_index; 因为目前没有数据，所以，你会发现，这个值一直都是0，没有变化。 InoDB存储引擎Cardinality的策略 在InnoDB存储引擎中，这个关键字的更新发生在两个操作中：insert和update。但是，并不是每次都会更新，这样会增加负荷，所以，对于这个关键字的更新有它的策略： 表中1/16的数据发生变化 InnoDB存储引擎的计数器stat_modified_conter&gt;2000000000 默认InnoDB存储引擎会对8个叶子节点进行采样，采样过程如下： B+树索引中叶子节点数量，记做A 随机取得B+树索引中的8个叶子节点。统计每个页不同的记录个数，分别为p1-p8 根据采样信息得到Cardinality的预估值：(p1+p2+p3+…+p8)*A/8 因为随机采样，所以，每次的Cardinality值都是不一样的，只有一种情况会一样的，就是表中的叶子节点小于或者等于8，这时候，怎么随机采样都是这8个，所以也就一样的。 Fast Index Creation在MySQL5.5之前，对于索引的添加或者删除，每次都需要创建一张临时表，然后导入数据到临时表，接着删除原表，如果一张大表进行这样的操作，会非常的耗时，这是一个很大的缺陷。 InnoDB存储引擎从1.0.x版本开始加入了一种Fast Index Creation（快速索引创建）的索引创建方式。 这种方式的策略为：每次为创建索引的表加上一个S锁（共享锁），在创建的时候，不需要重新建表，删除辅助索引只需要更新内部视图，并将辅助索引空间标记为可用，所以，这种效率就大大提高了。 在线数据定义MySQL5.6开始支持的在线数据定义操作就是：允许辅助索引创建的同时，还允许其他insert、update、delete这类DM操作，这就极大提高了数据库的可用性。 所以，我们可以使用新的语法进行创建索引： 123ALTER TABLE table_name ADD [UNIQUE|FULLLTEXT] INDEX index_name (column(length))[ALGORITHM = &#123;DEFAULT|INPLACE|COPY&#125;][LOCK = &#123;DEFAULT|NONE|SHARED|EXLUSIVE&#125;] ALGORITHM指定创建或者删除索引的算法 COPY：创建临时表的方式 INPLACE：不需要创建临时表 DEFAULT：根据参数 old_alter_table参数判断，如果是 OFF,采用 INPLACE的方式 LOCK表示对表添加锁的情况 NONE：不加任何锁 SHARE：加一个S锁，并发读可以进行，写操作需要等待 EXCLUSIVE：加一个X锁，读写都不能并发进行 DEFAULT：先判断是否可以使用NONE，如不能，判断是否可以使用SHARE，如不能，再判断是否可以使用EXCLUSIVE模式。 B+树索引的使用联合索引联合索引是指对表上的多个列进行索引，这一部分我们将通过几个例子来讲解联合索引的相关知识点。 首先，我们先创建一张表以及为这张表创建联合索引。 123456create table t_index(a char(2) not null default '',b char(2) not null default '',c char(2) not null default '',d char(2) not null default '')engine myisam charset utf8; 创建联合索引 1alter table t_index add index abcd(a,b,c,d); 插入几条测试数据 123456insert into t_index values('a','b','c','d'),('a2','b2','c2','d2'),('a3','b3','c3','d3'),('a4','b4','c4','d4'),('a5','b5','c5','d5'),('a6','b6','c6','d6'); 到这一步，我们已经基本准备好了需要的数据，我们可以进行更深一步的联合索引的探讨。 我们什么时候需要创建联合索引呢索引建立的主要目的就是为了提高查询的效率，那么联合索引的目的也是类似的，联合索引的目的就是为了提高存在多个查询条件的情况下的效率，就如上面建立的表一样，有多个字段，当我们需要利用多个字段进行查询的时候，我们就需要利用到联合索引了。 什么时候联合索引才会发挥作用呢有时候，我们会用联合索引，但是，我们并不清楚其原理，不知道什么时候联合索引会起到作用，什么时候又是会失效的？ 带着这个问题，我们了解一下联合索引的最左匹配原则。 最左匹配原则：这个原则的意思就是创建组合索引，以最左边的为准，只要查询条件中带有最左边的列，那么查询就会使用到索引。 下面，我们用几个例子来看看这个原则。 1EXPLAIN SELECT * FROM t_index WHERE a = 'a' \G; 我们看看这条语句的结果，首先，我们看到使用了索引，因为查询条件中带有最左边的列a，那么利用了几个索引呢？这个我们需要看key_len这个字段，我们知道utf8编码的一个字符3个字节，而我们使用的数据类型是 char(2)，占两个字节，索引就是2*3等于6个字节，所以只有一个索引起到了作用。 1EXPLAIN SELECT * FROM t_index WHERE b = 'b2' \G; 这个语句我们可以看出，这个没有使用索引，因为possible_keys为空，而且，从查询的行数 rows可以看出为6（我们测试数据总共6条），说明进行了全盘扫描的，说明这种情况是不符合最左匹配原则，所以不会使用索引查询。 1EXPLAIN SELECT * FROM t_index WHERE a = 'a2' AND b = 'b2' ORDER BY d \G; 这种情况又有点不一样了，我们使用了一个排序，可以看出使用了索引，通过key_len为12可以得到使用了2个索引a、b，另外在Extra选项中可以看到使用了Using filesort，也就是文件排序，这里使用文件排序的原因是这样的：上面的查询使用了a、b索引，但是当我们用d字段来排序时，（a，d）或者（b，d）这两个索引是没有排序的，联合索引的使用有一个好处，就是索引的下一个字段是会自动排序的，在这里的这种情况来说，c字段就是排序的，但是d是不会，如果我们用c来排序就会得到不一样的结果。 1EXPLAIN SELECT * FROM t_index WHERE a = 'a2' AND b = 'b2' ORDER BY c \G; 是不是可以看到，当我们用c进行排序的时候，因为使用了a、b索引，所以c就自动排序了，所以也就不用filesort了。 讲到这里，我相信通过上面的几个例子，对于联合索引的相关知识已经非常的透彻清晰了，最后，我们再来聊几个常见的问题。 Q1：为什么不对表中的每一个列创建一个索引呢 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 Q2：为什么需要使用联合索引 减少开销。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3)三个索引。每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！ 覆盖索引。对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机io操作。减少io操作，特别的随机io其实是dba主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。 效率高。索引列越多，通过索引筛选出的数据越少。有1000W条数据的表，有如下sql:select from table where col1=1 and col2=2 and col3=3,假设假设每个条件可以筛选出10%的数据，如果只有单值索引，那么通过该索引能筛选出1000W10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页；如果是联合索引，通过索引筛选出1000w10% 10% *10%=1w，效率提升可想而知！ 覆盖索引覆盖索引是一种从辅助索引中就可以得到查询的记录，而不需要查询聚集索引中的记录，使用覆盖索引的一个好处是辅助索引不包含整行记录的所有信息，所以大小远小于聚集索引，因此可以大大减少IO操作。覆盖索引的另外一个好处就是对于统计问题有优化，我们看下面的一个例子。 1explain select count(*) from t_index \G; 如果是myisam引擎，Extra列会输出 Select tables optimized away语句，myisam引擎已经保存了记录的总数，直接返回结果，就不需要覆盖索引优化了。 如果是InnoDB引擎，Extra列会输出 Using index语句，说明InnoDB引擎优化器使用了覆盖索引操作。 索引提示MySQL数据库支持索引提示功能，索引提示功能就是我们可以显示的告诉优化器使用哪个索引，一般有下面两种情况可能使用到索引提示功能（INDEX HINT）： MySQL数据库的优化器错误的选择了某个索引，导致SQL运行很慢 某SQL语句可以选择的索引非常的多，这时优化器选择执行计划时间的开销可能会大于SQL语句本身。 这里我们接着上面的例子来讲解，首先，我们先为上面的t_index表添加几个索引； 123alter table t_index add index a (a);alter table t_index add index b (b);alter table t_index add index c (c); 接着，我们执行下面的语句； 1EXPLAIN SELECT * FROM t_index WHERE a = 'a' AND b = 'b' AND c = 'c' \G; 你会发现这条语句就可以使用三个索引，这个时候，我们可以显示的使用索引提示来使用a这个索引，如下： 1EXPLAIN SELECT * FROM t_index USE INDEX(a) WHERE a = 'a' AND b = 'b' AND c = 'c' \G; 这样就显示的使用索引a了，如果这种方式有时候优化器还是没有选择你想要的索引，那么，我们可以另外一种方式 FORCE INDEX。 1EXPLAIN SELECT * FROM t_index FORCE INDEX(a) WHERE a = 'a' AND b = 'b' AND c = 'c' \G; 这种方式则一定会选择你想要的索引。 索引优化Multi-Range Read优化 MySQL5.6开始支持，这种优化的目的是为了减少磁盘的随机访问，并且将随机访问转化为较为顺序的数据访问，这种优化适用于range、ref、eq_ref类型的查询。 Multi-Range Read 优化的好处： 让数据访问变得较为顺序。 减少缓冲区中页被替换的次数。 批量处理对键值的查询操作。 我们可以使用参数 optimizer_switch中的标记来控制是否开启Multi-Range Read优化。下面的方式将设置为总是开启状态： 1SET @@optimizer_switch='mrr=on,mrr_cost_based=off'; Index Condition Pushdown（ICP）优化 这种优化方式也是从MySQL5.6开始支持的，不支持这种方式之前，当进行索引查询时，首先我们先根据索引查找记录，然后再根据where条件来过滤记录。然而，当支持ICP优化后，MySQL数据库会在取出索引的同时，判断是否可以进行where条件过滤，也就是将where过滤部分放在了存储引擎层，大大减少了上层SQL对记录的索取。 ICP支持range、ref、eq_ref、ref_or_null类型的查询，当前支持MyISAM和InnoDB存储引擎。 我们可以使用下面语句开启ICP： 1set @@optimizer_switch = "index_condition_pushdown=on" 或者关闭： 1set @@optimizer_switch = "index_condition_pushdown=off" 当开启了ICP之后，在执行计划Extra可以看到 Using index condition提示。 索引的特点、优点、缺点及适用场景索引的特点 可以加快数据库的检索速度 降低数据库插入、修改、删除等维护的速度 只能创建在表上，不能创建在视图上 既可以直接创建也可以间接创建 索引的优点 创建唯一性索引，保证数据库表中的每一行数据的唯一性 大大加快数据的检索速度 加快数据库表之间的连接，特别是在实现数据的参考完整性方面特别有意义 在使用分组和排序字句进行数据检索时，同样可以显著减少查询的时间 通过使用索引，可以在查询中使用优化隐藏器，提高系统性能 索引的缺点 第一，创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。 第二，索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果要建立聚簇索引，那么需要的空间就会更大。 第三，当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。 索引的适用场景 匹配全值 对索引中所有列都指定具体值，即是对索引中的所有列都有等值匹配的条件。 匹配值的范围查询 对索引的值能够进行范围查找。 匹配最左前缀 仅仅使用索引中的最左边列进行查询，比如在 col1 + col2 + col3 字段上的联合索引能够被包含 col1、(col1 + col2)、（col1 + col2 + col3）的等值查询利用到，可是不能够被 col2、（col2、col3）的等值查询利用到。最左匹配原则可以算是 MySQL 中 B-Tree 索引使用的首要原则。 仅仅对索引进行查询 当查询的列都在索引的字段中时，查询的效率更高，所以应该尽量避免使用 select *，需要哪些字段，就只查哪些字段。 匹配列前缀 仅仅使用索引中的第一列，并且只包含索引第一列的开头一部分进行查找。 能够实现索引匹配部分精确而其他部分进行范围匹配 如果列名是索引，那么使用 column_name is null 就会使用索引，例如下面的就会使用索引： 1explain select * from t_index where a is null \G 经常出现在关键字order by、group by、distinct后面的字段 在union等集合操作的结果集字段 经常用作表连接的字段 考虑使用索引覆盖，对数据很少被更新，如果用户经常值查询其中你的几个字段，可以考虑在这几个字段上建立索引，从而将表的扫描变为索引的扫描 索引失效情况 以%开头的like查询不能利用B-Tree索引，执行计划中key的值为null表示没有使用索引 数据类型出现隐式转换的时候也不会使用索引，例如，where ‘age’+10=30 对索引列进行函数运算，原因同上 正则表达式不会使用索引 字符串和数据比较不会使用索引 复合索引的情况下，假如查询条件不包含索引列最左边部分，即不满足最左原则leftmost，是不会使用复合索引的 如果MySQL估计使用索引比全表扫描更慢，则不使用索引 用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到 使用负向查询（not ，not in， not like ，&lt;&gt; ,!= ,!&gt; ,!&lt; ）不会使用索引]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务，这篇文章就够了]]></title>
    <url>%2F2020%2F05%2F28%2FMySQL%E4%BA%8B%E5%8A%A1%EF%BC%8C%E8%BF%99%E7%AF%87%E6%96%87%E7%AB%A0%E5%B0%B1%E5%A4%9F%E4%BA%86%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是事务事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。 同时，事务有着严格的地定义，必须满足四个特性，也就是我们一直说的ACID，但是，并不是说各种数据库就一定会满足四个特性，对于不同的数据库的实现来说，在不同程度上是不一定完全满足要求的，比如，Oracle数据库来说，默认的事务隔离级别是READ COMMITTED，是不满足隔离性的要求的。 下面我们趁热打铁，介绍一下事务的必知必会的四大特性，这几个特性也是在面试中，面试官面试MySQL的相关知识的时候，问的比较多的问题，所以，这几个特性务必需要理解并且透彻的记在心里！ 事务的四大特性事务的四大特性简称为：ACID，分别是原子性、一致性、隔离性和持久性。 下面我们一一来介绍一下。 原子性（Atomicity） 原子性指的是整个数据库的事务是一个不可分割的工作单位，每一个都应该是一个原子操作。 当我们执行一个事务的时候，如果一系列的操作中，有一个操作失败了，那么，需要将这一个事务中的所有操作恢复到执行事务之前的状态，这就是事务的原子性。 下面举个简单的例子。1i++; 上面这个最简单不过的代码经常也会被问到，这是一个原子操作吗？那肯定不是，如果我们把这个代码放到一个事务中来说，当i+1出现问题的时候，回滚的就是整个代码i++（i = i + 1）了，所以回滚之后，i的值也是不会改变的。 以上就是原子性的概念。 一致性（consistency） 一致性是指事务将数据库从一种状态转变为下一种一致性的状态，也就是说在事务执行前后，这两种状态应该是一样的，也就是数据库的完整性约束不会被破坏。 另外，需要注意的是一致性是不关注中间状态的，比如银行转账的过程，你转账给别人，至于中间的状态，你少了500 ，他多了500，这些中间状态不关注，如果分多次转账中间状态也是不可见的，只有最后的成功或者失败的状态是可见的。 如果到分布式的一致性问题，又可以分为强一致性、弱一致性和最终一致性，关于这些概念，可以自己查查，还是很有意思的。 隔离性（isolation） 事务我们是可以开启很多的，MySQL数据库中可以同时启动很多的事务，但是，事务和事务之间他们是相互分离的，也就是互不影响的，这就是事务的隔离性。 持久性（durability） 事务的持久性是指事务一旦提交，就是永久的了，就是发生问题，数据库也是可以恢复的。因此，持久性保证事务的高可靠性。 事务的分类事务可以分为很多种类型，一般分为：扁平事务、带有保存点的扁平事务、链事务、嵌套事务、分布式事务。 扁平事务扁平事务是最简单的一种，在实际开发中也是使用的最多的一种事务。在这种事务中，所有操作都处于同一层次，最常见的方式如下： 1234567BEGIN WORKOperation 1Operation 2Operation 3...Operation NCOMMIT WORK 举个例子1234567begin work;select * from user;update user set name = 'sihai' where id = 1;commit work; 扁平事务的主要缺点是不能提交或回滚事务的某一部分，或者分几个独立的步骤去提交。 带有保存点的扁平事务这种事务除了支持扁平事务支持的操作外，这种事务跟扁平事务最大的区别就是允许在事务执行过程中回滚到同一事务中较早的一个状态，这是因为可能某些事务在执行过程中出现的错误并不会对所有的操作都无效，放弃整个事务不合乎要求，开销也太大。保存点用来通知系统应该记住事务当前的状态，以便以后发生错误时，事务能回到该状态。 举个例子1234567891011begin work;select * from user;savepoint t1;update user set name = 'sihai' where id = 1;savepoint t2;commit work; 通过上面的方式我们就建立了两个保存点t1、t2，通过ROLLBACK TO SAVEPOINT t1，我们就可以返回到保存点t1。 链事务链事务：在提交一个事务时，释放不需要的数据对象，将必要的处理上下文隐式的传给下一个要开始的事务。需要注意，提交事务操作和下一个事务操作将合并为一个原子操作，就是下一个事务可以看到上一个事务的结果。 链事务，就是指回滚时，只能恢复到最近一个保存点；而带有保存点的扁平事务则可以回滚到任意正确的保存点。 举个例子 1234567891011begin work;select * from user;savepoint t1;update user set name = 'sihai' where id = 1;savepoint t2;commit work; 还是这个例子，但是对于链事务来说，是不能直接rollback到保存点t1的，最能恢复到最近的一个保存点t2；另外我们需要注意，链事务在执行commit后就会释放当前事务所持有的所有锁，而带有保存点的扁平事务不会影响所持有的锁。 嵌套事务在事务中再嵌套事务，这种结构有点像一颗横着的树的结构，位于根节点的事务称为顶层事务。事务的前驱称为父事务，其它事务称为子事务。事务的前驱称为父事务，事务的下一层称为子事务。 子事务既可以提交也可以回滚，但是它的提交操作并不马上生效，除非由其父事务提交。因此就可以确定，任何子事务都在顶层事务提交后才真正的被提交了。同理，任意一个事务的回滚都会引起它的所有子事务一同回滚。 123456789101112131415BEGIN WORK SubTransaction1: BEGIN WORK SubOperationX COMMIT WORK SubTransaction2: BEGIN WORK SubOperationY COMMIT WORK ... SubTransactionN: BEGIN WORK SubOperationN COMMIT WORKCOMMIT WORK 分布式事务分布式事务通常是指在一个分布式环境下运行的扁平事务，因此需要根据数据所在位置访问网络中的不同节点。 在不同的物理地址，通过网络访问，执行不同的事务，这就是分布式事务。 事务的使用首先这一部分我们还是先介绍一下这些事务的语句，也不是很多，使用也不复杂，下面用一个表格做一个整理。 注意：COMMIT和COMMIT WORK语句不同之处在于COMMIT WORK用来控制事务结束后的行为是CHAIN还是RELEASE，如果是CHAIN，那么事务就是链事务。 用户可以通过参数completion_type控制，如下： completion_type = 1 实例 执行下面的操作； 1234567SET @@completion_type = 1;BEGIN WORK;INSERT INTO lock_test SELECT 10;COMMIT WORK; 接着我们再执行下面的操作；12345INSERT INTO lock_test SELECT 115;ROLLBACK;SELECT * FROM lock_test; 我们先插入一条数据115，然后再回滚，我们知道如果不是在一个事务的时候，115应该是会插入成功的，就算我们回滚了，但是，这里我们回滚之后，查询结果如下： 这个时候并没有115这条记录，也就是回滚生效了，说明在COMMIT WORK之后，又是一个新的事务，所以才会出现这样的结果。 completion_type = 2 实例 我们先进行下面的操作； 1234567SET @@completion_type = 2;BEGIN WORK;INSERT INTO lock_test SELECT 5;COMMIT WORK; 上面我们已经提交事务了，当我们使用下面的语句查询lock_test的数据的时候，就会出现断开连接。 1SELECT * FROM lock_test; 事务的隔离级别事务的隔离级别有四种分别是： READ UNCOMMITTED READ COMMITTED REPEATABLE READ SERIALIZABLE 对于这几种隔离级别会带来的问题及总结，可以查看这篇文章：MySQL的又一神器-锁，MySQL面试必备 总结这篇文章从下面几个内容介绍了一下MySQL数据库事务的内容，更详细的其他内容在后面的文章中再讲解。 概念事务类型事务使用事务的隔离级别]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Database-数据库的CURD操作]]></title>
    <url>%2F2020%2F05%2F25%2FLaravel-Database-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%9A%84CURD%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Exception::getPrevious—返回异常链中的前一个异常。什么意思？ 前言当Connection对象构建初始化完成后，我们就可以利用DB来进行数据库的CURD（Create、Update、Retrieve、Delete）操作。本篇文章，我们将会讲述Laravel如何与PDO交互，实现基本数据库服务的原理。 源码runLaravel中任何数据库的操作都要经过run这个函数，这个函数作用在于重新连接数据库、记录数据库日志、数据库异常处理： Illuminate\Database\Connection.php 123456789101112131415161718192021222324252627282930313233343536373839/** * 运行一条SQL语句并记录其执行上下文。 * * @param string $query * @param array $bindings * @param \Closure $callback * @return mixed * * @throws \Illuminate\Database\QueryException */protected function run($query, $bindings, Closure $callback)&#123; $this-&gt;reconnectIfMissingConnection(); $start = microtime(true); // 在这里，我们将运行此查询。 // 如果发生异常，我们将确定它是否是连接丢失引起的。 // 如果是，我们将尝试重新建立连接，并使用新的连接重新运行查询。 try &#123; $result = $this-&gt;runQueryCallback($query, $bindings, $callback); &#125; catch (QueryException $e) &#123; $result = $this-&gt;handleQueryException( $e, $query, $bindings, $callback ); &#125; // 运行查询后，我们将计算运行时间， // 然后记录查询，绑定和执行时间，以便在开发人员需要它们时报告它们。 // 我们将以毫秒为单位记录时间。 $this-&gt;logQuery( $query, $bindings, $this-&gt;getElapsedTime($start) ); return $result;&#125; 重新连接数据库reconnect如果当前的pdo是空，那么就会调用reconnector重新与数据库进行连接：12345678910111213141516171819202122232425262728293031/** * 如果PDO连接丢失，重新连接数据库。 * * @return void */protected function reconnectIfMissingConnection()&#123; if (is_null($this-&gt;pdo)) &#123; $this-&gt;reconnect(); &#125;&#125;/** * 重新连接数据库。 * * @return void * * @throws \LogicException */public function reconnect()&#123; if (is_callable($this-&gt;reconnector)) &#123; $this-&gt;doctrineConnection = null; return call_user_func($this-&gt;reconnector, $this); &#125; throw new LogicException('Lost connection and no reconnector available.');&#125; 运行数据库操作数据库的CURD操作会被包装成为一个闭包函数，作为runQueryCallback的一个参数，当运行正常时，会返回结果，如果遇到异常的话，会将异常转化为QueryException，并且抛出。 123456789101112131415161718192021222324252627282930/** * 运行一个SQL语句。 * * @param string $query * @param array $bindings * @param \Closure $callback * @return mixed * * @throws \Illuminate\Database\QueryException */protected function runQueryCallback($query, $bindings, Closure $callback)&#123; // 为了执行该语句，我们将简单地调用回调，该回调实际上将针对PDO连接运行SQL。 // 然后，我们可以计算执行时间并在内存中记录查询SQL，绑定和时间。 try &#123; $result = $callback($query, $bindings); &#125; // 如果在尝试运行查询时发生异常，我们将格式化错误消息以包含SQL绑定， // 这将使该异常对开发人员有很大帮助，而不仅仅是数据库的错误。 catch (Exception $e) &#123; throw new QueryException( $query, $this-&gt;prepareBindings($bindings), $e ); &#125; return $result;&#125; 数据库异常处理当pdo查询返回异常的时候，如果当前是事务进行时，那么直接返回异常，让上一层事务来处理。 如果是由于与数据库事情连接导致的异常，那么就要重新与数据库进行连接： 1234567891011121314151617181920212223242526272829/** * 活跃事务数。 * * @var int */protected $transactions = 0;/** * 处理查询异常。 * * @param \Illuminate\Database\QueryException $e * @param string $query * @param array $bindings * @param \Closure $callback * @return mixed * * @throws \Illuminate\Database\QueryException */protected function handleQueryException(QueryException $e, $query, $bindings, Closure $callback)&#123; if ($this-&gt;transactions &gt;= 1) &#123; throw $e; &#125; return $this-&gt;tryAgainIfCausedByLostConnection( $e, $query, $bindings, $callback );&#125; 与数据库失去连接： 12345678910111213141516171819202122/** * 处理在查询执行期间发生的查询异常。 * * @param \Illuminate\Database\QueryException $e * @param string $query * @param array $bindings * @param \Closure $callback * @return mixed * * @throws \Illuminate\Database\QueryException */protected function tryAgainIfCausedByLostConnection(QueryException $e, $query, $bindings, Closure $callback)&#123; if ($this-&gt;causedByLostConnection($e-&gt;getPrevious())) &#123; $this-&gt;reconnect(); return $this-&gt;runQueryCallback($query, $bindings, $callback); &#125; throw $e;&#125; Illuminate\Database\DetectsLostConnections.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace Illuminate\Database;use Illuminate\Support\Str;use Throwable;trait DetectsLostConnections&#123; /** * 确定给定的异常是否由丢失的连接引起。 * * @param \Throwable $e * @return bool */ protected function causedByLostConnection(Throwable $e) &#123; $message = $e-&gt;getMessage(); return Str::contains($message, [ 'server has gone away', 'no connection to the server', 'Lost connection', 'is dead or not enabled', 'Error while sending', 'decryption failed or bad record mac', 'server closed the connection unexpectedly', 'SSL connection has been closed unexpectedly', 'Error writing data to the connection', 'Resource deadlock avoided', 'Transaction() on null', 'child connection forced to terminate due to client_idle_limit', 'query_wait_timeout', 'reset by peer', 'Physical connection is not usable', 'TCP Provider: Error code 0x68', 'ORA-03114', 'Packets out of order. Expected', 'Adaptive Server connection failed', 'Communication link failure', 'connection is no longer usable', 'Login timeout expired', 'Connection refused', 'running with the --read-only option so it cannot execute this statement', ]); &#125;&#125; 数据库日志123456789101112131415161718192021222324/** * All of the queries run against the connection. * * @var array */protected $queryLog = [];/** * 将查询记录在连接的查询日志中。 * * @param string $query * @param array $bindings * @param float|null $time * @return void */public function logQuery($query, $bindings, $time = null)&#123; $this-&gt;event(new QueryExecuted($query, $bindings, $time, $this)); if ($this-&gt;loggingQueries) &#123; $this-&gt;queryLog[] = compact('query', 'bindings', 'time'); &#125;&#125; 想要开启或关闭日志功能：1234567891011121314151617181920212223242526/** * 指明是否正在记录查询。 * * @var bool */protected $loggingQueries = false;/** * 在连接上启用查询日志。 * * @return void */public function enableQueryLog()&#123; $this-&gt;loggingQueries = true;&#125;/** * 在连接上禁用查询日志。 * * @return void */public function disableQueryLog()&#123; $this-&gt;loggingQueries = false;&#125; Select查询12345678910111213141516171819202122232425262728/** * 对数据库运行一条select语句。 * * @param string $query * @param array $bindings * @param bool $useReadPdo * @return array */public function select($query, $bindings = [], $useReadPdo = true)&#123; return $this-&gt;run($query, $bindings, function ($query, $bindings) use ($useReadPdo) &#123; if ($this-&gt;pretending()) &#123; return []; &#125; // 对于select语句，我们将简单地执行查询并返回数据库结果集的数组。 // 数组中的每个元素都是数据库表中的一行，并且可以是数组或对象。 $statement = $this-&gt;prepared($this-&gt;getPdoForSelect($useReadPdo) -&gt;prepare($query)); $this-&gt;bindValues($statement, $this-&gt;prepareBindings($bindings)); $statement-&gt;execute(); return $statement-&gt;fetchAll(); &#125;);&#125; 数据库的查询主要有以下几个步骤： 获取$this-&gt;pdo成员变量，若当前未连接数据库，则进行数据库连接，获取pdo对象。 设置pdo数据fetch模式。 pdo进行sql语句预处理。 pdo绑定参数sql语句执行，并获取数据。 getPdoForSelect获取pdo对象1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * 获取用于选择查询的PDO连接。 * * @param bool $useReadPdo * @return \PDO */protected function getPdoForSelect($useReadPdo = true)&#123; return $useReadPdo ? $this-&gt;getReadPdo() : $this-&gt;getPdo();&#125;/** * 获取当前的PDO连接。 * * @return \PDO */public function getPdo()&#123; if ($this-&gt;pdo instanceof Closure) &#123; return $this-&gt;pdo = call_user_func($this-&gt;pdo); &#125; return $this-&gt;pdo;&#125;/** * 获取用于读取的当前PDO连接。 * * @return \PDO */public function getReadPdo()&#123; if ($this-&gt;transactions &gt; 0) &#123; return $this-&gt;getPdo(); &#125; if ($this-&gt;recordsModified &amp;&amp; $this-&gt;getConfig('sticky')) &#123; return $this-&gt;getPdo(); &#125; if ($this-&gt;readPdo instanceof Closure) &#123; return $this-&gt;readPdo = call_user_func($this-&gt;readPdo); &#125; return $this-&gt;readPdo ?: $this-&gt;getPdo();&#125; getPdo这里逻辑比较简单，值得我们注意的是getReadPdo。为了减缓数据库的压力，我们常常对数据库进行读写分离，也就是只要当写数据库这种操作发生时，才会使用写数据库，否则都会用读数据库。这种措施减少了数据库的压力，但是也带来了一些问题，那就是读写两个数据库在一定时间内会出现数据不一致的情况，原因就是写库的数据未能及时推送给读库，造成读库数据延迟的现象。为了在一定程度上解决这类问题，Laravel增添了sticky选项，从程序中我们可以看出，当我们设置选项sticky为真，并且的确对数据库进行了写操作后，getReadPdo会强制返回主库的连接，这样就避免了读写分离造成的延迟问题。 还有一种情况，当数据库在执行事务期间，所有的读取操作也会被强制连接主库。 prepared设置数据获取方式1234567891011121314151617181920212223/** * 连接的默认fetchMode。 * * @var int */protected $fetchMode = PDO::FETCH_OBJ;/** * 配置PDO准备语句。 * * @param \PDOStatement $statement * @return \PDOStatement */protected function prepared(PDOStatement $statement)&#123; $statement-&gt;setFetchMode($this-&gt;fetchMode); $this-&gt;event(new StatementPrepared( $this, $statement )); return $statement;&#125; pdo的setFetchMode函数用于为语句设置默认的获取模式，通常模式有-以下几种： PDO::FETCH_ASSOC 从结果集中获取以列名为索引的关联数组。 PDO::FETCH_NUM 从结果集中获取一个以列在行中的数值偏移量为索引的值数组。 PDO::FETCH_BOTH 这是默认值，包含上面两种数组。 PDO::FETCH_OBJ 从结果集当前行的记录中获取其属性对应各个列名的一个对象。 PDO::FETCH_BOUND 使用fetch()返回TRUE，并将获取的列值赋给在bindParm()方法中指定的相应变量。 PDO::FETCH_LAZY 创建关联数组和索引数组，以及包含列属性的一个对象，从而可以在这三种接口中任选一种。 pdo的prepare函数prepare函数会为PDOStatement::execute()方法准备要执行的SQL语句， SQL语句可以包含零个或多个命名（:name）或问号（?）参数标记，参数在SQL执行时会被替换。 不能在SQL语句中同时包含命名（:name）或问号（?）参数标记，只能选择其中一种风格。 预处理SQL语句中的参数在使用PDOStatement::execute()方法时会传递真实的参数。 之所以使用prepare函数，是因为这个函数可以防止SQL注入，并且可以加快同一查询语句的速度。关于预处理与参数绑定防止SQL漏洞注入的原理可以参考：Web安全之SQL注入攻击技巧与防范. pdo的bindValues函数在调用pdo的参数绑定函数之前，Laravel对参数值进一步进行了优化，把时间类型的对象利用grammer的设置重新格式化，false也改为0。 pdo的参数绑定函数bindValue，对于使用命名占位符的预处理语句，应是类似:name形式的参数名。对于使用问号占位符的预处理语句，应是以1开始索引的参数位置。 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * 准备要执行的查询绑定。 * * @param array $bindings * @return array */public function prepareBindings(array $bindings)&#123; $grammar = $this-&gt;getQueryGrammar(); foreach ($bindings as $key =&gt; $value) &#123; // 我们需要将DateTimeInterface的所有实例转换为实际的日期字符串。 // 每个查询语法都维护自己的日期字符串格式，因此我们只要求语法从日期中获取格式。 if ($value instanceof DateTimeInterface) &#123; $bindings[$key] = $value-&gt;format($grammar-&gt;getDateFormat()); &#125; elseif (is_bool($value)) &#123; $bindings[$key] = (int) $value; &#125; &#125; return $bindings;&#125;/** * 将值绑定到给定语句中的参数。 * * @param \PDOStatement $statement * @param array $bindings * @return void */public function bindValues($statement, $bindings)&#123; foreach ($bindings as $key =&gt; $value) &#123; $statement-&gt;bindValue( is_string($key) ? $key : $key + 1, $value, is_int($value) ? PDO::PARAM_INT : PDO::PARAM_STR ); &#125;&#125; insert123456789101112131415161718192021222324252627282930313233343536/** * 对数据库运行insert语句。 * * @param string $query * @param array $bindings * @return bool */public function insert($query, $bindings = [])&#123; return $this-&gt;statement($query, $bindings);&#125;/** * 执行一条SQL语句并返回布尔值。 * * @param string $query * @param array $bindings * @return bool */public function statement($query, $bindings = [])&#123; return $this-&gt;run($query, $bindings, function ($query, $bindings) &#123; if ($this-&gt;pretending()) &#123; return true; &#125; $statement = $this-&gt;getPdo()-&gt;prepare($query); $this-&gt;bindValues($statement, $this-&gt;prepareBindings($bindings)); $this-&gt;recordsHaveBeenModified(); return $statement-&gt;execute(); &#125;);&#125; 这部分的代码与select非常相似，不同之处有以下几个： 直接获取写库的连接，不会考虑读库。 由于不需要返回任何数据库数据，因此也不必设置fetchMode。 recordsHaveBeenModified函数标志当前连接数据库已被写入。 不需要调用函数fetchAll。 12345678910111213/** * 指出是否有任何记录被修改。 * * @param bool $value * @return void */public function recordsHaveBeenModified($value = true)&#123; if (! $this-&gt;recordsModified) &#123; $this-&gt;recordsModified = $value; &#125;&#125; update、deleteaffectingStatement这个函数与上面的statement函数一致，只是最后会返回更新、删除影响的行数。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * 对数据库运行一条update语句。 * * @param string $query * @param array $bindings * @return int */public function update($query, $bindings = [])&#123; return $this-&gt;affectingStatement($query, $bindings);&#125;/** * 对数据库运行一条delete语句。 * * @param string $query * @param array $bindings * @return int */public function delete($query, $bindings = [])&#123; return $this-&gt;affectingStatement($query, $bindings);&#125;/** * 运行一条SQL语句并获取受影响的行数。 * * @param string $query * @param array $bindings * @return int */public function affectingStatement($query, $bindings = [])&#123; return $this-&gt;run($query, $bindings, function ($query, $bindings) &#123; if ($this-&gt;pretending()) &#123; return 0; &#125; // 对于update或delete语句，我们希望获得该语句影响的行数，并将其返回给开发人员。 // 我们首先需要执行该语句，然后使用PDO来获取受影响的对象。 $statement = $this-&gt;getPdo()-&gt;prepare($query); $this-&gt;bindValues($statement, $this-&gt;prepareBindings($bindings)); $statement-&gt;execute(); $this-&gt;recordsHaveBeenModified( ($count = $statement-&gt;rowCount()) &gt; 0 ); return $count; &#125;);&#125; 事务transaction数据库事务为保持数据的一致性，对于重要的数据我们经常使用数据库事务，transaction函数接受一个闭包函数，与一个重复尝试的次数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;?phpnamespace Illuminate\Database\Concerns;use Closure;use Throwable;trait ManagesTransactions&#123; /** * 在事务中执行闭包 * * @param \Closure $callback * @param int $attempts * @return mixed * * @throws \Throwable */ public function transaction(Closure $callback, $attempts = 1) &#123; for ($currentAttempt = 1; $currentAttempt &lt;= $attempts; $currentAttempt++) &#123; $this-&gt;beginTransaction(); // 我们将简单地在try/catch块中执行给定的回调，如果捕获到任何异常， // 我们可以回滚该事务，这样就不会使这些事务实际持久化到数据库或以永久方式存储。 try &#123; $callbackResult = $callback($this); &#125; // 如果我们捕获到异常，我们将回滚此事务，如果没有超出尝试次数，就重试。 // 如果超出，我们将抛出异常，让开发人员处理未捕获的异常。 catch (Throwable $e) &#123; $this-&gt;handleTransactionException( $e, $currentAttempt, $attempts ); continue; &#125; try &#123; $this-&gt;commit(); &#125; catch (Throwable $e) &#123; $this-&gt;handleCommitTransactionException( $e, $currentAttempt, $attempts ); continue; &#125; return $callbackResult; &#125; &#125;&#125; 开始事务数据库事务中非常重要的成员变量是$this-&gt;transactions，它标志着当前事务的进程： 123456789101112131415/** * 启动一个新的数据库事务。 * * @return void * * @throws \Throwable */public function beginTransaction()&#123; $this-&gt;createTransaction(); $this-&gt;transactions++; $this-&gt;fireConnectionEvent('beganTransaction');&#125; 可以看出，当创建事务成功后，就会累加$this-&gt;transactions，并且启动event，创建事务： 123456789101112131415161718192021222324252627/** * 在数据库中创建一个事务。 * * @return void * * @throws \Throwable */protected function createTransaction()&#123; if ($this-&gt;transactions == 0) &#123; $this-&gt;reconnectIfMissingConnection(); try &#123; $this-&gt;getPdo()-&gt;beginTransaction(); &#125; catch (Throwable $e) &#123; $this-&gt;handleBeginTransactionException($e); &#125; &#125; elseif ($this-&gt;transactions &gt;= 1 &amp;&amp; $this-&gt;queryGrammar-&gt;supportsSavepoints()) &#123; $this-&gt;createSavepoint(); &#125;&#125; 如果当前没有任何事务，那么就会调用pdo来开启事务。 如果当前已经在事务保护的范围内，那么就会创建SAVEPOINT，实现数据库嵌套事务：12345678910111213/** * 在数据库中创建一个保存点。 * * @return void * * @throws \Throwable */protected function createSavepoint()&#123; $this-&gt;getPdo()-&gt;exec( $this-&gt;queryGrammar-&gt;compileSavepoint('trans'.($this-&gt;transactions + 1)) );&#125; 1234567891011121314151617&lt;?phpnamespace Illuminate\Database\Query\Grammars;class Grammar extends BaseGrammar&#123; /** * 编译SQL语句以定义一个保存点。 * * @param string $name * @return string */ public function compileSavepoint($name) &#123; return 'SAVEPOINT '.$name; &#125;&#125; 如果创建事务失败，那么就会调用handleBeginTransactionException： 123456789101112131415161718192021/** * 从事务开始处理异常。 * * @param \Throwable $e * @return void * * @throws \Throwable */protected function handleBeginTransactionException(Throwable $e)&#123; if ($this-&gt;causedByLostConnection($e)) &#123; $this-&gt;reconnect(); $this-&gt;getPdo()-&gt;beginTransaction(); &#125; else &#123; throw $e; &#125;&#125; 如果创建事务失败是由于与数据库失去连接的话，那么就会重新连接数据库，否则就要抛出异常。 事务异常事务的异常处理比较复杂，可以先看一看代码：1234567891011121314151617181920212223242526272829303132333435/** * 处理运行事务语句时遇到的异常。 * * @param \Throwable $e * @param int $currentAttempt * @param int $maxAttempts * @return void * * @throws \Throwable */protected function handleTransactionException(Throwable $e, $currentAttempt, $maxAttempts)&#123; // 陷入僵局时，MySQL会回滚整个事务，因此我们不能只是重试查询。 // 我们必须彻底消除该异常，并让开发人员以另一种方式处理它。 // 我们也会减少transactions。 if ($this-&gt;causedByConcurrencyError($e) &amp;&amp; $this-&gt;transactions &gt; 1) &#123; $this-&gt;transactions--; throw $e; &#125; // 如果有异常，我们将回滚该事务，然后我们可以检查是否超出了最大尝试次数， // 如果没有，我们将返回并在循环中再次尝试此查询。 $this-&gt;rollBack(); if ($this-&gt;causedByConcurrencyError($e) &amp;&amp; $currentAttempt &lt; $maxAttempts) &#123; return; &#125; throw $e;&#125; 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace Illuminate\Database;use Illuminate\Support\Str;use PDOException;use Throwable;trait DetectsConcurrencyErrors&#123; /** * 确定给定的异常是否由并发错误（例如死锁或序列化失败）引起。 * * @param \Throwable $e * @return bool */ protected function causedByConcurrencyError(Throwable $e) &#123; if ($e instanceof PDOException &amp;&amp; $e-&gt;getCode() === '40001') &#123; return true; &#125; $message = $e-&gt;getMessage(); return Str::contains($message, [ 'Deadlock found when trying to get lock', 'deadlock detected', 'The database file is locked', 'database is locked', 'database table is locked', 'A table in the database is locked', 'has been chosen as the deadlock victim', 'Lock wait timeout exceeded; try restarting transaction', 'WSREP detected deadlock/conflict and aborted the transaction. Try restarting the transaction', ]); &#125;&#125; 这里可以分为四种情况： 单一事务，非死锁导致的异常 单一事务就是说，此时的事务只有一层，没有嵌套事务的存在。数据库的异常也不是死锁导致的，一般是由于sql语句不正确引起的。这个时候，handleTransactionException会直接回滚事务，并且抛出异常到外层： 123456789101112131415try &#123; return tap($callback($this), function ($result) &#123; $this-&gt;commit(); &#125;);&#125;catch (Exception $e) &#123; $this-&gt;handleTransactionException($e, $currentAttempt, $attempts);&#125; catch (Throwable $e) &#123; $this-&gt;rollBack(); throw $e;&#125; 接到异常之后，程序会再次回滚，但是由于$this-&gt;transactions已经为0，因此回滚直接返回，并未真正执行，之后就会抛出异常。 单一事务，死锁异常 有死锁导致的单一事务异常，一般是由于其他程序同时更改了数据库，这个时候，就要判断当前重复尝试的次数是否大于用户设置的maxAttempts，如果小于就继续尝试，如果大于，那么就会抛出异常。 嵌套事务，非死锁异常 如果出现嵌套事务，例如： 123456789\DB::transaction(function()&#123; ... // 直接或间接调用另一笔交易： \DB::transaction(function() &#123; ... ... &#125;, 2);//attempt twice &#125;, 2);//attempt twice 如果是非死锁导致的异常，那么就要首先回滚内层的事务，抛出异常到外层事务，再回滚外层事务，抛出异常，让用户来处理。也就是说，对于嵌套事务来说，内部事务异常，一定要回滚整个事务，而不是仅仅回滚内部事务。 嵌套事务，死锁异常 嵌套事务的死锁异常，仍然和嵌套事务非死锁异常一样，内部事务异常，一定要回滚整个事务。 但是，不同的是，mysql对于嵌套事务的回滚会导致外部事务一并回滚：InnoDB Error Handling，因此这时，我们仅仅将$this-&gt;transactions减一，并抛出异常，使得外层事务回滚抛出异常即可。 回滚事务如果事务内的数据库更新操作失败，那么就要进行回滚： 12345678910111213141516171819202122232425262728293031323334353637/** * 回滚活跃的数据库事务。 * * @param int|null $toLevel * @return void * * @throws \Throwable */public function rollBack($toLevel = null)&#123; // 我们允许开发人员回滚到某个交易级别。 // 在尝试回滚到该级别之前，我们将验证该给定的交易级别是否有效。 // 如果不是，我们只会退出，不会尝试任何事情。 $toLevel = is_null($toLevel) ? $this-&gt;transactions - 1 : $toLevel; if ($toLevel &lt; 0 || $toLevel &gt;= $this-&gt;transactions) &#123; return; &#125; // 接下来，我们将实际在此数据库中执行此回滚并触发回滚事件。 // 我们还将当前交易级别设置为传递给此方法的给定级别，因此从现在开始就正确了。 try &#123; $this-&gt;performRollBack($toLevel); &#125; catch (Throwable $e) &#123; $this-&gt;handleRollBackException($e); &#125; $this-&gt;transactions = $toLevel; $this-&gt;fireConnectionEvent('rollingBack');&#125; 回滚的第一件事就是要减少$this-&gt;transactions的值，标志当前事务失败。 回滚的时候仍然要判断当前事务的状态，如果当前处于嵌套事务的话，就要进行回滚到SAVEPOINT，如果是单一事务的话，才会真正回滚退出事务： 1234567891011121314151617181920212223242526272829303132/** * 在数据库内执行回滚。 * * @param int $toLevel * @return void * * @throws \Throwable */protected function performRollBack($toLevel)&#123; if ($toLevel == 0) &#123; $this-&gt;getPdo()-&gt;rollBack(); &#125; elseif ($this-&gt;queryGrammar-&gt;supportsSavepoints()) &#123; $this-&gt;getPdo()-&gt;exec( $this-&gt;queryGrammar-&gt;compileSavepointRollBack('trans'.($toLevel + 1)) ); &#125;&#125;/** * 编译SQL语句以执行保存点回滚。 * * @param string $name * @return string */public function compileSavepointRollBack($name)&#123; return 'ROLLBACK TO SAVEPOINT '.$name;&#125; 提交事务提交事务比较简单，仅仅是调用pdo的commit即可。需要注意的是对于嵌套事务的事务提交，commit函数仅仅更新了$this-&gt;transactions，而并没有真正提交事务，原因是内层事务的提交对于mysql来说是无效的，只有外部事务的提交才能更新整个事务。 123456789101112131415161718/** * 提交活跃的数据库事务。 * * @return void * * @throws \Throwable */public function commit()&#123; if ($this-&gt;transactions == 1) &#123; $this-&gt;getPdo()-&gt;commit(); &#125; $this-&gt;transactions = max(0, $this-&gt;transactions - 1); $this-&gt;fireConnectionEvent('committed');&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Database-Eloquent Model关联源码分析]]></title>
    <url>%2F2020%2F05%2F24%2FLaravel-Database-Eloquent-Model%E5%85%B3%E8%81%94%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言数据库表通常相互关联。Laravel中的模型关联功能使得关于数据库的关联代码变得更加简单，更加优雅。本文会详细说说关于模型关联的源码，以便更好的理解和使用关联模型。 定义关联所谓的定义关联，就是在一个Model中定义一个关联函数，我们利用这个关联函数去操作另外一个Model，例如，user表是用户表，posts是用户发的文章，一个用户可以发表多篇文章，我们就可以这样写：1$user-&gt;posts()-&gt;where('active', 1)-&gt;get(); 这表明了我们想通过$user这个用户查询到状态active为1的所有文章，posts就是关联函数，我们可以通过这个关联函数去操作另一个与user关联的表。 在说模型关联的定义之前，我们要先说说父模型与子模型的概念。所谓的父模型是指在模型关系中主动的一方，例如用户模型和文章模型中的用户，相应的子模型就是模型关系中的被动一方，例如文章模型。在正向定义中，被关联的是子模型，而在反向关联中，被关联的是父模型。 我们知道，关联有多种形式，各种关系如下： hasOne一对一我们以官方文档的例子来说明，一个User模型可能关联一个Phone模型： 12345678910class User extends Model&#123; /** * 获得与用户关联的电话记录。 */ public function phone() &#123; $this-&gt;hasOne('App\Phone', 'user_id', 'id'); &#125;&#125; 我们来看看hasOne的源码： 1234567891011121314151617181920212223namespace Illuminate\Database\Eloquent\Concerns;trait HasRelationships&#123; /** * Define a one-to-one relationship. * * @param string $related * @param string|null $foreignKey * @param string|null $localKey * @return \Illuminate\Database\Eloquent\Relations\HasOne */ public function hasOne($related, $foreignKey = null, $localKey = null) &#123; $instance = $this-&gt;newRelatedInstance($related); $foreignKey = $foreignKey ?: $this-&gt;getForeignKey(); $localKey = $localKey ?: $this-&gt;getKeyName(); return $this-&gt;newHasOne($instance-&gt;newQuery(), $this, $instance-&gt;getTable().'.'.$foreignKey, $localKey); &#125;&#125; newRelatedInstance函数负责建立一个新的被关联的模型实例，主要目的是设置数据库连接： 1234567891011121314/** * Create a new model instance for a related model. * * @param string $class * @return mixed */protected function newRelatedInstance($class)&#123; return tap(new $class, function ($instance) &#123; if (! $instance-&gt;getConnectionName()) &#123; $instance-&gt;setConnection($this-&gt;connection); &#125; &#125;);&#125; 在一对一的关系中，foreignKey外键名默认是父模型的类名和主键名的蛇形变量，localKey是父模型的主键名： 1234567891011121314namespace Illuminate\Database\Eloquent;abstract class Model implements Arrayable, ArrayAccess, Jsonable, JsonSerializable, QueueableEntity, UrlRoutable&#123; /** * Get the default foreign key name for the model. * * @return string */ public function getForeignKey() &#123; return Str::snake(class_basename($this)).'_'.$this-&gt;getKeyName(); &#125;&#125; hasOne函数的构造函数继承HasOneOrMany类，也就是说，一对一与一对多构造函数相同，这部分主要设置外键名：123456789101112131415161718192021namespace Illuminate\Database\Eloquent\Relations;abstract class HasOneOrMany extends Relation&#123; /** * Create a new has one or many relationship instance. * * @param \Illuminate\Database\Eloquent\Builder $query * @param \Illuminate\Database\Eloquent\Model $parent * @param string $foreignKey * @param string $localKey * @return void */ public function __construct(Builder $query, Model $parent, $foreignKey, $localKey) &#123; $this-&gt;localKey = $localKey; $this-&gt;foreignKey = $foreignKey; parent::__construct($query, $parent); &#125;&#125; HasOneOrMany类继承Relation类，这部分主要设置parent（父模型）、被关联模型（子模型）与被关联模型（子模型）的查询构造器： 1234567891011121314151617181920212223namespace Illuminate\Database\Eloquent\Relations;/** * @mixin \Illuminate\Database\Eloquent\Builder */abstract class Relation&#123; /** * Create a new relation instance. * * @param \Illuminate\Database\Eloquent\Builder $query * @param \Illuminate\Database\Eloquent\Model $parent * @return void */ public function __construct(Builder $query, Model $parent) &#123; $this-&gt;query = $query; $this-&gt;parent = $parent; $this-&gt;related = $query-&gt;getModel(); $this-&gt;addConstraints(); &#125;&#125; hasOne的模型关系如下： 除了保存被关联模型的查询构造器、被关联模型与parent模型之外，还会提供额外的限制条件：123456789101112131415161718192021222324/** * Set the base constraints on the relation query. * * @return void */public function addConstraints()&#123; if (static::$constraints) &#123; $this-&gt;query-&gt;where($this-&gt;foreignKey, '=', $this-&gt;getParentKey()); $this-&gt;query-&gt;whereNotNull($this-&gt;foreignKey); &#125;&#125;/** * Get the key value of the parent's local key. * * @return mixed */public function getParentKey()&#123; return $this-&gt;parent-&gt;getAttribute($this-&gt;localKey);&#125; 限制条件为被关联模型和关联模型建立外键约束关系：1select phone where phone.user_id = 1 (user.id) hasMany一对多在模型关联的定义中，一对一与一对多源码是一样的：12345678910111213141516171819202122232425namespace Illuminate\Database\Eloquent\Concerns;trait HasRelationships&#123; /** * Define a one-to-many relationship. * * @param string $related * @param string|null $foreignKey * @param string|null $localKey * @return \Illuminate\Database\Eloquent\Relations\HasMany */ public function hasMany($related, $foreignKey = null, $localKey = null) &#123; $instance = $this-&gt;newRelatedInstance($related); $foreignKey = $foreignKey ?: $this-&gt;getForeignKey(); $localKey = $localKey ?: $this-&gt;getKeyName(); return $this-&gt;newHasMany( $instance-&gt;newQuery(), $this, $instance-&gt;getTable().'.'.$foreignKey, $localKey ); &#125;&#125; hasMany的模型关系如下： 限制条件与一对一相同，为被关联模型和关联模型建立外键约束关系：1select phone where phone.user_id = 1 (user.id) belongsTo一对一、一对多反向关联如果想要从文章反向查找作者用户，那么可以定义反向关联： 1234public function user()&#123; return $this-&gt;belongsTo('App\User', 'foreign_key', 'other_key');&#125; belongsTo源码：12345678910111213141516171819202122232425262728293031323334353637383940414243namespace Illuminate\Database\Eloquent\Concerns;trait HasRelationships&#123; /** * Define an inverse one-to-one or many relationship. * * @param string $related * @param string|null $foreignKey * @param string|null $ownerKey * @param string|null $relation * @return \Illuminate\Database\Eloquent\Relations\BelongsTo */ public function belongsTo($related, $foreignKey = null, $ownerKey = null, $relation = null) &#123; // If no relation name was given, we will use this debug backtrace to extract // the calling method's name and use that as the relationship name as most // of the time this will be what we desire to use for the relationships. if (is_null($relation)) &#123; $relation = $this-&gt;guessBelongsToRelation(); &#125; $instance = $this-&gt;newRelatedInstance($related); // If no foreign key was supplied, we can use a backtrace to guess the proper // foreign key name by using the name of the relationship function, which // when combined with an "_id" should conventionally match the columns. if (is_null($foreignKey)) &#123; $foreignKey = Str::snake($relation).'_'.$instance-&gt;getKeyName(); &#125; // Once we have the foreign key names, we'll just create a new Eloquent query // for the related models and returns the relationship instance which will // actually be responsible for retrieving and hydrating every relations. $ownerKey = $ownerKey ?: $instance-&gt;getKeyName(); return $this-&gt;newBelongsTo( $instance-&gt;newQuery(), $this, $foreignKey, $ownerKey, $relation ); &#125;&#125; 正向定义与反向定义不同的是多了一个参数relation，这个参数默认值是从debug_backtrace函数获取的：1234567891011/** * Guess the "belongs to" relationship name. * * @return string */protected function guessBelongsToRelation()&#123; [$one, $two, $caller] = debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS, 3); return $caller['function'];&#125; 也就是我们的关联函数名user，belongsTo函数会将关联函数名作为关联名保存起来。 另一个不同是外键的默认名称，不再是类名+主键名，而是关联名+主键名：1234if (is_null($foreignKey)) &#123; $foreignKey = Str::snake($relation).'_'.$instance-&gt;getKeyName();&#125; 我们接着看belongsTo函数：123456789101112131415161718namespace Illuminate\Database\Eloquent\Relations;class BelongsTo extends Relation&#123; public function __construct(Builder $query, Model $child, $foreignKey, $ownerKey, $relationName) &#123; $this-&gt;ownerKey = $ownerKey; $this-&gt;relationName = $relationName; $this-&gt;foreignKey = $foreignKey; // In the underlying base relationship class, this variable is referred to as // the "parent" since most relationships are not inversed. But, since this // one is we will create a "child" variable for much better readability. $this-&gt;child = $child; parent::__construct($query, $child); &#125;&#125; 我们可以看出来，相对于正向关联，反向关联除了保存外键名与主键名之外，还保存了关系名、子模型。值得注意的是，反向关联中related代表父模型，parent代表子模型，与正向关联相反。 hasMany的模型关系如下： 约束条件也相应地进行反转改变： 12345678public function addConstraints()&#123;if (static::$constraints) &#123;$table = $this-&gt;related-&gt;getTable();$this-&gt;query-&gt;where($table.'.'.$this-&gt;ownerKey, '=', $this-&gt;child-&gt;&#123;$this-&gt;foreignKey&#125;);&#125;&#125; 限制条件：1select user where user.id = 1 (post.user_id) belongsMany多对多多对多关系由于中间表的原因相对来说比较复杂，涉及的参数也非常多。我们以官网例子：12345678910class User extends Model&#123; /** * 获得此用户的角色。 */ public function roles() &#123; return $this-&gt;belongsToMany('App\Role', 'role_user', 'user_id', 'role_id'); &#125;&#125; User表与role表是多对多关系，另外有一中间表user_role表，我们在定义关系的时候，related是被关联模型，table是中间表，foreignPivotKey是中间表中父模型外键名，relatedPivotKey是中间表中子模型外键名，parentKey是父模型主键名，relatedKey是子模型主键名，relation是关系名。123456789101112131415161718192021public function belongsToMany($related, $table = null, $foreignPivotKey = null, $relatedPivotKey = null, $parentKey = null, $relatedKey = null, $relation = null)&#123;if (is_null($relation)) &#123;$relation = $this-&gt;guessBelongsToManyRelation();&#125;$instance = $this-&gt;newRelatedInstance($related);$foreignPivotKey = $foreignPivotKey ?: $this-&gt;getForeignKey();$relatedPivotKey = $relatedPivotKey ?: $instance-&gt;getForeignKey();if (is_null($table)) &#123;$table = $this-&gt;joiningTable($related);&#125;return new BelongsToMany($instance-&gt;newQuery(), $this, $table, $foreignPivotKey,$relatedPivotKey, $parentKey ?: $this-&gt;getKeyName(),$relatedKey ?: $instance-&gt;getKeyName(), $relation);&#125; 获取关联名称仍然使用的是debug_backtrace函数，不同于guessBelongsToRelation函数只有 belongsTo调用，guessBelongsToManyRelation函数还可以被morphedByMany函数调用，所以不能单纯的限制返回堆栈帧：1234567891011121314public static $manyMethods = ['belongsToMany', 'morphToMany', 'morphedByMany','guessBelongsToManyRelation', 'findFirstMethodThatIsntRelation',];protected function guessBelongsToManyRelation()&#123;$caller = Arr::first(debug_backtrace(DEBUG_BACKTRACE_IGNORE_ARGS), function ($trace) &#123;return ! in_array($trace['function'], Model::$manyMethods);&#125;);return ! is_null($caller) ? $caller['function'] : null;&#125; 默认的中间表是两个表名的蛇形变量：123456789public function joiningTable($related)&#123;$models = [Str::snake(class_basename($related)),Str::snake(class_basename($this)),];sort($models);return strtolower(implode('_', $models));&#125; BelongsToMany的初始化也需要保存这些变量：12345678910111213public function __construct(Builder $query, Model $parent, $table, $foreignPivotKey,$relatedPivotKey, $parentKey, $relatedKey, $relationName = null)&#123;$this-&gt;table = $table;$this-&gt;parentKey = $parentKey;$this-&gt;relatedKey = $relatedKey;$this-&gt;relationName = $relationName;$this-&gt;relatedPivotKey = $relatedPivotKey;$this-&gt;foreignPivotKey = $foreignPivotKey;parent::__construct($query, $parent);&#125; belongsToMany 的模型关系如下：反向的多对多模型关系： 限制条件：123456789101112131415161718192021222324public function addConstraints()&#123;$this-&gt;performJoin();if (static::$constraints) &#123;$this-&gt;addWhereConstraints();&#125;&#125;protected function performJoin($query = null)&#123;$query = $query ?: $this-&gt;query;$baseTable = $this-&gt;related-&gt;getTable();$key = $baseTable.'.'.$this-&gt;relatedKey;$query-&gt;join($this-&gt;table, $key, '=', $this-&gt;getQualifiedRelatedPivotKeyName());return $this;&#125;protected function addWhereConstraints()&#123;$this-&gt;query-&gt;where($this-&gt;getQualifiedForeignPivotKeyName(), '=', $this-&gt;parent-&gt;&#123;$this-&gt;parentKey&#125;);return $this;&#125; 本例中wher条件：12select role join role_user on role_user.role_id = 1 (role.id)select role where role_user.user_id = 1 (user.id) hasManyThrough远程一对多远程一对多关联提供了方便、简短的方式通过中间的关联来获得远层的关联。以官方例子来看： 1234567891011121314class Country extends Model&#123; public function posts() &#123; return $this-&gt;hasManyThrough( 'App\Post', 'App\User', 'country_id', // 用户表外键... 'user_id', // 文章表外键... 'id', // 国家表本地键... 'id' // 用户表本地键... ); &#125;&#125; 可以看到，远程一对多的参数比较多。第一个参数related是最终被关联的模型，through是中间模型，firstKey是中间模型关于父模型的外键，secondKey是最终被关联的模型关于中间模型的外键，localKey是父模型的主键，secondLocalKey是中间模型的主键：123456789101112public function hasManyThrough($related, $through, $firstKey = null, $secondKey = null, $localKey = null, $secondLocalKey = null)&#123;$through = new $through;$firstKey = $firstKey ?: $this-&gt;getForeignKey();$secondKey = $secondKey ?: $through-&gt;getForeignKey();$localKey = $localKey ?: $this-&gt;getKeyName();$secondLocalKey = $secondLocalKey ?: $through-&gt;getKeyName();$instance = $this-&gt;newRelatedInstance($related);return new HasManyThrough($instance-&gt;newQuery(), $this, $through, $firstKey, $secondKey, $localKey, $secondLocalKey);&#125; HasManyThrough的初始化：123456789101112public function __construct(Builder $query, Model $farParent, Model $throughParent, $firstKey, $secondKey, $localKey, $secondLocalKey)&#123;$this-&gt;localKey = $localKey;$this-&gt;firstKey = $firstKey;$this-&gt;secondKey = $secondKey;$this-&gt;farParent = $farParent;$this-&gt;throughParent = $throughParent;$this-&gt;secondLocalKey = $secondLocalKey;parent::__construct($query, $throughParent);&#125; hasManyThrough的模型关系如下： 限制条件： 12345678910111213141516171819202122232425262728293031323334353637public function addConstraints()&#123;$localValue = $this-&gt;farParent[$this-&gt;localKey];$this-&gt;performJoin();if (static::$constraints) &#123;$this-&gt;query-&gt;where($this-&gt;getQualifiedFirstKeyName(), '=', $localValue);&#125;&#125;protected function performJoin(Builder $query = null)&#123;$query = $query ?: $this-&gt;query;$farKey = $this-&gt;getQualifiedFarKeyName();$query-&gt;join($this-&gt;throughParent-&gt;getTable(), $this-&gt;getQualifiedParentKeyName(), '=', $farKey);if ($this-&gt;throughParentSoftDeletes()) &#123;$query-&gt;whereNull($this-&gt;throughParent-&gt;getQualifiedDeletedAtColumn());&#125;&#125;public function getQualifiedParentKeyName()&#123;return $this-&gt;parent-&gt;getTable().'.'.$this-&gt;secondLocalKey;&#125;public function getQualifiedFarKeyName()&#123;return $this-&gt;getQualifiedForeignKeyName();&#125;public function getQualifiedForeignKeyName()&#123;return $this-&gt;related-&gt;getTable().'.'.$this-&gt;secondKey;&#125;public function getQualifiedFirstKeyName()&#123;return $this-&gt;throughParent-&gt;getTable().'.'.$this-&gt;firstKey;&#125; 本例中的限制条件： 123select post join user on user.id = post.user_idselect post where user.delete_at is nullselect post where user.country_id = 1 (country.id) morphOne/morphMany多态关联 多态关联允许我们应用一个表来单独作为多个表的属性，多态关联存在一对一、一对多、多对多的情形。所谓一对一、一对多是指，一个模型只拥有一个属性或多个属性，例如官网中的例子： 用户可以「评论」文章和视频。使用多态关联，您可以用一个comments表同时满足这两个使用场景 1234567891011121314151617181920class Post extends Model&#123;/*** 获得此文章的所有评论。*/public function comments()&#123;return $this-&gt;morphMany('App\Comment', 'commentable');&#125;&#125;class Video extends Model&#123;/*** 获得此视频的所有评论。*/public function comments()&#123;return $this-&gt;morphMany('App\Comment', 'commentable');&#125;&#125; 这个 comments 表就是属性表，当文章和视频只能有一个评论的时候，那么就是一对一多态关联；如果文章和视频可以由多个评论的时候，就是一对多多态关联。 这种属性表一般会有两个固定的字段： commentable_type用于标识该条评论是文章的还是视频的、 commentable_id 用于记录文章或视频的主键 id 。我们可以把多态关联看作普通的一对一、一对多关系，只是外键参数是 type 与id 的组合。related 是属性表，也就是这里的 comments ，type参数是属性表中存储父模型类型的列名(commentable_type)， id 参数是属性表中存储父模型主键的列名(commentable_id)，而name专用于省略type参数与id参数，localKey是指父模型的主键。123456789101112131415161718192021222324public function morphOne($related, $name, $type = null, $id = null, $localKey = null)&#123;$instance = $this-&gt;newRelatedInstance($related);list($type, $id) = $this-&gt;getMorphs($name, $type, $id);$table = $instance-&gt;getTable();$localKey = $localKey ?: $this-&gt;getKeyName();return new MorphOne($instance-&gt;newQuery(), $this, $table.'.'.$type, $table.'.'.$id, $localKey);&#125;public function morphMany($related, $name, $type = null, $id = null, $localKey = null)&#123;$instance = $this-&gt;newRelatedInstance($related);list($type, $id) = $this-&gt;getMorphs($name, $type, $id);$table = $instance-&gt;getTable();$localKey = $localKey ?: $this-&gt;getKeyName();return new MorphMany($instance-&gt;newQuery(), $this, $table.'.'.$type, $table.'.'.$id, $localKey);&#125;protected function getMorphs($name, $type, $id)&#123;return [$type ?: $name.'_type', $id ?: $name.'_id'];&#125; 一对一、一对多多态关联主要保存属性表中表示类型的列名，还有需要向该类型列中写入的父模型名称，一般来说，默认会写父模型的类名( App\Post 、 App\Video )12345678910111213141516public function __construct(Builder $query, Model $parent, $type, $id, $localKey)&#123;$this-&gt;morphType = $type;$this-&gt;morphClass = $parent-&gt;getMorphClass();parent::__construct($query, $parent, $id, $localKey);&#125;public function getMorphClass()&#123;$morphMap = Relation::morphMap();if (! empty($morphMap) &amp;&amp; in_array(static::class, $morphMap)) &#123;return array_search(static::class, $morphMap, true);&#125;return static::class;&#125; 不过我们也可以自定义写入的值： 1234Relation::morphMap(['posts' =&gt; 'App\Post','videos' =&gt; 'App\Video',]); 这样，就会把App\Post换成posts， App\Video换成videos。我们来看看这个多态映射表函数：1234567891011121314151617181920public static function morphMap(array $map = null, $merge = true)&#123;$map = static::buildMorphMapFromModels($map);if (is_array($map)) &#123;static::$morphMap = $merge &amp;&amp; static::$morphMap? array_merge(static::$morphMap, $map) :$map;&#125;return static::$morphMap;&#125;protected static function buildMorphMapFromModels(array $models= null)&#123;if (is_null($models) || Arr::isAssoc($models)) &#123;return $models;&#125;return array_combine(array_map(function ($model) &#123;return (new $model)-&gt;getTable();&#125;, $models), $models);&#125; 可以看到， buildMorphMapFromModels 函数将字符串App\Post转为model，并利用array_combine转为键。 morphOne的模型关系如下： morphMany的模型关系如下：限制条件：12345678910111213141516public function addConstraints()&#123;if (static::$constraints) &#123;parent::addConstraints();$this-&gt;query-&gt;where($this-&gt;morphType, $this-&gt;morphClass);&#125;&#125;public function addConstraints()&#123;if (static::$constraints) &#123;$this-&gt;query-&gt;where($this-&gt;foreignKey, '=', $this-&gt;getParentKey());$this-&gt;query-&gt;whereNotNull($this-&gt;foreignKey);&#125;&#125; 本例中的限制条件：123select comments where comment.commentable_id = post.idselect comments where comment.commentable_id is not nullselect comments where comment.commentable_type = 'App\Post' morphTo 反向多态关联 和一对一、一对多的 belongsTo 相似，多态关联还可以定义反向关联morphTo :12345678910class Comment extends Model&#123;/*** 获得拥有此评论的模型。*/public function commentable()&#123;return $this-&gt;morphTo();&#125;&#125; 与 belongsTo 类似， morphTo 也是利用 debug_backtrace 获取关联名称。当前如果正处于预加载状态的时候， Comment 一般还没有从数据库获取数据，$this-&gt;{$type}是空值，这个时候需要去除预加载来初始化：12345678910111213141516171819202122232425262728public function morphTo($name = null, $type = null, $id = null)&#123;$name = $name ?: $this-&gt;guessBelongsToRelation();list($type, $id) = $this-&gt;getMorphs(Str::snake($name), $type, $id);return empty($class = $this-&gt;&#123;$type&#125;)? $this-&gt;morphEagerTo($name, $type, $id): $this-&gt;morphInstanceTo($class, $name, $type, $id);&#125;protected function morphEagerTo($name, $type, $id)&#123;return new MorphTo($this-&gt;newQuery()-&gt;setEagerLoads([]), $this, $id, null,$type, $name);&#125;protected function morphInstanceTo($target, $name, $type, $id)&#123;$instance = $this-&gt;newRelatedInstance(static::getActualClassNameForMorph($target));return new MorphTo($instance-&gt;newQuery(), $this, $id, $instance-&gt;getKeyName(), $type, $name);&#125; 多态的成员变量 morphType 代表属性表的类型列， morphClass MorphTo的成员变量只有一个 morphType :1234567public function __construct(Builder $query, Model $parent, $foreignKey, $ownerKey, $type, $relation)&#123;$this-&gt;morphType = $type;parent::__construct($query, $parent, $foreignKey, $ownerKey,$relation);&#125; morphTo 的模型关系如下：限制条件与 belongsTo 相同：12345678public function addConstraints()&#123;if (static::$constraints) &#123;$table = $this-&gt;related-&gt;getTable();$this-&gt;query-&gt;where($table.'.'.$this-&gt;ownerKey, '=', $this-&gt;child-&gt;&#123;$this-&gt;foreignKey&#125;);&#125;&#125; 本例中的限制条件 1select post where post.id = comments.commentable_id 多对多多态关联除了传统的多态关联，您也可以定义「多对多」的多态关联。例如，Post模型和Video模型可以共享一个多态关联至 Tag 模型。 使用多对多多态关联可以让您在文章和视频中共享唯一的标签列表。 12345678910class Post extends Model&#123;/*** 获得此文章的所有标签。*/public function tags()&#123;return $this-&gt;morphToMany('App\Tag', 'taggable');&#125;&#125; 多对多多态关联与多对多关联的代码类似，不同的是中间表不再是两个父模型的蛇形变量，而是name的复数，值得注意的是foreignPivotKey代表中间表中对当前post或者video的外键，一般会放在taggable_id字段中，relatedPivotKey代表中间表中对属性表 tag 的外键 tag_id :123456789101112131415161718192021public function morphToMany($related, $name, $table = null, $foreignPivotKey = null,$relatedPivotKey = null, $parentKey = null,$relatedKey = null, $inverse = false)&#123;$caller = $this-&gt;guessBelongsToManyRelation();$instance = $this-&gt;newRelatedInstance($related);$foreignPivotKey = $foreignPivotKey ?: $name.'_id';$relatedPivotKey = $relatedPivotKey ?: $instance-&gt;getForeignKey();$table = $table ?: Str::plural($name);return new MorphToMany($instance-&gt;newQuery(), $this, $name, $table,$foreignPivotKey, $relatedPivotKey, $parentKey ?: $this-&gt;getKeyName(),$relatedKey ?: $instance-&gt;getKeyName(), $caller, $inverse);&#125; MorphToMany的构造函数依然有morphType与morphClass，morphType标识着当前中间表的记录类型是Post，还是videos，morphClass的值默认值是Post类或者videos的全名，正向关联的时候， inverse是false，反向关联的时候，inverse是true 。1234567891011121314public function __construct(Builder $query, Model $parent, $name, $table, $foreignPivotKey,$relatedPivotKey, $parentKey, $relatedKey, $relationName = null, $inverse = false)&#123;$this-&gt;inverse = $inverse;$this-&gt;morphType = $name.'_type';$this-&gt;morphClass = $inverse ? $query-&gt;getModel()-&gt;getMorphClass() : $parent-&gt;getMorphClass();parent::__construct($query, $parent, $table, $foreignPivotKey,$relatedPivotKey, $parentKey, $relatedKey, $relationName);&#125; 正向关联的时候， parent 类是 Post 类或者 videos 类，反向关联的时候related 是 Post 类或者 videos 类。限制条件：12345678910111213141516171819protected function addWhereConstraints()&#123;parent::addWhereConstraints();$this-&gt;query-&gt;where($this-&gt;table.'.'.$this-&gt;morphType, $this-&gt;morphClass);return $this;&#125;protected function addWhereConstraints()&#123;$this-&gt;query-&gt;where($this-&gt;getQualifiedForeignPivotKeyName(), '=', $this-&gt;parent-&gt;&#123;$this-&gt;parentKey&#125;);return $this;&#125;public function getQualifiedForeignPivotKeyName()&#123;return $this-&gt;table.'.'.$this-&gt;foreignPivotKey;&#125; 官网中例子限制条件转化为 sql (假设 Post 的主键为 1) ： 12where taggables.taggable_id = 1;where taggables.taggable_type = 'App\Post' morphToMany 的模型关系如下： 限制条件： 12345678910111213141516171819202122232425262728293031public function addConstraints()&#123;$this-&gt;performJoin();if (static::$constraints) &#123;$this-&gt;addWhereConstraints();&#125;&#125;protected function performJoin($query = null)&#123;$query = $query ?: $this-&gt;query;$baseTable = $this-&gt;related-&gt;getTable();$key = $baseTable.'.'.$this-&gt;relatedKey;$query-&gt;join($this-&gt;table, $key, '=', $this-&gt;getQualifiedRelatedPivotKeyName());return $this;&#125;protected function addWhereConstraints()&#123;parent::addWhereConstraints();$this-&gt;query-&gt;where($this-&gt;table.'.'.$this-&gt;morphType, $this-&gt;morphClass);return $this;&#125;protected function addWhereConstraints()&#123;$this-&gt;query-&gt;where($this-&gt;getQualifiedForeignPivotKeyName(), '=', $this-&gt;parent-&gt;&#123;$this-&gt;parentKey&#125;);return $this;&#125; 本例中的限制条件：123select tag join tagable on tagable.tag_id = tag.idselect tags where tagable.tagables_id = post.idselect tags where tagable.tagables_type = 'App\Tag' 多对多多态反向关联官方文档例子：12345678910class Tag extends Model&#123;/*** 获得此标签下所有的文章。*/public function posts()&#123;return $this-&gt;morphedByMany('App\Post', 'taggable');&#125;&#125; 与正向关联相反，relatedPivotKey代表中间表中对related表post或者video的外键，一般会放在taggable_id字段中， foreignPivotKey代表中间表中对当前属性表tag的外键tag_id： 12345678910111213public function morphedByMany($related, $name, $table = null, $foreignPivotKey = null,$relatedPivotKey = null, $parentKey = null, $relatedKey = null)&#123;$foreignPivotKey = $foreignPivotKey ?: $this-&gt;getForeignKey();$relatedPivotKey = $relatedPivotKey ?: $name.'_id';return $this-&gt;morphToMany($related, $name, $table, $foreignPivotKey,$relatedPivotKey, $parentKey, $relatedKey, true);&#125; 官网中例子限制条件转化为 sql (假设 Tag 的主键为 1) ： 12where taggables.tag_id = 1;where taggables.taggable_type = 'App\Post' morphedByMany 的模型关系如下：限制条件与 morphToMany 一致： 1234567891011121314151617181920212223242526272829303132public function addConstraints()&#123;$this-&gt;performJoin();if (static::$constraints) &#123;$this-&gt;addWhereConstraints();&#125;&#125;protected function performJoin($query = null)&#123;$query = $query ?: $this-&gt;query;$baseTable = $this-&gt;related-&gt;getTable();$key = $baseTable.'.'.$this-&gt;relatedKey;$query-&gt;join($this-&gt;table, $key, '=', $this-&gt;getQualifiedRelatedPivotKeyName());return $this;&#125;protected function addWhereConstraints()&#123;parent::addWhereConstraints();$this-&gt;query-&gt;where($this-&gt;table.'.'.$this-&gt;morphType, $this-&gt;morphClass);return $this;&#125;protected function addWhereConstraints()&#123;$this-&gt;query-&gt;where($this-&gt;getQualifiedForeignPivotKeyName(), '=', $this-&gt;parent-&gt;&#123;$this-&gt;parentKey&#125;);return $this;&#125; 本例中的限制条件123select post join post on post.id = tagables.tagable_idselect post where tagables.tag_id = tag.idselect post where tagables.tagable_type = 'App\Post']]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel HTTP-控制器方法的参数构建与运行]]></title>
    <url>%2F2020%2F05%2F24%2FLaravel-HTTP-%E6%8E%A7%E5%88%B6%E5%99%A8%E6%96%B9%E6%B3%95%E7%9A%84%E5%8F%82%E6%95%B0%E6%9E%84%E5%BB%BA%E4%B8%8E%E8%BF%90%E8%A1%8C%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言经过前面一系列中间件的工作，现在请求终于要达到了正确的控制器方法了。本篇文章主要讲Laravel如何调用控制器方法，并且为控制器方法依赖注入构建参数的过程。 路由控制器的调用我们前面已经解析过中间件的搜集与排序、pipeline的原理，接下来就要进行路由的run运行函数： 1234567891011121314151617181920212223242526272829namespace Illuminate\Routing;class Router implements BindingRegistrar, RegistrarContract&#123; /** * Run the given route within a Stack "onion" instance. * * @param \Illuminate\Routing\Route $route * @param \Illuminate\Http\Request $request * @return mixed */ protected function runRouteWithinStack(Route $route, Request $request) &#123; $shouldSkipMiddleware = $this-&gt;container-&gt;bound('middleware.disable') &amp;&amp; $this-&gt;container-&gt;make('middleware.disable') === true; $middleware = $shouldSkipMiddleware ? [] : $this-&gt;gatherRouteMiddleware($route); return (new Pipeline($this-&gt;container)) -&gt;send($request) -&gt;through($middleware) -&gt;then(function ($request) use ($route) &#123; return $this-&gt;prepareResponse( $request, $route-&gt;run() ); &#125;); &#125;&#125; 路由的run函数主要负责路由控制器方法与路由闭包函数的运行：123456789101112131415161718192021222324namespace Illuminate\Routing;class Route&#123; /** * Run the route action and return the response. * * @return mixed */ public function run() &#123; $this-&gt;container = $this-&gt;container ?: new Container; try &#123; if ($this-&gt;isControllerAction()) &#123; return $this-&gt;runController(); &#125; return $this-&gt;runCallable(); &#125; catch (HttpResponseException $e) &#123; return $e-&gt;getResponse(); &#125; &#125;&#125; 路由的运行主要靠ControllerDispatcher这个类：1234567891011121314151617181920212223242526class Route&#123; /** * Checks whether the route's action is a controller. * * @return bool */ protected function isControllerAction() &#123; return is_string($this-&gt;action['uses']); &#125; /** * Run the route action and return the response. * * @return mixed * * @throws \Symfony\Component\HttpKernel\Exception\NotFoundHttpException */ protected function runController() &#123; return $this-&gt;controllerDispatcher()-&gt;dispatch( $this, $this-&gt;getController(), $this-&gt;getControllerMethod() ); &#125;&#125; 123456789101112131415161718192021222324252627282930namespace Illuminate\Routing;use Illuminate\Container\Container;use Illuminate\Routing\Contracts\ControllerDispatcher as ControllerDispatcherContract;class ControllerDispatcher implements ControllerDispatcherContract&#123; use RouteDependencyResolverTrait; /** * Dispatch a request to a given controller and method. * * @param \Illuminate\Routing\Route $route * @param mixed $controller * @param string $method * @return mixed */ public function dispatch(Route $route, $controller, $method) &#123; $parameters = $this-&gt;resolveClassMethodDependencies( $route-&gt;parametersWithoutNulls(), $controller, $method ); if (method_exists($controller, 'callAction')) &#123; return $controller-&gt;callAction($method, $parameters); &#125; return $controller-&gt;&#123;$method&#125;(...array_values($parameters)); &#125;&#125; 上面可以很清晰地看出，控制器的运行分为两步：解析函数参数、调用callAction 解析控制器方法参数解析参数的功能主要由ControllerDispatcher类的RouteDependencyResolverTrait这一trait负责： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;?phpnamespace Illuminate\Routing;use Illuminate\Support\Arr;use ReflectionFunctionAbstract;use ReflectionMethod;use ReflectionParameter;trait RouteDependencyResolverTrait&#123; /** * Resolve the object method's type-hinted dependencies. * * @param array $parameters * @param object $instance * @param string $method * @return array */ protected function resolveClassMethodDependencies(array $parameters, $instance, $method) &#123; if (! method_exists($instance, $method)) &#123; return $parameters; &#125; return $this-&gt;resolveMethodDependencies( $parameters, new ReflectionMethod($instance, $method) ); &#125; /** * Resolve the given method's type-hinted dependencies. * * @param array $parameters * @param \ReflectionFunctionAbstract $reflector * @return array */ public function resolveMethodDependencies(array $parameters, ReflectionFunctionAbstract $reflector) &#123; $instanceCount = 0; $values = array_values($parameters); foreach ($reflector-&gt;getParameters() as $key =&gt; $parameter) &#123; $instance = $this-&gt;transformDependency( $parameter, $parameters ); if (! is_null($instance)) &#123; $instanceCount++; $this-&gt;spliceIntoParameters($parameters, $key, $instance); &#125; elseif (! isset($values[$key - $instanceCount]) &amp;&amp; $parameter-&gt;isDefaultValueAvailable()) &#123; $this-&gt;spliceIntoParameters($parameters, $key, $parameter-&gt;getDefaultValue()); &#125; &#125; return $parameters; &#125;&#125; 控制器方法函数参数构造难点在于，参数来源有三种： 路由参数赋值 IoC容器自动注入 函数自带默认值 在IoC容器自动注入的时候，要保证路由的现有参数中没有相应的类，防止依赖注入覆盖路由绑定的参数： 1234567891011121314151617181920/** * Attempt to transform the given parameter into a class instance. * * @param \ReflectionParameter $parameter * @param array $parameters * @return mixed */protected function transformDependency(ReflectionParameter $parameter, $parameters)&#123; $class = $parameter-&gt;getClass(); // If the parameter has a type-hinted class, we will check to see if it is already in // the list of parameters. If it is we will just skip it as it is probably a model // binding and we do not want to mess with those; otherwise, we resolve it here. if ($class &amp;&amp; ! $this-&gt;alreadyInParameters($class-&gt;name, $parameters)) &#123; return $parameter-&gt;isDefaultValueAvailable() ? $parameter-&gt;getDefaultValue() : $this-&gt;container-&gt;make($class-&gt;name); &#125;&#125; 由IoC容器构造出的参数需要插入到原有的路由参数数组中： 123456789101112131415161718192021if (! is_null($instance)) &#123; $instanceCount++; $this-&gt;spliceIntoParameters($parameters, $key, $instance);&#125;/** * Splice the given value into the parameter list. * * @param array $parameters * @param string $offset * @param mixed $value * @return void */protected function spliceIntoParameters(array &amp;$parameters, $offset, $value)&#123; array_splice( $parameters, $offset, 0, [$value] );&#125; 当路由的参数数组与IoC容器构造的参数数量不足以覆盖控制器参数个数时，就要去判断控制器是否具有默认参数： 1234elseif (! isset($values[$key - $instanceCount]) &amp;&amp; $parameter-&gt;isDefaultValueAvailable()) &#123; $this-&gt;spliceIntoParameters($parameters, $key, $parameter-&gt;getDefaultValue());&#125; 调用控制器方法callAction所有的控制器并非是直接调用相应方法的，而是通过callAction函数再分配，如果实在没有相应方法还会调用魔术方法__call() : 12345678910111213141516171819202122232425262728293031323334namespace Illuminate\Routing;use BadMethodCallException;abstract class Controller&#123; /** * Execute an action on the controller. * * @param string $method * @param array $parameters * @return \Symfony\Component\HttpFoundation\Response */ public function callAction($method, $parameters) &#123; return call_user_func_array([$this, $method], $parameters); &#125; /** * Handle calls to missing methods on the controller. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public function __call($method, $parameters) &#123; throw new BadMethodCallException(sprintf( 'Method %s::%s does not exist.', static::class, $method )); &#125;&#125; 路由闭包函数的调用路由闭包函数的调用与控制器方法一样，仍然需要依赖注入，参数构造： 1234567891011121314151617class Route&#123; /** * Run the route action and return the response. * * @return mixed */ protected function runCallable() &#123; $callable = $this-&gt;action['uses']; return $callable(...array_values($this-&gt;resolveMethodDependencies( $this-&gt;parametersWithoutNulls(), new ReflectionFunction($this-&gt;action['uses']) ))); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Database-数据库服务的启动与连接]]></title>
    <url>%2F2020%2F05%2F23%2FLaravel-Database-%E6%95%B0%E6%8D%AE%E5%BA%93%E6%9C%8D%E5%8A%A1%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E8%BF%9E%E6%8E%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言大致的讲，Laravel的数据库功能可以分为两部分：数据库DB、数据库Eloquent Model。数据库的Eloquent是功能十分丰富的ORM，让我们可以避免写繁杂的SQL语句。数据库DB是比较底层的与PDO交互的功能，Eloquent的底层依赖于DB。本文将会介绍数据库DB中关于数据库服务的启动与连接部分。 在详细讲解数据库各个功能之前，我们先看看支撑着整个Laravel数据库功能的框架： DB也就是DatabaseManager，承担着数据库接口的工作，一切数据库相关的操作，例如查询、更新、插入、删除都可以通过DB这个接口来完成。但是，具体的调用PDO API的工作却不是由该类完成的，它仅仅是一个对外的接口而已。 ConnectionFactory顾名思义专门为DB构造初始化Connector、Connection对象。 Connector负责数据库的连接功能，为保障程序的高效，Laravel将其包装成为闭包函数，并将闭包函数作为Connection的一个成员对象，实现懒加载。 Connection负责数据库的具体功能，负责底层与PDO API的交互。 数据库服务的注册与启动数据库服务也是一种服务提供者。 Illuminate\Database\DatabaseServiceProvider.php 123456789101112131415namespace Illuminate\Database;class DatabaseServiceProvider extends ServiceProvider&#123; public function register() &#123; Model::clearBootedModels(); $this-&gt;registerConnectionServices(); $this-&gt;registerEloquentFactory(); $this-&gt;registerQueueableEntityResolver(); &#125;&#125; 我们先来看这个注册函数的第一句：Model::clearBootedModels()。这一句其实是为了Eloquent服务的启动做准备。数据库的Eloquent Model有一个静态的成员变量数组$booted，这个静态数组存储了所有已经被初始化的数据库model，以便加载数据库模型时更加迅速。因此，在Eloquent服务启动之前需要初始化静态成员变量$booted： Illuminate\Database\Eloquent\Model.php 123456789101112131415161718192021222324252627282930namespace Illuminate\Database\Eloquent;abstract class Model implements Arrayable, ArrayAccess, Jsonable, JsonSerializable, QueueableEntity, UrlRoutable&#123; /** * 已经初始化的数据库 * * @var array */ protected static $booted = []; /** * The array of global scopes on the model. * * @var array */ protected static $globalScopes = []; /** * 清除已经初始化的数据库的列表，以便将其重新初始化。 * * @return void */ public static function clearBootedModels() &#123; static::$booted = []; static::$globalScopes = []; &#125;&#125; 接下来我们就开始看数据库服务的注册最重要的两部分：ConnectionServices与Eloquent。 ConnectionServices注册 Illuminate\Database\DatabaseServiceProvider.php 12345678910111213141516171819202122232425262728namespace Illuminate\Database;class DatabaseServiceProvider extends ServiceProvider&#123; /** * 注册主数据库绑定。 * * @return void */ protected function registerConnectionServices() &#123; // ConnectionFactory用于在数据库上创建实际的连接实例。 // 我们会将工厂注入到manager中，以便它可以在实际需要时（而不是以前）建立连接。 $this-&gt;app-&gt;singleton('db.factory', function ($app) &#123; return new ConnectionFactory($app); &#125;); // DatabaseManager用于解析各种连接，因为可以管理多个连接。 // 它还实现了连接解析器接口，该接口可以由需要连接的其他组件使用。 $this-&gt;app-&gt;singleton('db', function ($app) &#123; return new DatabaseManager($app, $app['db.factory']); &#125;); $this-&gt;app-&gt;bind('db.connection', function ($app) &#123; return $app['db']-&gt;connection(); &#125;); &#125;&#125; 可以看出，数据库服务向IoC容器注册了db、db.factory与db.connection。 最重要的莫过于db对象，它有一个Facade是DB，我们可以利用DB::connection()来连接任意数据库，可以利用DB::select()来进行数据库的查询，可以说DB就是我们操作数据库的接口。 db.factory负责为DB创建connector提供数据库的底层连接服务，负责为DB创建connection对象来进行数据库的查询等操作。 db.connection是Laravel用于与数据库pdo接口进行交互的底层类，可用于数据库的查询、更新、创建等操作。 Eloquent注册12345678910111213141516171819202122namespace Illuminate\Database;class DatabaseServiceProvider extends ServiceProvider&#123; /** * 在容器中注册Eloquent工厂实例。 * * @return void */ protected function registerEloquentFactory() &#123; $this-&gt;app-&gt;singleton(FakerGenerator::class, function ($app, $parameters) &#123; return FakerFactory::create($parameters['locale'] ?? $app['config']-&gt;get('app.faker_locale', 'en_US')); &#125;); $this-&gt;app-&gt;singleton(EloquentFactory::class, function ($app) &#123; return EloquentFactory::construct( $app-&gt;make(FakerGenerator::class), $this-&gt;app-&gt;databasePath('factories') ); &#125;); &#125;&#125; EloquentFactory用于创建Eloquent Model，用于全局函数factory()来创建数据库模型。 数据库服务的启动1234567891011/** * 初始化应用程序事件。 * * @return void */public function boot()&#123; Model::setConnectionResolver($this-&gt;app['db']); Model::setEventDispatcher($this-&gt;app['events']);&#125; 数据库服务的启动主要设置Eloquent Model的connection resolver，用于数据库模型model利用db来连接数据库。还有设置数据库事件的分发器dispatcher，用于监听数据库的事件。 DatabaseManager-数据库的接口如果我们想要使用任何数据库服务，首先要做的事情当然是利用用户名与密码来连接数据库。在Laravel中，数据库的用户名与密码一般放在.env文件中或者放入nginx配置中，并且利用数据库的接口DB来与pdo进行交互，利用pdo来连接数据库。 DB即是类Illuminate\Database\DatabaseManager，首先我们来看看其构造函数： 1234567891011121314namespace Illuminate\Database;class DatabaseManager implements ConnectionResolverInterface&#123; public function __construct($app, ConnectionFactory $factory) &#123; $this-&gt;app = $app; $this-&gt;factory = $factory; $this-&gt;reconnector = function ($connection) &#123; $this-&gt;reconnect($connection-&gt;getName()); &#125;; &#125;&#125; 我们称DB为一个接口，或者是一个门面模式，是因为数据库操作，例如数据库的连接或者查询、更新等操作均不是DB的功能，数据库的连接使用类Illuminate\Database\Connectors\Connector完成，数据库的查询等操作由类Illuminate\Database\Connection完成，因此，我们不必直接操作connector或者connection，仅仅会操作DB即可。 那么DB是如何实现connector或者connection的功能的呢？关键还是这个ConnectionFactory类，这个工厂类专门为DB来生成connection对象，并将其放入DB的成员变量数组$connections中去。connection中会包含connector对象来实现数据库的连接工作。 12345678910111213namespace Illuminate\Database;class DatabaseManager implements ConnectionResolverInterface&#123; protected $app; protected $factory; protected $connections = []; public function __call($method, $parameters) &#123; return $this-&gt;connection()-&gt;$method(...$parameters); &#125;&#125; 魔术函数实现了DB与connection的无缝连接，任何对数据库的操作，例如DB::select()、DB::table(‘user’)-&gt;save()，都会被转移至connection中去。 connection函数-获取数据库连接对象123456789101112131415161718192021222324252627282930313233343536373839namespace Illuminate\Database;use Illuminate\Database\Connectors\ConnectionFactory;use Illuminate\Support\Arr;use Illuminate\Support\ConfigurationUrlParser;use Illuminate\Support\Str;use InvalidArgumentException;use PDO;/** * @mixin \Illuminate\Database\Connection */class DatabaseManager implements ConnectionResolverInterface&#123; /** * 获取数据库连接实例。 * * @param string|null $name * @return \Illuminate\Database\Connection */ public function connection($name = null) &#123; [$database, $type] = $this-&gt;parseConnectionName($name); $name = $name ?: $database; // 如果尚未创建此连接，则将基于应用程序中提供的配置来创建它。 // 创建连接后，我们将为PDO设置“fetch mode”，该模式将确定查询返回类型。 if (! isset($this-&gt;connections[$name])) &#123; $this-&gt;connections[$name] = $this-&gt;configure( $this-&gt;makeConnection($database), $type ); &#125; return $this-&gt;connections[$name]; &#125;&#125; 具体流程如下： DB的connection函数可以传入数据库的名字，也可以不传任何参数，此时会连接默认数据库，默认数据库的设置在config/database文件中。 connection函数流程： 解析数据库名称与数据库类型，例如只读、写。 若没有创建过与该数据库的连接，则开始创建数据库连接。 返回数据库连接对象Connection。 123456789101112131415161718192021222324252627282930313233343536373839namespace Illuminate\Database;use Illuminate\Database\Connectors\ConnectionFactory;use Illuminate\Support\Arr;use Illuminate\Support\ConfigurationUrlParser;use Illuminate\Support\Str;use InvalidArgumentException;use PDO;/** * @mixin \Illuminate\Database\Connection */class DatabaseManager implements ConnectionResolverInterface&#123; /** * 将连接解析为名称和读/写类型的数组。 * * @param string $name * @return array */ protected function parseConnectionName($name) &#123; $name = $name ?: $this-&gt;getDefaultConnection(); return Str::endsWith($name, ['::read', '::write']) ? explode('::', $name, 2) : [$name, null]; &#125; /** * 获取默认的连接名称。 * * @return string */ public function getDefaultConnection() &#123; return $this-&gt;app['config']['database.default']; &#125;&#125; 可以看出，若没有特别指定连接的数据库名称，那么就会利用文件config/database文件中设置的default数据库名称作为默认连接数据库名称。若数据库支持读写分离，那么还可以指定数据库的读写属性，例如mysql::read。 makeConnection函数-创建新的数据库连接对象当框架从未连接过当前数据库的时候，就要对数据库进行连接操作，首先程序会调用makeConnection函数：123456789101112131415161718192021222324252627/** * make数据库连接实例。 * * @param string $name * @return \Illuminate\Database\Connection */protected function makeConnection($name)&#123; $config = $this-&gt;configuration($name); // 首先，我们将通过连接名称进行检查，以查看是否已为该连接专门注册了扩展名。 // 如果有，我们将调用Closure并将其传递给配置，以使其能够解析连接。 if (isset($this-&gt;extensions[$name])) &#123; return call_user_func($this-&gt;extensions[$name], $config, $name); &#125; // 接下来，我们将检查是否已为驱动程序注册了扩展名， // 如果已注册，则将调用Closure，这将使我们能够为驱动程序本身使用更通用的解析器， //该解析器适用于所有连接。 if (isset($this-&gt;extensions[$driver = $config['driver']])) &#123; return call_user_func($this-&gt;extensions[$driver], $config, $name); &#125; return $this-&gt;factory-&gt;make($config, $name);&#125; 可以看出，连接数据库仅仅需要两个步骤：获取数据库配置、利用connection factory获取connection对象。 获取数据库配置： 123456789101112131415161718192021222324/** * 获取连接的配置。 * * @param string $name * @return array * * @throws \InvalidArgumentException */protected function configuration($name)&#123; $name = $name ?: $this-&gt;getDefaultConnection(); // 要获取数据库连接配置，我们将仅提取每个连接配置并获取给定名称的配置。 // 如果配置不存在，我们将抛出异常并撒手不管。 $connections = $this-&gt;app['config']['database.connections']; if (is_null($config = Arr::get($connections, $name))) &#123; throw new InvalidArgumentException("Database connection [&#123;$name&#125;] not configured."); &#125; return (new ConfigurationUrlParser) -&gt;parseConfiguration($config);&#125; 也是非常简单，直接从配置文件中获取当前数据库的配置： 123456789101112131415161718192021'connections' =&gt; [ 'mysql' =&gt; [ 'driver' =&gt; 'mysql', 'host' =&gt; env('DB_HOST', '127.0.0.1'), 'port' =&gt; env('DB_PORT', '3306'), 'database' =&gt; env('DB_DATABASE', 'forge'), 'username' =&gt; env('DB_USERNAME', 'forge'), 'password' =&gt; env('DB_PASSWORD', ''), 'charset' =&gt; 'utf8mb4', 'collation' =&gt; 'utf8mb4_unicode_ci', 'prefix' =&gt; '', 'strict' =&gt; true, 'engine' =&gt; null, 'read' =&gt; [ 'database' =&gt; env('DB_DATABASE', 'forge'), ], 'write' =&gt; [ 'database' =&gt; env('DB_DATABASE', 'forge'), ], ],], $this-&gt;factory-&gt;make($config, $name)函数向我们提供了数据库连接对象。 configure-连接对象读写配置当我们从connection factory中获取到连接对象connection之后，我们就要根据传入的参数进行读写配置：1234567891011121314151617181920212223242526/** * 准备数据库连接实例。 * * @param \Illuminate\Database\Connection $connection * @param string $type * @return \Illuminate\Database\Connection */protected function configure(Connection $connection, $type)&#123; $connection = $this-&gt;setPdoForType($connection, $type); // 首先，我们将设置获取模式以及数据库连接的其他一些依赖性。 // 该方法基本上只是配置并准备好供应用程序使用。 // 完成后，我们将其退回。 if ($this-&gt;app-&gt;bound('events')) &#123; $connection-&gt;setEventDispatcher($this-&gt;app['events']); &#125; // 在这里，我们将设置一个reconnector回调。 // 此重新连接器可以是任何可调用的， // 因此我们将设置一个Closure以使用连接名从该管理器重新连接， // 这将允许我们从连接中重新连接。 $connection-&gt;setReconnector($this-&gt;reconnector); return $connection;&#125; setPdoForType函数就是根据type来设置读写： 当我们需要read数据库连接时，我们将read-pdo设置为主pdo。当我们需要write数据库连接时，我们将读写pdo都设置为write-pdo： 1234567891011121314151617181920/** * 准备数据库连接实例的读/写模式。 * * @param \Illuminate\Database\Connection $connection * @param string|null $type * @return \Illuminate\Database\Connection */protected function setPdoForType(Connection $connection, $type = null)&#123; if ($type === 'read') &#123; $connection-&gt;setPdo($connection-&gt;getReadPdo()); &#125; elseif ($type === 'write') &#123; $connection-&gt;setReadPdo($connection-&gt;getPdo()); &#125; return $connection;&#125; ConnectionFactory-数据库连接对象工厂 make函数-工厂接口获取到了数据库的配置参数之后，就要利用ConnectionFactory来获取connection对象了： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace Illuminate\Database\Connectors;use Illuminate\Contracts\Container\Container;use Illuminate\Database\Connection;use Illuminate\Database\MySqlConnection;use Illuminate\Database\PostgresConnection;use Illuminate\Database\SQLiteConnection;use Illuminate\Database\SqlServerConnection;use Illuminate\Support\Arr;use InvalidArgumentException;use PDOException;class ConnectionFactory&#123; /** * 根据配置建立PDO连接。 * * @param array $config * @param string|null $name * @return \Illuminate\Database\Connection */ public function make(array $config, $name = null) &#123; $config = $this-&gt;parseConfig($config, $name); if (isset($config['read'])) &#123; return $this-&gt;createReadWriteConnection($config); &#125; return $this-&gt;createSingleConnection($config); &#125; /** * 解析并准备数据库配置。 * * @param array $config * @param string $name * @return array */ protected function parseConfig(array $config, $name) &#123; return Arr::add(Arr::add($config, 'prefix', ''), 'name', $name); &#125;&#125; 在建立连接之前，要先向配置参数中添加默认的prefix属性与name属性。 接着，就要判断我们在配置文件中是否设置了读写分离。如果设置了读写分离，那么就会调用createReadWriteConnection函数，生成具有读、写两个功能的connection；否则的话，就会调用createSingleConnection函数，生成普通的连接对象。 createSingleConnection函数-制造数据库连接对象createSingleConnection函数是类ConnectionFactory的核心，用于生成新的数据库连接对象。 1234567891011121314/** * 创建一个数据库连接单例。 * * @param array $config * @return \Illuminate\Database\Connection */protected function createSingleConnection(array $config)&#123; $pdo = $this-&gt;createPdoResolver($config); return $this-&gt;createConnection( $config['driver'], $pdo, $config['database'], $config['prefix'], $config );&#125; ConnectionFactory也很简单，只做了两件事情：制造pdo连接的闭包函数、构造一个新的connection对象。 createPdoResolver-数据库连接器闭包函数根据配置参数中是否含有host，创建不同的闭包函数： 123456789101112/** * 创建一个新的Closure，解析为PDO实例。 * * @param array $config * @return \Closure */protected function createPdoResolver(array $config)&#123; return array_key_exists('host', $config) ? $this-&gt;createPdoResolverWithHosts($config) : $this-&gt;createPdoResolverWithoutHosts($config);&#125; 不带有host的pdo闭包函数： 123456789101112/** * 创建一个新的Closure，解析为没有配置主机的PDO实例。 * * @param array $config * @return \Closure */protected function createPdoResolverWithoutHosts(array $config)&#123; return function () use ($config) &#123; return $this-&gt;createConnector($config)-&gt;connect($config); &#125;;&#125; 可以看出，不带有pdo的闭包函数非常简单，仅仅创建connector对象，利用connector对象进行数据库的连接。 带有host的pdo闭包函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 创建一个新的Closure，解析为具有特定主机或主机阵列的PDO实例。 * * @param array $config * @return \Closure */protected function createPdoResolverWithHosts(array $config)&#123; return function () use ($config) &#123; foreach (Arr::shuffle($hosts = $this-&gt;parseHosts($config)) as $key =&gt; $host) &#123; $config['host'] = $host; try &#123; return $this-&gt;createConnector($config)-&gt;connect($config); &#125; catch (PDOException $e) &#123; continue; &#125; &#125; throw $e; &#125;;&#125;/** * 将主机配置项解析为一个数组。 * * @param array $config * @return array * * @throws \InvalidArgumentException */protected function parseHosts(array $config)&#123; $hosts = Arr::wrap($config['host']); if (empty($hosts)) &#123; throw new InvalidArgumentException('Database hosts array is empty.'); &#125; return $hosts;&#125; 带有host的闭包函数相对比较复杂，首先程序会随机选择不同的数据库依次来建立数据库连接，若均失败，就会报告异常。 createConnector-创建连接器程序会根据配置参数中driver的不同来创建不同的连接器，每个连接器都继承自connector类，用于连接数据库。 12345678910111213141516171819202122232425262728293031323334/** * 根据配置创建连接器实例。 * * @param array $config * @return \Illuminate\Database\Connectors\ConnectorInterface * * @throws \InvalidArgumentException */public function createConnector(array $config)&#123; if (! isset($config['driver'])) &#123; throw new InvalidArgumentException('A driver must be specified.'); &#125; if ($this-&gt;container-&gt;bound($key = "db.connector.&#123;$config['driver']&#125;")) &#123; return $this-&gt;container-&gt;make($key); &#125; switch ($config['driver']) &#123; case 'mysql': return new MySqlConnector; case 'pgsql': return new PostgresConnector; case 'sqlite': return new SQLiteConnector; case 'sqlsrv': return new SqlServerConnector; &#125; throw new InvalidArgumentException("Unsupported driver [&#123;$config['driver']&#125;]");&#125; createConnection-创建连接对象123456789101112131415161718192021222324252627282930313233/** * 创建一个新的连接实例。 * * @param string $driver * @param \PDO|\Closure $connection * @param string $database * @param string $prefix * @param array $config * @return \Illuminate\Database\Connection * * @throws \InvalidArgumentException */protected function createConnection($driver, $connection, $database, $prefix = '', array $config = [])&#123; if ($resolver = Connection::getResolver($driver)) &#123; return $resolver($connection, $database, $prefix, $config); &#125; switch ($driver) &#123; case 'mysql': return new MySqlConnection($connection, $database, $prefix, $config); case 'pgsql': return new PostgresConnection($connection, $database, $prefix, $config); case 'sqlite': return new SQLiteConnection($connection, $database, $prefix, $config); case 'sqlsrv': return new SqlServerConnection($connection, $database, $prefix, $config); &#125; throw new InvalidArgumentException("Unsupported driver [&#123;$driver&#125;]");&#125; 创建pdo闭包函数之后，会将该闭包函数放入connection对象当中去。以后我们利用connection对象进行查询或者更新数据库时，程序便会运行该闭包函数，与数据库进行连接。 createReadWriteConnection-创建读写连接对象当配置文件中有read、write等配置项时，说明用户希望创建一个可以读写分离的数据库连接，此时：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 创建一个数据库连接单例。 * * @param array $config * @return \Illuminate\Database\Connection */protected function createReadWriteConnection(array $config)&#123; $connection = $this-&gt;createSingleConnection($this-&gt;getWriteConfig($config)); return $connection-&gt;setReadPdo($this-&gt;createReadPdo($config));&#125;/** * 获取读/写连接的读配置。 * * @param array $config * @return array */protected function getWriteConfig(array $config)&#123; return $this-&gt;mergeReadWriteConfig( $config, $this-&gt;getReadWriteConfig($config, 'write') );&#125;/** * 获取读/写级别配置。 * * @param array $config * @param string $type * @return array */protected function getReadWriteConfig(array $config, $type)&#123; return isset($config[$type][0]) ? Arr::random($config[$type]) : $config[$type];&#125;/** * 合并读/写连接的配置。 * * @param array $config * @param array $merge * @return array */protected function mergeReadWriteConfig(array $config, array $merge)&#123; return Arr::except(array_merge($config, $merge), ['read', 'write']);&#125; 可以看出，程序先读出关于write数据库的配置，之后将其合并到总配置当中，删除关于read数据库的配置，然后进行createSingleConnection建立新的连接对象。 建立连接对象之后，再根据read数据库的配置，生成read数据库的pdo闭包函数，并调用setReadPdo将其设置为读库pdo。1234567891011121314151617181920212223/** * 创建一个新的PDO实例进行读取。 * * @param array $config * @return \Closure */protected function createReadPdo(array $config)&#123; return $this-&gt;createPdoResolver($this-&gt;getReadConfig($config));&#125;/** * 获取读/写连接的读配置。 * * @param array $config * @return array */protected function getReadConfig(array $config)&#123; return $this-&gt;mergeReadWriteConfig( $config, $this-&gt;getReadWriteConfig($config, 'read') );&#125; Connector连接我们以MySQL为例：12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Illuminate\Database\Connectors;use PDO;class MySqlConnector extends Connector implements ConnectorInterface&#123; /** * 建立数据库连接。 * * @param array $config * @return \PDO */ public function connect(array $config) &#123; $dsn = $this-&gt;getDsn($config); $options = $this-&gt;getOptions($config); // 我们需要获取在创建全新连接实例时应使用的PDO选项。 // PDO选项控制连接行为的各个方面，某些可能由开发人员指定。 $connection = $this-&gt;createConnection($dsn, $config, $options); if (! empty($config['database'])) &#123; $connection-&gt;exec("use `&#123;$config['database']&#125;`;"); &#125; $this-&gt;configureEncoding($connection, $config); // 接下来，我们将检查是否在此配置中指定了时区， // 如果已指定，则将发出一条语句来修改数据库的时区。 // 设置此数据库时区是可选配置项。 $this-&gt;configureTimezone($connection, $config); $this-&gt;setModes($connection, $config); return $connection; &#125;&#125; getDsn-获取数据库连接DSN参数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * 从配置中创建一个DSN字符串。 * * 根据“ unix_socket”配置值选择socket或host/port。 * * @param array $config * @return string */protected function getDsn(array $config)&#123; return $this-&gt;hasSocket($config) ? $this-&gt;getSocketDsn($config) : $this-&gt;getHostDsn($config);&#125;/** * 确定给定的配置数组是否具有UNIX套接字值。 * * @param array $config * @return bool */protected function hasSocket(array $config)&#123; return isset($config['unix_socket']) &amp;&amp; ! empty($config['unix_socket']);&#125;/** * 获取套接字配置的DSN字符串。 * * @param array $config * @return string */protected function getSocketDsn(array $config)&#123; return "mysql:unix_socket=&#123;$config['unix_socket']&#125;;dbname=&#123;$config['database']&#125;";&#125;/** * 获取主机/端口配置的DSN字符串。 * * @param array $config * @return string */protected function getHostDsn(array $config)&#123; extract($config, EXTR_SKIP); return isset($port) ? "mysql:host=&#123;$host&#125;;port=&#123;$port&#125;;dbname=&#123;$database&#125;" : "mysql:host=&#123;$host&#125;;dbname=&#123;$database&#125;";&#125; mysql数据库的连接有两种：tcp连接与socket连接。 socket连接更快，但是它要求应用程序与数据库在同一台机器，更普通的是使用tcp的方式连接数据库。框架根据配置参数来选择是采用socket还是tcp的方式连接数据库。 getOptions-pdo属性设置12345678910111213141516171819202122232425/** * 默认的PDO连接选项。 * * @var array */protected $options = [ PDO::ATTR_CASE =&gt; PDO::CASE_NATURAL, PDO::ATTR_ERRMODE =&gt; PDO::ERRMODE_EXCEPTION, PDO::ATTR_ORACLE_NULLS =&gt; PDO::NULL_NATURAL, PDO::ATTR_STRINGIFY_FETCHES =&gt; false, PDO::ATTR_EMULATE_PREPARES =&gt; false,];/** * 根据配置获取PDO选项。 * * @param array $config * @return array */public function getOptions(array $config)&#123; $options = $config['options'] ?? []; return array_diff_key($this-&gt;options, $options) + $options;&#125; pdo的属性主要有以下几种： PDO::ATTR_CASE强制列名为指定的大小写。他的$value可为： PDO::CASE_LOWER：强制列名小写。 PDO::CASE_NATURAL：保留数据库驱动返回的列名。 PDO::CASE_UPPER：强制列名大写。 PDO::ATTR_ERRMODE：错误报告。他的$value可为： PDO::ERRMODE_SILENT：仅设置错误代码。 PDO::ERRMODE_WARNING：引发E_WARNING错误。 PDO::ERRMODE_EXCEPTION：抛出exceptions异常。 PDO::ATTR_ORACLE_NULLS（在所有驱动中都可用，不仅限于Oracle）：转换NULL和空字符串。他的$value可为: PDO::NULL_NATURAL：不转换。 PDO::NULL_EMPTY_STRING：将空字符串转换成NULL。 PDO::NULL_TO_STRING：将NULL转换成空字符串。 PDO::ATTR_STRINGIFY_FETCHES：提取的时候将数值转换为字符串。 PDO::ATTR_EMULATE_PREPARES 启用或禁用预处理语句的模拟。有些驱动不支持或有限度地支持本地预处理。使用此设置强制PDO总是模拟预处理语句（如果为TRUE），或试着使用本地预处理语句（如果为FALSE）。如果驱动不能成功预处理当前查询，它将总是回到模拟预处理语句上。 需要bool类型。 PDO::ATTR_AUTOCOMMIT：设置当前连接MySQL服务器的客户端的SQL语句是否自动执行，默认是自动提交。 PDO::ATTR_PERSISTENT：当前对MySQL服务器的连接是否是长连接. createConnection-创建数据库连接12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 创建一个新的PDO连接。 * * @param string $dsn * @param array $config * @param array $options * @return \PDO * * @throws \Exception */public function createConnection($dsn, array $config, array $options)&#123; [ $username, $password ] = [ $config['username'] ?? null, $config['password'] ?? null, ]; try &#123; return $this-&gt;createPdoConnection( $dsn, $username, $password, $options ); &#125; catch (Exception $e) &#123; return $this-&gt;tryAgainIfCausedByLostConnection( $e, $dsn, $username, $password, $options ); &#125;&#125;/** * 创建一个新的PDO连接实例。 * * @param string $dsn * @param string $username * @param string $password * @param array $options * @return \PDO */protected function createPdoConnection($dsn, $username, $password, $options)&#123; if (class_exists(PDOConnection::class) &amp;&amp; ! $this-&gt;isPersistentConnection($options)) &#123; return new PDOConnection($dsn, $username, $password, $options); &#125; return new PDO($dsn, $username, $password, $options);&#125; 当pdo对象成功的建立起来后，说明我们已经与数据库成功地建立起来了一个连接，接下来我们就可以利用这个pdo对象进行查询或者更新等操作。 当创建pdo的时候抛出异常时： 12345678910111213141516171819202122/** * 处理在查询执行期间发生的查询异常。 * * @param \Illuminate\Database\QueryException $e * @param string $query * @param array $bindings * @param \Closure $callback * @return mixed * * @throws \Illuminate\Database\QueryException */protected function tryAgainIfCausedByLostConnection(QueryException $e, $query, $bindings, Closure $callback)&#123; if ($this-&gt;causedByLostConnection($e-&gt;getPrevious())) &#123; $this-&gt;reconnect(); return $this-&gt;runQueryCallback($query, $bindings, $callback); &#125; throw $e;&#125; Illuminate\Database\DetectsLostConnections.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace Illuminate\Database;use Illuminate\Support\Str;use Throwable;trait DetectsLostConnections&#123; /** * 确定给定的异常是否由丢失的连接引起。 * * @param \Throwable $e * @return bool */ protected function causedByLostConnection(Throwable $e) &#123; $message = $e-&gt;getMessage(); return Str::contains($message, [ 'server has gone away', 'no connection to the server', 'Lost connection', 'is dead or not enabled', 'Error while sending', 'decryption failed or bad record mac', 'server closed the connection unexpectedly', 'SSL connection has been closed unexpectedly', 'Error writing data to the connection', 'Resource deadlock avoided', 'Transaction() on null', 'child connection forced to terminate due to client_idle_limit', 'query_wait_timeout', 'reset by peer', 'Physical connection is not usable', 'TCP Provider: Error code 0x68', 'ORA-03114', 'Packets out of order. Expected', 'Adaptive Server connection failed', 'Communication link failure', 'connection is no longer usable', 'Login timeout expired', 'Connection refused', 'running with the --read-only option so it cannot execute this statement', ]); &#125;&#125; 当判断出的异常是上面几种情况时，框架会再次尝试连接数据库。 configureEncoding-设置字符集与校对集123456789101112131415161718192021222324252627/** * 设置连接字符集和排序规则。 * * @param \PDO $connection * @param array $config * @return void */protected function configureEncoding($connection, $config)&#123; if (! isset($config['charset'])) &#123; return; &#125; $connection-&gt;prepare("set names '&#123;$config['charset']&#125;'")-&gt;execute();&#125;/** * 获取配置的排序规则。 * * @param array $config * @return string */protected function getCollation(array $config)&#123; return isset($config['collation']) ? " collate '&#123;$config['collation']&#125;'" : '';&#125; 如果配置参数中设置了字符集与校对集，程序会利用配置的参数对数据库进行相关设置。 所谓的字符集与校对集设置，可以参考mysql中character set与collation的点滴理解 configureTimezone-设置时间区12345678910111213/** * 在连接上设置时区。 * * @param \PDO $connection * @param array $config * @return void */protected function configureTimezone($connection, array $config)&#123; if (isset($config['timezone'])) &#123; $connection-&gt;prepare('set time_zone="'.$config['timezone'].'"')-&gt;execute(); &#125;&#125; setModes-设置SQL_MODE模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455/** * 设置连接模式。 * * @param \PDO $connection * @param array $config * @return void */protected function setModes(PDO $connection, array $config)&#123; if (isset($config['modes'])) &#123; $this-&gt;setCustomModes($connection, $config); &#125; elseif (isset($config['strict'])) &#123; if ($config['strict']) &#123; $connection-&gt;prepare($this-&gt;strictMode($connection))-&gt;execute(); &#125; else &#123; $connection-&gt;prepare("set session sql_mode='NO_ENGINE_SUBSTITUTION'")-&gt;execute(); &#125; &#125;&#125;/** * 在连接上设置自定义模式。 * * @param \PDO $connection * @param array $config * @return void */protected function setCustomModes(PDO $connection, array $config)&#123; $modes = implode(',', $config['modes']); $connection-&gt;prepare("set session sql_mode='&#123;$modes&#125;'")-&gt;execute();&#125;/** * 获取查询以启用严格模式。 * * @param \PDO $connection * @return string */protected function strictMode(PDO $connection)&#123; if (version_compare($connection-&gt;getAttribute(PDO::ATTR_SERVER_VERSION), '8.0.11') &gt;= 0) &#123; return "set session sql_mode='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_ENGINE_SUBSTITUTION'"; &#125; return "set session sql_mode='ONLY_FULL_GROUP_BY,STRICT_TRANS_TABLES,NO_ZERO_IN_DATE,NO_ZERO_DATE,ERROR_FOR_DIVISION_BY_ZERO,NO_AUTO_CREATE_USER,NO_ENGINE_SUBSTITUTION'";&#125; 以下内容参考：mysql的sql_mode设置简介: SQL_MODE直接理解就是：sql的运作模式。官方的说法是：sql_mode可以影响sql支持的语法以及数据的校验执行，这使得MySQL可以运行在不同的环境中以及和其他数据库一起运作。 想设置sql_mode有三种方式： 在命令行启动MySQL时添加参数—sql-mode=”modes” 在MySQL的配置文件（my.cnf或者my.ini）中添加一个配置sql-mode=”modes” 运行时修改SQL mode可以通过以下命令之一：12SET GLOBAL sql_mode = &apos;modes&apos;;SET SESSION sql_mode = &apos;modes&apos;; 几种常见的mode介绍： ONLY_FULL_GROUP_BY：出现在select语句、HAVING条件和ORDER BY语句中的列，必须是GROUP BY的列或者依赖于GROUP BY列的函数列。 NO_AUTO_VALUE_ON_ZERO：该值影响自增长列的插入。默认设置下，插入0或NULL代表生成下一个自增长值。如果用户希望插入的值为0，而该列又是自增长的，那么这个选项就有用了。 STRICT_TRANS_TABLES：在该模式下，如果一个值不能插入到一个事务表中，则中断当前的操作，对非事务表不做限制 NO_ZERO_IN_DATE：这个模式影响了是否允许日期中的月份和日包含0。如果开启此模式，2016-01-00是不允许的，但是0000-02-01是允许的。它实际的行为受到strict mode是否开启的影响1。 NO_ZERO_DATE：设置该值，mysql数据库不允许插入零日期。它实际的行为受到strict mode是否开启的影响。 ERROR_FOR_DIVISION_BY_ZERO：在INSERT或UPDATE过程中，如果数据被零除，则产生错误而非警告。如果未给出该模式，那么数据被零除时MySQL返回NULL NO_AUTO_CREATE_USER：禁止GRANT创建密码为空的用户 NO_ENGINE_SUBSTITUTION：如果需要的存储引擎被禁用或未编译，那么抛出错误。不设置此值时，用默认的存储引擎替代，并抛出一个异常 PIPES_AS_CONCAT：将”||”视为字符串的连接操作符而非或运算符，这和Oracle数据库是一样的，也和字符串的拼接函数Concat相类似 ANSI_QUOTES：启用ANSI_QUOTES后，不能用双引号来引用字符串，因为它被解释为识别符]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel HTTP-路由加载源码分析]]></title>
    <url>%2F2020%2F05%2F22%2FLaravel-HTTP-%E8%B7%AF%E7%94%B1%E5%8A%A0%E8%BD%BD%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言作为Laravel极其重要的一部分，route功能贯穿着整个网络请求，是request生命周期的主干。本文主要讲述route服务的注册与启动、路由的属性注册。本篇内容相对简单，更多的是框架添加路由的整体设计流程。 route服务的注册Laravel在接受到请求后，先进行了服务容器与http核心的初始化，再进行了请求request的构造与分发。 route服务的注册-RoutingServiceProvider发生在服务容器container的初始化上； route服务的启动与加载-RouteServiceProvider发生在request的分发上。 route服务的注册-RoutingServiceProvider所有需要Laravel服务的请求都会加载入口文件index.php： 123require __DIR__.'/../vendor/autoload.php';$app = require_once __DIR__.'/../bootstrap/app.php'; 第一句我们在之前的博客提过，是实现PSR0、PSR4标准自动加载的功能模块，第二句就是今天说的Container的初始化：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php/*|--------------------------------------------------------------------------| Create The Application|--------------------------------------------------------------------------|| The first thing we will do is create a new Laravel application instance| which serves as the "glue" for all the components of Laravel, and is| the IoC container for the system binding all of the various parts.|*/$app = new Illuminate\Foundation\Application( $_ENV['APP_BASE_PATH'] ?? dirname(__DIR__));/*|--------------------------------------------------------------------------| Bind Important Interfaces|--------------------------------------------------------------------------|| Next, we need to bind some important interfaces into the container so| we will be able to resolve them when needed. The kernels serve the| incoming requests to this application from both the web and CLI.|*/$app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Console\Kernel::class, App\Console\Kernel::class);$app-&gt;singleton( Illuminate\Contracts\Debug\ExceptionHandler::class, App\Exceptions\Handler::class);/*|--------------------------------------------------------------------------| Return The Application|--------------------------------------------------------------------------|| This script returns the application instance. The instance is given to| the calling script so we can separate the building of the instances| from the actual running of the application and sending responses.|*/return $app; Application： 123456789101112131415161718192021namespace Illuminate\Foundation;class Application extends Container implements ApplicationContract, CachesConfiguration, CachesRoutes, HttpKernelInterface&#123; /** * Create a new Illuminate application instance. * * @param string|null $basePath * @return void */ public function __construct($basePath = null) &#123; if ($basePath) &#123; $this-&gt;setBasePath($basePath); &#125; $this-&gt;registerBaseBindings(); $this-&gt;registerBaseServiceProviders(); $this-&gt;registerCoreContainerAliases(); &#125;&#125; 路由服务的注册就在registerBaseServiceProviders()这个函数中：1234567891011/** * Register all of the base service providers. * * @return void */protected function registerBaseServiceProviders()&#123; $this-&gt;register(new EventServiceProvider($this)); $this-&gt;register(new LogServiceProvider($this)); $this-&gt;register(new RoutingServiceProvider($this));&#125; RoutingServiceProvider：123456789101112131415161718192021222324namespace Illuminate\Routing;class RoutingServiceProvider extends ServiceProvider&#123; public function register() &#123; $this-&gt;registerRouter(); ... &#125; /** * Register the router instance. * * @return void */ protected function registerRouter() &#123; $this-&gt;app-&gt;singleton('router', function ($app) &#123; return new Router($app['events'], $app); &#125;); &#125; ...&#125; 可以看到，RoutingServiceProvider做的事情比较简单，就是向服务容易中注册router。 route服务的启动与加载-RouteServiceProviderLaravel在初始化Application后，就要进行http/Kernel的构造： 12345$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture()); 初始化结束后，就会调用handle函数，这个函数用于Laravel各个功能服务的注册启动，还有request的分发： 1234567891011121314151617181920public function handle($request)&#123; try &#123; $request-&gt;enableHttpMethodParameterOverride(); $response = $this-&gt;sendRequestThroughRouter($request); &#125; return $response;&#125;protected function sendRequestThroughRouter($request)&#123; $this-&gt;app-&gt;instance('request', $request); Facade::clearResolvedInstance('request'); $this-&gt;bootstrap();//各种服务的注册与 return (new Pipeline($this-&gt;app))//请求的分发 -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [ ] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125; 路由服务的启动与加载就在其中一个函数中bootstrap，这个函数用于各种服务的注册与启动，比较复杂，我们有机会在以后单独来说。 总之，这个函数会调用RouteServiceProvider这个类的两个函数：注册-register、启动-boot。 由于route的注册工作由之前RoutingServiceProvider完成，所以RouteServiceProvider的register是空的，这里它只负责路由的启动与加载工作，我们主要看boot：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849namespace Illuminate\Foundation\Support\Providers;class RouteServiceProvider extends ServiceProvider&#123; /** * Bootstrap any application services. * * @return void */ public function boot() &#123; $this-&gt;setRootControllerNamespace(); if ($this-&gt;routesAreCached()) &#123; $this-&gt;loadCachedRoutes(); &#125; else &#123; $this-&gt;loadRoutes(); $this-&gt;app-&gt;booted(function () &#123; $this-&gt;app['router']-&gt;getRoutes()-&gt;refreshNameLookups(); $this-&gt;app['router']-&gt;getRoutes()-&gt;refreshActionLookups(); &#125;); &#125; &#125; /** * Load the cached routes for the application. * * @return void */ protected function loadCachedRoutes() &#123; $this-&gt;app-&gt;booted(function () &#123; require $this-&gt;app-&gt;getCachedRoutesPath(); &#125;); &#125; /** * Load the application routes. * * @return void */ protected function loadRoutes() &#123; if (method_exists($this, 'map')) &#123; $this-&gt;app-&gt;call([$this, 'map']); &#125; &#125;&#125; 12345678910111213141516171819202122class Application extends Container implements ApplicationContract, CachesConfiguration, CachesRoutes, HttpKernelInterface&#123; /** * Determine if the application routes are cached. * * @return bool */ public function routesAreCached() &#123; return $this['files']-&gt;exists($this-&gt;getCachedRoutesPath()); &#125; /** * Get the path to the routes cache file. * * @return string */ public function getCachedRoutesPath() &#123; return $this-&gt;normalizeCachePath('APP_ROUTES_CACHE', 'cache/routes-v7.php'); &#125;&#125; 从boot中可以看出，Laravel首先去寻找路由的缓存文件，没有缓存文件再去进行加载路由。缓存文件一般在bootstrap/cache/routes.php文件中。 加载路由主要调用map函数，这个函数一般在App\Providers\RouteServiceProvider这个类中，这个类继承上面的Illuminate\Foundation\Support\Providers\RouteServiceProvider：1234567891011121314151617181920212223242526use Illuminate\Foundation\Support\Providers\RouteServiceProvider as ServiceProvider;class RouteServiceProvider extends ServiceProvider&#123; public function map() &#123; $this-&gt;mapApiRoutes(); $this-&gt;mapWebRoutes(); // &#125; protected function mapWebRoutes() &#123; Route::middleware('web') -&gt;namespace($this-&gt;namespace) -&gt;group(base_path('routes/web.php')); &#125; protected function mapApiRoutes() &#123; Route::prefix('api') -&gt;middleware('api') -&gt;namespace($this-&gt;namespace) -&gt;group(base_path('routes/api.php')); &#125;&#125; Laravel将路由分为两个大组：api、web。这两个部分的路由分别写在两个文件中：routes/web.php、routes/api.php。 路由的加载所谓的路由加载，就是将定义路由时添加的属性，例如’name’、’domain’、’scheme’等等保存起来，以待后用。 Laravel定义路由的属性的方法很灵活，可以定义在路由群组前，例如： 123Route::domain('route.domain.name')-&gt;group(function() &#123; Route::get('foo','controller@method');&#125;) 可以定义在路由群组中，例如： 123Route::group('domain' =&gt; 'group.domain.name',function() &#123; Route::get('foo','controller@method');&#125;) 可以定义在method的前面，例如： 1Route::domain('route.domain.name')-&gt;get('foo','controller@method'); 可以定义在method中，例如： 1Route::get('foo', ['domain' =&gt; 'route.domain.name','use' =&gt; 'controller@method']); 还可以定义在method后，例如： 1Route::get('&#123;one&#125;', 'use' =&gt; 'controller@method')-&gt;where('one', '(.+)'); 事实上，路由的加载功能主要有三个类负责： Illuminate\Routing\Router、Illuminate\Routing\Route、Illuminate\Routing\RouteRegistrar。 Router在整个路由功能中都是起着中枢的作用，RouteRegistrar主要负责位于group、method这些函数之前的属性注册，例如上面的第一种和第三种，route主要负责位于group、method这些函数之后的属性注册，例如第五种。 RouteRegistrar路由加载属性注册当我们想要在Route后面直接利用domain()、name()等函数来为路由注册属性的时候，我们实际调用的是router的魔术方法__call()： 123456789101112131415161718192021222324namespace Illuminate\Routing;class Router implements BindingRegistrar, RegistrarContract&#123; /** * Dynamically handle calls into the router instance. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; if (static::hasMacro($method)) &#123; return $this-&gt;macroCall($method, $parameters); &#125; if ($method === 'middleware') &#123; return (new RouteRegistrar($this))-&gt;attribute($method, is_array($parameters[0]) ? $parameters[0] : $parameters); &#125; return (new RouteRegistrar($this))-&gt;attribute($method, $parameters[0]); &#125;&#125; 在类RouteRegistrar中：12345678910111213141516171819202122232425262728293031class RouteRegistrar&#123; /** * The attributes that can be set through this class. * * @var array */ protected $allowedAttributes = [ 'as', 'domain', 'middleware', 'name', 'namespace', 'prefix', 'where', ]; /** * Set the value for a given attribute. * * @param string $key * @param mixed $value * @return $this * * @throws \InvalidArgumentException */ public function attribute($key, $value) &#123; if (! in_array($key, $this-&gt;allowedAttributes)) &#123; throw new InvalidArgumentException("Attribute [&#123;$key&#125;] does not exist."); &#125; $this-&gt;attributes[Arr::get($this-&gt;aliases, $key, $key)] = $value; return $this; &#125;&#125; 添加路由注册属性之后，创建路由的时候，可以仅仅提供uri，可以提供uri与闭包，可以提供uri与控制器，可以提供uri与数组：123456789Route::as('Foo')-&gt;namespace('Namespace\\Example\\')-&gt;get('foo/bar'); // 仅仅uriRoute::as('Foo')-&gt;namespace('Namespace\\Example\\')-&gt;get('foo/bar', function () &#123;&#125;); // uri与闭包Route::as('Foo')-&gt;namespace('Namespace\\Example\\')-&gt;get('foo/bar', 'controller@method');// uri与控制器Route::as('Foo')-&gt;namespace('Namespace\\Example\\')-&gt;get('foo/bar', ['as'=&gt; 'foo','use' =&gt;'controller@method']) ;// uri与数组 利用get、post等方法创建新的路由时，会调用类RouteRegistrar中的魔术方法__call()： Illuminate\Routing\RouteRegistrar.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576class RouteRegistrar&#123; /** * The methods to dynamically pass through to the router. * * @var array */ protected $passthru = [ 'get', 'post', 'put', 'patch', 'delete', 'options', 'any', ]; /** * Dynamically handle calls into the route registrar. * * @param string $method * @param array $parameters * @return \Illuminate\Routing\Route|$this * * @throws \BadMethodCallException */ public function __call($method, $parameters) &#123; if (in_array($method, $this-&gt;passthru)) &#123; return $this-&gt;registerRoute($method, ...$parameters); &#125; if (in_array($method, $this-&gt;allowedAttributes)) &#123; if ($method === 'middleware') &#123; return $this-&gt;attribute($method, is_array($parameters[0]) ? $parameters[0] : $parameters); &#125; return $this-&gt;attribute($method, $parameters[0]); &#125; throw new BadMethodCallException(sprintf( 'Method %s::%s does not exist.', static::class, $method )); &#125; /** * Register a new route with the router. * * @param string $method * @param string $uri * @param \Closure|array|string|null $action * @return \Illuminate\Routing\Route */ protected function registerRoute($method, $uri, $action = null) &#123; if (! is_array($action)) &#123; $action = array_merge($this-&gt;attributes, $action ? ['uses' =&gt; $action] : []); &#125; return $this-&gt;router-&gt;&#123;$method&#125;($uri, $this-&gt;compileAction($action)); &#125; /** * Compile the action into an array including the attributes. * * @param \Closure|array|string|null $action * @return array */ protected function compileAction($action) &#123; if (is_null($action)) &#123; return $this-&gt;attributes; &#125; if (is_string($action) || $action instanceof Closure) &#123; $action = ['uses' =&gt; $action]; &#125; return array_merge($this-&gt;attributes, $action); &#125;&#125; 也就是说，RouteRegistrar在这里会为闭包或控制器等所有非数组的action添加use键，然后才会去router中创建路由。 添加路由群组注册属性之后，还可以创建路由群组，但是这时路由群组不允许添加属性action： 12345678910111213class RouteRegistrar&#123; /** * Create a route group with shared attributes. * * @param \Closure|string $callback * @return void */ public function group($callback) &#123; $this-&gt;router-&gt;group($this-&gt;attributes, $callback); &#125;&#125; Router路由群组加载路由群组的功能可以不断叠加递归，因此每次调用group，都要用新路由群组的属性与旧路由群组属性合并，以待新的路由去继承。group参数可以是闭包函数，也可以是包含定义路由的文件路径。 Illuminate\Routing\Router.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?phpnamespace Illuminate\Routing;/** * @mixin \Illuminate\Routing\RouteRegistrar */class Router implements BindingRegistrar, RegistrarContract&#123; /** * Create a route group with shared attributes. * * @param array $attributes * @param \Closure|string $routes * @return void */ public function group(array $attributes, $routes) &#123; $this-&gt;updateGroupStack($attributes); // Once we have updated the group stack, we'll load the provided routes and // merge in the group's attributes when the routes are created. After we // have created the routes, we will pop the attributes off the stack. $this-&gt;loadRoutes($routes); array_pop($this-&gt;groupStack); &#125; /** * Update the group stack with the given attributes. * * @param array $attributes * @return void */ protected function updateGroupStack(array $attributes) &#123; if ($this-&gt;hasGroupStack()) &#123; $attributes = $this-&gt;mergeWithLastGroup($attributes); &#125; $this-&gt;groupStack[] = $attributes; &#125; /** * Determine if the router currently has a group stack. * * @return bool */ public function hasGroupStack() &#123; return ! empty($this-&gt;groupStack); &#125; /** * Merge the given array with the last group stack. * * @param array $new * @param bool $prependExistingPrefix * @return array */ public function mergeWithLastGroup($new, $prependExistingPrefix = true) &#123; return RouteGroup::merge($new, end($this-&gt;groupStack), $prependExistingPrefix); &#125;&#125; 关于路由群组属性的合并： prefix、as、namespace这几个属性会连接在一起，例如prefix1/prefix2/prefix3。 where属性数组相同的会被替换，不同的会被合并。 domain属性会被替换。 其他属性，例如middleware数组会直接被合并，即使存在相同的元素。 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace Illuminate\Routing;use Illuminate\Support\Arr;class RouteGroup&#123; /** * Merge route groups into a new array. * * @param array $new * @param array $old * @param bool $prependExistingPrefix * @return array */ public static function merge($new, $old, $prependExistingPrefix = true) &#123; if (isset($new['domain'])) &#123; unset($old['domain']); &#125; $new = array_merge(static::formatAs($new, $old), [ 'namespace' =&gt; static::formatNamespace($new, $old), 'prefix' =&gt; static::formatPrefix($new, $old, $prependExistingPrefix), 'where' =&gt; static::formatWhere($new, $old), ]); return array_merge_recursive(Arr::except( $old, ['namespace', 'prefix', 'where', 'as'] ), $new); &#125;&#125; Router路由加载添加路由需要很多步骤，需要将路由本身的属性和路由群组的属性相结合。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960class Router implements BindingRegistrar, RegistrarContract&#123; /** * Register a new GET route with the router. * * @param string $uri * @param array|string|callable|null $action * @return \Illuminate\Routing\Route */ public function get($uri, $action = null) &#123; return $this-&gt;addRoute(['GET', 'HEAD'], $uri, $action); &#125; /** * Add a route to the underlying route collection. * * @param array|string $methods * @param string $uri * @param array|string|callable|null $action * @return \Illuminate\Routing\Route */ public function addRoute($methods, $uri, $action) &#123; return $this-&gt;routes-&gt;add($this-&gt;createRoute($methods, $uri, $action)); &#125; /** * Create a new route instance. * * @param array|string $methods * @param string $uri * @param mixed $action * @return \Illuminate\Routing\Route */ protected function createRoute($methods, $uri, $action) &#123; // If the route is routing to a controller we will parse the route action into // an acceptable array format before registering it and creating this route // instance itself. We need to build the Closure that will call this out. if ($this-&gt;actionReferencesController($action)) &#123; $action = $this-&gt;convertToControllerAction($action); &#125; $route = $this-&gt;newRoute( $methods, $this-&gt;prefix($uri), $action ); // If we have groups that need to be merged, we will merge them now after this // route has already been created and is ready to go. After we're done with // the merge we will be ready to return the route back out to the caller. if ($this-&gt;hasGroupStack()) &#123; $this-&gt;mergeGroupAttributesIntoRoute($route); &#125; $this-&gt;addWhereClausesToRoute($route); return $route; &#125;&#125; 从上面来看，添加一个新的路由需要： 给路由的控制器添加group的namespace 给路由的uri添加group的prefix前缀 创建新的路由 更新路由的属性信息 为路由添加router-pattern正则约束 路由添加到RouteCollection中 控制器namespace路由控制器的命名空间一般不用特别指定，默认值是\App\Http\Controllers，每次创建新的路由，都要将默认的命名空间添加到控制器中去：123456789101112131415161718192021222324252627protected function actionReferencesController($action)&#123;if (! $action instanceof Closure) &#123;return is_string($action) || (isset($action['uses']) &amp;&amp;is_string($action['uses']));&#125;return false;&#125;protected function convertToControllerAction($action)&#123;if (is_string($action)) &#123;$action = ['uses' =&gt; $action];&#125;if (! empty($this-&gt;groupStack)) &#123;$action['uses'] = $this-&gt;prependGroupNamespace($action['uses']);&#125;$action['controller'] = $action['uses'];return $action;&#125;protected function prependGroupNamespace($class)&#123;$group = end($this-&gt;groupStack);return isset($group['namespace']) &amp;&amp; strpos($class, '\\') !== 0? $group['namespace'].'\\'.$class : $class;&#125; uri前缀在创建新的路由前，需要将路由群组的prefix添加到路由的uri中：12345678910111213protected function prefix($uri)&#123;return trim(trim($this-&gt;getLastGroupPrefix(), '/').'/'.trim($uri, '/'), '/') ?: '/';&#125;public function getLastGroupPrefix()&#123;if (! empty($this-&gt;groupStack)) &#123;$last = end($this-&gt;groupStack);return isset($last['prefix']) ? $last['prefix'] : '';&#125;return '';&#125; 创建新的路由路由的创建需要Route类： 123456protected function newRoute($methods, $uri, $action)&#123;return (new Route($methods, $uri, $action))-&gt;setRouter($this)-&gt;setContainer($this-&gt;container);&#125; 关于Router类添加新的路由我们在下一部分详细说。 更新路由属性信息创建新的路由之后，需要将路由本身的属性action与路由群组的属性结合在一起：12345678public function hasGroupStack()&#123;return ! empty($this-&gt;groupStack);&#125;protected function mergeGroupAttributesIntoRoute($route)&#123;$route-&gt;setAction($this-&gt;mergeWithLastGroup($route-&gt;getAction()));&#125; 添加全局正则约束到路由上一篇文章我们说过，我们可以为路由通过pattern方法添加全局的参数正则约束，所有每次添加新的路由都要将这个全局正则约束添加到路由中： 1234567891011public function pattern($key, $pattern)&#123;$this-&gt;patterns[$key] = $pattern;&#125;protected function addWhereClausesToRoute($route)&#123;$route-&gt;where(array_merge($this-&gt;patterns, isset($route-&gt;getAction()['where']) ? $route-&gt;getAction()['where'] : []));return $route;&#125; Route路由加载前面说过，路由的创建是由Route这个类完成的：12345678910111213public function __construct($methods, $uri, $action)&#123;$this-&gt;uri = $uri;$this-&gt;methods = (array) $methods;$this-&gt;action = $this-&gt;parseAction($action);if (in_array('GET', $this-&gt;methods) &amp;&amp; ! in_array('HEAD', $this-&gt;methods)) &#123;$this-&gt;methods[] = 'HEAD';&#125;if (isset($this-&gt;action['prefix'])) &#123;$this-&gt;prefix($this-&gt;action['prefix']);&#125;&#125; 由此可以看出，路由的创建主要是路由的各个属性的初始化，其中值得注意的有两个：action与prefix action解析 1234protected function parseAction($action)&#123;return RouteAction::parse($this-&gt;uri, $action);&#125; 我们可以看出，添加新的路由时，action属性需要利用RouteAction类：12345678910111213141516171819202122232425262728293031323334class RouteAction&#123;public static function parse($uri, $action)&#123;if (is_null($action)) &#123;return static::missingAction($uri);&#125;if (is_callable($action)) &#123;return ['uses' =&gt; $action];&#125;elseif (! isset($action['uses'])) &#123;$action['uses'] = static::findCallable($action);&#125;if (is_string($action['uses']) &amp;&amp; ! Str::contains($action['uses'], '@')) &#123;$action['uses'] = static::makeInvokable($action['uses']);&#125;return $action;&#125;protected static function findCallable(array $action)&#123;return Arr::first($action, function ($value, $key) &#123;return is_callable($value) &amp;&amp; is_numeric($key);&#125;);&#125;protected static function makeInvokable($action)&#123;if (! method_exists($action, '__invoke')) &#123;throw new UnexpectedValueException("Invalid route action: [&#123;$action&#125;].");&#125;return $action.'@__invoke';&#125;&#125; 前面的博客我们说过，创建路由的时候，除了为路由分配控制器之外，还可以为路由分配闭包函数，还有类函数，例如之前说的单动作控制器：123456789$router-&gt;get('foo/bar2', [‘domain’ =&gt; 'www.example.com', 'Illuminate\Tests\Routing\ActionStub']);class ActionStub&#123;public function __invoke()&#123;return 'hello';&#125;&#125; 因此，解析action主要做两件事： 为闭包函数添加use键。对于此时没有use键的路由，由于之前在Router中已经为控制器添加use键，因此这时没有use键的，必然是闭包函数，在这里直接或者在action中寻找闭包函数后，为闭包函数添加use键。 单动作控制器添加__invoke 。对于单动作控制器来说，此时已经和控制器一样拥有’use’键，但是并没有@符号，此时就会调用makeInvokable函数来将__invoke添加到后面。 prefix前缀路由自身也有prefix属性，而且这个属性要加在其他prefix的最前面，作为路由的uri： 123456public function prefix($prefix)&#123;$uri = rtrim($prefix, '/').'/'.ltrim($this-&gt;uri, '/');$this-&gt;uri = trim($uri, '/');return $this;&#125; Route路由属性加载除了RouteRegistrar之外，Route也可以为路由添加属性： prefix前缀123456public function prefix($prefix)&#123;$uri = rtrim($prefix, '/').'/'.ltrim($this-&gt;uri, '/');$this-&gt;uri = trim($uri, '/');return $this;&#125; where正则约束123456789101112public function where($name, $expression = null)&#123;foreach ($this-&gt;parseWhere($name, $expression) as $name =&gt; $expression) &#123;$this-&gt;wheres[$name] = $expression;&#125;return $this;&#125;protected function parseWhere($name, $expression)&#123;return is_array($name) ? $name : [$name =&gt; $expression];&#125; middleware中间件1234567891011121314public function middleware($middleware = null)&#123;if (is_null($middleware)) &#123;return (array) Arr::get($this-&gt;action, 'middleware', []);&#125;if (is_string($middleware)) &#123;$middleware = func_get_args();&#125;$this-&gt;action['middleware'] = array_merge((array) Arr::get($this-&gt;action, 'middleware', []), $middleware);return $this;&#125; uses控制器1234567891011121314public function uses($action)&#123; $action = is_string($action) ? $this-&gt;addGroupNamespaceToStringUses($action) : $action; return $this-&gt;setAction( array_merge( $this-&gt;action, $this-&gt;parseAction([ 'uses' =&gt; $action, 'controller' =&gt; $action, ]) ) );&#125; name命名123456public function name($name)&#123; $this-&gt;action['as'] = isset($this-&gt;action['as']) ? $this-&gt;action['as'].$name : $name; return $this;&#125; RouteCollection添加路由在上面的部分，我们看到添加路由的代码： 1234protected function addRoute($methods, $uri, $action)&#123; return $this-&gt;routes-&gt;add($this-&gt;createRoute($methods, $uri,$action));&#125; 新创建的路由会加入到RouteCollection中，会更新类中的routes、allRoutes、nameList、actionList。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?phpnamespace Illuminate\Routing;use Illuminate\Container\Container;use Illuminate\Http\Request;use Illuminate\Support\Arr;class RouteCollection extends AbstractRouteCollection&#123; /** * Add a Route instance to the collection. * * @param \Illuminate\Routing\Route $route * @return \Illuminate\Routing\Route */ public function add(Route $route) &#123; $this-&gt;addToCollections($route); $this-&gt;addLookups($route); return $route; &#125; /** * Add the given route to the arrays of routes. * * @param \Illuminate\Routing\Route $route * @return void */ protected function addToCollections($route) &#123; $domainAndUri = $route-&gt;getDomain().$route-&gt;uri(); foreach ($route-&gt;methods() as $method) &#123; $this-&gt;routes[$method][$domainAndUri] = $route; &#125; $this-&gt;allRoutes[$method.$domainAndUri] = $route; &#125; /** * Add the route to any look-up tables if necessary. * * @param \Illuminate\Routing\Route $route * @return void */ protected function addLookups($route) &#123; // If the route has a name, we will add it to the name look-up table so that we // will quickly be able to find any route associate with a name and not have // to iterate through every route every time we need to perform a look-up. if ($name = $route-&gt;getName()) &#123; $this-&gt;nameList[$name] = $route; &#125; // When the route is routing to a controller we will also store the action that // is used by the route. This will let us reverse route to controllers while // processing a request and easily generate URLs to the given controllers. $action = $route-&gt;getAction(); if (isset($action['controller'])) &#123; $this-&gt;addToActionList($action, $route); &#125; &#125; /** * Add a route to the controller action dictionary. * * @param array $action * @param \Illuminate\Routing\Route $route * @return void */ protected function addToActionList($action, $route) &#123; $this-&gt;actionList[trim($action['controller'], '\\')] = $route; &#125;&#125; 我们在上面路由的注册启动章节说道，路由的启动是namespace Illuminate\Foundation\Support\Providers\RouteServiceProvider完成的，调用的是boot函数： 123456789101112public function boot()&#123;$this-&gt;setRootControllerNamespace();if ($this-&gt;app-&gt;routesAreCached()) &#123;$this-&gt;loadCachedRoutes();&#125; else &#123;$this-&gt;loadRoutes();$this-&gt;app-&gt;booted(function () &#123;$this-&gt;app['router']-&gt;getRoutes()-&gt;refreshNameLookups();&#125;);&#125;&#125; 在最后一句，程序将会在所有服务都启动后运行refreshNameLookups函数，把所有的name属性加载到RouteCollection中: 1234567891011121314151617181920212223242526272829class RouteCollection extends AbstractRouteCollection&#123; /** * A flattened array of all of the routes. * * @var \Illuminate\Routing\Route[] */ protected $allRoutes = []; /** * Refresh the name look-up table. * * This is done in case any names are fluently defined or if routes are overwritten. * * @return void */ public function refreshNameLookups() &#123; $this-&gt;nameList = []; foreach ($this-&gt;allRoutes as $route) &#123; if ($route-&gt;getName()) &#123; $this-&gt;nameList[$route-&gt;getName()] = $route; &#125; &#125; &#125;&#125; 测试样例如下：1234567891011121314public function testRouteCollectionCanRefreshNameLookups()&#123; $routeIndex = new Route('GET', 'foo/index', ['uses' =&gt; 'FooController@index',]); $this-&gt;assertNull($routeIndex-&gt;getName()); $this-&gt;routeCollection-&gt;add($routeIndex)-&gt;name('route_name'); $this-&gt;assertNull($this-&gt;routeCollection-&gt;getByName('route_name')); $this-&gt;routeCollection-&gt;refreshNameLookups(); $this-&gt;assertEquals($routeIndex, $this-&gt;routeCollection-&gt;getByName('route_name'));&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel HTTP-路由]]></title>
    <url>%2F2020%2F05%2F22%2FLaravel-HTTP-%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言作为一个web后台框架，路由无疑是极其重要的一部分。本博客接下来几篇文章都将会围绕路由这一主题来展开讨论，分别讲述： 路由的使用 路由属性注册 路由的正则编译与匹配 路由的中间件 路由的控制器与参数绑定 RESTful路由 和之前一样，第一篇将会利用单元测试样例说明我们在平时可能用到的route的api函数用法，后面几篇文章将会剖析Laravel的route源码。下面开始介绍Laravel中路由的各种用法。 路由属性注册所有Laravel路由都定义在位于routes目录下的路由文件中，这些文件通过框架自动加载。routes/web.php文件定义了web界面的路由，这些路由被分配了web中间件组，从而可以提供session和csrf防护等功能。routes/api.php中的路由是无状态的，被分配了api中间件组。 对大多数应用而言，都是从routes/web.php文件开始定义路由。 路由method方法我们可以注册路由来响应任何HTTP请求：123456Route::get($uri, $callback);Route::post($uri, $callback);Route::put($uri, $callback);Route::patch($uri, $callback);Route::delete($uri, $callback);Route::options($uri, $callback); 有时候还需要注册路由响应多个HTTP请求——这可以通过match方法来实现。或者，可以使用any方法注册一个路由来响应所有HTTP请求：1234567Route::match(['get', 'post'], '/', function () &#123; //&#125;);Route::any('foo', function () &#123; //&#125;); 值得注意的是，一般的HTML表单仅仅支持get、post，并不支持put、patch、delete等动作，这时候就需要在前端添加一个隐藏的_method字段到给表单中，其值被用作HTTP请求方法名：1&lt;input type="hidden" name="_method" value="PUT"&gt; 在web路由文件中所有请求方式为PUT、POST或DELETE的HTML表单都会包含一个CSRF令牌字段，否则，请求会被拒绝。关于CSRF的更多细节，可以参考浅谈CSRF攻击方式：1234&lt;form method="POST" action="/profile"&gt;&#123;&#123; csrf_field() &#125;&#125;...&lt;/form&gt; 路由scheme协议对于web后台框架来说，路由的scheme底层协议一般使用http、https：1234567Route::get('foo/&#123;bar&#125;', ['http', function () &#123;&#125;]);Route::get('foo/&#123;bar&#125;', ['https', function () &#123;&#125;]); 路由domain子域名子域名可以像URI一样被分配给路由参数，子域名可以通过路由属性中的domain来指定：1234567Route::domain('api.name.bar')-&gt;get('foo/bar', function ($name) &#123; return $name;&#125;);Route::get('foo/bar', ['domain' =&gt; 'api.name.bar', function ($name) &#123; return $name;&#125;]); 路由prefix前缀可以为路由添加一个给定URI前缀，通过利用路由属性的prefix指定： 1234567891011Route::prefix('pre')-&gt;get('foo/bar', function () &#123;&#125;);Route::get('foo/bar', ['prefix' =&gt; 'pre', function () &#123;&#125;]);Route::get('foo/bar', function () &#123;&#125;)-&gt;prefix('pre'); 路由where正则约束可以为路由的URI参数指定正则约束：1234567Route::get('&#123;one&#125;', ['where' =&gt; ['one' =&gt; '(.+)'], function () &#123;&#125;]);Route::get('&#123;one&#125;', function () &#123;&#125;)-&gt;where('one', '(.+)'); 如果想要路由参数在全局范围内被给定正则表达式约束，可以使用pattern方法。在RouteServiceProvider类的boot方法中定义约束模式： 12345public function boot()&#123; Route::pattern('one', '(.+)'); parent::boot();&#125; 路由middleware中间件为路由添加中间件，通过利用路由属性的middleware指定： 1234567891011Route::middleware('web')-&gt;get('foo/bar', function () &#123;&#125;);Route::get('foo/bar', ['middleware' =&gt; 'web', function () &#123;&#125;]);Route::get('foo/bar', function () &#123;&#125;)-&gt;middleware('web'); 路由namespace属性可以为路由的控制器添加namespace来指定控制器的命名空间：1234567Route::namespace('Namespace\\Example\\')-&gt;get('foo/bar', function () &#123;&#125;);Route::get('foo/bar', ['namespace' =&gt; 'Namespace\\Example\\', function () &#123;&#125;]); 路由uses属性可以为路由添加URI对应的执行逻辑，例如闭包或者控制器： 123456789101112Route::get('foo/bar', ['uses' =&gt; function () &#123;&#125;]);Route::get('foo/bar', ['uses' =&gt; 'Illuminate\Tests\Routing\RouteTestControllerStub@index']);Route::get('foo/bar')-&gt;uses(function () &#123;&#125;);Route::get('foo/bar')-&gt;uses('Illuminate\Tests\Routing\RouteTestControllerStub@index'); 路由as别名可以为路由指定别名，通过路由属性的as来指定：123456789101112131415Route::as('Foo')-&gt;get('foo/bar', function () &#123;&#125;);Route::name('Foo')-&gt;get('foo/bar', function () &#123;&#125;);Route::get('foo/bar', ['as' =&gt; 'Foo', function () &#123;&#125;]);Route::get('foo/bar', function () &#123;&#125;)-&gt;name('Foo'); 路由group群组属性可以为一系列具有类似属性的路由归为同一组，利用group将这些路由归并到一起： 12345678910111213141516171819202122232425262728293031323334353637383940414243Route::group( [ 'domain' =&gt; 'group.domain.name', 'prefix' =&gt; 'grouppre', 'where' =&gt; ['one' =&gt; '(.+)'], 'middleware' =&gt; 'groupMiddleware', 'namespace' =&gt; 'Namespace\\Group\\', 'as' =&gt; 'Group::', ],function () &#123; Route::get('/replace','domain' =&gt; 'route.domain.name','uses' =&gt; function ()&#123; return 'replace'; &#125;); Route::get('additional/&#123;one&#125;/&#123;two&#125;', 'prefix' =&gt; 'routepre','where' =&gt; ['one' =&gt; '([0-9]+)', 'two' =&gt; '(.+)'], 'middleware' =&gt; 'routeMiddleware', 'namespace' =&gt; 'Namespace\\Group\\', 'as' =&gt; 'Route', 'use' =&gt; function () &#123; return 'additional'; &#125;);&#125;);$this-&gt;assertEquals('replace', $router-&gt;dispatch(Request::create('http://route.domain.name/grouppre/replace', 'GET'))-&gt;getContent());$this-&gt;assertEquals('additional', $router-&gt;dispatch(Request::create('http://group.domain.name/routepre/grouppre/additional/111/add', 'GET'))-&gt;getContent());$routes = $router-&gt;getRoutes()-&gt;getRoutes();$action = $routes[0]-&gt;getAction();$this-&gt;assertEquals('Namespace\\Group\\', $action['namespace']);$this-&gt;assertEquals('Group::', $action['as']);$routes = $router-&gt;getRoutes()-&gt;getRoutes();$action = $routes[1]-&gt;getAction();$this-&gt;assertEquals(['groupMiddleware', 'routeMiddleware'], $action['middleware']);$this-&gt;assertEquals('Namespace\\Group\\Namespace\\Group\\', $action['namespace']);$this-&gt;assertEquals('Group::Route', $action['as']); group群组的属性分为两类：替换型、递增型。当群组属性与路由属性重复的时候，替换型属性会用路由的属性替换群组的属性，递增型的属性会综合路由和群组的属性。 在上面的例子可以看出： domain这个属性是替换型属性，路由的属性会覆盖和替换群组的这几个属性； prefix、middleware、namespace、as、where这几个属性是递增型属性，路由的属性和群组属性会相互结合。 另外值得注意的是： 路由的prefix属性具有优先级，因此上面第二个路由的uri是routepre/grouppre/additional/111/add，而不是grouppre/routepre/additional/111/add； where属性对于相同的路由参数会替换，不同的路由参数会结合，因此上面where中one被替换，two被结合进来 路由参数与匹配Laravel允许在注册定义路由的时候设定路由参数，以供控制器或者闭包所用。路由参数可以设定在URI中，也可以设定在domain中。 路由编码匹配对于已编码的请求URI，框架会自动进行解码然后进行匹配: 123456789101112131415$router = $this-&gt;getRouter();$router-&gt;get('foo/bar/åαф', function () &#123; return 'hello';&#125;);$this-&gt;assertEquals('hello', $router-&gt;dispatch(Request::create('foo/bar/%C3%A5%CE%B1%D1%84', 'GET'))-&gt;getContent());$router = $this-&gt;getRouter();$route = $router-&gt;get('foo/&#123;file&#125;', function ($file) &#123; return $file;&#125;);$this-&gt;assertEquals('oxygen%20', $router-&gt;dispatch(Request::create('http://test.com/foo/oxygen%2520', 'GET'))-&gt;getContent()); 路由参数路由参数总是通过花括号进行包裹，这些参数在路由被执行时会被传递到路由的闭包。路由参数不能包含-字符，需要的话可以使用_替代。 12345678910111213141516171819202122$router = $this-&gt;getRouter();$route = $router-&gt;get('foo/&#123;age&#125;', ['domain' =&gt; 'api.&#123;name&#125;.bar', function ($name, $age)&#123; return $name.$age;&#125;]);$this-&gt;assertEquals('taylor25', $router-&gt;dispatch(Request::create('http://api.taylor.bar/foo/25', 'GET'))-&gt;getContent());$route = new Route('GET', 'images/&#123;id&#125;.&#123;ext&#125;', function () &#123;&#125;);$request1 = Request::create('images/1.png', 'GET');$this-&gt;assertTrue($route-&gt;matches($request1));$route-&gt;bind($request1);$this-&gt;assertTrue($route-&gt;hasParameter('id'));$this-&gt;assertFalse($route-&gt;hasParameter('foo'));$this-&gt;assertEquals('1', $route-&gt;parameter('id'));$this-&gt;assertEquals('png', $route-&gt;parameter('ext')); 路由可选参数有时候可能需要指定可选的路由参数，这可以通过在参数名后加一个?标记来实现，这种情况下需要给相应的变量指定默认值：12345678910111213$router = $this-&gt;getRouter();$router-&gt;get('&#123;foo?&#125;/&#123;baz?&#125;', function ($name = 'taylor', $age = 25) &#123; return $name.$age;&#125;);$this-&gt;assertEquals('fred25', $router-&gt;dispatch(Request::create('fred', 'GET'))-&gt;getContent());$router-&gt;get('default/&#123;foo?&#125;/&#123;baz?&#125;', function ($name, $age = 25)&#123; return $name.$age;&#125;)-&gt;default('name', 'taylor');$this-&gt;assertEquals('fred25', $router-&gt;dispatch(Request::create('fred', 'GET'))-&gt;getContent()); 路由参数正则约束可以使用路由实例上的where方法来约束路由参数的格式。where方法接收参数名和一个正则表达式来定义该参数如何被约束： 123Route::get('user/&#123;name&#125;', function ($name) &#123; //&#125;)-&gt;where('name', '[A-Za-z]+'); 如果想要路由参数在全局范围内被给定正则表达式约束，可以使用pattern方法。在RouteServiceProvider类的boot方法中定义约束模式: 12345public function boot()&#123; Route::pattern('id', '[0-9]+'); parent::boot();&#125; 值得注意的是，路由参数是不允许出现/字符的，例如：1234567$router-&gt;get('&#123;one?&#125;', ['uses' =&gt; function ($one = null)&#123; return $one;&#125;]);$request2 = Request::create('foo/bar/baz', 'GET');$this-&gt;assertFalse($route-&gt;matches($request2)); 上例中one只能匹配foo，不能匹配foo/bar/baz，这时就需要对one进行正则约束： 123456789101112131415161718public function testLeadingParamDoesntReceiveForwardSlashOnEmptyPath()&#123; $router = $this-&gt;getRouter(); $router-&gt;get( '&#123;one?&#125;', [ 'uses' =&gt; function ($one = null)&#123; return $one; &#125;, 'where' =&gt; ['one' =&gt; '(.+)'], ] ); $this-&gt;assertEquals('foo', $router-&gt;dispatch(Request::create('/foo', 'GET'))-&gt;getContent()); $this-&gt;assertEquals('foo/bar/baz', $router-&gt;dispatch(Request::create('/foo/bar/baz', 'GET'))-&gt;getContent());&#125; 路由中间件HTTP中间件为过滤进入应用的HTTP请求提供了一套便利的机制。例如，Laravel内置了一个中间件来验证用户是否经过认证，如果用户没有经过认证，中间件会将用户重定向到登录页面，否则如果用户经过认证，中间件就会允许请求继续往前进入下一步操作。 Laravel框架自带了一些中间件，包括认证、CSRF保护中间件等等。所有的中间件都位于app/Http/Middleware目录。 中间件之前/之后/终止一个中间件是请求前还是请求后执行取决于中间件本身。比如，以下中间件会在请求处理前执行一些任务： 123456789101112131415161718class BeforeMiddleware&#123; public function handle($request, Closure $next) &#123; // 执行动作 return $next($request); &#125;&#125;class AfterMiddleware&#123; public function handle($request, Closure $next) &#123; $response = $next($request); // 执行动作 return $response; &#125;&#125; 有时候中间件可能需要在HTTP响应发送到浏览器之后做一些工作。比如，Laravel内置的“session”中间件会在响应发送到浏览器之后将Session数据写到存储器中，为了实现这个功能，需要定义一个终止中间件并添加terminate方法到这个中间件：123456789101112class StartSession&#123; public function handle($request, Closure $next) &#123; return $next($request); &#125; public function terminate($request, $response) &#123; // 存储session数据... &#125;&#125; 全局中间件如果你想要中间件在每一个HTTP请求期间被执行，只需要将相应的中间件类设置到app/Http/Kernel.php的数组属性$middleware中即可。 1234567protected $middleware = [ \Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class, \Illuminate\Foundation\Http\Middleware\ValidatePostSize::class, \App\Http\Middleware\TrimStrings::class, \Illuminate\Foundation\Http\Middleware\ConvertEmptyStringsToNull::class,]; 路由中间件如果你想要分配中间件到指定路由，可以传递完整的类名：12345use App\Http\Middleware\CheckAge;Route::get('admin/profile', function () &#123; //&#125;)-&gt;middleware(CheckAge::class); 或者可以给中间件提供一个别名：1234567891011121314public function testDefinedClosureMiddleware()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/bar', ['middleware' =&gt; 'foo', function ()&#123; return 'hello'; &#125;]); $router-&gt;aliasMiddleware('foo', function ($request, $next) &#123; return 'caught'; &#125;); $this-&gt;assertEquals('caught', $router-&gt;dispatch(Request::create('foo/bar', 'GET'))-&gt;getContent());&#125; 也可以在app/Http/Kernel.php文件中分配给该中间件一个key，默认情况下，该类的$routeMiddleware属性包含了Laravel自带的中间件，要添加你自己的中间件，只需要将其追加到后面并为其分配一个key，例如：12345678910111213protected $routeMiddleware = [ 'auth' =&gt; \Illuminate\Auth\Middleware\Authenticate::class, 'auth.basic' =&gt; \Illuminate\Auth\Middleware\AuthenticateWithBasicAuth::class, 'bindings' =&gt; \Illuminate\Routing\Middleware\SubstituteBindings::class, 'can' =&gt; \Illuminate\Auth\Middleware\Authorize::class, 'guest' =&gt; \App\Http\Middleware\RedirectIfAuthenticated::class, 'throttle' =&gt; \Illuminate\Routing\Middleware\ThrottleRequests::class,];Route::get('admin/profile', function () &#123; //&#125;)-&gt;middleware('auth'); 使用数组分配多个中间件到路由： 123Route::get('/', function () &#123; //&#125;)-&gt;middleware('first', 'second'); 中间件组有时候你可能想要通过指定一个键名的方式将相关中间件分到同一个组里面，从而更方便将其分配到路由中，这可以通过使用HTTP Kernel的$middlewareGroups属性实现。 Laravel自带了开箱即用的web和api两个中间件组以分别包含可以应用到Web UI和API路由的通用中间件：12345678910111213141516171819protected $middlewareGroups = [ 'web' =&gt; [ \App\Http\Middleware\EncryptCookies::class, \Illuminate\Cookie\Middleware\AddQueuedCookiesToResponse::class, \Illuminate\Session\Middleware\StartSession::class, \Illuminate\View\Middleware\ShareErrorsFromSession::class, \App\Http\Middleware\VerifyCsrfToken::class, \Illuminate\Routing\Middleware\SubstituteBindings::class, ], 'api' =&gt; [ 'throttle:60,1', 'auth:api', ],];Route::get('/', function () &#123;//&#125;)-&gt;middleware('web'); 值得注意的是，中间件组中可以循环嵌套中间件组：12345678910111213141516171819202122public function testMiddlewareGroupsCanReferenceOtherGroups()&#123; unset($_SERVER['__middleware.group']); $router = $this-&gt;getRouter(); $router-&gt;get('foo/bar', ['middleware' =&gt; 'web', function ()&#123; return 'hello'; &#125;]); $router-&gt;aliasMiddleware('two', 'Illuminate\Tests\Routing\RoutingTestMiddlewareGroupTwo'); $router-&gt;middlewareGroup('first', ['two:abigail']); $router-&gt;middlewareGroup('web', ['Illuminate\Tests\Routing\RoutingTestMiddlewareGroupOne', 'first']); $this-&gt;assertEquals('caught abigail', $router-&gt;dispatch(Request::create('foo/bar', 'GET'))-&gt;getContent()); $this-&gt;assertTrue($_SERVER['__middleware.group']); unset($_SERVER['__middleware.group']);&#125; 中间件参数中间件还可以接收额外的自定义参数，例如，如果应用需要在执行给定动作之前验证认证用户是否拥有指定的角色，可以创建一个CheckRole来接收角色名作为额外参数。 额外的中间件参数会在$next参数之后传入中间件：1234567891011121314151617181920namespace App\Http\Middleware;use Closure;class CheckRole&#123; public function handle($request, Closure $next, $role) &#123; if (! $request-&gt;user()-&gt;hasRole($role)) &#123; // Redirect... &#125; return $next($request); &#125;&#125;Route::put('post/&#123;id&#125;', function ($id) &#123; //&#125;)-&gt;middleware('role:editor'); 中间件的顺序当router中有多个中间件的时候，中间件的执行顺序并不是严格按照中间件数组进行的，框架中存在一个数组$middlewarePriority，规定了这个数组中各个中间件的顺序：123456789protected $middlewarePriority = [ \Illuminate\Session\Middleware\StartSession::class, \Illuminate\View\Middleware\ShareErrorsFromSession::class, \Illuminate\Auth\Middleware\Authenticate::class, \Illuminate\Session\Middleware\AuthenticateSession::class, \Illuminate\Routing\Middleware\SubstituteBindings::class, \Illuminate\Auth\Middleware\Authorize::class,]; 当我们使用了上面其中多个中间件的时候，框架会自动按照上面的数组进行排序：1234567891011121314151617181920212223242526public function testMiddlewarePrioritySorting()&#123; $middleware = [ Placeholder1::class, SubstituteBindings::class, Placeholder2::class, Authenticate::class, Placeholder3::class, ]; $router = $this-&gt;getRouter(); $router-&gt;middlewarePriority = [Authenticate::class, SubstituteBindings::class, Authorize::class]; $route = $router-&gt;get('foo', ['middleware' =&gt; $middleware, 'uses' =&gt; function ($name) &#123; return $name; &#125;]); $this-&gt;assertEquals([ Placeholder1::class, Authenticate::class, SubstituteBindings::class, Placeholder2::class, Placeholder3::class, ], $router-&gt;gatherRouteMiddleware($route));&#125; 控制器控制器类更普遍的方法是使用控制器来组织管理这些行为。控制器可以将相关的HTTP请求封装到一个类中进行处理。通常控制器存放在app/Http/Controllers目录中. 所有的Laravel控制器应该继承自Laravel自带的控制器基类Controller，控制器基类提供了一些很方便的方法如middleware，用于添加中间件到控制器动作： 1234567class UserController extends Controller&#123; public function show($id) &#123; return view('user.profile', ['user' =&gt; User::findOrFail($id)]); &#125;&#125; 1Route::get('user/&#123;id&#125;', 'UserController@show'); 单动作控制器如果想要定义一个只处理一个动作的控制器，可以在这个控制器中定义__invoke方法，当为这个单动作控制器注册路由的时候，不需要指定方法：12345678910111213141516171819202122public function testDispatchingCallableActionClasses()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/bar', 'Illuminate\Tests\Routing\ActionStub'); $this-&gt;assertEquals('hello', $router-&gt;dispatch(Request::create('foo/bar', 'GET'))-&gt;getContent()); $router-&gt;get('foo/bar2', [ 'uses' =&gt; 'Illuminate\Tests\Routing\ActionStub@func', ]); $this-&gt;assertEquals('hello2', $router-&gt;dispatch(Request::create('foo/bar2', 'GET'))-&gt;getContent());&#125;class ActionStub extends Controller&#123; public function __invoke() &#123; return 'hello'; &#125;&#125; 控制器中间件将中间件放在控制器构造函数中更方便，在控制器的构造函数中使用middleware方法你可以很轻松的分配中间件给该控制器。你甚至可以限定该中间件应用到该控制器类的指定方法：123456789class UserController extends Controller&#123; public function __construct() &#123; $this-&gt;middleware('auth'); $this-&gt;middleware('log')-&gt;only('index'); $this-&gt;middleware('subscribed')-&gt;except('store'); &#125;&#125; callAction方法值得注意的是每次执行控制器方法都会先执行控制器的callAction函数： 1234public function callAction($method, $parameters)&#123; return call_user_func_array([$this, $method], $parameters);&#125; 测试样例：12345678910111213141516171819unset($_SERVER['__test.controller_callAction_parameters']);$router-&gt;get(($str = str_random()).'/&#123;one&#125;/&#123;two&#125;', 'Illuminate\Tests\Routing\RouteTestAnotherControllerWithParameterStub@oneArgument');$router-&gt;dispatch(Request::create($str.'/one/two', 'GET'));$this-&gt;assertEquals(['one' =&gt; 'one', 'two' =&gt; 'two'], $_SERVER['__test.controller_callAction_parameters']);class RouteTestAnotherControllerWithParameterStub extends Controller&#123; public function callAction($method, $parameters) &#123; $_SERVER['__test.controller_callAction_parameters'] = $parameters; &#125; public function oneArgument($one) &#123; &#125;&#125; __call方法和普通类一样，若控制器中没有对应classname@method中的method，则会调用类的__call函数。1234567891011121314151617181920public function testCallableControllerRouting()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/bar', 'Illuminate\Tests\Routing\RouteTestControllerCallableStub@bar'); $router-&gt;get('foo/baz', 'Illuminate\Tests\Routing\RouteTestControllerCallableStub@baz'); $this-&gt;assertEquals('bar', $router-&gt;dispatch(Request::create('foo/bar', 'GET'))-&gt;getContent()); $this-&gt;assertEquals('baz', $router-&gt;dispatch(Request::create('foo/baz', 'GET'))-&gt;getContent());&#125;class RouteTestControllerCallableStub extends Controller&#123; public function __call($method, $arguments = []) &#123; return $method; &#125;&#125; 路由参数依赖注入与绑定Laravel使用服务容器解析所有的Laravel控制器，因此，可以在控制器的构造函数中类型声明任何依赖，这些依赖会被自动解析并注入到控制器实例中。路由的参数绑定可以分为两种：显示绑定与隐示绑定。 路由隐示绑定控制器方法期望输入路由参数，只需要将路由参数放到其他依赖之后12345678Route::put('user/&#123;id&#125;', 'UserController@update');class UserController extends Controller&#123; public function update(Request $request, $id) &#123; &#125;&#125; 可以在控制器的动作方法中进行依赖的类型提示，例如，我们可以在某个方法中类型提示Illuminate\Http\Request实例： 1234567class UserController extends Controller&#123; public function store(Request $request) &#123; $name = $request-&gt;input('name'); &#125;&#125; 可以为控制器的动作方法中添加数据库模型的主键，框架会自动利用主键来获取对应的记录，需要注意的是，route定义路由的路由参数必须和控制器内的变量名相同，例如下例中路由参数userid和控制器参数userid： 12345678910Route::put('user/&#123;userid&#125;', 'UserController@update');class UserController extends Controller&#123; public function update(UserModel $userid) &#123; $userid-&gt;name = 'taylor'; $userid-&gt;update(); &#125;&#125; 综合测试样例：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public function testImplicitBindingsWithOptionalParameter()&#123; unset($_SERVER['__test.controller_callAction_parameters']); $router-&gt;get(($str = str_random()).'/&#123;user&#125;/&#123;defaultNull?&#125;/&#123;team?&#125;', [ 'middleware' =&gt; SubstituteBindings::class,'uses' =&gt; 'Illuminate\Tests\Routing\RouteTestAnotherControllerWithParameterStub@withModels', ]); $router-&gt;dispatch(Request::create($str.'/1', 'GET')); $values = array_values($_SERVER['__test.controller_callAction_parameters']); $this-&gt;assertInstanceOf('Illuminate\Http\Request', $values[0]); $this-&gt;assertEquals(1, $values[1]-&gt;value); $this-&gt;assertNull($values[2]); $this-&gt;assertInstanceOf('Illuminate\Tests\Routing\RoutingTestTeamModel', $values[3]);&#125;class RouteTestAnotherControllerWithParameterStub extends Controller&#123; public function callAction($method, $parameters) &#123; $_SERVER['__test.controller_callAction_parameters'] = $parameters; &#125; public function withModels(Request $request, RoutingTestUserModel $user, $defaultNull = null, RoutingTestTeamModel $team = null) &#123; &#125;&#125;class RoutingTestUserModel extends Model&#123; public function getRouteKeyName() &#123; return 'id'; &#125; public function where($key, $value) &#123; $this-&gt;value = $value; return $this; &#125; public function first() &#123; return $this; &#125; public function firstOrFail() &#123; return $this; &#125;&#125;class RoutingTestTeamModel extends Model&#123; public function getRouteKeyName() &#123; return 'id'; &#125; public function where($key, $value) &#123; $this-&gt;value = $value; return $this; &#125; public function first() &#123; return $this; &#125; public function firstOrFail() &#123; return $this; &#125;&#125; 路由显示绑定除了隐示地转化路由参数外，我们还可以给路由参数显示提供绑定。显示绑定有bind、model两种方法。 通过bind为参数绑定闭包函数： 1234567891011121314public function testRouteBinding()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/&#123;bar&#125;', ['middleware' =&gt; SubstituteBindings::class, 'uses' =&gt; function ($name) &#123; return $name; &#125;]); $router-&gt;bind('bar', function ($value) &#123; return strtoupper($value); &#125;); $this-&gt;assertEquals('TAYLOR', $router-&gt;dispatch(Request::create('foo/taylor', 'GET'))-&gt;getContent());&#125; 通过bind为参数绑定类方法，可以指定classname@method，也可以直接使用类名，默认会调用类的bind函数：1234567891011121314151617181920212223242526272829303132333435363738public function testRouteClassBinding()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/&#123;bar&#125;', ['middleware' =&gt; SubstituteBindings::class, 'uses' =&gt; function ($name) &#123; return $name; &#125;]); $router-&gt;bind('bar', 'Illuminate\Tests\Routing\RouteBindingStub'); $this-&gt;assertEquals('TAYLOR', $router-&gt;dispatch(Request::create('foo/taylor', 'GET'))-&gt;getContent());&#125;public function testRouteClassMethodBinding()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/&#123;bar&#125;', ['middleware' =&gt; SubstituteBindings::class, 'uses' =&gt; function ($name) &#123; return $name; &#125;]); $router-&gt;bind('bar', 'Illuminate\Tests\Routing\RouteBindingStub@find'); $this-&gt;assertEquals('dragon', $router-&gt;dispatch(Request::create('foo/Dragon', 'GET'))-&gt;getContent());&#125;class RouteBindingStub&#123; public function bind($value, $route) &#123; return strtoupper($value); &#125; public function find($value, $route) &#123; return strtolower($value); &#125;&#125; 通过model为参数绑定数据库模型，路由的参数就不需要和控制器方法中的变量名相同，Laravel会利用路由参数的值去调用where方法查找对应记录： 123if ($model = $instance-&gt;where($instance-&gt;getRouteKeyName(), $value)-&gt;first()) &#123; return $model;&#125; 测试样例如下：12345678910111213141516171819202122232425262728293031public function testModelBinding()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/&#123;bar&#125;', ['middleware' =&gt; SubstituteBindings::class, 'uses' =&gt; function($name) &#123; return $name; &#125;]); $router-&gt;model('bar', 'Illuminate\Tests\Routing\RouteModelBindingStub'); $this-&gt;assertEquals('TAYLOR', $router-&gt;dispatch(Request::create('foo/taylor', 'GET'))-&gt;getContent());&#125;class RouteModelBindingStub&#123; public function getRouteKeyName() &#123; return 'id'; &#125; public function where($key, $value) &#123; $this-&gt;value = $value; return $this; &#125; public function first() &#123; return strtoupper($this-&gt;value); &#125;&#125; 若绑定的model并没有找到对应路由参数的记录，可以在model中定义一个闭包函数，路由参数会调用闭包函数： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354public function testModelBindingWithCustomNullReturn()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/&#123;bar&#125;', ['middleware' =&gt; SubstituteBindings::class, 'uses' =&gt; function ($name) &#123; return $name; &#125;]); $router-&gt;model('bar', 'Illuminate\Tests\Routing\RouteModelBindingNullStub', function () &#123; return 'missing'; &#125;); $this-&gt;assertEquals('missing', $router-&gt;dispatch(Request::create('foo/taylor', 'GET'))-&gt;getContent());&#125;public function testModelBindingWithBindingClosure()&#123; $router = $this-&gt;getRouter(); $router-&gt;get('foo/&#123;bar&#125;', ['middleware' =&gt; SubstituteBindings::class, 'uses' =&gt; function ($name) &#123; return $name; &#125;]); $router-&gt;model('bar', 'Illuminate\Tests\Routing\RouteModelBindingNullStub', function ($value) &#123; return (new RouteModelBindingClosureStub())-&gt;findAlternate($value); &#125;); $this-&gt;assertEquals('tayloralt', $router-&gt;dispatch(Request::create('foo/TAYLOR', 'GET'))-&gt;getContent());&#125;class RouteModelBindingNullStub&#123; public function getRouteKeyName() &#123; return 'id'; &#125; public function where($key, $value) &#123; return $this; &#125; public function first() &#123; &#125;&#125;class RouteModelBindingClosureStub&#123; public function findAlternate($value) &#123; return strtolower($value).'alt'; &#125;&#125; router扩展方法router支持添加自定义的方法，只需要利用macro函数来注册对应的函数名和函数实现： 12345678910111213141516public function testMacro()&#123; $router = $this-&gt;getRouter(); $router-&gt;macro('webhook', function () use ($router) &#123; $router-&gt;match(['GET', 'POST'], 'webhook', function () &#123; return 'OK'; &#125;); &#125;); $router-&gt;webhook(); $this-&gt;assertEquals('OK', $router-&gt;dispatch(Request::create('webhook', 'GET'))-&gt;getContent()); $this-&gt;assertEquals('OK', $router-&gt;dispatch(Request::create('webhook', 'POST'))-&gt;getContent());&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP Composer自动加载]]></title>
    <url>%2F2020%2F05%2F19%2FPHP-Composer%E8%87%AA%E5%8A%A8%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在__autoload()函数中将所有的映射规则全部实现，可能会非常复杂。为什么？ __autoload()是全局函数只能定义一次，不够灵活，所以所有的类名与文件名对应的逻辑规则都要在一个函数里面实现，造成这个函数的臃肿。怎么解决？ PHP自动加载功能由来在PHP开发过程中，如果希望从外部引入一个Class，通常会使用include和require方法，去把定义这个Class的文件包含进来。这个在小规模开发的时候，没什么大问题。但在大型的开发项目中，使用这种方式会带来一些隐含的问题：如果一个PHP文件需要使用很多其它类，那么就需要很多的require/include语句，这样有可能会造成遗漏或者包含进不必要的类文件。如果大量的文件都需要使用其它的类，那么要保证每个文件都包含正确的类文件肯定是一个噩梦，况且require_once的代价很大。 PHP5为这个问题提供了一个解决方案，这就是类的自动加载（autoload）机制。autoload机制可以使得PHP程序有可能在使用类时才自动包含类文件，而不是一开始就将所有的类文件include进来，这种机制也称为Lazy Loading（延迟加载）。 总结起来，自动加载功能带来了几处优点： 1.使用类之前无需include/require。 2.使用类的时候才会include/require文件，实现了Lazy Loading，避免了include/require多余文件。 3.无需考虑引入类的实际磁盘地址，实现了逻辑和实体文件的分离。 PHP自动加载函数__autoload()通常PHP5在使用一个类时，如果发现这个类没有加载，就会自动运行__autoload()函数，这个函数是我们在程序中自定义的，在这个函数中我们可以加载需要使用的类。下面是个简单的示例：123456&lt;?phpfunction __autoload($classname)&#123; require_once ($classname . ".class.php");&#125; 在我们这个简单的例子中，我们直接将类名加上扩展名.class.php构成了类文件名，然后使用require_once将其加载。 从这个例子中，我们可以看出__autoload至少要做三件事情： 1.根据类名确定类文件名； 2.确定类文件所在的磁盘路径（在我们的例子是最简单的情况，类与调用它们的PHP程序文件在同一个文件夹下）； 3.将类从磁盘文件中加载到系统中。 第三步最简单，只需要使用include/require即可。要实现第一步，第二步的功能，必须在开发时约定类名与磁盘文件的映射方法，只有这样我们才能根据类名找到它对应的磁盘文件。 当有大量的类文件要包含的时候，我们只要确定相应的规则，然后在__autoload()函数中，将类名与实际的磁盘文件对应起来，就可以实现Lazy Loading的效果。从这里我们也可以看出__autoload()函数的实现中最重要的是类名与实际的磁盘文件映射规则的实现。 __autoload()函数存在的问题如果在一个系统的实现中，需要使用很多其它的类库，这些类库可能是由不同的开发人员编写的，其类名与实际的磁盘文件的映射规则不尽相同。这时如果要实现类库文件的自动加载，就必须在__autoload()函数中将所有的映射规则全部实现，这样的话__autoload()函数有可能会非常复杂，甚至无法实现。最后可能会导致__autoload()函数十分臃肿，这时即便能够实现，也会给将来的维护和系统效率带来很大的负面影响。 那么问题出现在哪里呢？问题出现在__autoload()是全局函数只能定义一次，不够灵活，所以所有的类名与文件名对应的逻辑规则都要在一个函数里面实现，造成这个函数的臃肿。那么如何来解决这个问题呢？答案就是使用一个__autoload调用堆栈，不同的映射关系写到不同的__autoload函数中去，然后统一注册统一管理，这个就是PHP5引入的SPL Autoload。 SPL AutoloadSPL是Standard PHP Library（标准PHP库）的缩写。它是PHP5引入的一个扩展库，其主要功能包括autoload机制的实现及包括各种Iterator接口或类。SPL Autoload具体有几个函数： 1.spl_autoload_register：注册__autoload()函数 2.spl_autoload_unregister：注销已注册的函数 3.spl_autoload_functions：返回所有已注册的函数 4.spl_autoload_call：尝试所有已注册的函数来加载类 5.spl_autoload：__autoload()的默认实现 6.spl_autoload_extionsions：注册并返回spl_autoload函数使用的默认文件扩展名。 简单来说，spl_autoload就是SPL自己定义的__autoload()函数，功能很简单，就是去注册的目录（由set_include_path设置）找与$classname同名的.php/.inc文件。当然，你也可以指定特定类型的文件，方法是注册扩展名(spl_autoload_extionsions)。 而splautoload_register()就是我们上面所说的__autoload调用堆栈，我们可以向这个函数注册多个我们自己的__autoload()函数，当PHP找不到类名时，PHP就会调用这个堆栈，一个一个去调用自定义的__autoload()函数，实现自动加载功能。如果我们不向这个函数输入任何参数，那么就会注册spl_autoload()函数。 好啦，PHP自动加载的底层就是这些，注册机制已经非常灵活，但是还缺什么呢？我们上面说过，自动加载关键就是类名和文件的映射，这种映射关系不同框架有不同方法，非常灵活，但是过于灵活就会显得杂乱，PHP有专门对这种映射关系的规范，那就是PSR标准中PSR0与PSR4。 不过在谈PSR0与PSR4之前，我们还需要了解PHP的命名空间的问题，因为这两个标准其实针对的都不是类名与目录文件的映射，而是命名空间与文件的映射。 为什么会这样呢？在我的理解中，规范的面向对象PHP思想，命名空间在一定程度上算是类名的别名，那么为什么要推出命名空间，命名空间的优点是什么呢？ 二、Namespace命名空间什么是命名空间？从广义上来说，命名空间是一种封装事物的方法。在很多地方都可以见到这种抽象概念。例如，在操作系统中目录用来将相关文件分组，对于目录中的文件来说，它就扮演了命名空间的角色。具体举个例子，文件foo.txt可以同时在目录/home/greg和/home/other中存在，但在同一个目录中不能存在两个foo.txt文件。另外，在目录/home/greg外访问foo.txt文件时，我们必须将目录名以及目录分隔符放在文件名之前得到/home/greg/foo.txt。这个原理应用到程序设计领域就是命名空间的概念。 在PHP中，命名空间用来解决在编写类库或应用程序时创建可重用的代码如类或函数时碰到的两类问题： 1.用户编写的代码与PHP内部的类/函数/常量或第三方类/函数/常量之间的名字冲突。 2.为很长的标识符名称（通常是为了缓解第一类问题而定义的）创建一个别名（或简短）的名称，提高源代码的可读性。 PHP命名空间提供了一种将相关的类、函数和常量组合到一起的途径。 简单来说就是PHP是不允许程序中存在两个名字一样一样的类或者函数或者变量名的，那么有人就很疑惑了，那就不起一样名字不就可以了？事实上很多大程序依赖很多第三方库，名字冲突什么的不要太常见，这个就是官网中的第一个问题。那么如何解决这个问题呢？在没有命名空间的时候，可怜的程序员只能给类名起 a_b_c_d_e_f 这样的，其中 a/b/c/d/e/f 一般有其特定意义，这样一般就不会发生冲突了，但是这样长的类名编写起来累，读起来更是难受。因此PHP5就推出了命名空间，类名是类名，命名空间是命名空间，程序写/看的时候直接用类名，运行起来机器看的是命名空间，这样就解决了问题。 另外，命名空间提供了一种将相关的类、函数和常量组合到一起的途径。这也是面向对象语言命名空间的很大用途，把特定用途所需要的类、变量、函数写到一个命名空间中，进行封装。 解决了类名的问题，我们终于可以回到PSR标准来了，那么PSR0与PSR4是怎么 规范 文件与命名空间的映射关系的呢？答案就是：对命名空间的命名（额，有点绕）、类文件目录的位置 和 两者映射关系 做出了限制，这个就是标准的核心了。 三、PSR标准PSR是Proposing a Standards Recommendation（提出标准建议）的缩写，截止到目前为止，总共有5套PSR规范，分别是： PSR-0 (Autoloading Standard) 自动加载标准PSR-1 (Basic Coding Standard)基础编码标准PSR-2 (Coding Style Guide) 编码风格向导PSR-3 (Logger Interface) 日志接口PSR-4 (Improved Autoloading) 自动加载的增强版，可以替换掉PSR-0了。 PSR0标准 PRS-0规范是他们出的第1套规范，主要是制定了一些自动加载标准（Autoloading Standard）PSR-0强制性要求几点： 1.一个完全合格的namespace和class必须符合这样的结构： 1&lt;VendorName&gt;[&lt;Namespace&gt;]*&lt;Class Name&gt; 2.每个namespace必须有一个顶层的namespace（”Vendor Name”提供者名字） 3.每个namespace可以有多个子namespace 4.当从文件系统中加载时，每个namespace的分隔符(/)要转换成DIRECTORY_SEPARATOR(操作系统路径分隔符) 5.在类名中，每个下划线(_) 符号要转换成DIRECTORY_SEPARATOR(操作系统路径分隔符)。在 namespace 中，下划线 _ 符号是没有（特殊）意义的。 6.当从文件系统中载入时，合格的 namespace 和 class 一定是以.php结尾的 7.verdor name , namespaces , class 名可以由大小写字母组合而成（大小写敏感的） 具体规则可能有些让人晕，我们从头讲一下。 我们先来看PSR0标准大致内容，第1、2、3、7条对命名空间的名字做出了限制，第4、5条对命名空间和文件目录的映射关系做出了限制，第6条是文件后缀名。 前面我们说过，PSR标准是如何规范命名空间和所在文件目录之间的映射关系？是通过限制命名空间的名字、所在文件目录的位置和两者映射关系。 那么我们可能就要问了，哪里限制了文件所在目录的位置了呢？其实答案就是： 限制命名空间名字 + 限制命名空间名字与文件目录映射 = 限制文件目录 好了，我们先想一想，对于一个具体程序来说，如果它想要支持PSR0标准,它需要做什么调整呢？ 首先，程序必须定义一个符合PSR0标准第4、5条的映射函数，然后把这个函数注册到spl_register()中； 其次，定义一个新的命名空间时，命名空间的名字和所在文件的目录位置必须符合第1、2、3、7条。 一般为了代码维护方便，我们会在一个文件只定义一个命名空间。 好了，我们有了符合PSR0的命名空间的名字，通过符合PSR0标准的映射关系就可以得到符合PSR0标准的文件目录地址，如果我们按照PSR0标准正确存放文件，就可以顺利require该文件了，我们就可以使用该命名空间啦，是不是很神奇呢？ 接下来，我们详细地来看看PSR0标准到底规范了什么呢？ 我们以Laravel中第三方库Symfony其中一个命名空间 /Symfony/Core/Request为例，讲一讲上面PSR0标准。 一个完全合格的namespace和class必须符合这样的结构： 1&lt;VendorName&gt;[&lt;Namespace&gt;]*&lt;Class Name&gt; 上面所展示的/Symfony就是Vendor Name，也就是第三方库的名字，/Core是Namespace名字，一般是我们命名空间的一些属性信息(例如request是Symfony的核心功能)；最后Request就是我们命名空间的名字，这个标准规范就是让人看到命名空间的来源、功能非常明朗，有利于代码的维护。 2 . 每个namespace必须有一个顶层的namespace（”Vendor Name”提供者名字） 也就是说每个命名空间都要有一个类似于/Symfony的顶级命名空间，为什么要有这种规则呢？因为PSR0标准只负责顶级命名空间之后的映射关系，也就是/Symfony/Core/Request这一部分，关于/Symfony应该关联到哪个目录，那就是用户或者框架自己定义的了。所谓的顶层的namespace，就是自定义了映射关系的命名空间，一般就是提供者名字（第三方库的名字）。换句话说顶级命名空间是自动加载的基础。为什么标准要这么设置呢？原因很简单，如果有个命名空间是/Symfony/Core/Transport/Request，还有个命名空间是/Symfony/Core/Transport/Request1,如果没有顶级命名空间，我们就得写两个路径和这两个命名空间相对应，如果再有Request2、Request3呢。有了顶层命名空间/Symfony，那我们就仅仅需要一个目录对应即可，剩下的就利用PSR标准去解析就行了。 3.每个namespace可以有多个子namespace 这个很简单，Request可以定义成/Symfony/Core/Request，也可以定义成/Symfony/Core/Transport/Request，/Core这个命名空间下面可以有很多子命名空间，放多少层命名空间都是自己定义。 4.当从文件系统中加载时，每个namespace的分隔符(/)要转换成DIRECTORY_SEPARATOR(操作系统路径分隔符) 现在我们终于来到了映射规范了。命名空间的/符号要转为路径分隔符，也就是说要把/Symfony/Core/Request这个命名空间转为\Symfony\Core\Request这样的目录结构。 5.在类名中，每个下划线_符号要转换成DIRECTORYSEPARATOR(操作系统路径分隔符)。在namespace中，下划线\符号是没有（特殊）意义的。 这句话的意思就是说，如果我们的命名空间是/Symfony/Core/Request_a，那么我们就应该把它映射到\Symfony\Core\Request\a这样的目录。为什么会有这种规定呢？这是因为PHP5之前并没有命名空间，程序员只能把名字起成Symfony_Core_Request_a这样，PSR0的这条规定就是为了兼容这种情况。 剩下两个很简单就不说了。有这样的命名空间命名规则和映射标准，我们就可以推理出我们应该把命名空间所在的文件该放在哪里了。依旧以Symfony/Core/Request为例， 它的目录是/path/to/project/vendor/Symfony/Core/Request.php，其中/path/to/project是你项目在磁盘的位置，/path/to/project/vendor是项目用的所有第三方库所在目录。/path/to/project/vendor/Symfony就是与顶级命名空间/Symfony存在对应关系的目录，再往下的文件目录就是按照PSR0标准建立的：/Symfony/Core/Request =&gt; /Symfony/Core/Request.php一切很完满了是吗？不，还有一些瑕疵： 我们是否应该还兼容没有命名空间的情况呢？ 按照PSR0标准，命名空间/A/B/C/D/E/F必然对应一个目录结构/A/B/C/D/E/F，这种目录结构层次是不是太深了？ PSR4标准 2013年底，新出了第5个规范——PSR-4。 PSR-4规范了如何指定文件路径从而自动加载类定义，同时规范了自动加载文件的位置。这个乍一看和PSR-0重复了，实际上，在功能上确实有所重复。区别在于PSR-4的规范比较干净，去除了兼容PHP 5.3以前版本的内容，有一点PSR-0升级版的感觉。当然，PSR-4也不是要完全替代PSR-0，而是在必要的时候补充PSR-0——当然，如果你愿意，PSR-4也可以替代PSR-0。PSR-4可以和包括PSR-0在内的其他自动加载机制共同使用。 PSR4标准与PSR0标准的区别： 在类名中使用下划线没有任何特殊含义。 命名空间与文件目录的映射方法有所调整。 对第二项我们详细解释一下(Composer自动加载的原理)： 假如我们有一个命名空间：Foo/class，Foo是顶级命名空间，其存在着用户定义的与目录的映射关系：“Foo/“ =&gt; “src/“ 按照PSR0标准，映射后的文件目录是:src/Foo/class.php，但是按照PSR4标准，映射后的文件目录就会是:src/class.php，为什么要这么更改呢？原因就是怕命名空间太长导致目录层次太深，使得命名空间和文件目录的映射关系更加灵活。 再举一个例子,来源PSR-4——新鲜出炉的PHP规范： PSR-0风格 1234567891011-vendor/| -vendor_name/| | -package_name/| | | -src/| | | | -Vendor_Name/| | | | | -Package_Name/| | | | | | -ClassName.php # Vendor_Name\Package_Name\ClassName| | | -tests/| | | | -Vendor_Name/| | | | | -Package_Name/| | | | | | -ClassNameTest.php # Vendor_Name\Package_Name\ClassName PSR-4风格 1234567-vendor/| -vendor_name/| | -package_name/| | | -src/| | | | -ClassName.php # Vendor_Name\Package_Name\ClassName| | | -tests/| | | | -ClassNameTest.php # Vendor_Name\Package_Name\ClassNameTest 对比以上两种结构，明显可以看出PSR-4带来更简洁的文件结构。 前言上一篇文章中，我们讨论了PHP自动加载功能、PHP命名空间、PSR0/PSR4标准，有了这些知识，其实我们就可以按照PSR4标准写出可以自动加载的程序了。然而我们为什么要自己写呢？尤其是有Composer这神一样的包管理器的情况下？ Composer自动加载概论简单的说，Composer 帮助我们下载好了符合PSR0/PSR4标准的第三方库，并把文件放在相应位置；帮我们写了__autoload()函数，注册到了spl_register()函数，当我们想用第三方库的时候直接使用命名空间即可。 那么当我们想要写自己的命名空间的时候，该怎么办呢？很简单，我们只要按照PSR4标准命名我们的命名空间，放置我们的文件，然后在composer里面写好顶级域名与具体目录的映射，就可以享用composer的便利了。 当然如果有一个非常棒的框架，我们会惊喜地发现，在 composer 里面写顶级域名映射这事我们也不用做了，框架已经帮我们写好了顶级域名映射了，我们只需要在框架里面新建文件，在新建的文件中写好命名空间，就可以在任何地方 use 我们的命名空间了。 下面我们就以 Laravel 框架为例，讲一讲composer是如何实现PSR0/PSR4标准的自动加载功能。Composer自动加载文件 首先，我们先大致了解一下Composer自动加载所用到的源文件。 autoload_real.php: 自动加载功能的引导类。任务是composer加载类的初始化 (顶级命名空间与文件路径映射初始化) 和注册(spl_autoload_register())。 ClassLoader.php: composer加载类。composer自动加载功能的核心类。 autoload_static.php: 顶级命名空间初始化类，用于给核心类初始化顶级命名空间。 autoload_classmap.php: 自动加载的最简单形式，有完整的命名空间和文件目录的映射； autoload_files.php: 用于加载全局函数的文件，存放各个全局函数所在的文件路径名； autoload_namespaces.php: 符合PSR0标准的自动加载文件，存放着顶级命名空间与文件的映射； autoload_psr4.php: 符合PSR4标准的自动加载文件，存放着顶级命名空间与文件的映射； Laravel框架下Composer的自动加载源码分析启动Laravel框架的初始化是需要composer自动加载协助的，所以Laravel的入口文件index.php利用composer来实现自动加载功能。 12345&lt;?phpdefine('LARAVEL_START', microtime(true));require __DIR__.'/../vendor/autoload.php'; 再去vendor目录下的autoload.php：1234&lt;?phprequire_once __DIR__ . '/composer/autoload_real.php';return ComposerAutoloaderInit41730e5b8bc2247776726758bb07e21b::getLoader(); 好了，我们终于要看到了Composer真正要显威的地方了。autoload_real.php里面就是一个自动加载功能的引导类，这个类不负责具体功能逻辑，只做了两件事：初始化自动加载类、注册自动加载类。 到autoload_real这个文件里面去看，发现这个引导类的名字叫ComposerAutoloaderInit832ea71bfb9a4128da8660baedaac82e，为什么要叫这么古怪的名字呢？因为这是防止用户自定义类名跟这个类重复冲突了，所以在类名上加了一个hash值。其实还有一个做法我们更加熟悉，那就是不直接定义类名，而是定义一个命名空间。这里为什么不定义一个命名空间呢？个人理解：命名空间一般都是为了复用，而这个类只需要运行一次即可，以后也不会用得到，用hash值更加合适。 Laravel框架下Composer的自动加载源码分析-autoload_real引导类在vendor目录下的autoload.php文件中我们可以看出，程序主要调用了引导类的静态方法getLoader()，我们接着看看这个函数。12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static function getLoader()&#123; if (null !== self::$loader) &#123; return self::$loader; &#125; spl_autoload_register(array('ComposerAutoloaderInit41730e5b8bc2247776726758bb07e21b', 'loadClassLoader'), true, true); self::$loader = $loader = new \Composer\Autoload\ClassLoader(); spl_autoload_unregister(array('ComposerAutoloaderInit41730e5b8bc2247776726758bb07e21b', 'loadClassLoader')); $useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION') &amp;&amp; (!function_exists('zend_loader_file_encoded') || !zend_loader_file_encoded()); if ($useStaticLoader) &#123; require_once __DIR__ . '/autoload_static.php'; call_user_func(\Composer\Autoload\ComposerStaticInit41730e5b8bc2247776726758bb07e21b::getInitializer($loader)); &#125; else &#123; $map = require __DIR__ . '/autoload_namespaces.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;set($namespace, $path); &#125; $map = require __DIR__ . '/autoload_psr4.php'; foreach ($map as $namespace =&gt; $path) &#123; $loader-&gt;setPsr4($namespace, $path); &#125; $classMap = require __DIR__ . '/autoload_classmap.php'; if ($classMap) &#123; $loader-&gt;addClassMap($classMap); &#125; &#125; $loader-&gt;register(true); if ($useStaticLoader) &#123; $includeFiles = Composer\Autoload\ComposerStaticInit41730e5b8bc2247776726758bb07e21b::$files; &#125; else &#123; $includeFiles = require __DIR__ . '/autoload_files.php'; &#125; foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire41730e5b8bc2247776726758bb07e21b($fileIdentifier, $file); &#125; return $loader;&#125; 从上面可以看出，我把自动加载引导类分为5个部分。 第一部分—单例第一部分很简单，就是个最经典的单例模式，自动加载类只能有一个。12345&lt;?phpif (null !== self::$loader) &#123; return self::$loader;&#125; 第二部分——构造ClassLoader核心类 第二部分new一个自动加载的核心类对象。 123456789101112&lt;?php/***********************获得自动加载核心类对象********************/spl_autoload_register(array('ComposerAutoloaderInit832ea71bfb9a4128da8660baedaac82e', 'loadClassLoader'), true, true);self::$loader = $loader = new \Composer\Autoload\ClassLoader();spl_autoload_unregister(array('ComposerAutoloaderInit832ea71bfb9a4128da8660baedaac82e', 'loadClassLoader')); loadClassLoader()函数：1234567&lt;?phppublic static function loadClassLoader($class)&#123;if ('Composer\Autoload\ClassLoader' === $class) &#123;require __DIR__ . '/ClassLoader.php';&#125;&#125; 从程序里面我们可以看出，composer先向PHP自动加载机制注册了一个函数，这个函数require了 ClassLoader 文件。成功new出该文件中核心类ClassLoader()后，又销毁了该函数。 为什么不直接require，而要这么麻烦？原因就是怕有的用户也定义了个\Composer\Autoload\ClassLoader命名空间，导致自动加载错误文件。那为什么不跟引导类一样用个hash呢？因为这个类是可以复用的，框架允许用户使用这个类。 第三部分-初始化核心类对象12345678910111213141516171819202122232425&lt;?php/***********************初始化自动加载核心类对象********************/$useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp; !defined('HHVM_VERSION');if ($useStaticLoader) &#123;require_once __DIR__ . '/autoload_static.php';call_user_func(\Composer\Autoload\ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::getInitializer($loader));&#125; else &#123;$map = require __DIR__ . '/autoload_namespaces.php';foreach ($map as $namespace =&gt; $path) &#123;$loader-&gt;set($namespace, $path);&#125;$map = require __DIR__ . '/autoload_psr4.php';foreach ($map as $namespace =&gt; $path) &#123;$loader-&gt;setPsr4($namespace, $path);&#125;$classMap = require __DIR__ . '/autoload_classmap.php';if ($classMap) &#123;$loader-&gt;addClassMap($classMap);&#125;&#125; 这一部分就是对自动加载类的初始化，主要是给自动加载核心类初始化顶级命名空间映射。初始化的方法有两种： 使用autoload_static进行静态初始化； 调用核心类接口初始化。 autoload_static静态初始化 静态初始化只支持 PHP5.6 以上版本并且不支持 HHVM 虚拟机。我们深入autoload_static.php 这个文件发现这个文件定义了一个用于静态初始化的类，名字叫ComposerStaticInit832ea71bfb9a4128da8660baedaac82e ，仍然为了避免冲突加了 hash 值。这个类很简单： 123456789101112131415161718192021222324&lt;?phpclass ComposerStaticInit832ea71bfb9a4128da8660baedaac82e&#123;public static $files = array(...);public static $prefixLengthsPsr4 = array(...);public static $prefixDirsPsr4 = array(...);public static $prefixesPsr0 = array(...);public static $classMap = array (...);public static function getInitializer(ClassLoader $loader)&#123;return \Closure::bind(function () use ($loader) &#123;$loader-&gt;prefixLengthsPsr4= ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$prefixLengthsPsr4;$loader-&gt;prefixDirsPsr4= ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$prefixDirsPsr4;$loader-&gt;prefixesPsr0= ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$prefixesPsr0;$loader-&gt;classMap= ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$classMap;&#125;, null, ClassLoader::class);&#125; 这个静态初始化类的核心就是 getInitializer() 函数，它将自己类中的顶级命名空间映射给了ClassLoader类。值得注意的是这个函数返回的是一个匿名函数，为什么呢？原因就是ClassLoader类中的prefixLengthsPsr4、prefixDirsPsr4等等方法都是private的。。。普通的函数没办法给类的private成员变量赋值。利用匿名函数的绑定功能就可以将把匿名函数转为ClassLoader类 的成员函数。 关于匿名函数的绑定功能。 接下来就是顶级命名空间初始化的关键了。 最简单的 classMap:1234567891011121314151617&lt;?phppublic static $classMap = array ('App\\Console\\Kernel'=&gt; __DIR__ . '/../..' . '/app/Console/Kernel.php','App\\Exceptions\\Handler'=&gt; __DIR__ . '/../..' . '/app/Exceptions/Handler.php','App\\Http\\Controllers\\Auth\\ForgotPasswordController'=&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/ForgotPasswordController.php','App\\Http\\Controllers\\Auth\\LoginController'=&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/LoginController.php','App\\Http\\Controllers\\Auth\\RegisterController'=&gt; __DIR__ . '/../..' . '/app/Http/Controllers/Auth/RegisterController.php',...) 简单吧，直接命名空间全名与目录的映射，没有顶级命名空间。。。简单粗暴，也导致这个数组相当的大。 PSR0 顶级命名空间映射：12345678910111213141516171819202122232425262728293031&lt;?phppublic static $prefixesPsr0 = array ('P' =&gt; array ('Prophecy\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/phpspec/prophecy/src',),'Parsedown' =&gt; array (0 =&gt; __DIR__ . '/..' . '/erusev/parsedown',),),'M' =&gt; array ('Mockery' =&gt; array (0 =&gt; __DIR__ . '/..' . '/mockery/mockery/library',),),'J' =&gt; array ('JakubOnderka\\PhpConsoleHighlighter' =&gt; array (0 =&gt; __DIR__ . '/..' . '/jakub-onderka/php-console-highlighter/src',),'JakubOnderka\\PhpConsoleColor' =&gt; array (0 =&gt; __DIR__ . '/..' . '/jakub-onderka/php-console-color/src',),),'D' =&gt; array ('Doctrine\\Common\\Inflector\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/doctrine/inflector/lib',),),); 为了快速找到顶级命名空间，我们这里使用命名空间第一个字母作为前缀索引。这个映射的用法比较明显，假如我们有Parsedown/example这样的命名空间，首先通过首字母P，找到123456789&lt;?php'P' =&gt; array ('Prophecy\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/phpspec/prophecy/src',),'Parsedown' =&gt; array (0 =&gt; __DIR__ . '/..' . '/erusev/parsedown',),), 这个数组，然后我们就会遍历这个数组来和 Parsedown/example 比较，发现第一个 Prophecy 不符合，第二个 Parsedown 符合，然后得到了映射目录：(映射目录可能不止一个)12&lt;?phparray (0 =&gt; __DIR__ . '/..' . '/erusev/parsedown',) 我们会接着遍历这个数组，尝试 DIR . ‘/..’ .‘/erusev/parsedown/Parsedown/example.php’ 是否存在，如果不存在接着遍历数组(这个例子数组只有一个元素)，如果数组遍历完都没有，就会加载失败。 PSR4标准顶级命名空间映射数组：12345678910111213141516171819202122232425262728&lt;?phppublic static $prefixLengthsPsr4 = array('p' =&gt; array ('phpDocumentor\\Reflection\\' =&gt; 25,),'S' =&gt; array ('Symfony\\Polyfill\\Mbstring\\' =&gt; 26,'Symfony\\Component\\Yaml\\' =&gt; 23,'Symfony\\Component\\VarDumper\\' =&gt; 28,...),...);public static $prefixDirsPsr4 = array ('phpDocumentor\\Reflection\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-common/src',1 =&gt; __DIR__ . '/..' . '/phpdocumentor/type-resolver/src',2 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src',),'Symfony\\Polyfill\\Mbstring\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring',),'Symfony\\Component\\Yaml\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/symfony/yaml',),...) PSR4标准顶级命名空间映射用了两个数组，第一个和 PSR0 一样用命名空间第一个字母作为前缀索引，然后是顶级命名空间，但是最终并不是文件路径，而是顶级命名空间的长度。为什么呢？因为前一篇文章我们说过，PSR4标准 的文件目录更加灵活，更加简洁。 PSR0 中顶级命名空间目录直接加到命名空间前面就可以得到路径 Parsedown/example =&gt; DIR . ‘/..’ . ‘/erusev/parsedown/Parsedown/example.php↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑而PSR4标准却是用顶级命名空间目录替换顶级命名空间，所以获得顶级命名空间的长度很重要。Parsedown/example =&gt; DIR . ‘/..’ . ‘/erusev/parsedown/example.php↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑↑具体的用法：假如我们找Symfony\\Polyfill\\Mbstring\\example这个命名空间，和PSR0一样通过前缀索引和字符串匹配我们得到了12&lt;?php'Symfony\\Polyfill\\Mbstring\\' =&gt; 26, 这条记录，键是顶级命名空间，值是命名空间的长度。拿到顶级命名空间后去$prefixDirsPsr4数组 获取它的映射目录数组：(注意映射目录可能不止一条) 12345&lt;?php'Symfony\\Polyfill\\Mbstring\\' =&gt; array (0 =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring',) 然后我们就可以将命名空间 Symfony\\Polyfill\\Mbstring\\example前26个字符替换成目录 DIR . ‘/..’ . ‘/symfony/polyfill-mbstring ，我们就得到了 DIR . ‘/..’ . ‘/symfony/polyfill-mbstring/example.php，先验证磁盘上这个文件是否存在，如果不存在接着遍历。如果遍历后没有找到，则加载失败。 自动加载核心类ClassLoader的静态初始化完成！！！ ClassLoader接口初始化 如果PHP版本低于5.6或者使用 HHVM 虚拟机环境，那么就要使用核心类的接口进行初始化。 123456789101112131415&lt;?php//PSR0标准$map = require __DIR__ . '/autoload_namespaces.php';foreach ($map as $namespace =&gt; $path) &#123;$loader-&gt;set($namespace, $path);&#125;//PSR4标准$map = require __DIR__ . '/autoload_psr4.php';foreach ($map as $namespace =&gt; $path) &#123;$loader-&gt;setPsr4($namespace, $path);&#125;$classMap = require __DIR__ . '/autoload_classmap.php';if ($classMap) &#123;$loader-&gt;addClassMap($classMap);&#125; PSR0标准autoload_namespaces：1234567891011121314151617&lt;?phpreturn array('Prophecy\\'=&gt; array($vendorDir . '/phpspec/prophecy/src'),'Parsedown'=&gt; array($vendorDir . '/erusev/parsedown'),'Mockery'=&gt; array($vendorDir . '/mockery/mockery/library'),'JakubOnderka\\PhpConsoleHighlighter'=&gt; array($vendorDir . '/jakub-onderka/php-console-highlighter/src'),'JakubOnderka\\PhpConsoleColor'=&gt; array($vendorDir . '/jakub-onderka/php-console-color/src'),'Doctrine\\Common\\Inflector\\'=&gt; array($vendorDir . '/doctrine/inflector/lib'),); PSR0标准的初始化接口：12345678910&lt;?phppublic function set($prefix, $paths)&#123;if (!$prefix) &#123;$this-&gt;fallbackDirsPsr0 = (array) $paths;&#125; else &#123;$this-&gt;prefixesPsr0[$prefix[0]][$prefix] = (array) $paths;&#125;&#125; 很简单，PSR0标准取出命名空间的第一个字母作为索引，一个索引对应多个顶级命名空间，一个顶级命名空间对应多个目录路径，具体形式可以查看上面我们讲的autoload_static的$prefixesPsr0。如果没有顶级命名空间，就只存储一个路径名，以便在后面尝试加载。PSR4标准autoload_psr4 123456789101112131415&lt;?phpreturn array('XdgBaseDir\\'=&gt; array($vendorDir . '/dnoegel/php-xdg-base-dir/src'),'Webmozart\\Assert\\'=&gt; array($vendorDir . '/webmozart/assert/src'),'TijsVerkoyen\\CssToInlineStyles\\'=&gt; array($vendorDir . '/tijsverkoyen/css-to-inline-styles/src'),'Tests\\'=&gt; array($baseDir . '/tests'),'Symfony\\Polyfill\\Mbstring\\'=&gt; array($vendorDir . '/symfony/polyfill-mbstring'),...) PSR4标准的初始化接口:123456789101112131415161718&lt;?phppublic function setPsr4($prefix, $paths)&#123;if (!$prefix) &#123;$this-&gt;fallbackDirsPsr4 = (array) $paths;&#125; else &#123;$length = strlen($prefix);if ('\\' !== $prefix[$length - 1]) &#123;throw new \InvalidArgumentException("A non-empty PSR-4 prefix must end with a namespace separator.");&#125;$this-&gt;prefixLengthsPsr4[$prefix[0]][$prefix] = $length;$this-&gt;prefixDirsPsr4[$prefix] = (array) $paths;&#125;&#125; PSR4初始化接口也很简单。如果没有顶级命名空间，就直接保存目录。如果有命名空间的话，要保证顶级命名空间最后是 \ ，然后分别保存( 前缀 -&gt; 顶级命名空间，顶级命名空间 -&gt; 顶级命名空间长度 )( 顶级命名空间 -&gt; 目录 )这两个映射数组。具体形式可以查看上面我们讲的autoload_static的prefixLengthsPsr4、$prefixDirsPsr4 。傻瓜式命名空间映射autoload_classmap：12345678&lt;?phppublic static $classMap = array ('App\\Console\\Kernel'=&gt; __DIR__ . '/../..' . '/app/Console/Kernel.php','App\\Exceptions\\Handler'=&gt; __DIR__ . '/../..' . '/app/Exceptions/Handler.php',...) addClassMap:12345678910&lt;?phppublic function addClassMap(array $classMap)&#123;if ($this-&gt;classMap) &#123;$this-&gt;classMap = array_merge($this-&gt;classMap, $classMap);&#125; else &#123;$this-&gt;classMap = $classMap;&#125;&#125; 这个最简单，就是整个命名空间与目录之间的映射。 结语我们回顾一下，这篇文章主要讲了： 1.框架如何启动composer自动加载;2.composer自动加载分为5部分； 其实说是5部分，真正重要的就两部分——初始化与注册。初始化负责顶层命名空间的目录映射，注册负责实现顶层以下的命名空间映射规则。 前言上一篇文章我们讲到了Composer自动加载功能的启动与初始化，经过启动与初始化，自动加载核心类对象已经获得了顶级命名空间与相应目录的映射，换句话说，如果有命名空间’App\Console\Kernel，我们已经知道了App\对应的目录，接下来我们就要解决下面的就是\Console\Kernel这一段。 Composer自动加载源码分析——注册 我们先回顾一下自动加载引导类：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public static function getLoader()&#123;/***************************经典单例模式********************/if (null !== self::$loader) &#123;return self::$loader;&#125;/***********************获得自动加载核心类对象********************/spl_autoload_register(array('ComposerAutoloaderInit832ea71bfb9a4128da8660baedaac82e', 'loadClassLoader'), true,true);self::$loader = $loader = new \Composer\Autoload\ClassLoader();spl_autoload_unregister(array('ComposerAutoloaderInit832ea71bfb9a4128da8660baedaac82e', 'loadClassLoader'));/***********************初始化自动加载核心类对象********************/$useStaticLoader = PHP_VERSION_ID &gt;= 50600 &amp;&amp;!defined('HHVM_VERSION');if ($useStaticLoader) &#123;require_once __DIR__ . '/autoload_static.php';call_user_func(\Composer\Autoload\ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::getInitializer($loader));&#125; else &#123;$map = require __DIR__ . '/autoload_namespaces.php';foreach ($map as $namespace =&gt; $path) &#123;$loader-&gt;set($namespace, $path);&#125;$map = require __DIR__ . '/autoload_psr4.php';foreach ($map as $namespace =&gt; $path) &#123;$loader-&gt;setPsr4($namespace, $path);&#125;$classMap = require __DIR__ . '/autoload_classmap.php';if ($classMap) &#123;$loader-&gt;addClassMap($classMap);&#125;&#125;/***********************注册自动加载核心类对象********************/$loader-&gt;register(true);/***********************自动加载全局函数********************/if ($useStaticLoader) &#123;$includeFiles = Composer\Autoload\ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$files;&#125; else &#123;$includeFiles = require __DIR__ . '/autoload_files.php';&#125;foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123; composerRequire832ea71bfb9a4128da8660baedaac82e($fileIdentifier, $file);&#125;return $loader;&#125; 现在我们开始引导类的第四部分：注册自动加载核心类对象。我们来看看核心类的register()函数：12345public function register($prepend = false)&#123;spl_autoload_register(array($this, 'loadClass'), true, $prepend);&#125; 简单到爆炸啊！一行代码实现自动加载有木有！其实奥秘都在自动加载核心类ClassLoader的loadClass()函数上，这个函数负责按照PSR标准将顶层命名空间以下的内容转为对应的目录，也就是上面所说的将’App\Console\Kernel中’Console\Kernel这一段转为目录，至于怎么转的我们在下面“Composer自动加载源码分析——运行”讲。核心类ClassLoader将loadClass()函数注册到PHP SPL中的spl_autoload_register()里面去，这个函数的来龙去脉我们之前文章讲过。这样，每当PHP遇到一个不认识的命名空间的时候，PHP会自动调用注册到spl_autoload_register里面的函数堆栈，运行其中的每个函数，直到找到命名空间对应的文件。 Composer自动加载源码分析——全局函数的自动加载 Composer不止可以自动加载命名空间，还可以加载全局函数。怎么实现的呢？很简单，把全局函数写到特定的文件里面去，在程序运行前挨个require就行了。这个就是composer自动加载的第五步，加载全局函数。 12345678910if ($useStaticLoader) &#123;$includeFiles = Composer\Autoload\ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$files;&#125; else &#123;$includeFiles = require __DIR__ . '/autoload_files.php';&#125;foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123;composerRequire832ea71bfb9a4128da8660baedaac82e($fileIdentifier, $file);&#125; 跟核心类的初始化一样，全局函数自动加载也分为两种：静态初始化和普通初始化，静态加载只支持PHP5.6以上并且不支持HHVM。 静态初始化： ComposerStaticInit832ea71bfb9a4128da8660baedaac82e::$files：1234567public static $files = array ('0e6d7bf4a5811bfa5cf40c5ccd6fae6a' =&gt; __DIR__ . '/..' . '/symfony/polyfill-mbstring/bootstrap.php','667aeda72477189d0494fecd327c3641' =&gt; __DIR__ . '/..' . '/symfony/var-dumper/Resources/functions/dump.php',...); 看到这里我们可能又要有疑问了，为什么不直接放文件路径名，还要一个hash干什么呢？这个我们一会儿讲，我们这里先了解一下这个数组的结构。 普通初始化 autoload_files: 123456789$vendorDir = dirname(dirname(__FILE__));$baseDir = dirname($vendorDir);return array('0e6d7bf4a5811bfa5cf40c5ccd6fae6a' =&gt; $vendorDir . '/symfony/polyfill-mbstring/bootstrap.php','667aeda72477189d0494fecd327c3641' =&gt; $vendorDir . '/symfony/var-dumper/Resources/functions/dump.php',....); 其实跟静态初始化区别不大。 加载全局函数 1234567891011121314151617181920class ComposerAutoloaderInit832ea71bfb9a4128da8660baedaac82e&#123;public static function getLoader()&#123;...foreach ($includeFiles as $fileIdentifier =&gt; $file) &#123;composerRequire832ea71bfb9a4128da8660baedaac82e($fileIdentifier, $file);&#125;...&#125;&#125;function composerRequire832ea71bfb9a4128da8660baedaac82e($fileIdentifier, $file)&#123;if (empty(\$GLOBALS['__composer_autoload_files'][\$fileIdentifier])) &#123;require $file;$GLOBALS['__composer_autoload_files'][$fileIdentifier] =true;&#125;&#125; 这一段很有讲究，第一个问题：为什么自动加载引导类的getLoader()函数不直接require $includeFiles里面的每个文件名，而要用类外面的函数composerRequire832ea71bfb9a4128da8660baedaac82e0？(顺便说下这个函数名hash仍然为了避免和用户定义函数冲突)为怕有人在全局函数所在的文件写$this或者self。 假如$includeFiles有个app/helper.php文件，这个helper.php文件的函数外有一行代码：$this-&gt;foo()，如果引导类在getLoader()函数直接require($file)，那么引导类就会运行这句代码，调用自己的foo()函数，这显然是错的。事实上helper.php就不应该出现$this或self这样的代码，这样写一般都是用户写错了的，一旦这样的事情发生，第一种情况：引导类恰好有foo()函数，那么就会莫名其妙执行了引导类的foo();第二种情况：引导类没有foo()函数，但是却甩出来引导类没有foo()方法这样的错误提示，用户不知道自己哪里错了。把require语句放到引导类的外面，遇到$this或者self，程序就会告诉用户根本没有类，$this或self无效， 错误信息更加明朗。 第二个问题，为什么要用hash作为$fileIdentifier，上面的代码明显可以看出来这个变量是用来控制全局函数只被require一次的，那为什么不用require_once呢？事实上require_once比require效率低很多，使用全局变量$GLOBALS这样控制加载会更快。还有一个原因我猜测应该是require_once对相对路径的支持并不理想，所以composer尽量少用require_once。 Composer自动加载源码分析——运行 我们终于来到了核心的核心——composer自动加载的真相，命名空间如何通过composer转为对应目录文件的奥秘就在这一章。 前面说过，ClassLoader的register()函数将loadClass()函数注册到PHP的SPL函数堆栈中，每当PHP遇到不认识的命名空间时就会调用函数堆栈的每个函数，直到加载命名空间成功。所以loadClass()函数就是自动加载的关键 了。 loadClass():12345678910111213141516171819202122232425262728293031323334public function loadClass($class)&#123;if ($file = $this-&gt;findFile($class)) &#123;includeFile($file);return true;&#125;&#125;public function findFile($class)&#123;// work around for PHP 5.3.0 - 5.3.2 https://bugs.php.net/50731if ('\\' == $class[0]) &#123;$class = substr($class, 1);&#125;// class map lookupif (isset($this-&gt;classMap[$class])) &#123;return $this-&gt;classMap[$class];&#125;if ($this-&gt;classMapAuthoritative) &#123;return false;PHP Composer-——-注册与运行源码分析41&#125;$file = $this-&gt;findFileWithExtension($class, '.php');// Search for Hack files if we are running on HHVMif ($file === null &amp;&amp; defined('HHVM_VERSION')) &#123;$file = $this-&gt;findFileWithExtension($class, '.hh');&#125;if ($file === null) &#123;// Remember that this class does not exist.return $this-&gt;classMap[$class] = false;&#125;return $file;&#125; 我们看到loadClass()，主要调用findFile()函数。findFile()在解析命名空间的时候主要分为两部分：classMap和findFileWithExtension()函数。classMap很简单，直接看命名空间是否在映射数组中即可。麻烦的是findFileWithExtension()函数，这个函数包含了PSR0和PSR4标准的实现。还有个值得我们注意的是查找路径成功后includeFile()仍然类外面的函数，并不是ClassLoader的成员函数，原理跟上面一样，防止有用户写$this或self。还有就是如果命名空间是以\开头的，要去掉\然后再匹配。 findFileWithExtension： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364private function findFileWithExtension($class, $ext)&#123;// PSR-4 lookup$logicalPathPsr4 = strtr($class, '\\', DIRECTORY_SEPARATOR). $ext;$first = $class[0];if (isset($this-&gt;prefixLengthsPsr4[$first])) &#123;foreach ($this-&gt;prefixLengthsPsr4[$first] as $prefix =&gt;$length) &#123;if (0 === strpos($class, $prefix)) &#123;foreach ($this-&gt;prefixDirsPsr4[$prefix] as $dir)&#123;if (file_exists($file = $dir . DIRECTORY_SEPARATOR . substr($logicalPathPsr4, $length))) &#123;return $file;&#125;&#125;&#125;&#125;&#125;// PSR-4 fallback dirsforeach ($this-&gt;fallbackDirsPsr4 as $dir) &#123;if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr4)) &#123;return $file;&#125;&#125;// PSR-0 lookupif (false !== $pos = strrpos($class, '\\')) &#123;// namespaced class name$logicalPathPsr0 = substr($logicalPathPsr4, 0, $pos + 1). strtr(substr($logicalPathPsr4, $pos + 1), '_', DIRECTORY_SEPARATOR);&#125; else &#123;// PEAR-like class name$logicalPathPsr0 = strtr($class, '_', DIRECTORY_SEPARATOR) . $ext;&#125;if (isset($this-&gt;prefixesPsr0[$first])) &#123;foreach ($this-&gt;prefixesPsr0[$first] as $prefix =&gt; $dirs) &#123;if (0 === strpos($class, $prefix)) &#123;foreach ($dirs as $dir) &#123;if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123;return $file;&#125;&#125;&#125;&#125;&#125;// PSR-0 fallback dirsforeach ($this-&gt;fallbackDirsPsr0 as $dir) &#123;if (file_exists($file = $dir . DIRECTORY_SEPARATOR . $logicalPathPsr0)) &#123;return $file;&#125;&#125;// PSR-0 include paths.if ($this-&gt;useIncludePath &amp;&amp; $file = stream_resolve_include_path($logicalPathPsr0)) &#123;return $file;&#125;&#125; 下面我们通过举例来说下上面代码的流程： 如果我们在代码中写下’phpDocumentor\Reflection\example’，PHP会通过SPL调用loadClass-&gt;findFile-&gt;findFileWithExtension。首先默认用php作为文件后缀名调用findFileWithExtension函数里，利用PSR4标准尝试解析目录文件，如果文件不存在则继续用PSR0标准解析，如果解析出来的目录文件仍然不存在，但是环境是HHVM虚拟机，继续用后缀名为hh再次调用findFileWithExtension函数，如果不存在，说明此命名空间无法加载，放到classMap中设为false，以便以后更快地加载。 对于phpDocumentor\Reflection\example，当尝试利用PSR4标准映射目录时，步骤如下： PSR4标准加载将\转为文件分隔符/，加上后缀php或hh，得到$logicalPathPsr4即phpDocumentor//Reflection//example.php(hh);利用命名空间第一个字母p作为前缀索引搜索prefixLengthsPsr4数组，查到下面这个数组： 12345p' =&gt;array ('phpDocumentor\\Reflection\\' =&gt; 25,'phpDocumentor\\Fake\\' =&gt; 19,) 遍历这个数组，得到两个顶层命名空间phpDocumentor\Reflection\和phpDocumentor\Fake\用这两个顶层命名空间与phpDocumentor\Reflection\example_e相比较，可以得到phpDocumentor\Reflection\这个顶层命名空间在prefixLengthsPsr4映射数组中得到phpDocumentor\Reflection\长度为25。 在prefixDirsPsr4映射数组中得到phpDocumentor\Reflection\的目录映射为：123456789'phpDocumentor\\Reflection\\' =&gt;array (0 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-common/src',1 =&gt; __DIR__ . '/..' . '/phpdocumentor/type-resolver/src',2 =&gt; __DIR__ . '/..' . '/phpdocumentor/reflection-docblock/src',), 遍历这个映射数组，得到三个目录映射；查看“目录+文件分隔符//+substr($logicalPathPsr4, $length)”文件是否存在，存在即返回。这里就是’_DIR_/../phpdocumentor/reflection-common/src + /+substr(phpDocumentor/Reflection/example_e.php(hh),25)’如果失败，则利用fallbackDirsPsr4数组里面的目录继续判断是否存在文件，具体方法是“目录+文件分隔符//+$logicalPathPsr4” PSR0标准加载 如果PSR4标准加载失败，则要进行PSR0标准加载： 找到phpDocumentor\Reflection\examplee最后“\”的位置，将其后面文件名中’‘’‘字符转为文件分隔符“/”,得到$logicalPathPsr0即phpDocumentor/Reflection/example/e.php(hh) 利用命名空间第一个字母p作为前缀索引搜索prefixLengthsPsr4数组，查到下面这个数组：1234567891011'P' =&gt;array ('Prophecy\\' =&gt;array (0 =&gt; __DIR__ . '/..' . '/phpspec/prophecy/src',),'phpDocumentor' =&gt;array (0 =&gt; __DIR__ . '/..' . '/erusev/parsedown',),), 遍历这个数组，得到两个顶层命名空间phpDocumentor和Prophecy用这两个顶层命名空间与phpDocumentor\Reflection\example_e相比较，可以得到phpDocumentor这个顶层命名空间在映射数组中得到phpDocumentor目录映射为’_DIR_ . ‘/..’ .’/erusev/parsedown’查看“目录+文件分隔符//+$logicalPathPsr0”文件是否存在，存在即返回。这里就是 “_DIR_ . ‘/..’ . ‘/erusev/parsedown + //+phpDocumentor//Reflection//example/e.php(hh)”如果失败，则利用fallbackDirsPsr0数组里面的目录继续判断是否存在文件，具体方法是“目录+文件分隔符//+$logicalPathPsr0”如果仍然找不到，则利用stream_resolve_include_path()，在当前include目录寻找该文件，如果找到返回绝对路径。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Facade-Facade门面源码分析]]></title>
    <url>%2F2020%2F05%2F18%2FLaravel-Facade-Facade%E9%97%A8%E9%9D%A2%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： __callStatic是什么意思？和Route::get()有什么关系？ 前言什么是门面呢？ Facades为应用程序的服务容器中可用的类提供了一个「静态」接口。Laravel自带了很多Facades，几乎可以用来访问到Laravel中所有的服务。Laravel Facades实际上是服务容器中那些底层类的「静态代理」，相比于传统的静态方法，Facades在提供了简洁且丰富的语法同时，还带来了更好的可测试性和扩展性。 首先，我们要知道Laravel框架的核心就是个IoC容器即服务容器，功能类似于一个工厂模式，是个高级版的工厂。Laravel的其他功能例如路由、缓存、日志、数据库其实都是类似于插件或者零件一样，叫做服务。IoC容器主要的作用就是生产各种零件，就是提供各个服务。在Laravel中，如果我们想要用某个服务，该怎么办呢？最简单的办法就是调用服务容器的make函数，或者利用依赖注入，或者就是今天要讲的门面Facade。门面相对于其他方法来说，最大的特点就是简洁，例如我们经常使用的Router，如果利用服务容器的make：123App::make('router')-&gt;get('/', function () &#123; return view('welcome');&#125;); 如果利用门面：123Route::get('/', function () &#123; return view('welcome');&#125;); 可以看出代码更加简洁。其实，下面我们就会介绍门面最后调用的函数也是服务容器的make函数。 Facade的原理我们以Route为例，来讲解一下门面Facade的原理与实现。我们先来看Route的门面类： Illuminate\Support\Facades\Route.php 123456789101112class Route extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return 'router'; &#125;&#125; 每个门面类也就是重定义一下getFacadeAccessor函数就行了，这个函数返回服务的唯一名称：router。需要注意的是要确保这个名称可以用服务容器的make函数创建成功（App::make(‘router’)），原因我们马上就会讲到。 那么当我们写出Route::get()这样的语句时，到底发生了什么呢？奥秘就在基类Facade中。 Illuminate\Support\Facades\Facade.php 1234567891011121314151617181920212223abstract class Facade&#123; /** * Handle dynamic, static calls to the object. * * @param string $method * @param array $args * @return mixed * * @throws \RuntimeException */ public static function __callStatic($method, $args) &#123; $instance = static::getFacadeRoot(); if (! $instance) &#123; throw new RuntimeException('A facade root has not been set.'); &#125; return $instance-&gt;$method(...$args); &#125;&#125; 当运行Route::get()时，发现门面Route没有静态get()函数，PHP就会调用这个魔术函数__callStatic。我们看到这个魔术函数做了两件事：获得对象实例，利用对象调用get()函数。首先看看如何获得对象实例的：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * The application instance being facaded. * * @var \Illuminate\Contracts\Foundation\Application */protected static $app;/** * The resolved object instances. * * @var array */protected static $resolvedInstance;/** * Get the root object behind the facade. * * @return mixed */public static function getFacadeRoot()&#123; return static::resolveFacadeInstance(static::getFacadeAccessor());&#125;/** * Get the registered name of the component. * * @return string * * @throws \RuntimeException */protected static function getFacadeAccessor()&#123; throw new RuntimeException('Facade does not implement getFacadeAccessor method.');&#125;/** * Resolve the facade root instance from the container. * * @param object|string $name * @return mixed */protected static function resolveFacadeInstance($name)&#123; if (is_object($name)) &#123; return $name; &#125; if (isset(static::$resolvedInstance[$name])) &#123; return static::$resolvedInstance[$name]; &#125; if (static::$app) &#123; return static::$resolvedInstance[$name] = static::$app[$name]; &#125;&#125; 我们看到基类getFacadeRoot()调用了getFacadeAccessor()，也就是我们的服务重载的函数，如果调用了基类的getFacadeAccessor，就会抛出异常。在我们的例子里getFacadeAccessor()返回了“router”，接下来getFacadeRoot()又调用了resolveFacadeInstance()。在这个函数里重点就是：1return static::$resolvedInstance[$name] = static::$app[$name]; 我们看到，在这里利用了$app也就是服务容器创建了“router”，创建成功后放入$resolvedInstance作为缓存，以便以后快速加载。 别名Aliases为什么我们可以在Laravel中全局用Route，而不需要使用use Illuminate\Support\Facades\Route？其实奥秘在于一个PHP函数：class_alias，它可以为任何类创建别名。Laravel在启动的时候为各个门面类调用了class_alias函数，因此不必直接用类名，直接用别名即可。在config文件夹的app文件里面存放着门面与类名的映射：123456'aliases' =&gt; [ 'App' =&gt; Illuminate\Support\Facades\App::class, 'Artisan' =&gt; Illuminate\Support\Facades\Artisan::class, 'Auth' =&gt; Illuminate\Support\Facades\Auth::class, ...] 下面我们来看看Laravel是如何为门面类创建别名的。 启动别名Aliases服务说到Laravel的启动，我们离不开index.php： 123456789require __DIR__.'/../vendor/autoload.php';$app = require_once __DIR__.'/../bootstrap/app.php';$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture()); 第一句就是我们前面博客说的composer的自动加载，接下来第二句获取Laravel核心的IoC容器，第三句“制造”出Http请求的内核，第四句是我们这里的关键，这句牵扯很大，Laravel里面所有功能服务的注册加载，乃至Http请求的构造与传递都是这一句的功劳。1$request = Illuminate\Http\Request::capture() 这句是Laravel通过全局$_SERVER数组构造一个Http请求的语句，接下来会调用Http的内核函数handle： Illuminate\Foundation\Http\Kernel.php 123456789101112131415161718192021222324252627class Kernel implements KernelContract&#123; /** * Handle an incoming HTTP request. * * @param \Illuminate\Http\Request $request * @return \Illuminate\Http\Response */ public function handle($request) &#123; try &#123; $request-&gt;enableHttpMethodParameterOverride(); $response = $this-&gt;sendRequestThroughRouter($request); &#125; catch (Throwable $e) &#123; $this-&gt;reportException($e); $response = $this-&gt;renderException($request, $e); &#125; $this-&gt;app['events']-&gt;dispatch( new RequestHandled($request, $response) ); return $response; &#125;&#125; 在handle函数方法中enableHttpMethodParameterOverride函数是允许在表单中使用delete、put等类型的请求。我们接着看sendRequestThroughRouter： 12345678910111213141516171819/** * Send the given request through the middleware / router. * * @param \Illuminate\Http\Request $request * @return \Illuminate\Http\Response */protected function sendRequestThroughRouter($request)&#123; $this-&gt;app-&gt;instance('request', $request); Facade::clearResolvedInstance('request'); $this-&gt;bootstrap(); return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125; 前两句是在Laravel的IoC容器设置request请求的对象实例，Facade中清除request的缓存实例。bootstrap： 12345678910111213141516171819202122232425/** * The bootstrap classes for the application. * * @var array */protected $bootstrappers = [ \Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class, \Illuminate\Foundation\Bootstrap\LoadConfiguration::class, \Illuminate\Foundation\Bootstrap\HandleExceptions::class, \Illuminate\Foundation\Bootstrap\RegisterFacades::class, \Illuminate\Foundation\Bootstrap\RegisterProviders::class, \Illuminate\Foundation\Bootstrap\BootProviders::class,];/** * Bootstrap the application for HTTP requests. * * @return void */public function bootstrap()&#123; if (! $this-&gt;app-&gt;hasBeenBootstrapped()) &#123; $this-&gt;app-&gt;bootstrapWith($this-&gt;bootstrappers()); &#125;&#125; $bootstrappers是Http内核里专门用于启动的组件，bootstrap函数中调用IoC容器的bootstrapWith函数来创建这些组件并利用组件进行启动服务。app-&gt;bootstrapWith： 12345678910111213141516171819/** * Run the given array of bootstrap classes. * * @param string[] $bootstrappers * @return void */public function bootstrapWith(array $bootstrappers)&#123; $this-&gt;hasBeenBootstrapped = true; foreach ($bootstrappers as $bootstrapper) &#123; $this['events']-&gt;dispatch('bootstrapping: '.$bootstrapper, [$this]); $this-&gt;make($bootstrapper)-&gt;bootstrap($this); $this['events']-&gt;dispatch('bootstrapped: '.$bootstrapper, [$this]); &#125;&#125; 可以看到bootstrapWith函数也就是利用IoC容器创建各个启动服务的实例后，回调启动自己的函数bootstrap，在这里我们只看我们Facade的启动组件： Illuminate\Foundation\Bootstrap\RegisterFacades.php 1234567891011121314151617181920212223242526272829&lt;?phpnamespace Illuminate\Foundation\Bootstrap;use Illuminate\Contracts\Foundation\Application;use Illuminate\Foundation\AliasLoader;use Illuminate\Foundation\PackageManifest;use Illuminate\Support\Facades\Facade;class RegisterFacades&#123; /** * Bootstrap the given application. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public function bootstrap(Application $app) &#123; Facade::clearResolvedInstances(); Facade::setFacadeApplication($app); AliasLoader::getInstance(array_merge( $app-&gt;make('config')-&gt;get('app.aliases', []), $app-&gt;make(PackageManifest::class)-&gt;aliases() ))-&gt;register(); &#125;&#125; 可以看出来，bootstrap做了一下几件事： 1.清除了Facade中的缓存 2.设置Facade的IoC容器 3.获得我们前面讲的config文件夹里面app文件aliases别名映射数组 4.使用aliases实例化初始化AliasLoader 5.调用AliasLoader-&gt;register() Illuminate\Foundation\AliasLoader.php 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace Illuminate\Foundation;class AliasLoader&#123; /** * Register the loader on the auto-loader stack. * * @return void */ public function register() &#123; if (! $this-&gt;registered) &#123; $this-&gt;prependToLoaderStack(); $this-&gt;registered = true; &#125; &#125; /** * Prepend the load method to the auto-loader stack. * * @return void */ protected function prependToLoaderStack() &#123; spl_autoload_register([$this, 'load'], true, true); &#125;&#125; 我们可以看出，别名服务的启动关键就是这个spl_autoload_register，这个函数我们应该很熟悉了，在自动加载中这个函数用于解析命名空间，在这里用于解析别名的真正类名。 别名Aliases服务我们首先来看看被注册到spl_autoload_register的函数，load： 123456789101112131415161718/** * Load a class alias if it is registered. * * @param string $alias * @return bool|null */public function load($alias)&#123; if (static::$facadeNamespace &amp;&amp; strpos($alias, static::$facadeNamespace) === 0) &#123; $this-&gt;loadFacade($alias); return true; &#125; if (isset($this-&gt;aliases[$alias])) &#123; return class_alias($this-&gt;aliases[$alias], $alias); &#125;&#125; 这个函数的下面很好理解，就是class_alias利用别名映射数组将别名映射到真正的门面类中去，但是上面这个是什么呢?实际上，这个是Laravel5.4版本新出的功能叫做实时门面服务。 实时门面服务其实门面功能已经很简单了，我们只需要定义一个类继承Facade即可，但是Laravel5.4打算更近一步——自动生成门面子类，这就是实时门面。 实时门面怎么用？看下面的例子： 1234567891011namespace App\Services;class PaymentGateway&#123; protected $tax; public function __construct(TaxCalculator $tax) &#123; $this-&gt;tax = $tax; &#125;&#125; 这是一个自定义的类，如果我们想要为这个类定义一个门面，在Laravel5.4我们可以这么做：1234567use Facades\ &#123; App\Services\PaymentGateway&#125;;Route::get('/pay/&#123;amount&#125;', function ($amount) &#123; PaymentGateway::pay($amount);&#125;); 当然如果你愿意，你还可以在alias数组为门面添加一个别名映射”PaymentGateway” =&gt; “use Facades\App\Services\PaymentGateway”，这样就不用写这么长的名字了。 那么这么做的原理是什么呢？我们接着看源码： 1234567protected static $facadeNamespace = 'Facades\\';if (static::$facadeNamespace &amp;&amp; strpos($alias, static::$facadeNamespace) === 0)&#123; $this-&gt;loadFacade($alias); return true;&#125; 如果命名空间是以Facades\开头的，那么就会调用实时门面的功能，调用loadFacade函数：123456protected function loadFacade($alias)&#123; tap($this-&gt;ensureFacadeExists($alias), function ($path) &#123; require $path; &#125;);&#125; tap是Laravel的全局帮助函数，ensureFacadeExists函数负责自动生成门面类，loadFacade负责加载门面类： 1234567891011121314protected function ensureFacadeExists($alias)&#123; if (file_exists($path = storage_path('framework/cache/facade-'.sha1($alias).'.php'))) &#123; return $path; &#125; file_put_contents( $path, $this-&gt;formatFacadeStub($alias, file_get_contents(__DIR__.'/stubs/facade.stub') )); return $path;&#125; 可以看出来，Laravel框架生成的门面类会放到stroge/framework/cache/文件夹下，名字以facade开头，以命名空间的哈希结尾。如果存在这个文件就会返回，否则就要利用file_put_contents生成这个文件，formatFacadeStub：1234567891011121314protected function formatFacadeStub($alias, $stub)&#123; $replacements = [ str_replace('/', '\\', dirname(str_replace('\\', '/', $alias))), class_basename($alias), substr($alias, strlen(static::$facadeNamespace)), ]; return str_replace( ['DummyNamespace', 'DummyClass', 'DummyTarget'], $replacements, $stub );&#125; 简单的说，对于Facades\App\Services\PaymentGateway，$replacements第一项是门面命名空间，将Facades\App\Services\PaymentGateway转为Facades/App/Services/PaymentGateway，取前面Facades/App/Services/，再转为命名空间Facades\App\Services\；第二项是门面类名，PaymentGateway；第三项是门面类的服务对象，App\Services\PaymentGateway，用这些来替换门面的模板文件：12345678910111213141516171819&lt;?phpnamespace DummyNamespace;use Illuminate\Support\Facades\Facade;/*** @see \DummyTarget*/class DummyClass extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return 'DummyTarget'; &#125;&#125; 替换后的文件是： 12345678910111213141516171819&lt;?phpnamespace Facades\App\Services\;use Illuminate\Support\Facades\Facade;/*** @see \DummyTarget*/class PaymentGateway extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return 'App\Services\PaymentGateway'; &#125;&#125; 就是这么简单！！！ 结语门面的原理就是这些，相对来说门面服务的原理比较简单，和自动加载相互配合使得代码更加简洁，希望大家可以更好的使用这些门面！]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel ENV/Config-环境变量/配置文件的加载与源码解析]]></title>
    <url>%2F2020%2F05%2F18%2FLaravel-ENV-Config-%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： ENVENV文件的使用多环境ENV文件的设置一、在项目写多个ENV文件，例如三个env文件： .env.development .env.staging .env.production 这三个文件中分别针对不同环境为某些变量配置了不同的值。 二、配置APP_ENV环境变量值 配置环境变量的方法有很多，其中一个方法是在nginx的配置文件中写下这句代码：1fastcgi_param APP_ENV production; 那么Laravel会通过env(‘APP_ENV’)根据环境变量APP_ENV来判断当前具体的环境，假如环境变量APP_ENV为production，那么Laravel将会自动加载.env.production文件。 自定义ENV文件的路径与文件名Laravel为用户提供了自定义ENV文件路径或文件名的函数，例如，若想要自定义env路径，就可以在bootstrap文件夹中修改app.php文件：12345$app = new Illuminate\Foundation\Application( realpath(__DIR__.'/../'));$app-&gt;useEnvironmentPath('/customer/path') 若想要自定义env文件名称，就可以在bootstrap文件夹中修改app.php文件：12345$app = new Illuminate\Foundation\Application( realpath(__DIR__.'/../'));$app-&gt;loadEnvironmentFrom('customer.env') ENV加载源码分析Laravel加载ENVENV的加载功能由类\Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class完成，它的启动函数为：123456789101112131415161718public function bootstrap(Application $app)&#123; if ($app-&gt;configurationIsCached()) &#123; return; &#125; $this-&gt;checkForSpecificEnvironmentFile($app); try &#123; $this-&gt;createDotenv($app)-&gt;safeLoad(); &#125; catch (InvalidFileException $e) &#123; $this-&gt;writeErrorAndDie($e); &#125;&#125; 如果我们在环境变量中设置了APP_ENV变量，那么就会调用函数checkForSpecificEnvironmentFile来根据环境加载不同的env文件：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * Detect if a custom environment file matching the APP_ENV exists. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */protected function checkForSpecificEnvironmentFile($app)&#123; if ($app-&gt;runningInConsole() &amp;&amp; ($input = new ArgvInput)-&gt;hasParameterOption('--env')) &#123; if ($this-&gt;setEnvironmentFilePath( $app, $app-&gt;environmentFile().'.'.$input-&gt;getParameterOption('--env') )) &#123; return; &#125; &#125; $environment = Env::get('APP_ENV'); if (! $environment) &#123; return; &#125; $this-&gt;setEnvironmentFilePath( $app, $app-&gt;environmentFile().'.'.$environment );&#125;/** * Load a custom environment file. * * @param \Illuminate\Contracts\Foundation\Application $app * @param string $file * @return bool */protected function setEnvironmentFilePath($app, $file)&#123; if (file_exists($app-&gt;environmentPath().'/'.$file)) &#123; $app-&gt;loadEnvironmentFrom($file); return true; &#125; return false;&#125; vlucas/phpdotenv源码解读 Laravel中对env文件的读取是采用vlucas/phpdotenv的开源项目：1234567891011121314151617181920class Dotenv&#123; public function __construct($path, $file = '.env') &#123; $this-&gt;filePath = $this-&gt;getFilePath($path, $file); $this-&gt;loader = new Loader($this-&gt;filePath, true); &#125; public function load() &#123; return $this-&gt;loadData(); &#125; protected function loadData($overload = false) &#123; $this-&gt;loader = new Loader($this-&gt;filePath, !$overload); return $this-&gt;loader-&gt;load(); &#125;&#125; env 文件变量的读取依赖类/Dotenv/Loader：1234567891011121314151617181920class Loader&#123; public function load() &#123; $this-&gt;ensureFileIsReadable(); $filePath = $this-&gt;filePath; $lines = $this-&gt;readLinesFromFile($filePath); foreach ($lines as $line) &#123; if (!$this-&gt;isComment($line) &amp;&amp; $this-&gt;looksLikeSetter($line)) &#123; $this-&gt;setEnvironmentVariable($line); &#125; &#125; return $lines; &#125;&#125; 我们可以看到，env文件的读取的流程： 判断env文件是否可读 读取整个env文件，并将文件按行存储 循环读取每一行，略过注释 进行环境变量赋值 12345678910111213141516171819202122232425262728293031protected function ensureFileIsReadable()&#123; if (!is_readable($this-&gt;filePath) || !is_file($this-&gt;filePath)) &#123; throw new InvalidPathException(sprintf('Unable to read the environment file at %s.', $this-&gt;filePath)); &#125;&#125;protected function readLinesFromFile($filePath)&#123; // Read file into an array of lines with auto-detected lineendings $autodetect = ini_get('auto_detect_line_endings'); ini_set('auto_detect_line_endings', '1'); $lines = file($filePath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES); ini_set('auto_detect_line_endings', $autodetect); return $lines;&#125;protected function isComment($line)&#123; return strpos(ltrim($line), '#') === 0;&#125;protected function looksLikeSetter($line)&#123; return strpos($line, '=') !== false;&#125; 环境变量赋值是env文件加载的核心，主要由setEnvironmentVariable函数：12345678910111213141516171819202122public function setEnvironmentVariable($name, $value = null)&#123; list($name, $value) = $this-&gt;normaliseEnvironmentVariable($name, $value); if ($this-&gt;immutable &amp;&amp; $this-&gt;getEnvironmentVariable($name) !== null) &#123; return; &#125; if (function_exists('apache_getenv') &amp;&amp; function_exists('apache_setenv') &amp;&amp; apache_getenv($name)) &#123; apache_setenv($name, $value); &#125; if (function_exists('putenv')) &#123; putenv("$name=$value"); &#125; $_ENV[$name] = $value; $_SERVER[$name] = $value;&#125; normaliseEnvironmentVariable函数用来加载各种类型的环境变量：123456789101112protected function normaliseEnvironmentVariable($name, $value)&#123; list($name, $value) = $this-&gt;splitCompoundStringIntoParts($name, $value); list($name, $value) = $this-&gt;sanitiseVariableName($name, $value); list($name, $value) = $this-&gt;sanitiseVariableValue($name, $value); $value = $this-&gt;resolveNestedVariables($value); return array($name, $value);&#125; splitCompoundStringIntoParts用于将赋值语句转化为环境变量名name和环境变量值value。12345678protected function splitCompoundStringIntoParts($name, $value)&#123; if (strpos($name, '=') !== false) &#123; list($name, $value) = array_map('trim', explode('=', $name, 2)); &#125; return array($name, $value);&#125; sanitiseVariableName用于格式化环境变量名：123456protected function sanitiseVariableName($name, $value)&#123; $name = trim(str_replace(array('export ', '\'', '"'), '', $name)); return array($name, $value);&#125; sanitiseVariableValue用于格式化环境变量值：123456789101112131415161718192021222324252627282930313233343536protected function sanitiseVariableValue($name, $value)&#123;$value = trim($value);if (!$value) &#123;return array($name, $value);&#125;if ($this-&gt;beginsWithAQuote($value)) &#123; // value starts witha quote$quote = $value[0];$regexPattern = sprintf('/^%1$s # match a quote at the start of the value( # capturing sub-pattern used(?: # we do not need to capture this|\\\\\\\\ # or two backslashes together|\\\\%1$s # or an escaped quote e.g \")* # as many characters that match the previous rules) # end of the capturing sub-pattern%1$s # and the closing quote.*$ # and discard any string after the closing quote/mx',$quote);$value = preg_replace($regexPattern, '$1', $value);$value = str_replace("\\$quote", $quote, $value);$value = str_replace('\\\\', '\\', $value);&#125; else &#123;$parts = explode(' #', $value, 2);$value = trim($parts[0]);// Unquoted values cannot contain whitespaceif (preg_match('/\s+/', $value) &gt; 0) &#123;throw new InvalidFileException('Dotenv values containing spaces must be surrounded by quotes.');&#125;&#125;return array($name, trim($value));&#125; 这段代码是加载env文件最复杂的部分，我们详细来说：若环境变量值是具体值，那么仅仅需要分割注 #部分，并判断是否存在空格符即可。若环境变量值由引用构成，那么就需要进行正则匹配，具体的正则表达式为：1/^"((?:[^"\\]|\\\\|\\"))".*$/mx 这个正则表达式的意思是：提取 “” 双引号内部的字符串，抛弃双引号之后的字符串若双引号内部还有双引号，那么以最前面的双引号为提取内容，例如”dfd(“dfd”)fdf”，我们只能提取出来最前面的部分 “dfd(“对于内嵌的引用可以使用 \” ，例如 “dfd\”dfd\”fdf”,我们就可以提取出来”dfd\”dfd\”fdf”。不允许引用中含有 \ ，但可以使用转义字符 \\ Configconfig配置文件的加载config配置文件由类\Illuminate\Foundation\Bootstrap\LoadConfiguration::class完成：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace Illuminate\Foundation\Bootstrap;use Exception;use Illuminate\Config\Repository;use Illuminate\Contracts\Config\Repository as RepositoryContract;use Illuminate\Contracts\Foundation\Application;use SplFileInfo;use Symfony\Component\Finder\Finder;class LoadConfiguration&#123; /** * 引导给定的应用程序 * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public function bootstrap(Application $app) &#123; $items = []; // 首先，我们将查看是否有缓存配置文件。如果有，我们将从该文件中加载配置项，以使其非常快。 // 否则，我们将需要遍历每个配置文件并全部加载它们。 if (file_exists($cached = $app-&gt;getCachedConfigPath())) &#123; $items = require $cached; $loadedFromCache = true; &#125; $app-&gt;instance('config', $config = new Repository($items)); // 接下来，我们将遍历配置目录中的所有配置文件，并将每个配置文件加载到存储库中。 // 这将使开发人员可以在该应用的各个部分中使用所有选项。 if (! isset($loadedFromCache)) &#123; $this-&gt;loadConfigurationFiles($app, $config); &#125; // 最后，我们将基于已加载的配置值设置应用程序的环境。 // 我们将传递一个回调，该回调将用于在不存在“--env”开关的Web上下文中获取环境。 $app-&gt;detectEnvironment(function () use ($config) &#123; return $config-&gt;get('app.env', 'production'); &#125;); date_default_timezone_set($config-&gt;get('app.timezone', 'UTC')); mb_internal_encoding('UTF-8'); &#125;&#125; 可以看到，配置文件的加载步骤： 加载缓存 若缓存不存在，则利用函数loadConfigurationFiles加载配置文件 加载环境变量、时间区、编码方式 函数loadConfigurationFiles用于加载配置文件：1234567891011121314151617181920212223/** * 从所有文件加载配置项 * * @param \Illuminate\Contracts\Foundation\Application $app * @param \Illuminate\Contracts\Config\Repository $repository * @return void * * @throws \Exception */protected function loadConfigurationFiles(Application $app, RepositoryContract $repository)&#123; $files = $this-&gt;getConfigurationFiles($app); if (! isset($files['app'])) &#123; throw new Exception('Unable to load the "app" configuration file.'); &#125; foreach ($files as $key =&gt; $path) &#123; $repository-&gt;set($key, require $path); &#125;&#125; 加载配置文件有两部分：搜索配置文件、加载配置文件的数组变量值 搜索配置文件getConfigurationFiles可以根据配置文件目录搜索所有的php为后缀的文件，并将其转化为files数组，其key为目录名以字符“.”为连接的字符串，value为文件真实路径：123456789101112131415161718192021222324252627282930313233343536373839404142/** * 获取该应用程序的所有配置文件 * * @param \Illuminate\Contracts\Foundation\Application $app * @return array */protected function getConfigurationFiles(Application $app)&#123; $files = []; $configPath = realpath($app-&gt;configPath()); foreach (Finder::create()-&gt;files()-&gt;name('*.php')-&gt;in($configPath) as $file) &#123; $directory = $this-&gt;getNestedDirectory($file, $configPath); $files[$directory.basename($file-&gt;getRealPath(), '.php')] = $file-&gt;getRealPath(); &#125; ksort($files, SORT_NATURAL); return $files;&#125;/** * 获取配置文件的嵌套路径 * * @param \SplFileInfo $file * @param string $configPath * @return string */protected function getNestedDirectory(SplFileInfo $file, $configPath)&#123; $directory = $file-&gt;getPath(); if ($nested = trim(str_replace($configPath, '', $directory), DIRECTORY_SEPARATOR)) &#123; $nested = str_replace(DIRECTORY_SEPARATOR, '.', $nested).'.'; &#125; return $nested;&#125; 加载配置文件数组加载配置文件由类Illuminate\Config\Repository\LoadConfiguration完成：123456789101112131415161718192021222324252627&lt;?phpnamespace Illuminate\Config;use ArrayAccess;use Illuminate\Contracts\Config\Repository as ConfigContract;use Illuminate\Support\Arr;class Repository implements ArrayAccess, ConfigContract&#123; /** * Set a given configuration value. * * @param array|string $key * @param mixed $value * @return void */ public function set($key, $value = null) &#123; $keys = is_array($key) ? $key : [$key =&gt; $value]; foreach ($keys as $key =&gt; $value) &#123; Arr::set($this-&gt;items, $key, $value); &#125; &#125;&#125; 加载配置文件时间上就是将所有配置文件的数值放入一个巨大的多维数组中，这一部分由类Illuminate\Support\Arr完成：1234567891011121314151617181920212223242526272829303132333435363738394041class Arr&#123; /** * Set an array item to a given value using "dot" notation. * * If no key is given to the method, the entire array will be replaced. * * @param array $array * @param string|null $key * @param mixed $value * @return array */ public static function set(&amp;$array, $key, $value) &#123; if (is_null($key)) &#123; return $array = $value; &#125; $keys = explode('.', $key); while (count($keys) &gt; 1) &#123; $key = array_shift($keys); // If the key doesn't exist at this depth, we will just create an empty array // to hold the next value, allowing us to create the arrays to hold final // values at the correct depth. Then we'll keep digging into the array. if (! isset($array[$key]) || ! is_array($array[$key])) &#123; $array[$key] = []; &#125; $array = &amp;$array[$key]; &#125; $array[array_shift($keys)] = $value; return $array; &#125;&#125; 例如dir1.dir2.app，配置文件会生成$array[dir1][dir2][app]这样的数组。 配置文件数值的获取当我们利用全局函数config来获取配置值的时候：1234567891011121314151617181920212223242526if (! function_exists('config')) &#123; /** * Get / set the specified configuration value. * * If an array is passed as the key, we will assume you want to set an array of values. * * @param array|string|null $key * @param mixed $default * @return mixed|\Illuminate\Config\Repository */ function config($key = null, $default = null) &#123; if (is_null($key)) &#123; return app('config'); &#125; if (is_array($key)) &#123; return app('config')-&gt;set($key); &#125; return app('config')-&gt;get($key, $default); &#125;&#125; 配置文件的获取和加载类似，都是将字符串转为多维数组，然后获取具体数组值：1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Get an item from an array using "dot" notation. * * @param \ArrayAccess|array $array * @param string|int|null $key * @param mixed $default * @return mixed */public static function get($array, $key, $default = null)&#123; if (! static::accessible($array)) &#123; return value($default); &#125; if (is_null($key)) &#123; return $array; &#125; if (static::exists($array, $key)) &#123; return $array[$key]; &#125; if (strpos($key, '.') === false) &#123; return $array[$key] ?? value($default); &#125; foreach (explode('.', $key) as $segment) &#123; if (static::accessible($array) &amp;&amp; static::exists($array, $segment)) &#123; $array = $array[$segment]; &#125; else &#123; return value($default); &#125; &#125; return $array;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Event-事件系统的启动与运行源码分析]]></title>
    <url>%2F2020%2F05%2F17%2FLaravel-Event-%E4%BA%8B%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E4%B8%8E%E8%BF%90%E8%A1%8C%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言Laravel的事件系统是一个简单的观察者模式，主要目的是用于代码的解耦，可以防止不同功能的代码耦合在一起。Laravel中事件系统由两部分构成，一个是事件的名称，事件的名称可以是个字符串，例如event.email，也可以是一个事件类，例如App\Events\OrderShipped；另一个是事件的Listener，可以是一个闭包，还可以是监听类，例如App\Listeners\SendShipmentNotification。 事件服务的注册事件服务的注册分为两部分，一个是Application启动时所调用的registerBaseServiceProviders函数： Illuminate\Foundation\Application.php 1234567891011/** * Register all of the base service providers. * * @return void */protected function registerBaseServiceProviders()&#123; $this-&gt;register(new EventServiceProvider($this)); $this-&gt;register(new LogServiceProvider($this)); $this-&gt;register(new RoutingServiceProvider($this));&#125; 其中的EventServiceProvider是/Illuminate/Events/EventServiceProvider： Illuminate\Support\ServiceProvider.php 1234567891011121314151617181920abstract class ServiceProvider&#123; /** * The application instance. * * @var \Illuminate\Contracts\Foundation\Application */ protected $app; /** * Create a new service provider instance. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public function __construct($app) &#123; $this-&gt;app = $app; &#125;&#125; Illuminate\Events\EventServiceProvider.php 1234567891011121314151617181920212223&lt;?phpnamespace Illuminate\Events;use Illuminate\Contracts\Queue\Factory as QueueFactoryContract;use Illuminate\Support\ServiceProvider;class EventServiceProvider extends ServiceProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton('events', function ($app) &#123; return (new Dispatcher($app))-&gt;setQueueResolver(function () use ($app) &#123; return $app-&gt;make(QueueFactoryContract::class); &#125;); &#125;); &#125;&#125; 这部分为IoC容器注册了events实例，Dispatcher就是events真正的实现类。QueueResolver是队列化事件的实现。 另一个注册是普通注册类/app/Providers/EventServiceProvider：12345678910111213141516171819202122232425class EventServiceProvider extends ServiceProvider&#123; /** * The event listener mappings for the application. * * @var array */ protected $listen = [ 'App\Events\SomeEvent' =&gt; [ 'App\Listeners\EventListener', ], ]; /** * Register any events for your application. * * @return void */ public function boot() &#123; parent::boot(); // &#125;&#125; 这个注册类的主要作用是事件系统的启动，这个类继承自/Illuminate/Foundation/Support/Providers/EventServiceProvider： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?phpnamespace Illuminate\Foundation\Support\Providers;use Illuminate\Foundation\Events\DiscoverEvents;use Illuminate\Support\Facades\Event;use Illuminate\Support\ServiceProvider;class EventServiceProvider extends ServiceProvider&#123; /** * The event handler mappings for the application. * * @var array */ protected $listen = []; /** * The subscriber classes to register. * * @var array */ protected $subscribe = []; /** * Register the application's event listeners. * * @return void */ public function boot() &#123; $events = $this-&gt;getEvents(); foreach ($events as $event =&gt; $listeners) &#123; foreach (array_unique($listeners) as $listener) &#123; Event::listen($event, $listener); &#125; &#125; foreach ($this-&gt;subscribe as $subscriber) &#123; Event::subscribe($subscriber); &#125; &#125;&#125; 可以看到，事件系统的启动主要是进行事件系统的监听与订阅。 事件系统的监听Listen所谓的事件监听，就是将事件名与闭包函数，或者事件类与监听类之间建立关联。1234567891011121314151617181920212223242526272829303132333435/** * Register an event listener with the dispatcher. * * @param string|array $events * @param \Closure|string $listener * @return void */public function listen($events, $listener)&#123; foreach ((array) $events as $event) &#123; if (Str::contains($event, '*')) &#123; $this-&gt;setupWildcardListen($event, $listener); &#125; else &#123; $this-&gt;listeners[$event][] = $this-&gt;makeListener($listener); &#125; &#125;&#125;/** * Setup a wildcard listener callback. * * @param string $event * @param \Closure|string $listener * @return void */protected function setupWildcardListen($event, $listener)&#123; $this-&gt;wildcards[$event][] = $this-&gt;makeListener($listener, true); $this-&gt;wildcardsCache = [];&#125; 对于有通配符的事件名，会统一放入wildcards数组中，makeListener是创建事件的关键：12345678910111213141516171819202122232425/** * Register an event listener with the dispatcher. * * @param \Closure|string $listener * @param bool $wildcard * @return \Closure */public function makeListener($listener, $wildcard = false)&#123; if (is_string($listener)) &#123; return $this-&gt;createClassListener($listener, $wildcard); &#125; if (is_array($listener) &amp;&amp; isset($listener[0]) &amp;&amp; is_string($listener[0])) &#123; return $this-&gt;createClassListener($listener, $wildcard); &#125; return function ($event, $payload) use ($listener, $wildcard) &#123; if ($wildcard) &#123; return $listener($event, $payload); &#125; return $listener(...array_values($payload)); &#125;;&#125; 创建监听者的时候，会判断监听对象是监听类还是闭包函数。 对于闭包监听来说，makeListener会再包上一层闭包函数，根据是否含有通配符来确定具体的参数。 对于监听类来说，会继续createClassListener：1234567891011121314151617181920212223242526272829303132333435363738/** * Create a class based listener using the IoC container. * * @param string $listener * @param bool $wildcard * @return \Closure */public function createClassListener($listener, $wildcard = false)&#123; return function ($event, $payload) use ($listener, $wildcard) &#123; if ($wildcard) &#123; return call_user_func($this-&gt;createClassCallable($listener), $event, $payload); &#125; return call_user_func_array( $this-&gt;createClassCallable($listener), $payload ); &#125;;&#125;/** * Create the class based event callable. * * @param array|string $listener * @return callable */protected function createClassCallable($listener)&#123; [$class, $method] = is_array($listener) ? $listener : $this-&gt;parseClassCallable($listener); if ($this-&gt;handlerShouldBeQueued($class)) &#123; return $this-&gt;createQueuedHandlerCallable($class, $method); &#125; return [$this-&gt;container-&gt;make($class), $method];&#125; 对于监听类来说，程序首先会判断监听类对应的函数：12345678910/** * Parse the class listener into class and method. * * @param string $listener * @return array */protected function parseClassCallable($listener)&#123; return Str::parseCallback($listener, 'handle');&#125; 如果未指定监听类的对应函数，那么会默认handle函数。 如果当前监听类是队列的话，会将任务推送给队列。 触发事件事件的触发可以利用事件名，或者事件类的实例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * 触发事件并调用侦听器 * * @param string|object $event * @param mixed $payload * @param bool $halt * @return array|null */public function dispatch($event, $payload = [], $halt = false)&#123; // 当给定的“事件”实际上是一个对象时，我们将假定它是一个事件对象，并使用类作为事件名称， // 并使用该事件本身作为处理程序的有效负载，这使基于对象的事件非常简单。 [$event, $payload] = $this-&gt;parseEventAndPayload( $event, $payload ); if ($this-&gt;shouldBroadcast($payload)) &#123; $this-&gt;broadcastEvent($payload[0]); &#125; $responses = []; foreach ($this-&gt;getListeners($event) as $listener) &#123; $response = $listener($event, $payload); // 如果从侦听器返回了响应，并且启用了事件暂停，我们将仅返回此响应，而不调用其余的事件侦听器。 // 否则，我们会将响应添加到响应列表中。 if ($halt &amp;&amp; ! is_null($response)) &#123; return $response; &#125; // 如果从侦听器返回false，则我们将停止将事件传播到链中任何其他侦听器， // 否则我们将继续遍历侦听器并触发序列中的每个侦听器。 if ($response === false) &#123; break; &#125; $responses[] = $response; &#125; return $halt ? null : $responses;&#125; parseEventAndPayload函数利用传入参数是事件名还是事件类实例来确定监听类函数的参数：12345678910111213141516/** * 解析给定的事件和有效负载，并为分发做好准备 * * @param mixed $event * @param mixed $payload * @return array */protected function parseEventAndPayload($event, $payload)&#123; if (is_object($event)) &#123; [$payload, $event] = [[$event], get_class($event)]; &#125; return [$event, Arr::wrap($payload)];&#125; 如果是事件类的实例，那么监听函数的参数就是事件类自身；如果是事件类名，那么监听函数的参数就是触发事件时传入的参数。 获得事件与参数后，就要获取监听类：12345678910111213141516171819/** * Get all of the listeners for a given event name. * * @param string $eventName * @return array */public function getListeners($eventName)&#123; $listeners = $this-&gt;listeners[$eventName] ?? []; $listeners = array_merge( $listeners, $this-&gt;wildcardsCache[$eventName] ?? $this-&gt;getWildcardListeners($eventName) ); return class_exists($eventName, false) ? $this-&gt;addInterfaceListeners($eventName, $listeners) : $listeners;&#125; 寻找监听类的时候，也要从通配符监听器中寻找：1234567891011121314protected function getWildcardListeners($eventName)&#123; $wildcards = []; foreach ($this-&gt;wildcards as $key =&gt; $listeners) &#123; if (Str::is($key, $eventName)) &#123; $wildcards = array_merge($wildcards, $listeners); &#125; &#125; return $wildcards;&#125; 如果监听类继承自其他类，那么父类也会一并当做监听类返回。 获得了监听类之后，就要调用监听类相应的函数。 触发事件时有一个参数halt，这个参数如果是true的时候，只要有一个监听类返回了结果，那么就会立刻返回。例如：1234567891011121314151617public function testHaltingEventExecution()&#123; unset($_SERVER['__event.test']); $d = new Dispatcher; $d-&gt;listen('foo', function ($foo) &#123; $this-&gt;assertTrue(true); return 'here'; &#125;); $d-&gt;listen('foo', function ($foo) &#123; throw new Exception('should not be called'); &#125;); $d-&gt;until('foo', ['bar']);&#125; 多个监听类在运行的时候，只要有一个返回了false，那么就会中断事件。 push函数push函数可以将触发事件的参数事先设置好，这样触发的时候只要写入事件名即可，例如：123456789101112131415161718public function testQueuedEventsAreFired()&#123; unset($_SERVER['__event.test']); $d = new Dispatcher; $d-&gt;push('update', ['name' =&gt; 'taylor']); $d-&gt;listen('update', function ($name) &#123; $_SERVER['__event.test'] = $name; &#125;); $this-&gt;assertFalse(isset($_SERVER['__event.test'])); $d-&gt;flush('update'); $this-&gt;assertEquals('taylor', $_SERVER['__event.test']);&#125; 原理也很简单：123456789101112131415161718192021222324/** * Register an event and payload to be fired later. * * @param string $event * @param array $payload * @return void */public function push($event, $payload = [])&#123; $this-&gt;listen($event.'_pushed', function () use ($event, $payload) &#123; $this-&gt;dispatch($event, $payload); &#125;);&#125;/** * Flush a set of pushed events. * * @param string $event * @return void */public function flush($event)&#123; $this-&gt;dispatch($event.'_pushed');&#125; 数据库Eloquent的事件数据库模型的事件的注册除了以上的方法还有另外两种，具体详情可以看：Laravel模型事件实现原理； 事件注册静态方法定义 12345678910111213class EventServiceProvider extends ServiceProvider&#123; public function boot() &#123; parent::boot(); User::saved(function(User$user) &#123; &#125;); User::saved('UserSavedListener@saved'); &#125;&#125; 观察者 123456789101112class UserObserver&#123; public function created(User $user) &#123; &#125; public function saved(User $user) &#123; &#125;&#125; 然后在某个服务提供者的boot方法中注册观察者：123456789101112class AppServiceProvider extends ServiceProvider&#123; public function boot() &#123; User::observe(UserObserver::class); &#125; public function register() &#123; &#125;&#125; 这两种方法都是向事件系统注册事件名eloquent.{$event}:{static::class}： 静态方法 123456789101112131415161718192021222324252627/** * Register a saved model event with the dispatcher. * * @param \Closure|string $callback * @return void */public static function saved($callback)&#123; static::registerModelEvent('saved', $callback);&#125; /** * Register a model event with the dispatcher. * * @param string $event * @param \Closure|string $callback * @return void */protected static function registerModelEvent($event, $callback)&#123; if (isset(static::$dispatcher)) &#123; $name = static::class; static::$dispatcher-&gt;listen("eloquent.&#123;$event&#125;: &#123;$name&#125;", $callback); &#125;&#125; 观察者 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Register observers with the model. * * @param object|array|string $classes * @return void * * @throws \RuntimeException */public static function observe($classes)&#123; $instance = new static; foreach (Arr::wrap($classes) as $class) &#123; $instance-&gt;registerObserver($class); &#125;&#125;/** * Register a single observer with the model. * * @param object|string $class * @return void * * @throws \RuntimeException */protected function registerObserver($class)&#123; $className = $this-&gt;resolveObserverClassName($class); // 在注册模型观察者时，我们将遍历所有可能的事件并确定该观察者是否具有该方法。 // 如果是这样，我们会将其挂接到模型的事件系统中，以方便观看。 foreach ($this-&gt;getObservableEvents() as $event) &#123; if (method_exists($class, $event)) &#123; static::registerModelEvent($event, $className.'@'.$event); &#125; &#125;&#125;/** * Get the observable event names. * * @return array */public function getObservableEvents()&#123; return array_merge( [ 'retrieved', 'creating', 'created', 'updating', 'updated', 'saving', 'saved', 'restoring', 'restored', 'replicating', 'deleting', 'deleted', 'forceDeleted', ], $this-&gt;observables );&#125; 事件触发模型事件的触发需要调用fireModelEvent函数：12345678910111213141516171819202122232425262728293031/** * Fire the given event for the model. * * @param string $event * @param bool $halt * @return mixed */protected function fireModelEvent($event, $halt = true)&#123; if (! isset(static::$dispatcher)) &#123; return true; &#125; // 首先，我们将获得适当的方法来调用事件分配器，然后尝试为给定事件触发基于对象的自定义事件。 // 如果返回一个结果，我们可以返回该结果，或者我们将调用字符串事件。 $method = $halt ? 'until' : 'dispatch'; $result = $this-&gt;filterModelEventResults( $this-&gt;fireCustomModelEvent($event, $method) ); if ($result === false) &#123; return false; &#125; return ! empty($result) ? $result : static::$dispatcher-&gt;&#123;$method&#125;( "eloquent.&#123;$event&#125;: ".static::class, $this );&#125; fireCustomModelEvent是我们本文中着重讲的事件类与监听类的触发：123456789101112131415161718192021/** * Fire a custom model event for the given event. * * @param string $event * @param string $method * @return mixed|null */protected function fireCustomModelEvent($event, $method)&#123; if (! isset($this-&gt;dispatchesEvents[$event])) &#123; return; &#125; $result = static::$dispatcher-&gt;$method(new $this-&gt;dispatchesEvents[$event]($this)); if (! is_null($result)) &#123; return $result; &#125;&#125; 如果没有对应的事件后，会继续利用事件名进行触发。 until是我们上一节讲的如果任意事件返回正确结果，就会直接返回，不会继续进行下一个事件。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Container-IoC服务容器]]></title>
    <url>%2F2020%2F05%2F14%2FLaravel-Container-IoC%E6%9C%8D%E5%8A%A1%E5%AE%B9%E5%99%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 服务容器在说IoC容器之前，我们需要了解什么是IoC容器。 Laravel服务容器是一个用于管理类依赖和执行依赖注入的强大工具。 在理解这句话之前，我们需要先了解一下服务容器的来龙去脉：Laravel神奇的服务容器。这篇博客告诉我们，服务容器就是工厂模式的升级版，对于传统的工厂模式来说，虽然解耦了对象和外部资源之间的关系，但是工厂和外部资源之间却存在了耦和。而服务容器在为对象创建了外部资源的同时，又与外部资源没有任何关系，这个就是IoC容器。 所谓的依赖注入和控制反转：依赖注入和控制反转，就是只要不是由内部生产（比如初始化、构造函数__construct中通过工厂方法、自行手动new的），而是由外部以参数或其他形式注入的，都属于依赖注入（DI）。 也就是说： 依赖注入是从应用程序的角度在描述，可以把依赖注入描述完整点：应用程序依赖容器创建并注入它所需要的外部资源；控制反转是从容器的角度在描述，描述完整点：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。 Laravel中的服务容器Laravel服务容器主要承担两个作用：绑定与解析。 绑定所谓的绑定就是将接口与实现建立对应关系。几乎所有的服务容器绑定都是在服务提供者中完成，也就是在服务提供者中绑定。 如果一个类没有基于任何接口那么就没有必要将其绑定到容器。容器并不需要被告知如何构建对象，因为它会使用PHP的反射服务自动解析出具体的对象。 也就是说，如果需要依赖注入的外部资源如果没有接口，那么就不需要绑定，直接利用服务容器进行解析就可以了，服务容器会根据类名利用反射对其进行自动构造。 bind绑定绑定有多种方法，首先最常用的是bind函数的绑定： 绑定自身 1234567891011121314151617181920212223242526272829$this-&gt;app-&gt;bind('App\Services\RedisEventPusher', null);$this-&gt;app-&gt;bind('name', function () &#123; return 'Taylor';&#125;); // 闭包返回变量$this-&gt;app-&gt;bind('HelpSpot\API', function () &#123; return HelpSpot\API::class;&#125;); // 闭包直接提供类实现方式public function testSharedClosureResolution()&#123; $container = new Container; $class = new stdClass; $container-&gt;bind('class', function () use ($class) &#123; return $class; &#125;); $this-&gt;assertSame($class, $container-&gt;make('class'));&#125; // 闭包返回类变量$this-&gt;app-&gt;bind('HelpSpot\API', function () &#123; return new HelpSpot\API();&#125;);// 闭包直接提供类实现方式$this-&gt;app-&gt;bind('HelpSpot\API', function ($app) &#123; return new HelpSpot\API($app-&gt;make('HttpClient'));&#125;);// 闭包返回需要依赖注入的类 绑定接口 1234567891011121314151617181920212223242526272829public function testCanBuildWithoutParameterStackWithConstructors()&#123; $container = new Container; $container-&gt;bind('Illuminate\Tests\Container\IContainerContractStub', 'Illuminate\Tests\Container\ContainerImplementationStub'); $this-&gt;assertInstanceOf( ContainerDependentStub::class, $container-&gt;build(ContainerDependentStub::class) );&#125;interface IContainerContractStub&#123;&#125;class ContainerImplementationStub implements IContainerContractStub&#123;&#125;class ContainerDependentStub&#123; public $impl; public function __construct(IContainerContractStub $impl) &#123; $this-&gt;impl = $impl; &#125;&#125; 这三种绑定方式中，第一种绑定自身一般用于绑定单例。 bindif绑定 1234567891011121314public function testBindIfDoesntRegisterIfServiceAlreadyRegistered()&#123; $container = new Container; $container-&gt;bind('name', function ()&#123; return 'Taylor'; &#125;); $container-&gt;bindIf('name', function () &#123; return 'Dayle'; &#125;); $this-&gt;assertEquals('Taylor', $container-&gt;make('name'));&#125; singleton绑定 singleton方法绑定一个只需要解析一次的类或接口到容器，然后接下来对容器的调用将会返回同一个实例：123$this-&gt;app-&gt;singleton('HelpSpot\API', function ($app) &#123; return new HelpSpot\API($app-&gt;make('HttpClient'));&#125;); 值得注意的是，singleton绑定在解析的时候若存在参数重载，那么就自动取消单例模式。123456789101112public function testSingletonBindingsNotRespectedWithMakeParameters()&#123; $container = new Container; $container-&gt;singleton('foo', function ($app, $config) &#123; return $config; &#125;); $this-&gt;assertEquals(['name' =&gt; 'taylor'], $container-&gt;makeWith('foo', ['name' =&gt; 'taylor'])); $this-&gt;assertEquals(['name' =&gt; 'abigail'], $container-&gt;makeWith('foo', ['name' =&gt; 'abigail']));&#125; instance绑定 我们还可以使用instance方法绑定一个已存在的对象实例到容器，随后调用容器将总是返回给定的实例：12$api = new HelpSpot\API(new HttpClient);$this-&gt;app-&gt;instance('HelpSpot\Api', $api); Context绑定 有时侯我们可能有两个类使用同一个接口，但我们希望在每个类中注入不同实现，例如，两个控制器依赖Illuminate\Contracts\Filesystem\Filesystem契约的不同实现。Laravel为此定义了简单、平滑的接口：12345678910111213141516171819202122use Illuminate\Support\Facades\Storage;use App\Http\Controllers\VideoController;use App\Http\Controllers\PhotoControllers;use Illuminate\Contracts\Filesystem\Filesystem;$this-&gt;app-&gt;when(StorageController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; Storage::class &#125;); // 提供类名$this-&gt;app-&gt;when(PhotoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return new Storage(); &#125;); // 提供实现方式$this-&gt;app-&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return new Storage($app-&gt;make(Disk::class)); &#125;); // 需要依赖注入 原始值绑定 我们可能有一个接收注入类的类，同时需要注入一个原生的数值比如整型，可以结合上下文轻松注入这个类需要的任何值：123$this-&gt;app-&gt;when('App\Http\Controllers\UserController') -&gt;needs('$variableName') -&gt;give($value); 数组绑定 数组绑定一般用于绑定闭包和变量，但是不能绑定接口，否则只能返回接口的实现类名字符串,并不能返回实现类的对象。1234567891011121314151617public function testArrayAccess()&#123; $container = new Container; $container[IContainerContractStub::class] = ContainerImplementationStub::class; $this-&gt;assertTrue(isset($container[IContainerContractStub::class])); $this-&gt;assertEquals( ContainerImplementationStub::class, $container[IContainerContractStub::class] ); unset($container['something']); $this-&gt;assertFalse(isset($container['something']));&#125; 标签绑定 少数情况下，我们需要解析特定分类下的所有绑定，例如，你正在构建一个接收多个不同Report接口实现的报告聚合器，在注册完Report实现之后，可以通过tag方法给它们分配一个标签：123456789$this-&gt;app-&gt;bind('SpeedReport', function () &#123;//&#125;);$this-&gt;app-&gt;bind('MemoryReport', function () &#123;//&#125;);$this-&gt;app-&gt;tag(['SpeedReport', 'MemoryReport'], 'reports'); 这些服务被打上标签后，可以通过tagged方法来轻松解析它们：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061$this-&gt;app-&gt;bind('ReportAggregator', function ($app) &#123; return new ReportAggregator($app-&gt;tagged('reports'));&#125;);public function testContainerTags()&#123; $container = new Container; $container-&gt;tag( 'Illuminate\Tests\Container\ContainerImplementationStub', 'foo', 'bar' ); $container-&gt;tag( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', ['foo'] ); $this-&gt;assertCount(1, $container-&gt;tagged('bar')); $this-&gt;assertCount(2, $container-&gt;tagged('foo')); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStub', $container-&gt;tagged('foo')[0] ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStub', $container-&gt;tagged('bar')[0] ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;tagged('foo')[1] ); $container = new Container; $container-&gt;tag( [ 'Illuminate\Tests\Container\ContainerImplementationStub', 'Illuminate\Tests\Container\ContainerImplementationStubTwo' ], ['foo'] ); $this-&gt;assertCount(2, $container-&gt;tagged('foo')); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStub', $container-&gt;tagged('foo')[0] ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;tagged('foo')[1] ); $this-&gt;assertEmpty($container-&gt;tagged('this_tag_does_not_exist'));&#125; extend扩展 extend是在当原来的类被注册或者实例化出来后，可以对其进行扩展，而且可以支持多重扩展：123456789101112131415161718192021222324252627282930public function testExtendInstancesArePreserved()&#123; $container = new Container; $container-&gt;bind('foo', function () &#123; $obj = new StdClass; $obj-&gt;foo = 'bar'; return $obj; &#125;); $obj = new StdClass; $obj-&gt;foo = 'foo'; $container-&gt;instance('foo', $obj); $container-&gt;extend('foo', function ($obj, $container) &#123; $obj-&gt;bar = 'baz'; return $obj; &#125;); $container-&gt;extend('foo', function ($obj, $container) &#123; $obj-&gt;baz = 'foo'; return $obj; &#125;); $this-&gt;assertEquals('foo', $container-&gt;make('foo')-&gt;foo); $this-&gt;assertEquals('baz', $container-&gt;make('foo')-&gt;bar); $this-&gt;assertEquals('foo', $container-&gt;make('foo')-&gt;baz);&#125; Rebounds与Rebinding绑定是针对接口的，是为接口提供实现方式的方法。我们可以对接口在不同的时间段里提供不同的实现方法，一般来说，对同一个接口提供新的实现方法后，不会对已经实例化的对象产生任何影响。但是在一些场景下，在提供新的接口实现后，我们希望对已经实例化的对象重新做一些改变，这个就是rebinding函数的用途。下面就是一个例子：1234567891011121314151617181920212223242526272829303132333435abstract class Car&#123; public function __construct(Fuel $fuel) &#123; $this-&gt;fuel = $fuel; &#125; public function refuel($litres) &#123; return $litres * $this-&gt;fuel-&gt;getPrice(); &#125; public function setFuel(Fuel $fuel) &#123; $this-&gt;fuel = $fuel; &#125;&#125;class JeepWrangler extends Car&#123;//&#125;interface Fuel&#123; public function getPrice();&#125;class Petrol implements Fuel&#123; public function getPrice() &#123; return 130.7; &#125;&#125; 我们在服务容器中是这样对car接口和fuel接口绑定的：123456789$this-&gt;app-&gt;bind('fuel', function ($app) &#123; return new Petrol;&#125;);$this-&gt;app-&gt;bind('car', function ($app) &#123; return new JeepWrangler($app['fuel']);&#125;);$this-&gt;app-&gt;make('car'); 如果car被服务容器解析实例化成对象之后，有人修改了fuel接口的实现，从Petrol改为 PremiumPetrol：123$this-&gt;app-&gt;bind('fuel', function ($app) &#123; return new PremiumPetrol;&#125;); 由于car已经被实例化，那么这个接口实现的改变并不会影响到car的实现，假若我们想要car的成员变量fuel随着fuel接口的变化而变化，我们就需要一个回调函数，每当对fuel接口实现进行改变的时候，都要对car的fuel变量进行更新，这就是rebinding的用途：12345678910$this-&gt;app-&gt;bindShared('car', function ($app) &#123; return new JeepWrangler( $app-&gt;rebinding( 'fuel', function ($app, $fuel) &#123; $app['car']-&gt;setFuel($fuel); &#125; ) );&#125;); 服务别名什么是服务别名在说服务容器的解析之前，需要先说说服务的别名。什么是服务别名呢？不同于上一个博客中提到的Facade门面的别名(在config/app中定义)，这里的别名服务绑定名称的别名。通过服务绑定的别名，在解析服务的时候，跟不使用别名的效果一致。别名的作用也是为了同时支持全类型的服务绑定名称以及简短的服务绑定名称考虑的。 通俗的讲，假如我们想要创建auth服务，我们既可以这样写：1$this-&gt;app-&gt;make('auth') 又可以写成：1$this-&gt;app-&gt;make('\Illuminate\Auth\AuthManager::class') 还可以写成1$this-&gt;app-&gt;make('\Illuminate\Contracts\Auth\Factory::class') 后面两个服务的名字都是auth的别名，使用别名和使用auth的效果是相同的。 服务别名的递归需要注意的是别名是可以递归的：123app()-&gt;alias('service', 'alias_a');app()-&gt;alias('alias_a', 'alias_b');app()-&gt;alias('alias_b', 'alias_c'); 会得到：123'alias_a' =&gt; 'service''alias_b' =&gt; 'alias_a''alias_c' =&gt; 'alias_b' 服务别名的实现那么这些别名是如何加载到服务容器里面的呢？实际上，服务容器里面有个aliases数组：12345678910111213141516171819202122$aliases = [ 'app' =&gt; [ \Illuminate\Foundation\Application::class, \Illuminate\Contracts\Container\Container::class, \Illuminate\Contracts\Foundation\Application::class ], 'auth' =&gt; [ \Illuminate\Auth\AuthManager::class, \Illuminate\Contracts\Auth\Factory::class ], 'auth.driver' =&gt; [ \Illuminate\Contracts\Auth\Guard::class ], 'blade.compiler' =&gt; [ \Illuminate\View\Compilers\BladeCompiler::class ], 'cache' =&gt; [ \Illuminate\Cache\CacheManager::class, \Illuminate\Contracts\Cache\Factory::class ], ...] 而服务容器的初始化的过程中，会运行一个函数：12345678910111213141516public function registerCoreContainerAliases()&#123; foreach ($aliases as $key =&gt; $aliases) &#123; foreach ($aliases as $alias) &#123; $this-&gt;alias($key, $alias); &#125; &#125;&#125;public function alias($abstract, $alias)&#123; $this-&gt;aliases[$alias] = $abstract; $this-&gt;abstractAliases[$abstract][] = $alias;&#125; 加载后，服务容器的aliases和abstractAliases数组：123456789101112131415161718192021222324252627282930$aliases = [ 'Illuminate\Foundation\Application' = "app" 'Illuminate\Contracts\Container\Container' = "app" 'Illuminate\Contracts\Foundation\Application' = "app" 'Illuminate\Auth\AuthManager' = "auth" 'Illuminate\Contracts\Auth\Factory' = "auth" 'Illuminate\Contracts\Auth\Guard' = "auth.driver" 'Illuminate\View\Compilers\BladeCompiler' = "blade.compiler" 'Illuminate\Cache\CacheManager' = "cache" 'Illuminate\Contracts\Cache\Factory' = "cache" ...］$abstractAliases = [ app = &#123;array&#125; [3] 0 = "Illuminate\Foundation\Application" 1 = "Illuminate\Contracts\Container\Container" 2 = "Illuminate\Contracts\Foundation\Application" auth = &#123;array&#125; [2] 0 = "Illuminate\Auth\AuthManager" 1 = "Illuminate\Contracts\Auth\Factory" auth.driver = &#123;array&#125; [1] 0 = "Illuminate\Contracts\Auth\Guard" blade.compiler = &#123;array&#125; [1] 0 = "Illuminate\View\Compilers\BladeCompiler" cache = &#123;array&#125; [2] 0 = "Illuminate\Cache\CacheManager" 1 = "Illuminate\Contracts\Cache\Factory" ...] 服务解析make解析有很多方式可以从容器中解析对象，首先，你可以使用make方法，该方法接收你想要解析的类名或接口名作为参数：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115public function testAutoConcreteResolution()&#123; $container = new Container; $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerConcreteStub', $container-&gt;make('Illuminate\Tests\Container\ContainerConcreteStub') );&#125;// 带有依赖注入和默认值的解析public function testResolutionOfDefaultParameters()&#123; $container = new Container; $instance = $container-&gt;make( 'Illuminate\Tests\Container\ContainerDefaultValueStub' ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerConcreteStub', $instance-&gt;stub ); $this-&gt;assertEquals('taylor', $instance-&gt;default);&#125;//public function testResolvingWithArrayOfParameters()&#123; $container = new Container; $instance = $container-&gt;makeWith( ContainerDefaultValueStub::class, ['default' =&gt; 'adam'] ); $this-&gt;assertEquals('adam', $instance-&gt;default); $instance = $container-&gt;make(ContainerDefaultValueStub::class); $this-&gt;assertEquals('taylor', $instance-&gt;default); $container-&gt;bind('foo', function ($app, $config) &#123; return $config; &#125;); $this-&gt;assertEquals( [1, 2, 3], $container-&gt;makeWith('foo', [1, 2, 3]) );&#125;public function testNestedDependencyResolution()&#123; $container = new Container; $container-&gt;bind( 'Illuminate\Tests\Container\IContainerContractStub', 'Illuminate\Tests\Container\ContainerImplementationStub' ); $class = $container-&gt;make( 'Illuminate\Tests\Container\ContainerNestedDependentStub'); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerDependentStub', $class-&gt;inner ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStub', $class-&gt;inner-&gt;impl );&#125;class ContainerDefaultValueStub&#123; public $stub; public $default; public function __construct(ContainerConcreteStub $stub, $default = 'taylor') &#123; $this-&gt;stub = $stub; $this-&gt;default = $default; &#125;&#125;class ContainerConcreteStub&#123;&#125;class ContainerImplementationStub implements IContainerContractStub&#123;&#125;class ContainerDependentStub&#123; public $impl; public function __construct(IContainerContractStub $impl) &#123; $this-&gt;impl = $impl; &#125;&#125;class ContainerNestedDependentStub&#123; public $inner; public function __construct(ContainerDependentStub $inner) &#123; $this-&gt;inner = $inner; &#125;&#125; 如果你所在的代码位置访问不了$app变量，可以使用辅助函数resolve：1$api = resolve('HelpSpot\API'); 自动注入12345678910111213141516171819202122namespace App\Http\Controllers;use App\Users\Repository as UserRepository;class UserController extends Controller&#123; /** * 用户仓库实例 */ protected $users; /** * 创建一个控制器实例 * * @param UserRepository $users 自动注入 * @return void */ public function __construct(UserRepository $users) &#123; $this-&gt;users = $users; &#125;&#125; call方法注入make解析是服务容器进行解析构建类对象时所用的方法，在实际应用中，还有另外一个需求，那就是当前已经获取了一个类对象，我们想要调用它的一个方法函数，这时发现这个方法中参数众多，如果一个个的make会比较繁琐，这个时候就要用到call解析了。我们可以看这个例子：123456789101112131415161718192021222324class TaskRepository&#123; public function testContainerCall(User $user,Task $task) &#123; $this-&gt;assertInstanceOf(User::class, $user); $this-&gt;assertInstanceOf(Task::class, $task); &#125; public static function testContainerCallStatic(User $user,Task $task) &#123; $this-&gt;assertInstanceOf(User::class, $user); $this-&gt;assertInstanceOf(Task::class, $task); &#125; public function testCallback() &#123; echo 'call callback successfully!'; &#125; public function testDefaultMethod() &#123; echo 'default Method successfully!'; &#125;&#125; 闭包函数注入12345678910111213141516171819public function testCallWithDependencies()&#123; $container = new Container; $result = $container-&gt;call(function (StdClass $foo, $bar =[]) &#123; return func_get_args(); &#125;); $this-&gt;assertInstanceOf('stdClass', $result[0]); $this-&gt;assertEquals([], $result[1]); $result = $container-&gt;call(function (StdClass $foo, $bar =[]) &#123; return func_get_args(); &#125;, ['bar' =&gt; 'taylor']); $this-&gt;assertInstanceOf('stdClass', $result[0]); $this-&gt;assertEquals('taylor', $result[1]);&#125; 普通函数注入12345678910111213public function testCallWithGlobalMethodName()&#123; $container = new Container; $result = $container-&gt;call('Illuminate\Tests\Container\containerTestInject'); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerConcreteStub', $result[0] ); $this-&gt;assertEquals('taylor', $result[1]);&#125; 静态方法注入服务容器的call解析主要依靠call_user_func_array()函数，关于这个函数可以查看Laravel学习笔记之Callback Type - 来生做个漫画家，这个函数对类中的静态函数和非静态函数有一些区别，对于静态函数来说：123456789class ContainerCallTest&#123; public function testContainerCallStatic() &#123; App::call(TaskRepository::class.'@testContainerCallStatic'); App::call(TaskRepository::class.'::testContainerCallStatic'); App::call([TaskRepository::class,'testContainerCallStatic']); &#125;&#125; 服务容器调用类的静态方法有三种，注意第三种使用数组的形式，数组中可以直接传类名 TaskRepository::class； 非静态方法注入对于类的非静态方法：123456789class ContainerCallTest&#123; public function testContainerCall() &#123; $taskRepo = new TaskRepository(); App::call(TaskRepository::class.'@testContainerCall'); App::call([$taskRepo,'testContainerCall']); &#125;&#125; 我们可以看到非静态方法只有两种调用方式，而且第二种数组传递的参数是类对象，原因就是 call_user_func_array函数的限制，对于非静态方法只能传递对象。 bindmethod方法绑定服务容器还有一个bindmethod的方法，可以绑定类的一个方法到自定义的函数：1234567891011121314151617181920212223public function testContainCallMethodBind()&#123; App::bindMethod(TaskRepository::class.'@testContainerCallStatic',function () &#123; $taskRepo = new TaskRepository(); $taskRepo-&gt;testCallback(); &#125;); App::call(TaskRepository::class.'@testContainerCallStatic'); App::call(TaskRepository::class.'::testContainerCallStatic'); App::call([TaskRepository::class,'testContainerCallStatic']); App::bindMethod( TaskRepository::class.'@testContainerCall', function (TaskRepository $taskRepo) &#123; $taskRepo-&gt;testCallback(); &#125; ); $taskRepo = new TaskRepository(); App::call(TaskRepository::class.'@testContainerCall'); App::call([$taskRepo,'testContainerCall']);&#125; 从结果上看，bindmethod不会对静态的第二种解析方法（::解析方式）起作用，对于其他方式都会调用绑定的函数。1234567891011121314151617181920212223242526272829303132333435363738public function testCallWithBoundMethod()&#123; $container = new Container; $container-&gt;bindMethod( 'Illuminate\Tests\Container\ContainerTestCallStub@unresolvable', function ($stub) &#123; return $stub-&gt;unresolvable('foo', 'bar'); &#125; ); $result = $container-&gt;call( 'Illuminate\Tests\Container\ContainerTestCallStub@unresolvable' ); $this-&gt;assertEquals(['foo', 'bar'], $result); $container = new Container; $container-&gt;bindMethod( 'Illuminate\Tests\Container\ContainerTestCallStub@unresolvable', function ($stub) &#123; return $stub-&gt;unresolvable('foo', 'bar'); &#125; ); $result = $container-&gt;call([new ContainerTestCallStub, 'unresolvable']); $this-&gt;assertEquals(['foo', 'bar'], $result);&#125;class ContainerTestCallStub&#123; public function unresolvable($foo, $bar) &#123; return func_get_args(); &#125;&#125; 默认函数注入1234567891011121314151617181920212223public function testContainCallDefultMethod()&#123; App::call(TaskRepository::class,[],'testContainerCall'); App::call(TaskRepository::class,[],'testContainerCallStatic'); App::bindMethod( TaskRepository::class.'@testContainerCallStatic', function () &#123; $taskRepo = new TaskRepository(); $taskRepo-&gt;testCallback(); &#125; ); App::bindMethod( TaskRepository::class.'@testContainerCall', function (TaskRepository $taskRepo) &#123; $taskRepo-&gt;testCallback(); &#125; ); App::call(TaskRepository::class,[],'testContainerCall'); App::call(TaskRepository::class,[],'testContainerCallStatic');&#125; 值得注意的是，这种默认函数注入的方法使得非静态的方法也可以利用类名去调用，并不需要对象。默认函数注入也回受到bindmethod函数的影响。 数组解析app()[‘service’];app($service)的形式app(‘service’); 服务容器事件每当服务容器解析一个对象时就会触发一个事件。你可以使用resolving方法监听这个事件：123456789101112131415$this-&gt;app-&gt;resolving(function ($object, $app) &#123; // 解析任何类型的对象时都会调用该方法...&#125;);$this-&gt;app-&gt;resolving(HelpSpot\API::class, function ($api, $app)&#123; // 解析「HelpSpot\API」类型的对象时调用...&#125;);$this-&gt;app-&gt;afterResolving(function ($object, $app) &#123; // 解析任何类型的对象后都会调用该方法...&#125;);$this-&gt;app-&gt;afterResolving(HelpSpot\API::class, function ($api, $app) &#123; // 解析「HelpSpot\API」类型的对象后调用...&#125;); 服务容器每次解析对象的时候，都会调用这些通过resolving和afterResolving函数传入的闭包函数，也就是触发这些事件。 注意：如果是单例，则只在解析时会触发一次123456789101112131415161718192021222324252627282930313233343536373839public function testResolvingCallbacksAreCalled()&#123;$container = new Container;$container-&gt;resolving(function ($object) &#123;return $object-&gt;name = 'taylor';&#125;);$container-&gt;bind('foo', function () &#123;return new StdClass;&#125;);$instance = $container-&gt;make('foo');$this-&gt;assertEquals('taylor', $instance-&gt;name);&#125;public function testResolvingCallbacksAreCalledForType()&#123;$container = new Container;$container-&gt;resolving('StdClass', function ($object) &#123;return $object-&gt;name = 'taylor';&#125;);$container-&gt;bind('foo', function () &#123;return new StdClass;&#125;);$instance = $container-&gt;make('foo');$this-&gt;assertEquals('taylor', $instance-&gt;name);&#125;public function testResolvingCallbacksShouldBeFiredWhenCalledWithAliases()&#123;$container = new Container;$container-&gt;alias('StdClass', 'std');$container-&gt;resolving('std', function ($object) &#123;return $object-&gt;name = 'taylor';&#125;);$container-&gt;bind('foo', function () &#123;return new StdClass;&#125;);$instance = $container-&gt;make('foo');$this-&gt;assertEquals('taylor', $instance-&gt;name);&#125; 装饰函数容器的装饰函数有两种，wrap用于装饰call，factory用于装饰make：1234567891011121314151617181920212223242526public function testContainerWrap()&#123; $result = $container-&gt;wrap(function (StdClass $foo, $bar =[]) &#123; return func_get_args(); &#125;, ['bar' =&gt; 'taylor']); $this-&gt;assertInstanceOf('Closure', $result); $result = $result(); $this-&gt;assertInstanceOf('stdClass', $result[0]); $this-&gt;assertEquals('taylor', $result[1]);&#125;public function testContainerGetFactory()&#123; $container = new Container; $container-&gt;bind('name', function () &#123; return 'Taylor'; &#125;); $factory = $container-&gt;factory('name'); $this-&gt;assertEquals($container-&gt;make('name'), $factory());&#125; 容器重置flush容器的重置函数flush会清空容器内部的aliases、abstractAliases、resolved、bindings、instances123456789101112131415161718192021222324252627public function testContainerFlushFlushesAllBindingsAliasesAndResolvedInstances()&#123; $container = new Container; $container-&gt;bind('ConcreteStub', function () &#123; return new ContainerConcreteStub; &#125;, true); $container-&gt;alias('ConcreteStub', 'ContainerConcreteStub'); $concreteStubInstance = $container-&gt;make('ConcreteStub'); $this-&gt;assertTrue($container-&gt;resolved('ConcreteStub')); $this-&gt;assertTrue($container-&gt;isAlias('ContainerConcreteStub')); $this-&gt;assertArrayHasKey('ConcreteStub', $container-&gt;getBindings()); $this-&gt;assertTrue($container-&gt;isShared('ConcreteStub')); $container-&gt;flush(); $this-&gt;assertFalse($container-&gt;resolved('ConcreteStub')); $this-&gt;assertFalse($container-&gt;isAlias('ContainerConcreteStub')); $this-&gt;assertEmpty($container-&gt;getBindings()); $this-&gt;assertFalse($container-&gt;isShared('ConcreteStub'));&#125; 前言在前面几个博客中，我详细讲了IoC容器各个功能的使用、绑定的源码、解析的源码，今天这篇博客会详细介绍Ioc容器的一些细节，一些特性，以便更好地掌握容器的功能。 注：本文使用的测试类与测试对象都取自Laravel的单元测试文件src/illuminate/tests/Container/ContainerTest.php rebind绑定特性 rebind在绑定之前instance和普通bind绑定一样，当重新绑定的时候都会调用rebind回调函数，但是有趣的是，对于普通bind绑定来说，rebind回调函数被调用的条件是当前接口被解析过：12345678910111213141516171819202122public function testReboundListeners()&#123; unset($_SERVER['__test.rebind']); $container = new Container; $container-&gt;rebinding('foo', function () &#123; $_SERVER['__test.rebind'] = true; &#125;); $container-&gt;bind('foo', function () &#123; &#125;); $container-&gt;make('foo'); $container-&gt;bind('foo', function () &#123; &#125;); $this-&gt;assertTrue($_SERVER['__test.rebind']);&#125; 所以遇到下面这样的情况，rebinding的回调函数是不会调用的：1234567891011121314151617181920public function testReboundListeners()&#123; unset($_SERVER['__test.rebind']); $container = new Container; $container-&gt;rebinding('foo', function () &#123; $_SERVER['__test.rebind'] = true; &#125;); $container-&gt;bind('foo', function () &#123; &#125;); $container-&gt;bind('foo', function () &#123; &#125;); $this-&gt;assertFalse(isset($_SERVER['__test.rebind']));&#125; 有趣的是对于instance绑定：1234567891011121314151617181920public function testReboundListeners()&#123; unset($_SERVER['__test.rebind']); $container = new Container; $container-&gt;rebinding('foo', function () &#123; $_SERVER['__test.rebind'] = true; &#125;); $container-&gt;bind('foo', function () &#123; &#125;); $container-&gt;instance('foo', function () &#123; &#125;); $this-&gt;assertTrue(isset($_SERVER['__test.rebind']));&#125; rebinding回调函数却是可以被调用的。其实原因就是 instance 源码中 rebinding 回调函数调用的条件是 rebound 为真，而普通 bind 函数调用 rebinding 回调函数的条件是 resolved 为真. 目前笔者不是很清楚为什么要对 instance 和 bind 区别对待，希望有大牛指导。 rebind在绑定之后 为了使得rebind回调函数在下一次的绑定中被激活，在rebind函数的源码中，如果判断当前对象已经绑定过，那么将会立即解析：12345678public function rebinding($abstract, Closure $callback)&#123; $this-&gt;reboundCallbacks[$abstract = $this-&gt;getAlias($abstract)][] = $callback; if ($this-&gt;bound($abstract)) &#123; return $this-&gt;make($abstract); &#125;&#125; 单元测试代码：12345678910111213141516171819202122232425public function testReboundListeners1()&#123; unset($_SERVER['__test.rebind']); $container = new Container; $container-&gt;bind('foo', function () &#123; return 'foo'; &#125;); $container-&gt;resolving('foo', function () &#123; $_SERVER['__test.rebind'] = true; &#125;); $container-&gt;rebinding('foo', function ($container,$object) &#123; // 会立即解析 $container['foobar'] = $object.'bar'; &#125;); $this-&gt;assertTrue($_SERVER['__test.rebind']); $container-&gt;bind('foo', function () &#123; &#125;); $this-&gt;assertEquals('bar', $container['foobar']);&#125; resolving特性resolving 回调的类型resolving不仅可以针对接口执行回调函数，还可以针对接口实现的类型进行回调函数。 1234567891011121314151617181920212223242526272829303132333435public function testResolvingCallbacksAreCalledForType()&#123; $container = new Container; $container-&gt;resolving('StdClass', function ($object) &#123; return $object-&gt;name = 'taylor'; &#125;); $container-&gt;bind('foo', function () &#123; return new StdClass; &#125;); $instance = $container-&gt;make('foo'); $this-&gt;assertEquals('taylor', $instance-&gt;name);&#125;public function testResolvingCallbacksShouldBeFiredWhenCalledWithAliases()&#123; $container = new Container; $container-&gt;alias('StdClass', 'std'); $container-&gt;resolving('std', function ($object) &#123; return $object-&gt;name = 'taylor'; &#125;); $container-&gt;bind('foo', function () &#123; return new StdClass; &#125;); $instance = $container-&gt;make('foo'); $this-&gt;assertEquals('taylor', $instance-&gt;name);&#125; resolving回调与instance前面讲过，对于singleton绑定来说，resolving回调函数仅仅运行一次，只在singleton 第一次解析的时候才会调用。如果我们利用instance直接绑定类的对象，不需要解析，那么resolving回调函数将不会被调用：1234567891011121314public function testResolvingCallbacksAreCalledForSpecificAbstracts()&#123; $container = new Container; $container-&gt;resolving('foo', function ($object) &#123; return $object-&gt;name = 'taylor'; &#125;); $obj = new StdClass; $container-&gt;instance('foo', $obj); $instance = $container-&gt;make('foo'); $this-&gt;assertFalse(isset($instance-&gt;name));&#125; extend扩展特性extend用于扩展绑定对象的功能，对于普通绑定来说，这个函数的位置很灵活：在绑定前扩展12345678910111213141516171819202122public function testExtendIsLazyInitialized()&#123; ContainerLazyExtendStub::$initialized = false; $container = new Container; $container-&gt;extend( 'Illuminate\Tests\Container\ContainerLazyExtendStub', function ($obj, $container) &#123; $obj-&gt;init(); return $obj; &#125; ); $container-&gt;bind('Illuminate\Tests\Container\ContainerLazyExtendStub'); $this-&gt;assertFalse(ContainerLazyExtendStub::$initialized); $container-&gt;make('Illuminate\Tests\Container\ContainerLazyExtendStub'); $this-&gt;assertTrue(ContainerLazyExtendStub::$initialized);&#125; 在绑定后解析前扩展 1234567891011121314151617181920public function testExtendIsLazyInitialized()&#123; ContainerLazyExtendStub::$initialized = false; $container = new Container; $container-&gt;bind('Illuminate\Tests\Container\ContainerLazyExtendStub'); $container-&gt;extend( 'Illuminate\Tests\Container\ContainerLazyExtendStub', function ($obj, $container) &#123; $obj-&gt;init(); return $obj; &#125; ); $this-&gt;assertFalse(ContainerLazyExtendStub::$initialized); $container-&gt;make('Illuminate\Tests\Container\ContainerLazyExtendStub'); $this-&gt;assertTrue(ContainerLazyExtendStub::$initialized);&#125; 在解析后扩展1234567891011121314151617181920212223public function testExtendIsLazyInitialized()&#123; ContainerLazyExtendStub::$initialized = false; $container = new Container; $container-&gt;bind('Illuminate\Tests\Container\ContainerLazyExtendStub'); $container-&gt;make('Illuminate\Tests\Container\ContainerLazyExtendStub'); $this-&gt;assertFalse(ContainerLazyExtendStub::$initialized); $container-&gt;extend( 'Illuminate\Tests\Container\ContainerLazyExtendStub', function ($obj, $container) &#123; $obj-&gt;init(); return $obj; &#125; ); $this-&gt;assertFalse(ContainerLazyExtendStub::$initialized); $container-&gt;make('Illuminate\Tests\Container\ContainerLazyExtendStub'); $this-&gt;assertTrue(ContainerLazyExtendStub::$initialized);&#125; 可以看出，无论在哪个位置，extend扩展都有lazy初始化的特点，也就是使用extend函数并不会立即起作用，而是要等到make解析才会激活。 extend与instance绑定对于instance绑定来说，暂时extend的位置需要位于instance之后才会起作用，并且会立即起作用，没有lazy的特点：123456789101112131415161718192021public function testExtendInstancesArePreserved()&#123; $container = new Container; $obj = new StdClass; $obj-&gt;foo = 'foo'; $container-&gt;instance('foo', $obj); $container-&gt;extend( 'foo', function ($obj, $container) &#123; $obj-&gt;bar = 'baz'; return $obj; &#125; ); $this-&gt;assertEquals('foo', $container-&gt;make('foo')-&gt;foo); $this-&gt;assertEquals('baz', $container-&gt;make('foo')-&gt;bar);&#125; extend绑定与rebind回调无论扩展对象是instance绑定还是bind绑定，extend都会启动rebind回调函数：1234567891011121314151617181920212223242526272829303132333435363738394041424344public function testExtendReBindingInstance()&#123; $_SERVER['_test_rebind'] = false; $container = new Container; $container-&gt;rebinding('foo',function ()&#123; $_SERVER['_test_rebind'] = true; &#125;); $obj = new StdClass; $container-&gt;instance('foo',$obj); $container-&gt;make('foo'); $container-&gt;extend('foo', function ($obj, $container) &#123; return $obj; &#125;); $this-&gt;assertTrue($_SERVER['_test_rebind']);&#125;public function testExtendReBinding()&#123; $_SERVER['_test_rebind'] = false; $container = new Container; $container-&gt;rebinding('foo',function ()&#123; $_SERVER['_test_rebind'] = true; &#125;); $container-&gt;bind('foo',function ()&#123; $obj = new StdClass; return $obj; &#125;); $container-&gt;make('foo'); $container-&gt;extend('foo', function ($obj, $container) &#123; return $obj; &#125;); $this-&gt;assertFalse($_SERVER['_test_rebind']);&#125; contextual绑定特性contextual在绑定前 contextual绑定不仅可以与bind绑定合作，相互不干扰，还可以与instance绑定相互合作。而且instance的位置也很灵活，可以在contextual绑定前，也可以在contextual绑定后：123456789101112131415public function testContextualBindingWorksForExistingInstancedBindings()&#123; $container = new Container; $container-&gt;instance('Illuminate\Tests\Container\IContainerContractStub', new ContainerImplementationStub); $container-&gt;when('Illuminate\Tests\Container\ContainerTestContextInjectOne') -&gt;needs('Illuminate\Tests\Container\IContainerContractStub') -&gt;give('Illuminate\Tests\Container\ContainerImplementationStubTwo'); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectOne')-&gt;impl );&#125; contextual在绑定后 123456789101112131415161718public function testContextualBindingWorksForNewlyInstancedBindings()&#123; $container = new Container; $container-&gt;when('Illuminate\Tests\Container\ContainerTestContextInjectOne') -&gt;needs('Illuminate\Tests\Container\IContainerContractStub') -&gt;give('Illuminate\Tests\Container\ContainerImplementationStubTwo'); $container-&gt;instance( 'Illuminate\Tests\Container\IContainerContractStub', new ContainerImplementationStub ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectOne')-&gt;impl );&#125; contextual绑定与别名contextual绑定也可以在别名上进行，无论赋予别名的位置是contextual的前面还是后面：12345678910111213141516171819202122232425262728293031323334353637383940414243444546public function testContextualBindingDoesntOverrideNonContextualResolution()&#123; $container = new Container; $container-&gt;instance('stub', new ContainerImplementationStub); $container-&gt;alias( 'stub', 'Illuminate\Tests\Container\IContainerContractStub' ); $container-&gt;when('Illuminate\Tests\Container\ContainerTestContextInjectTwo') -&gt;needs('Illuminate\Tests\Container\IContainerContractStub') -&gt;give('Illuminate\Tests\Container\ContainerImplementationStubTwo'); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectTwo')-&gt;impl ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStub', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectOne')-&gt;impl );&#125;public function testContextualBindingWorksOnNewAliasedBindings()&#123; $container = new Container; $container-&gt;when('Illuminate\Tests\Container\ContainerTestContextInjectOne') -&gt;needs('Illuminate\Tests\Container\IContainerContractStub') -&gt;give('Illuminate\Tests\Container\ContainerImplementationStubTwo'); $container-&gt;bind('stub', ContainerImplementationStub::class); $container-&gt;alias( 'stub', 'Illuminate\Tests\Container\IContainerContractStub' ); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectOne')-&gt;impl );&#125; 争议 目前比较有争议的是下面的情况：1234567891011121314151617public function testContextualBindingWorksOnExistingAliasedInstances()&#123; $container = new Container; $container-&gt;alias('Illuminate\Tests\Container\IContainerContractStub', 'stub'); $container-&gt;instance('stub', new ContainerImplementationStub); $container-&gt;when('Illuminate\Tests\Container\ContainerTestContextInjectOne') -&gt;needs('stub') -&gt;give('Illuminate\Tests\Container\ContainerImplementationStubTwo'); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectOne')-&gt;impl );&#125; 由于instance的特性，当别名被绑定到其他对象上时，别名stub已经失去了与Illuminate\Tests\Container\IContainerContractStub之间的关系，因此不能使用stub代替作上下文绑定。 但是另一方面：1234567891011121314151617public function testContextualBindingWorksOnBoundAlias()&#123; $container = new Container; $container-&gt;alias('Illuminate\Tests\Container\IContainerContractStub', 'stub'); $container-&gt;bind('stub', ContainerImplementationStub::class); $container-&gt;when('Illuminate\Tests\Container\ContainerTestContextInjectOne') -&gt;needs('stub') -&gt;give('Illuminate\Tests\Container\ContainerImplementationStubTwo'); $this-&gt;assertInstanceOf( 'Illuminate\Tests\Container\ContainerImplementationStubTwo', $container-&gt;make('Illuminate\Tests\Container\ContainerTestContextInjectOne')-&gt;impl );&#125; 代码只是从 instance 绑定改为bind绑定，由于bind绑定只切断了别名中的alias数组的联系，并没有断绝abstractAlias数组的联系，因此这段代码却可以通过，很让人难以理解。本人在给 Taylor Otwell 提出 PR 时，作者原话为“I’m not making any of these changes to the container on a patch release.”。也许，在以后(5.5或以后)版本作者会更新这里的逻辑，我们就可以看看服务容器对别名绑定的态度了，大家也最好不要这样用。 服务容器中的闭包函数参数 服务容器中很多函数都有闭包函数，这些闭包函数可以放入特定的参数，在绑定或者解析过程中，这些参数会被服务容器自动带入各种类对象或者服务容器实例。 bind闭包参数123456789101112public function testAliasesWithArrayOfParameters()&#123; $container = new Container; $container-&gt;bind('foo', function ($app, $config) &#123; return $config; &#125;); $container-&gt;alias('foo', 'baz'); $this-&gt;assertEquals([1, 2, 3], $container-&gt;makeWith('baz', [1, 2, 3]));&#125; extend闭包参数1234567891011121314151617181920212223242526272829public function testExtendedBindings()&#123; $container = new Container; $container['foo'] = 'foo'; $container-&gt;extend('foo', function ($old, $container) &#123; return $old.'bar'; &#125;); $this-&gt;assertEquals('foobar', $container-&gt;make('foo')); $container = new Container; $container-&gt;singleton('foo', function () &#123; return (object) ['name' =&gt; 'taylor']; &#125;); $container-&gt;extend('foo', function ($old, $container) &#123; $old-&gt;age = 26; return $old; &#125;); $result = $container-&gt;make('foo'); $this-&gt;assertEquals('taylor', $result-&gt;name); $this-&gt;assertEquals(26, $result-&gt;age); $this-&gt;assertSame($result, $container-&gt;make('foo'));&#125; bindmethod闭包参数1234567891011121314public function testCallWithBoundMethod()&#123; $container = new Container; $container-&gt;bindMethod('Illuminate\Tests\Container\ContainerTestCallStub@unresolvable', function ($stub, $container) &#123; $container['foo'] = 'foo'; return $stub-&gt;unresolvable('foo', 'bar'); &#125;); $result = $container-&gt;call('Illuminate\Tests\Container\ContainerTestCallStub@unresolvable'); $this-&gt;assertEquals(['foo', 'bar'], $result); $this-&gt;assertEquals('foo',$container['foo']);&#125; resolve闭包参数12345678910111213141516public function testResolvingCallbacksAreCalledForSpecificAbstracts()&#123; $container = new Container; $container-&gt;resolving('foo', function ($object，$container)&#123; return $object-&gt;name = 'taylor'; &#125;); $container-&gt;bind('foo', function () &#123; return new StdClass; &#125;); $instance = $container-&gt;make('foo'); $this-&gt;assertEquals('taylor', $instance-&gt;name);&#125; rebinding闭包参数123456789101112131415161718public function testReboundListeners()&#123; $container = new Container; $container-&gt;bind('foo', function () &#123; return 'foo'; &#125;); $container-&gt;rebinding('foo', function ($container, $object) &#123; $container['bar'] = $object.'bar'; &#125;); $container-&gt;bind('foo', function () &#123; &#125;); $this-&gt;assertEquals('bar', $container['foobar']);&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel HTTP-Pipeline中间件处理源码分析]]></title>
    <url>%2F2020%2F05%2F13%2FLaravel-HTTP-Pipeline%E4%B8%AD%E9%97%B4%E4%BB%B6%E5%A4%84%E7%90%86%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 前言当所有的路由都加载完毕后，就会根据请求的url来将请求分发到对应的路由上去。然而，在分发到路由之前还要经过各种中间件的计算。 Laravel利用装饰者模式来实现中间件的功能。 从原始装饰者模式到闭包装饰者 装饰者模式是设计模式的一种，主要进行对象的多次处理与过滤，是在开放-关闭原则下实现动态添加或减少功能的一种方式。下面先看一个装饰者模式的例子： 总共有两种咖啡：Decaf、Espresso，另有两种调味品：Mocha、Whip（3种设计的主要差别在于抽象方式不同）装饰模式分为3个部分：1，抽象组件 — 对应Coffee类2，具体组件 — 对应具体的咖啡，如：Decaf，Espresso3，装饰者 — 对应调味品，如：Mocha，Whip原始装饰者模式1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public interface Coffee&#123; public double cost();&#125;public class Espresso implements Coffee&#123; public double cost() &#123; return 2.5; &#125;&#125;public class Dressing implements Coffee&#123; private Coffee coffee; public Dressing(Coffee coffee) &#123; this.coffee = coffee; &#125; public double cost() &#123; return coffee.cost(); &#125;&#125;public class Whip extends Dressing &#123; public Whip(Coffee coffee) &#123; super(coffee); &#125; public double cost() &#123; return super.cost() + 0.1; &#125;&#125;public class Mocha extends Dressing&#123; public Mocha(Coffee coffee) &#123; super(coffee); &#125; public double cost() &#123; return super.cost() + 0.5; &#125;&#125; 当我们使用装饰者模式的时候：123456789101112public class Test &#123; public static void main(String[] args) &#123; Coffee coffee = new Espresso(); coffee = new Mocha(coffee); coffee = new Mocha(coffee); coffee = new Whip(coffee); //3.6(2.5 + 0.5 + 0.5 + 0.1) System.out.println(coffee.cost()); &#125;&#125; 我们可以看出来，装饰者模式就是利用装饰者类来对具体类不断的进行多层次的处理，首先我们创建了Espresso类，然后第一次利用Mocha装饰者对Espresso咖啡加了摩卡，第二次重复加了摩卡，第三次利用装饰者Whip对Espresso咖啡加了奶油。每次加入新的调料，装饰者都会对价格cost做一些处理（+0.1、+0.5）。 无构造函数的装饰者 我们对这个装饰者进行一些改造：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public class Espresso&#123; double cost; public double cost() &#123; $this-&gt; cost = 2.5; &#125;&#125;public class Dressing&#123; public double cost(Espresso $espresso) &#123; return ($espresso); &#125;&#125;public class Whip extends Dressing&#123; public double cost(Espresso $espresso) &#123; $espresso-&gt;cost = espresso-&gt;cost() + 0.1; return ($espresso); &#125;&#125;public class Mocha extends Dressing&#123; public double cost(Espresso $espresso) &#123; $espresso-&gt;cost = espresso-&gt;cost() + 0.5; return ($espresso); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Coffee $coffee = new Espresso(); $coffee = (new Mocha())-&gt;cost($coffee); $coffee = (new Mocha())-&gt;cost($coffee); $coffee = (new Whip())-&gt;cost($coffee); //3.6(2.5 + 0.5 + 0.5 + 0.1) System.out.println(coffee.cost()); &#125;&#125; 改造后，装饰者类通过函数cost来注入具体类caffee，而不是通过构造函数，这样做有助于自动化进行装饰处理。我们改造后发现，想要对具体类通过装饰类进行处理，需要不断的调用cost函数，如果有10个装饰操作，就要手动写10个语句，因此我们继续进行改造： 闭包装饰者模式12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public class Espresso&#123; double cost; public double cost() &#123; $this-&gt; cost = 2.5; &#125;&#125;public class Dressing&#123; public double cost(Espresso $espresso, Closure $closure) &#123; return ($espresso); &#125;&#125;public class Whip extends Dressing&#123; public double cost(Espresso $espresso, Closure $closure) &#123; $espresso-&gt;cost = espresso-&gt;cost() + 0.1; return $closure($espresso); &#125;&#125;public class Mocha extends Dressing&#123; public double cost(Espresso $espresso, Closure $closure) &#123; $espresso-&gt;cost = espresso-&gt;cost() + 0.5; return $closure($espresso); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Coffee $coffee = new Espresso(); $fun = function($coffee，$fuc，$dressing) &#123; $dressing-&gt;cost($coffee, $fuc); &#125; $fuc0 = function($coffee) &#123; return $coffee; &#125;; $fuc1 = function($coffee) use ($fuc0, $dressing = (new Mocha()，$fun)) &#123; return $fun($coffee, $fuc0, $dressing); &#125; $fuc2 = function($coffee) use ($fuc1, $dressing = (new Mocha()，$fun)) &#123; return $fuc($coffee, $fun1, $dressing); &#125; $fuc3 = function($coffee) use ($fuc2, $dressing = (new Whip()，$fun)) &#123; return $fuc($coffee, $fun2, $dressing); &#125; $coffee = $fun3($coffee); //3.6(2.5 + 0.5 + 0.5 + 0.1) System.out.println(coffee.cost()); &#125;&#125; 在这次改造中，我们使用了闭包函数，这样做的目的在于，我们只需要最后一句$fun3($coffee) ,就可以启动整个装饰链条。 闭包装饰者的抽象化 然而这种改造还不够深入，因为我们还可以把$fuc1、$fuc2、$fuc3继续抽象化为一个闭包函数，这个闭包函数仅仅是参数$fuc、$dressing每次不同，$coffee相同，因此改造如下：1234567891011121314151617181920212223242526public class Test &#123; public static void main(String[] args) &#123; Coffee $coffee = new Espresso(); $fun = function($coffee) use ($fuc，$dressing) &#123; $dressing-&gt;cost($coffee, $fuc); &#125; $fuc = function($fuc，$dressing) use ($fun) &#123; return $fun; &#125;; $fuc0 = function($coffee) &#123; return $coffee; &#125;; $fuc1 = $fuc($fuc0, (new Mocha()); $fuc2 = $fuc($fuc1, (new Mocha()); $fuc3 = $fuc($fuc2, (new Whip()); $coffee = $fun3($coffee); //3.6(2.5 + 0.5 + 0.5 + 0.1) System.out.println(coffee.cost()); &#125;&#125; 这次，我们把之前的闭包分为两个部分，$fun负责具体类的参数传递，$fuc负责装饰者和闭包函数的参数传递。在最后一句$fun3，只需要传递一个具体类，就可以启动整个装饰链条。 闭包装饰者的自动化 到这里，我们还有一件事没有完成，那就是$fuc1、$fuc2、$fuc3这些闭包的构建还是手动的，我们需要将这个过程改为自动的：1234567891011121314151617181920212223242526272829public class Test &#123; public static void main(String[] args) &#123; Coffee $coffee = new Espresso(); $fun = function($coffee) use ($fuc，$dressing) &#123; $dressing-&gt;cost($coffee, $fuc); &#125; $fuc = function($fuc，$dressing) use ($fun) &#123; return $fun; &#125;; $fuc0 = function($coffee) &#123; return $coffee; &#125;; $fucn = array_reduce( [(new Mocha(),(new Mocha(),(new Whip()], $fuc, $fuc0 ); $coffee = $fucn($coffee); //3.6(2.5 + 0.5 + 0.5 + 0.1) System.out.println(coffee.cost()); &#125;&#125; Laravel的闭包装饰者——Pipeline 上一章我们说到了路由的注册启动与加载过程，这个过程由bootstrap()完成。当所有的路由加载完毕后，就要进行各种中间件的处理了：123456789101112131415161718protected function sendRequestThroughRouter($request)&#123; $this-&gt;app-&gt;instance('request', $request); Facade::clearResolvedInstance('request'); $this-&gt;bootstrap(); return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125;public function shouldSkipMiddleware()&#123; return $this-&gt;bound('middleware.disable') &amp;&amp; $this-&gt;make('middleware.disable') === true;&#125; Laravel的中间件处理由Pipeline来完成，它是一个闭包装饰者模式，其中request是具体类，相当于我们上面的caffee类；middleware中间件是装饰者类，相当于上面的dressing类；我们先看看这个类内部的代码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455class Pipeline implements PipelineContract&#123; public function __construct(Container $container = null) &#123; $this-&gt;container = $container; &#125; public function send($passable) &#123; $this-&gt;passable = $passable; return $this; &#125; public function through($pipes) &#123; $this-&gt;pipes = is_array($pipes) ? $pipes : func_get_args(); return $this; &#125; public function then(Closure $destination) &#123; $pipeline = array_reduce( array_reverse($this-&gt;pipes), $this-&gt;carry(), $this-&gt;prepareDestination($destination) ); return $pipeline($this-&gt;passable); &#125; protected function prepareDestination(Closure $destination) &#123; return function ($passable) use ($destination) &#123; return $destination($passable); &#125;; &#125; protected function carry() &#123; return function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack); &#125; elseif (! is_object($pipe)) &#123; list($name, $parameters) = $this-&gt;parsePipeString($pipe); $pipe = $this-&gt;getContainer()-&gt;make($name); $parameters = array_merge([$passable, $stack], $parameters); &#125; else &#123; $parameters = [$passable, $stack]; &#125; return $pipe-&gt;&#123;$this-&gt;method&#125;(...$parameters); &#125;; &#125;; &#125;&#125; pipeline 的构造和我们上面所讲的闭包装饰者相同，我们着重来看carry()函数的代码：123function ($stack, $pipe) &#123;...&#125; 最外层的闭包相当于上个章节的 $fuc ,123function ($passable) use ($stack, $pipe) &#123;...&#125; 里面的这一层比闭包型党与上个章节的$fun，prepareDestination这个函数相当于上面的$fuc0 ,123456789101112131415if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack);&#125; elseif (! is_object($pipe)) &#123; list($name, $parameters) = $this-&gt;parsePipeString($pipe); $pipe = $this-&gt;getContainer()-&gt;make($name); $parameters = array_merge([$passable, $stack], $parameters);&#125; else &#123; $parameters = [$passable, $stack];&#125;return $pipe-&gt;&#123;$this-&gt;method&#125;(...$parameters); 这一部分相当于上个章节的$dressing-&gt;cost($coffee, $fuc);这部分主要解析中间件handle()函数的参数：12345678910111213141516public function via($method)&#123; $this-&gt;method = $method; return $this;&#125;protected function parsePipeString($pipe)&#123; list($name, $parameters) = array_pad(explode(':', $pipe, 2),2, []); if (is_string($parameters)) &#123; $parameters = explode(',', $parameters); &#125; return [$name, $parameters];&#125; 这样，Laravel就实现了中间件对request的层层处理。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Queue]]></title>
    <url>%2F2020%2F05%2F12%2FLaravel-Queue%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 文件目录 Opis Closure简介与安装Opis Closure是一个库，旨在通过提供使所有闭包可序列化的包装器，来克服PHP在闭包序列化方面的限制。 1composer require opis/closure 序列化闭包如果你曾经使用过闭包，那么你可能知道闭包不可序列化。尝试序列化闭包将导致异常： 1Fatal error: Uncaught exception &apos;Exception&apos; with message &apos;Serialization of &apos;Closure&apos; is not allowed&apos; 克服此问题的解决方案是将闭包包装到一个Opis\Closure\SerializableClosure对象中，然后使用标准的serialize序列化包装对象。 1234567891011use Opis\Closure\SerializableClosure;// Recursive factorial closure$factorial = function ($n) use (&amp;$factorial) &#123; return $n &lt;= 1 ? 1 : $factorial($n - 1) * $n;&#125;;// Wrap the closure$wrapper = new SerializableClosure($factorial);// Now it can be serialized$serialized = serialize($wrapper); 反序列化闭包使用标准unserialize函数可以完成闭包反序列化。一旦包装器反序列化，就可以直接调用包装器，也可以通过调用getClosure方法提取序列化的闭包。 12345678910// Unserialize the closure$wrapper = unserialize($serialized);// You can directly invoke the wrapper...echo $wrapper(5); //&gt; 120// Or, the recommended way, extract the closure object$closure = $wrapper-&gt;getClosure();echo $closure(5); //&gt; 120 由于Opis Closure在序列化/反序列化过程中不使用eval的事实，因此所有的闭包都可以无限制地序列化和非序列化。 123456789// Once again, but this time using the previously unserialized closure$wrapper = new SerializableClosure($closure);$serialized = serialize($wrapper);$wrapper = unserialize($serialized);$closure = $wrapper-&gt;getClosure();// Now watch this...echo $closure(5); //&gt; 120// It worked! 序列化/反序列化任意对象Opis Closure允许您借助Opis\Closure\serialize函数来序列化任意对象。通过使用Opis\Closure\unserialize函数可以进行反序列化。 1234567891011121314151617181920212223use function Opis\Closure\&#123;serialize as s, unserialize as u&#125;class A&#123; private $closure; public function __construct() &#123; $this-&gt;closure = function()&#123; echo 'It works!'; &#125;; &#125; public function test() &#123; //call closure ($this-&gt;closure)(); &#125;&#125;$obj = new A();u(s($obj))-&gt;test(); // It works 源码Job Illuminate\Queue\Jobs.php 抽象类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347namespace Illuminate\Queue\Jobs;use Illuminate\Contracts\Events\Dispatcher;use Illuminate\Queue\Events\JobFailed;use Illuminate\Queue\ManuallyFailedException;use Illuminate\Support\InteractsWithTime;abstract class Job&#123; use InteractsWithTime; /** * The job handler instance. * * @var mixed */ protected $instance; /** * The IoC container instance. * * @var \Illuminate\Container\Container */ protected $container; /** * Indicates if the job has been deleted. * * @var bool */ protected $deleted = false; /** * Indicates if the job has been released. * * @var bool */ protected $released = false; /** * Indicates if the job has failed. * * @var bool */ protected $failed = false; /** * The name of the connection the job belongs to. * * @var string */ protected $connectionName; /** * The name of the queue the job belongs to. * * @var string */ protected $queue; /** * Get the job identifier. * * @return string */ abstract public function getJobId(); /** * Get the raw body of the job. * * @return string */ abstract public function getRawBody(); /** * Get the UUID of the job. * * @return string|null */ public function uuid() &#123; return $this-&gt;payload()['uuid'] ?? null; &#125; /** * Fire the job. * * @return void */ public function fire() &#123; $payload = $this-&gt;payload(); [$class, $method] = JobName::parse($payload['job']); ($this-&gt;instance = $this-&gt;resolve($class))-&gt;&#123;$method&#125;($this, $payload['data']); &#125; /** * Delete the job from the queue. * * @return void */ public function delete() &#123; $this-&gt;deleted = true; &#125; /** * Determine if the job has been deleted. * * @return bool */ public function isDeleted() &#123; return $this-&gt;deleted; &#125; /** * Release the job back into the queue. * * @param int $delay * @return void */ public function release($delay = 0) &#123; $this-&gt;released = true; &#125; /** * Determine if the job was released back into the queue. * * @return bool */ public function isReleased() &#123; return $this-&gt;released; &#125; /** * Determine if the job has been deleted or released. * * @return bool */ public function isDeletedOrReleased() &#123; return $this-&gt;isDeleted() || $this-&gt;isReleased(); &#125; /** * Determine if the job has been marked as a failure. * * @return bool */ public function hasFailed() &#123; return $this-&gt;failed; &#125; /** * Mark the job as "failed". * * @return void */ public function markAsFailed() &#123; $this-&gt;failed = true; &#125; /** * Delete the job, call the "failed" method, and raise the failed job event. * * @param \Throwable|null $e * @return void */ public function fail($e = null) &#123; $this-&gt;markAsFailed(); if ($this-&gt;isDeleted()) &#123; return; &#125; try &#123; // If the job has failed, we will delete it, call the "failed" method and then call // an event indicating the job has failed so it can be logged if needed. This is // to allow every developer to better keep monitor of their failed queue jobs. $this-&gt;delete(); $this-&gt;failed($e); &#125; finally &#123; $this-&gt;resolve(Dispatcher::class)-&gt;dispatch(new JobFailed( $this-&gt;connectionName, $this, $e ?: new ManuallyFailedException )); &#125; &#125; /** * Process an exception that caused the job to fail. * * @param \Throwable|null $e * @return void */ protected function failed($e) &#123; $payload = $this-&gt;payload(); [$class, $method] = JobName::parse($payload['job']); if (method_exists($this-&gt;instance = $this-&gt;resolve($class), 'failed')) &#123; $this-&gt;instance-&gt;failed($payload['data'], $e); &#125; &#125; /** * Resolve the given class. * * @param string $class * @return mixed */ protected function resolve($class) &#123; return $this-&gt;container-&gt;make($class); &#125; /** * Get the resolved job handler instance. * * @return mixed */ public function getResolvedJob() &#123; return $this-&gt;instance; &#125; /** * Get the decoded body of the job. * * @return array */ public function payload() &#123; return json_decode($this-&gt;getRawBody(), true); &#125; /** * Get the number of times to attempt a job. * * @return int|null */ public function maxTries() &#123; return $this-&gt;payload()['maxTries'] ?? null; &#125; /** * Get the number of times to attempt a job after an exception. * * @return int|null */ public function maxExceptions() &#123; return $this-&gt;payload()['maxExceptions'] ?? null; &#125; /** * Get the number of seconds to delay a failed job before retrying it. * * @return int|null */ public function delaySeconds() &#123; return $this-&gt;payload()['delay'] ?? null; &#125; /** * Get the number of seconds the job can run. * * @return int|null */ public function timeout() &#123; return $this-&gt;payload()['timeout'] ?? null; &#125; /** * Get the timestamp indicating when the job should timeout. * * @return int|null */ public function timeoutAt() &#123; return $this-&gt;payload()['timeoutAt'] ?? null; &#125; /** * Get the name of the queued job class. * * @return string */ public function getName() &#123; return $this-&gt;payload()['job']; &#125; /** * Get the resolved name of the queued job class. * * Resolves the name of "wrapped" jobs such as class-based handlers. * * @return string */ public function resolveName() &#123; return JobName::resolve($this-&gt;getName(), $this-&gt;payload()); &#125; /** * Get the name of the connection the job belongs to. * * @return string */ public function getConnectionName() &#123; return $this-&gt;connectionName; &#125; /** * Get the name of the queue the job belongs to. * * @return string */ public function getQueue() &#123; return $this-&gt;queue; &#125; /** * Get the service container instance. * * @return \Illuminate\Container\Container */ public function getContainer() &#123; return $this-&gt;container; &#125;&#125; Illuminate\Queue\Jobs\RedisJob.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139&lt;?phpnamespace Illuminate\Queue\Jobs;use Illuminate\Container\Container;use Illuminate\Contracts\Queue\Job as JobContract;use Illuminate\Queue\RedisQueue;class RedisJob extends Job implements JobContract&#123; /** * The Redis queue instance. * * @var \Illuminate\Queue\RedisQueue */ protected $redis; /** * The Redis raw job payload. * * @var string */ protected $job; /** * The JSON decoded version of "$job". * * @var array */ protected $decoded; /** * The Redis job payload inside the reserved queue. * * @var string */ protected $reserved; /** * Create a new job instance. * * @param \Illuminate\Container\Container $container * @param \Illuminate\Queue\RedisQueue $redis * @param string $job * @param string $reserved * @param string $connectionName * @param string $queue * @return void */ public function __construct(Container $container, RedisQueue $redis, $job, $reserved, $connectionName, $queue) &#123; // The $job variable is the original job JSON as it existed in the ready queue while // the $reserved variable is the raw JSON in the reserved queue. The exact format // of the reserved job is required in order for us to properly delete its data. $this-&gt;job = $job; $this-&gt;redis = $redis; $this-&gt;queue = $queue; $this-&gt;reserved = $reserved; $this-&gt;container = $container; $this-&gt;connectionName = $connectionName; $this-&gt;decoded = $this-&gt;payload(); &#125; /** * Get the raw body string for the job. * * @return string */ public function getRawBody() &#123; return $this-&gt;job; &#125; /** * Delete the job from the queue. * * @return void */ public function delete() &#123; parent::delete(); $this-&gt;redis-&gt;deleteReserved($this-&gt;queue, $this); &#125; /** * Release the job back into the queue. * * @param int $delay * @return void */ public function release($delay = 0) &#123; parent::release($delay); $this-&gt;redis-&gt;deleteAndRelease($this-&gt;queue, $this, $delay); &#125; /** * Get the number of times the job has been attempted. * * @return int */ public function attempts() &#123; return ($this-&gt;decoded['attempts'] ?? null) + 1; &#125; /** * Get the job identifier. * * @return string|null */ public function getJobId() &#123; return $this-&gt;decoded['id'] ?? null; &#125; /** * Get the underlying Redis factory implementation. * * @return \Illuminate\Queue\RedisQueue */ public function getRedisQueue() &#123; return $this-&gt;redis; &#125; /** * Get the underlying reserved Redis job. * * @return string */ public function getReservedJob() &#123; return $this-&gt;reserved; &#125;&#125; Queue Illuminate\Contracts\Queue\Queue.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899&lt;?phpnamespace Illuminate\Contracts\Queue;interface Queue&#123; /** * Get the size of the queue. * * @param string|null $queue * @return int */ public function size($queue = null); /** * Push a new job onto the queue. * * @param string|object $job * @param mixed $data * @param string|null $queue * @return mixed */ public function push($job, $data = '', $queue = null); /** * Push a new job onto the queue. * * @param string $queue * @param string|object $job * @param mixed $data * @return mixed */ public function pushOn($queue, $job, $data = ''); /** * Push a raw payload onto the queue. * * @param string $payload * @param string|null $queue * @param array $options * @return mixed */ public function pushRaw($payload, $queue = null, array $options = []); /** * Push a new job onto the queue after a delay. * * @param \DateTimeInterface|\DateInterval|int $delay * @param string|object $job * @param mixed $data * @param string|null $queue * @return mixed */ public function later($delay, $job, $data = '', $queue = null); /** * Push a new job onto the queue after a delay. * * @param string $queue * @param \DateTimeInterface|\DateInterval|int $delay * @param string|object $job * @param mixed $data * @return mixed */ public function laterOn($queue, $delay, $job, $data = ''); /** * Push an array of jobs onto the queue. * * @param array $jobs * @param mixed $data * @param string|null $queue * @return mixed */ public function bulk($jobs, $data = '', $queue = null); /** * Pop the next job off of the queue. * * @param string|null $queue * @return \Illuminate\Contracts\Queue\Job|null */ public function pop($queue = null); /** * Get the connection name for the queue. * * @return string */ public function getConnectionName(); /** * Set the connection name for the queue. * * @param string $name * @return $this */ public function setConnectionName($name);&#125; Illuminate\Queue\SerializableClosure.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Illuminate\Queue;use Opis\Closure\SerializableClosure as OpisSerializableClosure;class SerializableClosure extends OpisSerializableClosure&#123; use SerializesAndRestoresModelIdentifiers; /** * Transform the use variables before serialization. * * @param array $data The Closure's use variables * @return array */ protected function transformUseVariables($data) &#123; foreach ($data as $key =&gt; $value) &#123; $data[$key] = $this-&gt;getSerializedPropertyValue($value); &#125; return $data; &#125; /** * Resolve the use variables after unserialization. * * @param array $data The Closure's transformed use variables * @return array */ protected function resolveUseVariables($data) &#123; foreach ($data as $key =&gt; $value) &#123; $data[$key] = $this-&gt;getRestoredPropertyValue($value); &#125; return $data; &#125;&#125; Illuminate\Queue\Queue.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290&lt;?phpnamespace Illuminate\Queue;use Closure;use DateTimeInterface;use Illuminate\Container\Container;use Illuminate\Support\InteractsWithTime;use Illuminate\Support\Str;abstract class Queue&#123; use InteractsWithTime; /** * The IoC container instance. * * @var \Illuminate\Container\Container */ protected $container; /** * The connection name for the queue. * * @var string */ protected $connectionName; /** * The create payload callbacks. * * @var callable[] */ protected static $createPayloadCallbacks = []; /** * Push a new job onto the queue. * * @param string $queue * @param string $job * @param mixed $data * @return mixed */ public function pushOn($queue, $job, $data = '') &#123; return $this-&gt;push($job, $data, $queue); &#125; /** * Push a new job onto the queue after a delay. * * @param string $queue * @param \DateTimeInterface|\DateInterval|int $delay * @param string $job * @param mixed $data * @return mixed */ public function laterOn($queue, $delay, $job, $data = '') &#123; return $this-&gt;later($delay, $job, $data, $queue); &#125; /** * Push an array of jobs onto the queue. * * @param array $jobs * @param mixed $data * @param string|null $queue * @return void */ public function bulk($jobs, $data = '', $queue = null) &#123; foreach ((array) $jobs as $job) &#123; $this-&gt;push($job, $data, $queue); &#125; &#125; /** * Create a payload string from the given job and data. * * @param \Closure|string|object $job * @param string $queue * @param mixed $data * @return string * * @throws \Illuminate\Queue\InvalidPayloadException */ protected function createPayload($job, $queue, $data = '') &#123; if ($job instanceof Closure) &#123; $job = CallQueuedClosure::create($job); &#125; $payload = json_encode($this-&gt;createPayloadArray($job, $queue, $data)); if (JSON_ERROR_NONE !== json_last_error()) &#123; throw new InvalidPayloadException( 'Unable to JSON encode payload. Error code: '.json_last_error() ); &#125; return $payload; &#125; /** * Create a payload array from the given job and data. * * @param string|object $job * @param string $queue * @param mixed $data * @return array */ protected function createPayloadArray($job, $queue, $data = '') &#123; return is_object($job) ? $this-&gt;createObjectPayload($job, $queue) : $this-&gt;createStringPayload($job, $queue, $data); &#125; /** * Create a payload for an object-based queue handler. * * @param object $job * @param string $queue * @return array */ protected function createObjectPayload($job, $queue) &#123; $payload = $this-&gt;withCreatePayloadHooks($queue, [ 'uuid' =&gt; (string) Str::uuid(), 'displayName' =&gt; $this-&gt;getDisplayName($job), 'job' =&gt; 'Illuminate\Queue\CallQueuedHandler@call', 'maxTries' =&gt; $job-&gt;tries ?? null, 'maxExceptions' =&gt; $job-&gt;maxExceptions ?? null, 'delay' =&gt; $this-&gt;getJobRetryDelay($job), 'timeout' =&gt; $job-&gt;timeout ?? null, 'timeoutAt' =&gt; $this-&gt;getJobExpiration($job), 'data' =&gt; [ 'commandName' =&gt; $job, 'command' =&gt; $job, ], ]); return array_merge($payload, [ 'data' =&gt; [ 'commandName' =&gt; get_class($job), 'command' =&gt; serialize(clone $job), ], ]); &#125; /** * Get the display name for the given job. * * @param object $job * @return string */ protected function getDisplayName($job) &#123; return method_exists($job, 'displayName') ? $job-&gt;displayName() : get_class($job); &#125; /** * Get the retry delay for an object-based queue handler. * * @param mixed $job * @return mixed */ public function getJobRetryDelay($job) &#123; if (! method_exists($job, 'retryAfter') &amp;&amp; ! isset($job-&gt;retryAfter)) &#123; return; &#125; $delay = $job-&gt;retryAfter ?? $job-&gt;retryAfter(); return $delay instanceof DateTimeInterface ? $this-&gt;secondsUntil($delay) : $delay; &#125; /** * Get the expiration timestamp for an object-based queue handler. * * @param mixed $job * @return mixed */ public function getJobExpiration($job) &#123; if (! method_exists($job, 'retryUntil') &amp;&amp; ! isset($job-&gt;timeoutAt)) &#123; return; &#125; $expiration = $job-&gt;timeoutAt ?? $job-&gt;retryUntil(); return $expiration instanceof DateTimeInterface ? $expiration-&gt;getTimestamp() : $expiration; &#125; /** * Create a typical, string based queue payload array. * * @param string $job * @param string $queue * @param mixed $data * @return array */ protected function createStringPayload($job, $queue, $data) &#123; return $this-&gt;withCreatePayloadHooks($queue, [ 'uuid' =&gt; (string) Str::uuid(), 'displayName' =&gt; is_string($job) ? explode('@', $job)[0] : null, 'job' =&gt; $job, 'maxTries' =&gt; null, 'maxExceptions' =&gt; null, 'delay' =&gt; null, 'timeout' =&gt; null, 'data' =&gt; $data, ]); &#125; /** * Register a callback to be executed when creating job payloads. * * @param callable $callback * @return void */ public static function createPayloadUsing($callback) &#123; if (is_null($callback)) &#123; static::$createPayloadCallbacks = []; &#125; else &#123; static::$createPayloadCallbacks[] = $callback; &#125; &#125; /** * Create the given payload using any registered payload hooks. * * @param string $queue * @param array $payload * @return array */ protected function withCreatePayloadHooks($queue, array $payload) &#123; if (! empty(static::$createPayloadCallbacks)) &#123; foreach (static::$createPayloadCallbacks as $callback) &#123; $payload = array_merge($payload, call_user_func( $callback, $this-&gt;getConnectionName(), $queue, $payload )); &#125; &#125; return $payload; &#125; /** * Get the connection name for the queue. * * @return string */ public function getConnectionName() &#123; return $this-&gt;connectionName; &#125; /** * Set the connection name for the queue. * * @param string $name * @return $this */ public function setConnectionName($name) &#123; $this-&gt;connectionName = $name; return $this; &#125; /** * Set the IoC container instance. * * @param \Illuminate\Container\Container $container * @return void */ public function setContainer(Container $container) &#123; $this-&gt;container = $container; &#125;&#125; Illuminate\Queue\RedisQueue.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310&lt;?phpnamespace Illuminate\Queue;use Illuminate\Contracts\Queue\Queue as QueueContract;use Illuminate\Contracts\Redis\Factory as Redis;use Illuminate\Queue\Jobs\RedisJob;use Illuminate\Support\Str;class RedisQueue extends Queue implements QueueContract&#123; /** * The Redis factory implementation. * * @var \Illuminate\Contracts\Redis\Factory */ protected $redis; /** * The connection name. * * @var string */ protected $connection; /** * The name of the default queue. * * @var string */ protected $default; /** * The expiration time of a job. * * @var int|null */ protected $retryAfter = 60; /** * The maximum number of seconds to block for a job. * * @var int|null */ protected $blockFor = null; /** * Create a new Redis queue instance. * * @param \Illuminate\Contracts\Redis\Factory $redis * @param string $default * @param string|null $connection * @param int $retryAfter * @param int|null $blockFor * @return void */ public function __construct(Redis $redis, $default = 'default', $connection = null, $retryAfter = 60, $blockFor = null) &#123; $this-&gt;redis = $redis; $this-&gt;default = $default; $this-&gt;blockFor = $blockFor; $this-&gt;connection = $connection; $this-&gt;retryAfter = $retryAfter; &#125; /** * Get the size of the queue. * * @param string|null $queue * @return int */ public function size($queue = null) &#123; $queue = $this-&gt;getQueue($queue); return $this-&gt;getConnection()-&gt;eval( LuaScripts::size(), 3, $queue, $queue.':delayed', $queue.':reserved' ); &#125; /** * Push a new job onto the queue. * * @param object|string $job * @param mixed $data * @param string|null $queue * @return mixed */ public function push($job, $data = '', $queue = null) &#123; return $this-&gt;pushRaw($this-&gt;createPayload($job, $this-&gt;getQueue($queue), $data), $queue); &#125; /** * Push a raw payload onto the queue. * * @param string $payload * @param string|null $queue * @param array $options * @return mixed */ public function pushRaw($payload, $queue = null, array $options = []) &#123; $this-&gt;getConnection()-&gt;eval( LuaScripts::push(), 2, $this-&gt;getQueue($queue), $this-&gt;getQueue($queue).':notify', $payload ); return json_decode($payload, true)['id'] ?? null; &#125; /** * Push a new job onto the queue after a delay. * * @param \DateTimeInterface|\DateInterval|int $delay * @param object|string $job * @param mixed $data * @param string|null $queue * @return mixed */ public function later($delay, $job, $data = '', $queue = null) &#123; return $this-&gt;laterRaw($delay, $this-&gt;createPayload($job, $this-&gt;getQueue($queue), $data), $queue); &#125; /** * Push a raw job onto the queue after a delay. * * @param \DateTimeInterface|\DateInterval|int $delay * @param string $payload * @param string|null $queue * @return mixed */ protected function laterRaw($delay, $payload, $queue = null) &#123; $this-&gt;getConnection()-&gt;zadd( $this-&gt;getQueue($queue).':delayed', $this-&gt;availableAt($delay), $payload ); return json_decode($payload, true)['id'] ?? null; &#125; /** * Create a payload string from the given job and data. * * @param string $job * @param string $queue * @param mixed $data * @return array */ protected function createPayloadArray($job, $queue, $data = '') &#123; return array_merge(parent::createPayloadArray($job, $queue, $data), [ 'id' =&gt; $this-&gt;getRandomId(), 'attempts' =&gt; 0, ]); &#125; /** * Pop the next job off of the queue. * * @param string|null $queue * @return \Illuminate\Contracts\Queue\Job|null */ public function pop($queue = null) &#123; $this-&gt;migrate($prefixed = $this-&gt;getQueue($queue)); if (empty($nextJob = $this-&gt;retrieveNextJob($prefixed))) &#123; return; &#125; [$job, $reserved] = $nextJob; if ($reserved) &#123; return new RedisJob( $this-&gt;container, $this, $job, $reserved, $this-&gt;connectionName, $queue ?: $this-&gt;default ); &#125; &#125; /** * Migrate any delayed or expired jobs onto the primary queue. * * @param string $queue * @return void */ protected function migrate($queue) &#123; $this-&gt;migrateExpiredJobs($queue.':delayed', $queue); if (! is_null($this-&gt;retryAfter)) &#123; $this-&gt;migrateExpiredJobs($queue.':reserved', $queue); &#125; &#125; /** * Migrate the delayed jobs that are ready to the regular queue. * * @param string $from * @param string $to * @return array */ public function migrateExpiredJobs($from, $to) &#123; return $this-&gt;getConnection()-&gt;eval( LuaScripts::migrateExpiredJobs(), 3, $from, $to, $to.':notify', $this-&gt;currentTime() ); &#125; /** * Retrieve the next job from the queue. * * @param string $queue * @param bool $block * @return array */ protected function retrieveNextJob($queue, $block = true) &#123; $nextJob = $this-&gt;getConnection()-&gt;eval( LuaScripts::pop(), 3, $queue, $queue.':reserved', $queue.':notify', $this-&gt;availableAt($this-&gt;retryAfter) ); if (empty($nextJob)) &#123; return [null, null]; &#125; [$job, $reserved] = $nextJob; if (! $job &amp;&amp; ! is_null($this-&gt;blockFor) &amp;&amp; $block &amp;&amp; $this-&gt;getConnection()-&gt;blpop([$queue.':notify'], $this-&gt;blockFor)) &#123; return $this-&gt;retrieveNextJob($queue, false); &#125; return [$job, $reserved]; &#125; /** * Delete a reserved job from the queue. * * @param string $queue * @param \Illuminate\Queue\Jobs\RedisJob $job * @return void */ public function deleteReserved($queue, $job) &#123; $this-&gt;getConnection()-&gt;zrem($this-&gt;getQueue($queue).':reserved', $job-&gt;getReservedJob()); &#125; /** * Delete a reserved job from the reserved queue and release it. * * @param string $queue * @param \Illuminate\Queue\Jobs\RedisJob $job * @param int $delay * @return void */ public function deleteAndRelease($queue, $job, $delay) &#123; $queue = $this-&gt;getQueue($queue); $this-&gt;getConnection()-&gt;eval( LuaScripts::release(), 2, $queue.':delayed', $queue.':reserved', $job-&gt;getReservedJob(), $this-&gt;availableAt($delay) ); &#125; /** * Get a random ID string. * * @return string */ protected function getRandomId() &#123; return Str::random(32); &#125; /** * Get the queue or return the default. * * @param string|null $queue * @return string */ public function getQueue($queue) &#123; return 'queues:'.($queue ?: $this-&gt;default); &#125; /** * Get the connection for the queue. * * @return \Illuminate\Redis\Connections\Connection */ public function getConnection() &#123; return $this-&gt;redis-&gt;connection($this-&gt;connection); &#125; /** * Get the underlying Redis instance. * * @return \Illuminate\Contracts\Redis\Factory */ public function getRedis() &#123; return $this-&gt;redis; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Queue-消息队列任务处理器源码剖析]]></title>
    <url>%2F2020%2F05%2F12%2FLaravel-Queue-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%BB%E5%8A%A1%E5%A4%84%E7%90%86%E5%99%A8%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 运行队列处理器队列处理器的设置Laravel包含一个队列处理器，当新任务被推到队列中时它能处理这些任务。你可以通过queue:work命令来运行处理器。要注意，一旦queue:work命令开始，它将一直运行，直到你手动停止或者你关闭控制台：1php artisan queue:work 可以指定队列处理器所使用的连接。 1php artisan queue:work redis 可以自定义队列处理器，方式是处理给定连接的特定队列。 1php artisan queue:work redis --queue=emails 可以使用--once选项来指定仅对队列中的单一任务进行处理： 1php artisan queue:work --once 如果一个任务失败了，会被放入延时队列中去，--delay选项可以设置失败任务的延时时间： 1php artisan queue:work --delay=2 如果想要限制一个任务的内存，可以使用--memory : 1php artisan queue:work --memory=128 当队列需要处理任务时，进程将继续处理任务，它们之间没有延迟。但是，如果没有新的工作可用，--sleep参数决定了工作进程将「睡眠」多长时间： 1php artisan queue:work --sleep=3 可以指定Laravel队列处理器最多执行多长时间后就应该被关闭掉： 1php artisan queue:work --timeout=60 可以指定Laravel队列处理器失败任务重试的次数： 1php artisan queue:work --tries=60 可以看出来，队列处理器的设置大多数都可以由任务类进行设置，但是其中三个sleep、delay、memory只能由artisan来设置。 WorkCommand命令行启动任务处理器进程的命令行模式会调用Illuminate\Queue\Console\WorkCommand，这个类在初始化的时候依赖注入了Illuminate\Queue\Worker：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364class WorkCommand extends Command&#123; /** * The console command name. * * @var string */ protected $signature = 'queue:work &#123;connection? : The name of the queue connection to work&#125; &#123;--queue= : The names of the queues to work&#125; &#123;--daemon : Run the worker in daemon mode (Deprecated)&#125; &#123;--once : Only process the next job on the queue&#125; &#123;--stop-when-empty : Stop when the queue is empty&#125; &#123;--delay=0 : The number of seconds to delay failed jobs&#125; &#123;--force : Force the worker to run even in maintenance mode&#125; &#123;--memory=128 : The memory limit in megabytes&#125; &#123;--sleep=3 : Number of seconds to sleep when no job is available&#125; &#123;--timeout=60 : The number of seconds a child process can run&#125; &#123;--tries=1 : Number of times to attempt a job before logging it failed&#125;'; /** * Create a new queue work command. * * @param \Illuminate\Queue\Worker $worker * @param \Illuminate\Contracts\Cache\Repository $cache * @return void */ public function __construct(Worker $worker, Cache $cache) &#123; parent::__construct(); $this-&gt;cache = $cache; $this-&gt;worker = $worker; &#125; /** * Execute the console command. * * @return void */ public function handle() &#123; if ($this-&gt;downForMaintenance() &amp;&amp; $this-&gt;option('once')) &#123; return $this-&gt;worker-&gt;sleep($this-&gt;option('sleep')); &#125; // 我们将侦听已处理的事件和失败的事件，以便在处理作业时将信息写入控制台， // 这将使开发人员可以观察到队列中正在处理哪些作业，并了解其进度。 $this-&gt;listenForEvents(); $connection = $this-&gt;argument('connection') ?: $this-&gt;laravel['config']['queue.default']; // 我们需要为应用程序的队列配置文件中设置的连接获取正确的队列。 // 我们将基于为当前正在执行的队列操作运行的设置连接来拉它。 $queue = $this-&gt;getQueue($connection); $this-&gt;runWorker( $connection, $queue ); &#125;&#125; 任务处理器启动后，会运行handle函数，在执行任务之前，程序首先会注册监听事件，主要监听任务完成与任务失败的情况： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273/** * Listen for the queue events in order to update the console output. * * @return void */protected function listenForEvents()&#123; $this-&gt;laravel['events']-&gt;listen(JobProcessing::class, function ($event) &#123; $this-&gt;writeOutput($event-&gt;job, 'starting'); &#125;); $this-&gt;laravel['events']-&gt;listen(JobProcessed::class, function ($event) &#123; $this-&gt;writeOutput($event-&gt;job, 'success'); &#125;); $this-&gt;laravel['events']-&gt;listen(JobFailed::class, function ($event) &#123; $this-&gt;writeOutput($event-&gt;job, 'failed'); $this-&gt;logFailedJob($event); &#125;);&#125;/** * Write the status output for the queue worker. * * @param \Illuminate\Contracts\Queue\Job $job * @param string $status * @return void */protected function writeOutput(Job $job, $status)&#123; switch ($status) &#123; case 'starting': return $this-&gt;writeStatus($job, 'Processing', 'comment'); case 'success': return $this-&gt;writeStatus($job, 'Processed', 'info'); case 'failed': return $this-&gt;writeStatus($job, 'Failed', 'error'); &#125;&#125;/** * Format the status output for the queue worker. * * @param \Illuminate\Contracts\Queue\Job $job * @param string $status * @param string $type * @return void */protected function writeStatus(Job $job, $status, $type)&#123; $this-&gt;output-&gt;writeln(sprintf( "&lt;&#123;$type&#125;&gt;[%s][%s] %s&lt;/&#123;$type&#125;&gt; %s", Carbon::now()-&gt;format('Y-m-d H:i:s'), $job-&gt;getJobId(), str_pad("&#123;$status&#125;:", 11), $job-&gt;resolveName() ));&#125;/** * Store a failed job event. * * @param \Illuminate\Queue\Events\JobFailed $event * @return void */protected function logFailedJob(JobFailed $event)&#123; $this-&gt;laravel['queue.failer']-&gt;log( $event-&gt;connectionName, $event-&gt;job-&gt;getQueue(), $event-&gt;job-&gt;getRawBody(), $event-&gt;exception );&#125; 启动任务管理器runWorker，该函数默认会调用Illuminate\Queue\Worker的daemon函数，只有在命令中强制--once参数的时候，才会执行runNestJob函数：123456789101112131415/** * Run the worker instance. * * @param string $connection * @param string $queue * @return array */protected function runWorker($connection, $queue)&#123; $this-&gt;worker-&gt;setCache($this-&gt;cache); return $this-&gt;worker-&gt;&#123;$this-&gt;option('once') ? 'runNextJob' : 'daemon'&#125;( $connection, $queue, $this-&gt;gatherWorkerOptions() );&#125; Worker任务调度我们接下来接着看daemon函数： Illuminate\Queue\Worker.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263/** * Listen to the given queue in a loop. * * @param string $connectionName * @param string $queue * @param \Illuminate\Queue\WorkerOptions $options * @return void */public function daemon($connectionName, $queue, WorkerOptions $options)&#123; if ($this-&gt;supportsAsyncSignals()) &#123; $this-&gt;listenForSignals(); &#125; $lastRestart = $this-&gt;getTimestampOfLastQueueRestart(); while (true) &#123; // Before reserving any jobs, we will make sure this queue is not paused and // if it is we will just pause this worker for a given amount of time and // make sure we do not need to kill this worker process off completely. if (! $this-&gt;daemonShouldRun($options, $connectionName, $queue)) &#123; $this-&gt;pauseWorker($options, $lastRestart); continue; &#125; // First, we will attempt to get the next job off of the queue. We will also // register the timeout handler and reset the alarm for this job so it is // not stuck in a frozen state forever. Then, we can fire off this job. $job = $this-&gt;getNextJob( $this-&gt;manager-&gt;connection($connectionName), $queue ); if ($this-&gt;supportsAsyncSignals()) &#123; $this-&gt;registerTimeoutHandler($job, $options); &#125; // If the daemon should run (not in maintenance mode, etc.), then we can run // fire off this job for processing. Otherwise, we will need to sleep the // worker so no more jobs are processed until they should be processed. if ($job) &#123; $this-&gt;runJob($job, $connectionName, $options); &#125; else &#123; $this-&gt;sleep($options-&gt;sleep); &#125; if ($this-&gt;supportsAsyncSignals()) &#123; $this-&gt;resetTimeoutHandler(); &#125; // Finally, we will check to see if we have exceeded our memory limits or if // the queue should restart based on other indications. If so, we'll stop // this worker and let whatever is "monitoring" it restart the process. $this-&gt;stopIfNecessary($options, $lastRestart, $job); &#125;&#125; 信号处理listenForSignals函数用于PHP 7.1版本以上，用于脚本的信号处理。所谓的信号处理，就是由Process Monitor（如Supervisor）发送并与我们的脚本进行通信的异步通知。 123456789101112131415161718192021222324protected function listenForSignals()&#123; if ($this-&gt;supportsAsyncSignals()) &#123; pcntl_async_signals(true); pcntl_signal(SIGTERM, function () &#123; $this-&gt;shouldQuit = true; &#125;); pcntl_signal(SIGUSR2, function () &#123; $this-&gt;paused = true; &#125;); pcntl_signal(SIGCONT, function () &#123; $this-&gt;paused = false; &#125;); &#125;&#125;protected function supportsAsyncSignals()&#123; return version_compare(PHP_VERSION, '7.1.0') &gt;= 0 &amp;&amp; extension_loaded('pcntl');&#125; pcntl_async_signals()被调用来启用信号处理，然后我们为多个信号注册处理程序： 当脚本被Supervisor指示关闭时，会引发信号SIGTERM。 SIGUSR2是用户定义的信号，Laravel用来表示脚本应该暂停。 当暂停的脚本被Supervisor指示继续进行时，会引发SIGCONT。 在真正运行任务之前，程序还从cache中取了一次最后一次重启的时间：1234567protected function getTimestampOfLastQueueRestart()&#123; if ($this-&gt;cache) &#123; return $this-&gt;cache-&gt;get('illuminate:queue:restart'); &#125;&#125; 确定worker是否应该处理作业进入循环后，首先要判断当前脚本是应该处理任务，还是应该暂停，还是应该退出： 12345678protected function daemonShouldRun(WorkerOptions $options)&#123; return ! ( ($this-&gt;manager-&gt;isDownForMaintenance() &amp;&amp; ! $options-&gt;force) || $this-&gt;paused || $this-&gt;events-&gt;until(new Events\Looping) === false );&#125; 以下几种情况，循环将不会处理任务： 脚本处于维护模式并且没有--force选项。 脚本被supervisor暂停。 脚本的looping事件监听器返回false。 looping事件监听器在每次循环的时候都会被启动，如果返回false，那么当前的循环将会被暂停：pauseWorker：12345protected function pauseWorker(WorkerOptions $options, $lastRestart)&#123; $this-&gt;sleep($options-&gt;sleep &gt; 0 ? $options-&gt;sleep : 1); $this-&gt;stopIfNecessary($options, $lastRestart);&#125; 脚本在sleep一段时间之后，就要重新判断当前脚本是否需要stop：1234567891011121314151617181920212223242526272829protected function stopIfNecessary(WorkerOptions $options, $lastRestart)&#123; if ($this-&gt;shouldQuit) &#123; $this-&gt;kill(); &#125; if ($this-&gt;memoryExceeded($options-&gt;memory)) &#123; $this-&gt;stop(12); &#125; elseif ($this-&gt;queueShouldRestart($lastRestart)) &#123; $this-&gt;stop(); &#125;&#125;protected function queueShouldRestart($lastRestart)&#123; return $this-&gt;getTimestampOfLastQueueRestart() != $lastRestart;&#125;protected function getTimestampOfLastQueueRestart()&#123; if ($this-&gt;cache) &#123; return $this-&gt;cache-&gt;get('illuminate:queue:restart'); &#125;&#125; 以下情况脚本将会被stop： 脚本被supervisor退出。 内存超限。 脚本被重启过。 1234567891011121314public function kill($status = 0)&#123; if (extension_loaded('posix')) &#123; posix_kill(getmypid(), SIGKILL); &#125; exit($status);&#125;public function stop($status = 0)&#123; $this-&gt;events-&gt;fire(new Events\WorkerStopping); exit($status);&#125; 脚本被重启，当前的进程需要退出并且重新加载。 获取下一个任务当含有多个队列的时候，命令行可以用“,”连接多个队列的名字，位于前面的队列优先级更高：1234567891011121314151617181920protected function getNextJob($connection, $queue)&#123; try &#123; foreach (explode(',', $queue) as $queue) &#123; if (! is_null($job = $connection-&gt;pop($queue))) &#123; return $job; &#125; &#125; &#125; catch (Exception $e) &#123; $this-&gt;exceptions-&gt;report($e); &#125; catch (Throwable $e) &#123; $this-&gt;exceptions-&gt;report(new FatalThrowableError($e)); &#125;&#125; $connection是具体的驱动，我们这里是Illuminate\Queue\RedisQueue：12345678910111213141516171819202122232425262728293031323334353637class RedisQueue extends Queue implements QueueContract&#123; /** * Pop the next job off of the queue. * * @param string|null $queue * @return \Illuminate\Contracts\Queue\Job|null */ public function pop($queue = null) &#123; $this-&gt;migrate($prefixed = $this-&gt;getQueue($queue)); if (empty($nextJob = $this-&gt;retrieveNextJob($prefixed))) &#123; return; &#125; [$job, $reserved] = $nextJob; if ($reserved) &#123; return new RedisJob( $this-&gt;container, $this, $job, $reserved, $this-&gt;connectionName, $queue ?: $this-&gt;default ); &#125; &#125; /** * Get the queue or return the default. * * @param string|null $queue * @return string */ public function getQueue($queue) &#123; return 'queues:'.($queue ?: $this-&gt;default); &#125;&#125; 在从队列中取出任务之前，需要先将delay队列和reserved队列中已经到时间的任务放到主队列中：1234567891011121314151617181920212223242526272829/** * Migrate any delayed or expired jobs onto the primary queue. * * @param string $queue * @return void */protected function migrate($queue)&#123; $this-&gt;migrateExpiredJobs($queue.':delayed', $queue); if (! is_null($this-&gt;retryAfter)) &#123; $this-&gt;migrateExpiredJobs($queue.':reserved', $queue); &#125;&#125;/** * Migrate the delayed jobs that are ready to the regular queue. * * @param string $from * @param string $to * @return array */public function migrateExpiredJobs($from, $to)&#123; return $this-&gt;getConnection()-&gt;eval( LuaScripts::migrateExpiredJobs(), 3, $from, $to, $to.':notify', $this-&gt;currentTime() );&#125; 由于从队列取出任务、在队列删除任务、压入主队列是三个操作，为了防止并发，程序这里使用了LUA脚本，保证三个操作的原子性：12345678910111213141516171819202122232425262728293031323334/** * Get the Lua script to migrate expired jobs back onto the queue. * * KEYS[1] - The queue we are removing jobs from, for example: queues:foo:reserved * KEYS[2] - The queue we are moving jobs to, for example: queues:foo * KEYS[3] - The notification list for the queue we are moving jobs to, for example queues:foo:notify * ARGV[1] - The current UNIX timestamp * * @return string */public static function migrateExpiredJobs()&#123; return &lt;&lt;&lt;'LUA'-- Get all of the jobs with an expired "score"...local val = redis.call('zrangebyscore', KEYS[1], '-inf', ARGV[1])-- If we have values in the array, we will remove them from the first queue-- and add them onto the destination queue in chunks of 100, which moves-- all of the appropriate jobs onto the destination queue very safely.if(next(val) ~= nil) then redis.call('zremrangebyrank', KEYS[1], 0, #val - 1) for i = 1, #val, 100 do redis.call('rpush', KEYS[2], unpack(val, i, math.min(i+99, #val))) -- Push a notification for every job that was migrated... for j = i, math.min(i+99, #val) do redis.call('rpush', KEYS[3], 1) end endendreturn valLUA;&#125; 接下来，就要从主队列中获取下一个任务，在取出下一个任务之后，还要将任务放入reserved队列中，当任务执行失败后，该任务会进行重试。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * Retrieve the next job from the queue. * * @param string $queue * @param bool $block * @return array */protected function retrieveNextJob($queue, $block = true)&#123; $nextJob = $this-&gt;getConnection()-&gt;eval( LuaScripts::pop(), 3, $queue, $queue.':reserved', $queue.':notify', $this-&gt;availableAt($this-&gt;retryAfter) ); if (empty($nextJob)) &#123; return [null, null]; &#125; [$job, $reserved] = $nextJob; if (! $job &amp;&amp; ! is_null($this-&gt;blockFor) &amp;&amp; $block &amp;&amp; $this-&gt;getConnection()-&gt;blpop([$queue.':notify'], $this-&gt;blockFor)) &#123; return $this-&gt;retrieveNextJob($queue, false); &#125; return [$job, $reserved];&#125;/** * Get the Lua script for popping the next job off of the queue. * * KEYS[1] - The queue to pop jobs from, for example: queues:foo * KEYS[2] - The queue to place reserved jobs on, for example: queues:foo:reserved * KEYS[3] - The notify queue * ARGV[1] - The time at which the reserved job will expire * * @return string */public static function pop()&#123; return &lt;&lt;&lt;'LUA'-- Pop the first job off of the queue...local job = redis.call('lpop', KEYS[1])local reserved = falseif(job ~= false) then -- Increment the attempt count and place job on the reserved queue... reserved = cjson.decode(job) reserved['attempts'] = reserved['attempts'] + 1 reserved = cjson.encode(reserved) redis.call('zadd', KEYS[2], ARGV[1], reserved) redis.call('lpop', KEYS[3])endreturn &#123;job, reserved&#125;LUA;&#125; 从redis中获取到job之后，就会将其包装成RedisJob类：1234567891011121314151617181920public function __construct(Container $container, RedisQueue $redis, $job, $reserved, $connectionName, $queue)&#123; $this-&gt;job = $job; $this-&gt;redis = $redis; $this-&gt;queue = $queue; $this-&gt;reserved = $reserved; $this-&gt;container = $container; $this-&gt;connectionName = $connectionName; $this-&gt;decoded = $this-&gt;payload();&#125;public function payload()&#123; return json_decode($this-&gt;getRawBody(), true);&#125;public function getRawBody()&#123; return $this-&gt;job;&#125; 超时处理如果一个脚本超时，pcntl_alarm将会启动并杀死当前的work进程。杀死进程后，work进程将会被守护进程重启，继续进行下一个任务。123456789101112131415161718protected function registerTimeoutHandler($job, WorkerOptions $options)&#123; if ($options-&gt;timeout &gt; 0 &amp;&amp; $this-&gt;supportsAsyncSignals()) &#123; pcntl_signal(SIGALRM, function () &#123; $this-&gt;kill(1); &#125;); pcntl_alarm($this-&gt;timeoutForJob($job, $options) + $options-&gt;sleep); &#125;&#125;protected function timeoutForJob($job, WorkerOptions $options)&#123; return $job &amp;&amp; ! is_null($job-&gt;timeout()) ? $job-&gt;timeout() : $options-&gt;timeout;&#125; 任务事务运行任务前后会启动两个事件JobProcessing与JobProcessed，这两个事件需要事先注册监听者：123456789101112131415161718192021222324252627282930313233343536373839404142434445protected function runJob($job, $connectionName, WorkerOptions $options)&#123; try &#123; return $this-&gt;process($connectionName, $job, $options); &#125; catch (Exception $e) &#123; $this-&gt;exceptions-&gt;report($e); &#125; catch (Throwable $e) &#123; $this-&gt;exceptions-&gt;report(new FatalThrowableError($e)); &#125;&#125;public function process($connectionName, $job, WorkerOptions $options)&#123; try &#123; $this-&gt;raiseBeforeJobEvent($connectionName, $job); $this-&gt;markJobAsFailedIfAlreadyExceedsMaxAttempts( $connectionName, $job, (int) $options-&gt;maxTries ); $job-&gt;fire(); $this-&gt;raiseAfterJobEvent($connectionName, $job); &#125; catch (Exception $e) &#123; $this-&gt;handleJobException($connectionName, $job, $options, $e); &#125; catch (Throwable $e) &#123; $this-&gt;handleJobException( $connectionName, $job, $options, new FatalThrowableError($e) ); &#125;&#125; 任务前与任务后事件raiseBeforeJobEvent函数用于触发任务处理前的事件，raiseAfterJobEvent函数用于触发任务处理后的事件：1234567891011121314151617protected function raiseBeforeJobEvent($connectionName, $job)&#123; $this-&gt;events-&gt;fire( new Events\JobProcessing( $connectionName, $job ) );&#125;protected function raiseAfterJobEvent($connectionName, $job)&#123; $this-&gt;events-&gt;fire( new Events\JobProcessed( $connectionName, $job ) );&#125; 任务异常处理任务在运行过程中会遇到异常情况，这个时候就要判断当前任务的失败次数是不是超过限制。如果没有超过限制，那么就会把当前任务重新放回队列当中；如果超过了限制，那么就要标记当前任务为失败任务，并且将任务从reserved队列中删除。 任务失败markJobAsFailedIfAlreadyExceedsMaxAttempts函数用于任务运行前，判断当前任务是否重试次数超过限制：123456789101112131415161718192021222324252627282930313233343536protected function markJobAsFailedIfAlreadyExceedsMaxAttempts($connectionName, $job, $maxTries)&#123; $maxTries = ! is_null($job-&gt;maxTries()) ? $job-&gt;maxTries() : $maxTries; if ($maxTries === 0 || $job-&gt;attempts() &lt;= $maxTries) &#123; return; &#125; $this-&gt;failJob( $connectionName, $job, $e = new MaxAttemptsExceededException( 'A queued job has been attempted too many times. The job may have previously timed out.' ) ); throw $e;&#125;public function maxTries()&#123; return array_get($this-&gt;payload(), 'maxTries');&#125;public function attempts()&#123; return Arr::get($this-&gt;decoded, 'attempts') + 1;&#125;protected function failJob($connectionName, $job, $e)&#123; return FailingJob::handle($connectionName, $job, $e);&#125; 当遇到重试次数大于限制的任务，work进程就会调用FailingJob：1234567891011121314151617181920212223242526272829303132333435363738394041424344protected function failJob($connectionName, $job, $e)&#123; return FailingJob::handle($connectionName, $job, $e);&#125;public static function handle($connectionName, $job, $e = null)&#123; $job-&gt;markAsFailed(); if ($job-&gt;isDeleted()) &#123; return; &#125; try &#123; $job-&gt;delete(); $job-&gt;failed($e); &#125; finally &#123; static::events()-&gt;fire( new JobFailed( $connectionName, $job, $e ? : new ManuallyFailedException ) ); &#125;&#125;public function markAsFailed()&#123; $this-&gt;failed = true;&#125;public function delete()&#123; parent::delete(); $this-&gt;redis-&gt;deleteReserved($this-&gt;queue, $this);&#125;public function isDeleted()&#123; return $this-&gt;deleted;&#125; FailingJob会标记当前任务failed、deleted，并且会将当前任务移除reserved队列，不会再重试：1234567public function deleteReserved($queue, $job)&#123; $this-&gt;getConnection()-&gt;zrem( $this-&gt;getQueue($queue).':reserved', $job-&gt;getReservedJob() );&#125; FailingJob还会调用RedisJob的failed函数，并且触发JobFailed事件：123456789101112public function failed($e)&#123; $this-&gt;markAsFailed(); $payload = $this-&gt;payload(); list($class, $method) = JobName::parse($payload['job']); if (method_exists($this-&gt;instance = $this-&gt;resolve($class),'failed')) &#123; $this-&gt;instance-&gt;failed($payload['data'], $e); &#125;&#125; 程序会解析job类，我们先前在redis中已经存储了：123456789[ 'job' =&gt; 'Illuminate\Queue\CallQueuedHandler@call', 'maxTries' =&gt; isset($job-&gt;tries) ? $job-&gt;tries : null, 'timeout' =&gt; isset($job-&gt;timeout) ? $job-&gt;timeout : null, 'data' =&gt; [ 'commandName' =&gt; get_class($job), 'command' =&gt; serialize(clone $job), ],]; 我们接着看failed函数：12345678public function failed(array $data, $e)&#123; $command = unserialize($data['command']); if (method_exists($command, 'failed')) &#123; $command-&gt;failed($e); &#125;&#125; 可以看到，最后程序调用了任务类的failed函数。 异常处理当任务遇到异常的时候，程序仍然会判断当前任务的重试次数，如果本次任务的重试次数已经大于或等于限制，那么就会停止重试，标记为失败；否则就会重新放入队列，记录日志。12345678910111213141516171819202122232425262728293031323334353637383940414243444546protected function handleJobException($connectionName, $job, WorkerOptions $options, $e)&#123; try &#123; $this-&gt;markJobAsFailedIfWillExceedMaxAttempts( $connectionName, $job, (int) $options-&gt;maxTries, $e ); $this-&gt;raiseExceptionOccurredJobEvent( $connectionName, $job, $e ); &#125; finally &#123; if (! $job-&gt;isDeleted()) &#123; $job-&gt;release($options-&gt;delay); &#125; &#125; throw $e;&#125;protected function markJobAsFailedIfWillExceedMaxAttempts($connectionName, $job, $maxTries, $e)&#123; $maxTries = ! is_null($job-&gt;maxTries()) ? $job-&gt;maxTries() : $maxTries; if ($maxTries &gt; 0 &amp;&amp; $job-&gt;attempts() &gt;= $maxTries) &#123; $this-&gt;failJob($connectionName, $job, $e); &#125;&#125;public function release($delay = 0)&#123; parent::release($delay); $this-&gt;redis-&gt;deleteAndRelease($this-&gt;queue, $this, $delay);&#125;public function deleteAndRelease($queue, $job, $delay)&#123; $queue = $this-&gt;getQueue($queue); $this-&gt;getConnection()-&gt;eval( LuaScripts::release(), 2, $queue.':delayed', $queue.':reserved', $job-&gt;getReservedJob(), $this-&gt;availableAt($delay) );&#125; 一旦任务出现异常错误。那么该任务将会立刻从reserved队列放入delayed队列，并且抛出异常，抛出异常后，程序会将其记录在日志中。12345678910public static function release()&#123; return &lt;&lt;&lt;'LUA'-- Remove the job from the current queue...redis.call('zrem', KEYS[2], ARGV[1])-- Add the job onto the "delayed" queue...redis.call('zadd', KEYS[1], ARGV[2], ARGV[1])return true LUA;&#125; 任务的运行任务的运行首先会调用CallQueuedHandler的call函数：123456789101112131415161718192021222324252627282930313233343536public function fire()&#123; $payload = $this-&gt;payload(); list($class, $method) = JobName::parse($payload['job']); with($this-&gt;instance = $this-&gt;resolve($class))-&gt;&#123;$method&#125;($this, $payload['data']);&#125;/** * Handle the queued job. * * @param \Illuminate\Contracts\Queue\Job $job * @param array $data * @return void */public function call(Job $job, array $data)&#123; try &#123; $command = $this-&gt;setJobInstanceIfNecessary( $job, unserialize($data['command']) ); &#125; catch (ModelNotFoundException $e) &#123; return $this-&gt;handleModelNotFound($job, $e); &#125; $this-&gt;dispatchThroughMiddleware($job, $command); if (! $job-&gt;hasFailed() &amp;&amp; ! $job-&gt;isReleased()) &#123; $this-&gt;ensureNextJobInChainIsDispatched($command); &#125; if (! $job-&gt;isDeletedOrReleased()) &#123; $job-&gt;delete(); &#125;&#125; setJobInstanceIfNecessary函数用于为任务类的trait:InteractsWithQueue的设置任务类：12345678910111213141516171819202122232425262728293031/** * Set the job instance of the given class if necessary. * * @param \Illuminate\Contracts\Queue\Job $job * @param mixed $instance * @return mixed */protected function setJobInstanceIfNecessary(Job $job, $instance)&#123; if (in_array(InteractsWithQueue::class, class_uses_recursive($instance))) &#123; $instance-&gt;setJob($job); &#125; return $instance;&#125;trait InteractsWithQueue&#123; /** * Set the base queue job instance. * * @param \Illuminate\Contracts\Queue\Job $job * @return $this */ public function setJob(JobContract $job) &#123; $this-&gt;job = $job; return $this; &#125;&#125; 接着任务的运行就要交给dispatch：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Dispatch a command to its appropriate handler in the current process. * * @param mixed $command * @param mixed $handler * @return mixed */public function dispatchNow($command, $handler = null)&#123; if ($handler || $handler = $this-&gt;getCommandHandler($command)) &#123; $callback = function ($command) use ($handler) &#123; return $handler-&gt;handle($command); &#125;; &#125; else &#123; $callback = function ($command) &#123; return $this-&gt;container-&gt;call([$command, 'handle']); &#125;; &#125; return $this-&gt;pipeline-&gt;send($command)-&gt;through($this-&gt;pipes)-&gt;then($callback);&#125;/** * Retrieve the handler for a command. * * @param mixed $command * @return bool|mixed */public function getCommandHandler($command)&#123; if ($this-&gt;hasCommandHandler($command)) &#123; return $this-&gt;container-&gt;make($this-&gt;handlers[get_class($command)]); &#125; return false;&#125;/** * Determine if the given command has a handler. * * @param mixed $command * @return bool */public function hasCommandHandler($command)&#123; return array_key_exists(get_class($command), $this-&gt;handlers);&#125; 如果不对dispatcher类进行任何map函数设置，getCommandHandler将会返回null，此时就会调用任务类的handle函数，进行具体的业务逻辑。 任务结束后，就会调用delete函数：1234567891011121314151617181920212223/** * Delete the job from the queue. * * @return void */public function delete()&#123; parent::delete(); $this-&gt;redis-&gt;deleteReserved($this-&gt;queue, $this);&#125;/** * Delete a reserved job from the queue. * * @param string $queue * @param \Illuminate\Queue\Jobs\RedisJob $job * @return void */public function deleteReserved($queue, $job)&#123; $this-&gt;getConnection()-&gt;zrem($this-&gt;getQueue($queue).':reserved', $job-&gt;getReservedJob());&#125; 这样，运行成功的任务会从reserved中删除。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Queue-消息队列任务与分发源码剖析]]></title>
    <url>%2F2020%2F05%2F11%2FLaravel-Queue-%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E4%BB%BB%E5%8A%A1%E4%B8%8E%E5%88%86%E5%8F%91%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Laravel的队列服务由两个进程控制，一个是生产者，一个是消费者。怎么理解？ 将有序集合ZSet的评分score设置为延时任务开启的时间，可以实现延迟任务的功能。怎么实现的？ 重试也是通过ZSet实现的。怎么理解？ 一个List，负责即时任务，两个ZSet，负责延时任务与待处理任务。怎么理解？ 前言在实际的项目开发中，我们经常会遇到需要轻量级队列的情形，例如发短信、发邮件等，这些任务不足以使用Kafka、RabbitMQ等重量级的消息队列，但是又的确需要异步、重试、并发控制等功能。通常来说，我们经常会使用Redis、Beanstalkd、Amazon SQS来实现相关功能，Laravel为此对不同的后台队列服务提供统一的API，本文将会介绍应用最为广泛的Redis队列。 背景知识在讲解Laravel的队列服务之前，我们要先说说基于Redis的队列服务。首先，Redis设计用来做缓存的，但是由于它自身的某种特性使得它可以用来做消息队列。 Redis队列的数据结构List链表 Redis做消息队列的特性例如FIFO（先入先出）很容易实现，只需要一个List对象从头取数据，从尾部塞数据即可。 相关的命令： （1）左侧入右侧出：lpush/rpop； （2）右侧入左侧出：rpush/lpop。 这个简单的消息队列很容易实现。 ZSet有序集合 有些任务场景，并不需要任务立刻执行，而是需要延迟执行；有些任务很重要，需要在任务失败的时候重新尝试。这些功能仅仅依靠List是无法完成的。这个时候，就需要Redis的有序集合。 Redis有序集合和Redis集合类似，是不包含相同字符串的合集。它们的差别是，每个有序集合的成员都关联着一个评分score，这个评分用于把有序集合中的成员按最低分到最高分排列。 单看有序集合和延迟任务并无关系，但是可以将有序集合的评分score设置为延时任务开启的时间，之后轮询这个有序集合，将到期的任务拿出来进行处理，这样就实现了延迟任务的功能。 对于重要的需要重试的任务，在任务执行之前，会将该任务放入有序集合中，设置任务最长的执行时间。若任务顺利执行完毕，该任务会在有序集合中删除。如果任务没有在规定时间内完成，那么该有序集合的任务将会被重新放入队列中。 相关命令： (1) ZADD 添加一个或多个成员到有序集合，或者如果它已经存在更新其分数。 (2) ZRANGEBYSCORE 按分数返回一个成员范围的有序集合。 (3) ZREMRANGEBYRANK 在给定的索引之内删除所有成员的有序集合。 Laravel队列服务的任务调度队列服务的任务调度过程如下： Laravel的队列服务由两个进程控制，一个是生产者，一个是消费者。这两个进程操纵了Redis三个队列，其中一个List，负责即时任务，两个ZSet，负责延时任务与待处理任务。 生产者负责向Redis推送任务，如果是即时任务，默认就会向queue:default推送；如果是延时任务，就会向queue:default:delayed推送。 消费者轮询两个队列，不断的从队列中取出任务，先把任务放入queue:default:reserved中，再执行相关任务。如果任务执行成功，就会删除queue:default:reserved中的任务，否则会被重新放入queue:default:delayed队列中。 Laravel队列服务的总体流程任务分发流程： 任务处理器运作： Laravel队列服务的注册与启动Laravel队列服务需要注册的服务比较多： Illuminate/Queue/QueueServiceProvider.php 12345678910111213141516171819202122232425262728293031&lt;?phpnamespace Illuminate\Queue;use Illuminate\Contracts\Debug\ExceptionHandler;use Illuminate\Contracts\Support\DeferrableProvider;use Illuminate\Queue\Connectors\RedisConnector;use Illuminate\Queue\Failed\DatabaseFailedJobProvider;use Illuminate\Support\Arr;use Illuminate\Support\ServiceProvider;use Illuminate\Support\Str;use Opis\Closure\SerializableClosure;class QueueServiceProvider extends ServiceProvider implements DeferrableProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;registerManager(); $this-&gt;registerConnection(); $this-&gt;registerWorker(); $this-&gt;registerListener(); $this-&gt;registerFailedJobServices(); $this-&gt;registerOpisSecurityKey(); &#125;&#125; registerManager注册门面registerManager负责注册队列服务的门面类： 123456789101112131415161718192021222324252627282930313233343536373839404142/** * Register the queue manager. * * @return void */protected function registerManager()&#123; $this-&gt;app-&gt;singleton('queue', function ($app) &#123; // Once we have an instance of the queue manager, we will register the various // resolvers for the queue connectors. These connectors are responsible for // creating the classes that accept queue configs and instantiate queues. return tap(new QueueManager($app), function ($manager) &#123; $this-&gt;registerConnectors($manager); &#125;); &#125;);&#125;/** * Register the connectors on the queue manager. * * @param \Illuminate\Queue\QueueManager $manager * @return void */public function registerConnectors($manager)&#123; foreach (['Null', 'Sync', 'Database', 'Redis', 'Beanstalkd', 'Sqs'] as $connector) &#123; $this-&gt;&#123;"register&#123;$connector&#125;Connector"&#125;($manager); &#125;&#125;/** * Register the Redis queue connector. * * @param \Illuminate\Queue\QueueManager $manager * @return void */protected function registerRedisConnector($manager)&#123; $manager-&gt;addConnector('redis', function () &#123; return new RedisConnector($this-&gt;app['redis']); &#125;);&#125; QueueManager是队列服务的总门面，提供一切与队列相关的操作接口。QueueManager中有一个成员变量$connectors，该成员变量中存储着所有Laravel支持的底层队列服务：“Database”,“Redis”,“Beanstalkd”,“SQS”。 123456789101112131415161718192021class QueueManager implements FactoryContract, MonitorContract&#123; /** * The array of resolved queue connectors. * * @var array */ protected $connectors = []; /** * Add a queue connection resolver. * * @param string $driver * @param \Closure $resolver * @return void */ public function addConnector($driver, Closure $resolver) &#123; $this-&gt;connectors[$driver] = $resolver; &#125;&#125; 成员变量$connectors会被存储各种驱动的connector，例如RedisConnector、SqsConnector、DatabaseConnector、BeanstalkdConnector。 registerConnection底层队列连接服务接下来，就要连接实现队列的底层服务了，例如Redis： 12345678910111213141516171819202122232425262728293031323334353637383940414243/** * Register the default queue connection binding. * * @return void */protected function registerConnection()&#123; $this-&gt;app-&gt;singleton('queue.connection', function ($app) &#123; return $app['queue']-&gt;connection(); &#125;);&#125;/** * Resolve a queue connection instance. * * @param string|null $name * @return \Illuminate\Contracts\Queue\Queue */public function connection($name = null)&#123; $name = $name ?: $this-&gt;getDefaultDriver(); // If the connection has not been resolved yet we will resolve it now as all // of the connections are resolved when they are actually needed so we do // not make any unnecessary connection to the various queue end-points. if (! isset($this-&gt;connections[$name])) &#123; $this-&gt;connections[$name] = $this-&gt;resolve($name); $this-&gt;connections[$name]-&gt;setContainer($this-&gt;app); &#125; return $this-&gt;connections[$name];&#125;/** * Get the name of the default queue connection. * * @return string */public function getDefaultDriver()&#123; return $this-&gt;app['config']['queue.default'];&#125; connection函数首先会获取连接名，没有连接名就会从config中获取默认的连接。 1234567891011121314/** * Resolve a queue connection. * * @param string $name * @return \Illuminate\Contracts\Queue\Queue */protected function resolve($name)&#123; $config = $this-&gt;getConfig($name); return $this-&gt;getConnector($config['driver']) -&gt;connect($config) -&gt;setConnectionName($name);&#125; resolve函数利用相应的底层驱动connector进行连接操作，也就是connect函数，该函数会返回RedisQueue： Illuminate/Queue/Connectors/RedisConnector.php 12345678910111213141516171819202122232425&lt;?phpnamespace Illuminate\Queue\Connectors;use Illuminate\Contracts\Redis\Factory as Redis;use Illuminate\Queue\RedisQueue;class RedisConnector implements ConnectorInterface&#123; /** * Establish a queue connection. * * @param array $config * @return \Illuminate\Contracts\Queue\Queue */ public function connect(array $config) &#123; return new RedisQueue( $this-&gt;redis, $config['queue'], $config['connection'] ?? $this-&gt;connection, $config['retry_after'] ?? 60, $config['block_for'] ?? null ); &#125;&#125; registerWorker消费者服务注册消费者的注册服务会返回Illuminate\Queue\Worker类：1234567891011121314151617181920/** * Register the queue worker. * * @return void */protected function registerWorker()&#123; $this-&gt;app-&gt;singleton('queue.worker', function ($app) &#123; $isDownForMaintenance = function () &#123; return $this-&gt;app-&gt;isDownForMaintenance(); &#125;; return new Worker( $app['queue'], $app['events'], $app[ExceptionHandler::class], $isDownForMaintenance ); &#125;);&#125; Laravel Bus服务注册与启动定义好自己想要的队列类之后，还需要将队列任务推送给底层驱动后台，例如Redis，一般会使用dispatch函数：1Job::dispatch(); 或者12$job = (new ProcessPodcast($pocast));dispatch($job); dispatch函数就是Bus服务，专门用于分发队列任务。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?phpnamespace Illuminate\Bus;use Illuminate\Contracts\Bus\Dispatcher as DispatcherContract;use Illuminate\Contracts\Bus\QueueingDispatcher as QueueingDispatcherContract;use Illuminate\Contracts\Queue\Factory as QueueFactoryContract;use Illuminate\Contracts\Support\DeferrableProvider;use Illuminate\Support\ServiceProvider;class BusServiceProvider extends ServiceProvider implements DeferrableProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton(Dispatcher::class, function ($app) &#123; return new Dispatcher($app, function ($connection = null) use ($app) &#123; return $app[QueueFactoryContract::class]-&gt;connection($connection); &#125;); &#125;); $this-&gt;app-&gt;alias( Dispatcher::class, DispatcherContract::class ); $this-&gt;app-&gt;alias( Dispatcher::class, QueueingDispatcherContract::class ); &#125; /** * Get the services provided by the provider. * * @return array */ public function provides() &#123; return [ Dispatcher::class, DispatcherContract::class, QueueingDispatcherContract::class, ]; &#125;&#125; 创建任务queue设置123456'redis' =&gt; [ 'driver' =&gt; 'redis', 'connection' =&gt; 'default', 'queue' =&gt; 'default', 'retry_after' =&gt; 90,], 一般来说，默认的redis配置如上，connection是database中redis的连接名称；queue是redis中的队列名称，值得注意的是，如果使用的是redis集群的话，这个需要使用key hash tag，也就是{default}；当任务运行超过retry_after这个时间后，该任务会被重新放入队列当中。 任务类的创建 任务类的结构很简单，一般来说只会包含一个让队列用来调用此任务的handle方法。 如果想要使得任务被推送到队列中，而不是同步执行，那么需要实现Illuminate\Contracts\Queue\ShouldQueue接口。 如果想要让任务推送到特定的连接中，例如redis或者sqs，那么需要设置conneciton变量。 如果想要让任务推送到特定的队列中去，可以设置queue变量。 如果想要让任务延迟推送，那么需要设置delay变量。 如果想要设置任务至多重试的次数，可以使用tries变量； 如果想要设置任务可以运行的最大秒数，那么可以使用timeout参数。 如果想要手动访问队列，可以使用trait:Illuminate\Queue\InteractsWithQueue。 如果队列监听器任务执行次数超过在工作队列中定义的最大尝试次数，监听器的failed方法将会被自动调用。failed方法接受事件实例和失败的异常作为参数：1234567891011121314151617181920212223242526272829class ProcessPodcast implements ShouldQueue&#123; use Dispatchable, InteractsWithQueue, Queueable, SerializesModels; protected $podcast; public $connection = 'redis'; public $queue = 'test'; public $delay = 30; public $tries = 5; public $timeout = 30; public function __construct(Podcast $podcast) &#123; $this-&gt;podcast = $podcast; &#125; public function handle(AudioProcessor $processor) &#123; // Process uploaded podcast... if (false) &#123; $this-&gt;release(30); &#125; &#125; public function failed(OrderShipped $event, $exception) &#123; // &#125;&#125; 任务事件12345678910111213141516171819202122232425262728293031323334353637383940class AppServiceProvider extends ServiceProvider&#123; public function boot() &#123; // 任务运行前 Queue::before(function (JobProcessing $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); //任务运行后 Queue::after(function (JobProcessed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;job-&gt;payload() &#125;); //任务循环前 Queue::looping(function () &#123; while (DB::transactionLevel() &gt; 0) &#123; DB::rollBack(); &#125; &#125;); // 任务失败后 Queue::failing(function (JobFailed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;exception &#125;); // 异常发生后 Queue::exceptionOccurred(function (JobFailed $event) &#123; // $event-&gt;connectionName // $event-&gt;job // $event-&gt;exception &#125;); &#125;&#125; 任务的分发分发服务写好任务类后，就能通过dispatch辅助函数来分发它了。唯一需要传递给dispatch的参数是这个任务类的实例：12345678class PodcastController extends Controller&#123; public function store(Request $request) &#123; // 创建播客... ProcessPodcast::dispatch($podcast); &#125;&#125; 如果想延迟执行一个队列中的任务，可以用任务实例的delay方法。1ProcessPodcast::dispatch($podcast)-&gt;delay(Carbon::now()-&gt;addMinutes(10)); 通过推送任务到不同的队列，可以给队列任务分类，甚至可以控制给不同的队列分配多少任务。要指定队列的话，就调用任务实例的onQueue方法：1ProcessPodcast::dispatch($podcast)-&gt;onQueue('processing'); 如果使用了多个队列连接，可以将任务推到指定连接。要指定连接的话，可以在分发任务的时候使用onConnection方法：1ProcessPodcast::dispatch($podcast)-&gt;onConnection('redis'); 这些链式的函数是在trait：Illuminate\Foundation\Bus\Dispatchable的基础上应用的，该trait由dispatch函数启动：1234567trait Dispatchable&#123; public static function dispatch() &#123; return new PendingDispatch(new static(...func_get_args())); &#125;&#125; PendingDispatch类中定义了链式函数，该函数巧妙在析构函数中，析构函数自动调用全局函数dispatch：123456789101112131415161718192021222324252627282930class PendingDispatch&#123; public function __construct($job) &#123; $this-&gt;job = $job; &#125; public function onConnection($connection) &#123; $this-&gt;job-&gt;onConnection($connection); return $this; &#125; public function onQueue($queue) &#123; $this-&gt;job-&gt;onQueue($queue); return $this; &#125; public function delay($delay) &#123; $this-&gt;job-&gt;delay($delay); return $this; &#125; public function __destruct() &#123; dispatch($this-&gt;job); &#125;&#125; 各个函数里面的onConnection、delay、onQueue等函数是任务中的trait：Illuminate\Bus\Queueable1234567891011121314151617181920trait Queueable&#123; public function onConnection($connection) &#123; $this-&gt;connection = $connection; return $this; &#125; public function onQueue($queue) &#123; $this-&gt;queue = $queue; return $this; &#125; public function delay($delay) &#123; $this-&gt;delay = $delay; return $this; &#125;&#125; dispatch任务分发源码任务的分发离不开Bus服务，可以利用全局函数dispatch，还可以使用Dispatchable这个trait： Illuminate/Bus/Dispatcher.php 1234567891011121314151617181920212223242526272829303132333435class Dispatcher implements QueueingDispatcher&#123; /** * The queue resolver callback. * * @var \Closure|null */ protected $queueResolver; /** * Dispatch a command to its appropriate handler. * * @param mixed $command * @return mixed */ public function dispatch($command) &#123; if ($this-&gt;queueResolver &amp;&amp; $this-&gt;commandShouldBeQueued($command)) &#123; return $this-&gt;dispatchToQueue($command); &#125; return $this-&gt;dispatchNow($command); &#125; /** * Determine if the given command should be queued. * * @param mixed $command * @return bool */ protected function commandShouldBeQueued($command) &#123; return $command instanceof ShouldQueue; &#125;&#125; 我们这里主要看异步的任务：12345678910111213141516171819202122/** * Dispatch a command to its appropriate handler behind a queue. * * @param mixed $command * @return mixed */public function dispatchToQueue($command)&#123; $connection = $command-&gt;connection ?? null; $queue = call_user_func($this-&gt;queueResolver, $connection); if (! $queue instanceof Queue) &#123; throw new RuntimeException('Queue resolver did not return a Queue implementation.'); &#125; if (method_exists($command, 'queue')) &#123; return $command-&gt;queue($queue, $command); &#125; return $this-&gt;pushCommandToQueue($queue, $command);&#125; 进行任务分发之前，首先要利用queueResolver连接底层驱动。如果任务类中含有queue函数，那么就会利用用户自己的queue对驱动进行推送任务。否则就会启动默认的程序：1234567891011121314151617181920212223/** * Push the command onto the given queue instance. * * @param \Illuminate\Contracts\Queue\Queue $queue * @param mixed $command * @return mixed */protected function pushCommandToQueue($queue, $command)&#123; if (isset($command-&gt;queue, $command-&gt;delay)) &#123; return $queue-&gt;laterOn($command-&gt;queue, $command-&gt;delay, $command); &#125; if (isset($command-&gt;queue)) &#123; return $queue-&gt;pushOn($command-&gt;queue, $command); &#125; if (isset($command-&gt;delay)) &#123; return $queue-&gt;later($command-&gt;delay, $command); &#125; return $queue-&gt;push($command);&#125; 我们以redis为例，queue这个类就是Illuminate\Queue\RedisQueue:123456789101112131415161718192021222324252627282930class RedisQueue extends Queue implements QueueContract&#123; /** * Push a new job onto the queue. * * @param object|string $job * @param mixed $data * @param string|null $queue * @return mixed */ public function push($job, $data = '', $queue = null) &#123; return $this-&gt;pushRaw($this-&gt;createPayload($job, $this-&gt;getQueue($queue), $data), $queue); &#125; /** * Push a new job onto the queue after a delay. * * @param \DateTimeInterface|\DateInterval|int $delay * @param object|string $job * @param mixed $data * @param string|null $queue * @return mixed */ public function later($delay, $job, $data = '', $queue = null) &#123; return $this-&gt;laterRaw($delay, $this-&gt;createPayload($job, $this-&gt;getQueue($queue), $data), $queue); &#125;&#125; 我们先看push，push函数调用pushRaw，在调用之前，要把任务类进行序列化，并且以特定的格式进行json序列化：12345678910111213141516171819202122232425262728293031323334353637383940/** * Create a payload string from the given job and data. * * @param string $job * @param string $queue * @param mixed $data * @return array */protected function createPayloadArray($job, $queue, $data = '')&#123; return array_merge(parent::createPayloadArray($job, $queue, $data), [ 'id' =&gt; $this-&gt;getRandomId(), 'attempts' =&gt; 0, ]);&#125;protected function createPayloadArray($job, $data = '', $queue = null)&#123; return is_object($job) ? $this-&gt;createObjectPayload($job) : $this-&gt;createStringPayload($job, $data);&#125;protected function createObjectPayload($job)&#123; return [ 'job' =&gt; 'Illuminate\Queue\CallQueuedHandler@call', 'maxTries' =&gt; isset($job-&gt;tries) ? $job-&gt;tries : null, 'timeout' =&gt; isset($job-&gt;timeout) ? $job-&gt;timeout : null, 'data' =&gt; [ 'commandName' =&gt; get_class($job), 'command' =&gt; serialize(clone $job), ], ];&#125;protected function createStringPayload($job, $data)&#123; return ['job' =&gt; $job, 'data' =&gt; $data];&#125; 格式化数据之后，就会将json推送到redis队列中，对于非延时的任务，直接调用rpush即可：123456public function pushRaw($payload, $queue = null, array $options = [])&#123; $this-&gt;getConnection()-&gt;rpush($this-&gt;getQueue($queue), $payload); return Arr::get(json_decode($payload, true), 'id');&#125; 对于延时的任务，会调用laterRaw，调用redis的有序集合zadd函数:1234567891011121314151617protected function availableAt($delay = 0)&#123; return $delay instanceof DateTimeInterface ? $delay-&gt;getTimestamp() : Carbon::now()-&gt;addSeconds($delay)-&gt;getTimestamp();&#125;protected function laterRaw($delay, $payload, $queue = null)&#123; $this-&gt;getConnection()-&gt;zadd( $this-&gt;getQueue($queue).':delayed', $this-&gt;availableAt($delay), $payload ); return Arr::get(json_decode($payload, true), 'id');&#125; 这样，相关任务就会被分发到redis对应的队列中去。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Redis]]></title>
    <url>%2F2020%2F05%2F10%2FLaravel-Redis%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Connector只负责连接，Connection负责操作。怎么理解？ RedisManager把Connection和Connetor组合起来。只new了PhpRedisConnector，通过Connector得到Connection。怎么理解？ 把$redis-&gt;get再封一层为$redis-&gt;command是为了触发CommandExecuted事件。怎么理解？ 管道命令当你需要在一次操作中发送多个命令到服务器的时候应该使用管道，pipeline方法接收一个参数：接收Redis实例的闭包。你可以将所有Redis命令发送到这个Redis实例，然后这些命令会在一次操作中被执行：1234567Redis::pipeline(function ($pipe) &#123; for ($i = 0; $i &lt; 1000; $i++) &#123; $pipe-&gt;set("key:$i", $i); &#125;&#125;); 源码文件结构 配置 config/database.php 12345678910111213141516171819'redis' =&gt; [ 'client' =&gt; 'predis', 'default' =&gt; [ 'host' =&gt; env('REDIS_HOST', '127.0.0.1'), 'password' =&gt; env('REDIS_PASSWORD', null), 'port' =&gt; env('REDIS_PORT', 6379), 'database' =&gt; env('REDIS_DB', 0), ], 'cache' =&gt; [ 'host' =&gt; env('REDIS_HOST', '127.0.0.1'), 'password' =&gt; env('REDIS_PASSWORD', null), 'port' =&gt; env('REDIS_PORT', 6379), 'database' =&gt; env('REDIS_CACHE_DB', 1), ], ], ConnectorConnector接口 Illuminate\Contracts\Redis\Connector.php 1234567891011121314151617181920212223242526&lt;?phpnamespace Illuminate\Contracts\Redis;interface Connector&#123; /** * Create a connection to a Redis instance. * * @param array $config * @param array $options * @return \Illuminate\Redis\Connections\Connection */ public function connect(array $config, array $options); /** * Create a connection to a Redis cluster. * * @param array $config * @param array $clusterOptions * @param array $options * @return \Illuminate\Redis\Connections\Connection */ public function connectToCluster(array $config, array $clusterOptions, array $options);&#125; Illuminate\Redis\Connectors\PhpRedisConnector.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168&lt;?phpnamespace Illuminate\Redis\Connectors;use Illuminate\Contracts\Redis\Connector;use Illuminate\Redis\Connections\PhpRedisClusterConnection;use Illuminate\Redis\Connections\PhpRedisConnection;use Illuminate\Support\Arr;use Illuminate\Support\Facades\Redis as RedisFacade;use LogicException;use Redis;use RedisCluster;class PhpRedisConnector implements Connector&#123; /** * Create a new clustered PhpRedis connection. * * @param array $config * @param array $options * @return \Illuminate\Redis\Connections\PhpRedisConnection */ public function connect(array $config, array $options) &#123; $connector = function () use ($config, $options) &#123; return $this-&gt;createClient(array_merge( $config, $options, Arr::pull($config, 'options', []) )); &#125;; return new PhpRedisConnection($connector(), $connector); &#125; /** * Create a new clustered PhpRedis connection. * * @param array $config * @param array $clusterOptions * @param array $options * @return \Illuminate\Redis\Connections\PhpRedisClusterConnection */ public function connectToCluster(array $config, array $clusterOptions, array $options) &#123; $options = array_merge($options, $clusterOptions, Arr::pull($config, 'options', [])); return new PhpRedisClusterConnection($this-&gt;createRedisClusterInstance( array_map([$this, 'buildClusterConnectionString'], $config), $options )); &#125; /** * Build a single cluster seed string from array. * * @param array $server * @return string */ protected function buildClusterConnectionString(array $server) &#123; return $server['host'].':'.$server['port'].'?'.Arr::query(Arr::only($server, [ 'database', 'password', 'prefix', 'read_timeout', ])); &#125; /** * Create the Redis client instance. * * @param array $config * @return \Redis * * @throws \LogicException */ protected function createClient(array $config) &#123; return tap(new Redis, function ($client) use ($config) &#123; if ($client instanceof RedisFacade) &#123; throw new LogicException( extension_loaded('redis') ? 'Please remove or rename the Redis facade alias in your "app" configuration file in order to avoid collision with the PHP Redis extension.' : 'Please make sure the PHP Redis extension is installed and enabled.' ); &#125; $this-&gt;establishConnection($client, $config); if (! empty($config['password'])) &#123; $client-&gt;auth($config['password']); &#125; if (isset($config['database'])) &#123; $client-&gt;select((int) $config['database']); &#125; if (! empty($config['prefix'])) &#123; $client-&gt;setOption(Redis::OPT_PREFIX, $config['prefix']); &#125; if (! empty($config['read_timeout'])) &#123; $client-&gt;setOption(Redis::OPT_READ_TIMEOUT, $config['read_timeout']); &#125; if (! empty($config['scan'])) &#123; $client-&gt;setOption(Redis::OPT_SCAN, $config['scan']); &#125; &#125;); &#125; /** * Establish a connection with the Redis host. * * @param \Redis $client * @param array $config * @return void */ protected function establishConnection($client, array $config) &#123; $persistent = $config['persistent'] ?? false; $parameters = [ $config['host'], $config['port'], Arr::get($config, 'timeout', 0.0), $persistent ? Arr::get($config, 'persistent_id', null) : null, Arr::get($config, 'retry_interval', 0), ]; if (version_compare(phpversion('redis'), '3.1.3', '&gt;=')) &#123; $parameters[] = Arr::get($config, 'read_timeout', 0.0); &#125; $client-&gt;&#123;($persistent ? 'pconnect' : 'connect')&#125;(...$parameters); &#125; /** * Create a new redis cluster instance. * * @param array $servers * @param array $options * @return \RedisCluster */ protected function createRedisClusterInstance(array $servers, array $options) &#123; $parameters = [ null, array_values($servers), $options['timeout'] ?? 0, $options['read_timeout'] ?? 0, isset($options['persistent']) &amp;&amp; $options['persistent'], ]; if (version_compare(phpversion('redis'), '4.3.0', '&gt;=')) &#123; $parameters[] = $options['password'] ?? null; &#125; return tap(new RedisCluster(...$parameters), function ($client) use ($options) &#123; if (! empty($options['prefix'])) &#123; $client-&gt;setOption(RedisCluster::OPT_PREFIX, $options['prefix']); &#125; if (! empty($options['scan'])) &#123; $client-&gt;setOption(RedisCluster::OPT_SCAN, $options['scan']); &#125; if (! empty($options['failover'])) &#123; $client-&gt;setOption(RedisCluster::OPT_SLAVE_FAILOVER, $options['failover']); &#125; &#125;); &#125;&#125; Connections Illuminate\Contracts\Redis\Connection.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phpnamespace Illuminate\Contracts\Redis;use Closure;interface Connection&#123; /** * Subscribe to a set of given channels for messages. * * @param array|string $channels * @param \Closure $callback * @return void */ public function subscribe($channels, Closure $callback); /** * Subscribe to a set of given channels with wildcards. * * @param array|string $channels * @param \Closure $callback * @return void */ public function psubscribe($channels, Closure $callback); /** * Run a command against the Redis database. * * @param string $method * @param array $parameters * @return mixed */ public function command($method, array $parameters = []);&#125; Illuminate\Redis\Connections\Connection.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222&lt;?phpnamespace Illuminate\Redis\Connections;use Closure;use Illuminate\Contracts\Events\Dispatcher;use Illuminate\Redis\Events\CommandExecuted;use Illuminate\Redis\Limiters\ConcurrencyLimiterBuilder;use Illuminate\Redis\Limiters\DurationLimiterBuilder;use Illuminate\Support\Traits\Macroable;abstract class Connection&#123; use Macroable &#123; __call as macroCall; &#125; /** * The Redis client. * * @var \Redis */ protected $client; /** * The Redis connection name. * * @var string|null */ protected $name; /** * The event dispatcher instance. * * @var \Illuminate\Contracts\Events\Dispatcher */ protected $events; /** * Subscribe to a set of given channels for messages. * * @param array|string $channels * @param \Closure $callback * @param string $method * @return void */ abstract public function createSubscription($channels, Closure $callback, $method = 'subscribe'); /** * Funnel a callback for a maximum number of simultaneous executions. * * @param string $name * @return \Illuminate\Redis\Limiters\ConcurrencyLimiterBuilder */ public function funnel($name) &#123; return new ConcurrencyLimiterBuilder($this, $name); &#125; /** * Throttle a callback for a maximum number of executions over a given duration. * * @param string $name * @return \Illuminate\Redis\Limiters\DurationLimiterBuilder */ public function throttle($name) &#123; return new DurationLimiterBuilder($this, $name); &#125; /** * Get the underlying Redis client. * * @return mixed */ public function client() &#123; return $this-&gt;client; &#125; /** * Subscribe to a set of given channels for messages. * * @param array|string $channels * @param \Closure $callback * @return void */ public function subscribe($channels, Closure $callback) &#123; return $this-&gt;createSubscription($channels, $callback, __FUNCTION__); &#125; /** * Subscribe to a set of given channels with wildcards. * * @param array|string $channels * @param \Closure $callback * @return void */ public function psubscribe($channels, Closure $callback) &#123; return $this-&gt;createSubscription($channels, $callback, __FUNCTION__); &#125; /** * Run a command against the Redis database. * * @param string $method * @param array $parameters * @return mixed */ public function command($method, array $parameters = []) &#123; $start = microtime(true); $result = $this-&gt;client-&gt;&#123;$method&#125;(...$parameters); $time = round((microtime(true) - $start) * 1000, 2); if (isset($this-&gt;events)) &#123; $this-&gt;event(new CommandExecuted($method, $parameters, $time, $this)); &#125; return $result; &#125; /** * Fire the given event if possible. * * @param mixed $event * @return void */ protected function event($event) &#123; if (isset($this-&gt;events)) &#123; $this-&gt;events-&gt;dispatch($event); &#125; &#125; /** * Register a Redis command listener with the connection. * * @param \Closure $callback * @return void */ public function listen(Closure $callback) &#123; if (isset($this-&gt;events)) &#123; $this-&gt;events-&gt;listen(CommandExecuted::class, $callback); &#125; &#125; /** * Get the connection name. * * @return string|null */ public function getName() &#123; return $this-&gt;name; &#125; /** * Set the connections name. * * @param string $name * @return $this */ public function setName($name) &#123; $this-&gt;name = $name; return $this; &#125; /** * Get the event dispatcher used by the connection. * * @return \Illuminate\Contracts\Events\Dispatcher */ public function getEventDispatcher() &#123; return $this-&gt;events; &#125; /** * Set the event dispatcher instance on the connection. * * @param \Illuminate\Contracts\Events\Dispatcher $events * @return void */ public function setEventDispatcher(Dispatcher $events) &#123; $this-&gt;events = $events; &#125; /** * Unset the event dispatcher instance on the connection. * * @return void */ public function unsetEventDispatcher() &#123; $this-&gt;events = null; &#125; /** * Pass other method calls down to the underlying client. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; if (static::hasMacro($method)) &#123; return $this-&gt;macroCall($method, $parameters); &#125; return $this-&gt;command($method, $parameters); &#125;&#125; Illuminate\Redis\Connections\PhpRedisConnection.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477&lt;?phpnamespace Illuminate\Redis\Connections;use Closure;use Illuminate\Contracts\Redis\Connection as ConnectionContract;use Illuminate\Support\Str;use Redis;use RedisCluster;use RedisException;/** * @mixin \Redis */class PhpRedisConnection extends Connection implements ConnectionContract&#123; /** * The connection creation callback. * * @var callable */ protected $connector; /** * Create a new PhpRedis connection. * * @param \Redis $client * @param callable|null $connector * @return void */ public function __construct($client, callable $connector = null) &#123; $this-&gt;client = $client; $this-&gt;connector = $connector; &#125; /** * Returns the value of the given key. * * @param string $key * @return string|null */ public function get($key) &#123; $result = $this-&gt;command('get', [$key]); return $result !== false ? $result : null; &#125; /** * Get the values of all the given keys. * * @param array $keys * @return array */ public function mget(array $keys) &#123; return array_map(function ($value) &#123; return $value !== false ? $value : null; &#125;, $this-&gt;command('mget', [$keys])); &#125; /** * Set the string value in argument as value of the key. * * @param string $key * @param mixed $value * @param string|null $expireResolution * @param int|null $expireTTL * @param string|null $flag * @return bool */ public function set($key, $value, $expireResolution = null, $expireTTL = null, $flag = null) &#123; return $this-&gt;command('set', [ $key, $value, $expireResolution ? [$flag, $expireResolution =&gt; $expireTTL] : null, ]); &#125; /** * Set the given key if it doesn't exist. * * @param string $key * @param string $value * @return int */ public function setnx($key, $value) &#123; return (int) $this-&gt;command('setnx', [$key, $value]); &#125; /** * Get the value of the given hash fields. * * @param string $key * @param mixed $dictionary * @return array */ public function hmget($key, ...$dictionary) &#123; if (count($dictionary) === 1) &#123; $dictionary = $dictionary[0]; &#125; return array_values($this-&gt;command('hmget', [$key, $dictionary])); &#125; /** * Set the given hash fields to their respective values. * * @param string $key * @param mixed $dictionary * @return int */ public function hmset($key, ...$dictionary) &#123; if (count($dictionary) === 1) &#123; $dictionary = $dictionary[0]; &#125; else &#123; $input = collect($dictionary); $dictionary = $input-&gt;nth(2)-&gt;combine($input-&gt;nth(2, 1))-&gt;toArray(); &#125; return $this-&gt;command('hmset', [$key, $dictionary]); &#125; /** * Set the given hash field if it doesn't exist. * * @param string $hash * @param string $key * @param string $value * @return int */ public function hsetnx($hash, $key, $value) &#123; return (int) $this-&gt;command('hsetnx', [$hash, $key, $value]); &#125; /** * Removes the first count occurrences of the value element from the list. * * @param string $key * @param int $count * @param mixed $value * @return int|false */ public function lrem($key, $count, $value) &#123; return $this-&gt;command('lrem', [$key, $value, $count]); &#125; /** * Removes and returns the first element of the list stored at key. * * @param mixed $arguments * @return array|null */ public function blpop(...$arguments) &#123; $result = $this-&gt;command('blpop', $arguments); return empty($result) ? null : $result; &#125; /** * Removes and returns the last element of the list stored at key. * * @param mixed $arguments * @return array|null */ public function brpop(...$arguments) &#123; $result = $this-&gt;command('brpop', $arguments); return empty($result) ? null : $result; &#125; /** * Removes and returns a random element from the set value at key. * * @param string $key * @param int|null $count * @return mixed|false */ public function spop($key, $count = 1) &#123; return $this-&gt;command('spop', [$key, $count]); &#125; /** * Add one or more members to a sorted set or update its score if it already exists. * * @param string $key * @param mixed $dictionary * @return int */ public function zadd($key, ...$dictionary) &#123; if (is_array(end($dictionary))) &#123; foreach (array_pop($dictionary) as $member =&gt; $score) &#123; $dictionary[] = $score; $dictionary[] = $member; &#125; &#125; $options = []; foreach (array_slice($dictionary, 0, 3) as $i =&gt; $value) &#123; if (in_array($value, ['nx', 'xx', 'ch', 'incr', 'NX', 'XX', 'CH', 'INCR'], true)) &#123; $options[] = $value; unset($dictionary[$i]); &#125; &#125; return $this-&gt;command('zadd', array_merge([$key], [$options], array_values($dictionary))); &#125; /** * Return elements with score between $min and $max. * * @param string $key * @param mixed $min * @param mixed $max * @param array $options * @return array */ public function zrangebyscore($key, $min, $max, $options = []) &#123; if (isset($options['limit'])) &#123; $options['limit'] = [ $options['limit']['offset'], $options['limit']['count'], ]; &#125; return $this-&gt;command('zRangeByScore', [$key, $min, $max, $options]); &#125; /** * Return elements with score between $min and $max. * * @param string $key * @param mixed $min * @param mixed $max * @param array $options * @return array */ public function zrevrangebyscore($key, $min, $max, $options = []) &#123; if (isset($options['limit'])) &#123; $options['limit'] = [ $options['limit']['offset'], $options['limit']['count'], ]; &#125; return $this-&gt;command('zRevRangeByScore', [$key, $min, $max, $options]); &#125; /** * Find the intersection between sets and store in a new set. * * @param string $output * @param array $keys * @param array $options * @return int */ public function zinterstore($output, $keys, $options = []) &#123; return $this-&gt;command('zinterstore', [$output, $keys, $options['weights'] ?? null, $options['aggregate'] ?? 'sum', ]); &#125; /** * Find the union between sets and store in a new set. * * @param string $output * @param array $keys * @param array $options * @return int */ public function zunionstore($output, $keys, $options = []) &#123; return $this-&gt;command('zunionstore', [$output, $keys, $options['weights'] ?? null, $options['aggregate'] ?? 'sum', ]); &#125; /** * Execute commands in a pipeline. * * @param callable|null $callback * @return \Redis|array */ public function pipeline(callable $callback = null) &#123; $pipeline = $this-&gt;client()-&gt;pipeline(); return is_null($callback) ? $pipeline : tap($pipeline, $callback)-&gt;exec(); &#125; /** * Execute commands in a transaction. * * @param callable|null $callback * @return \Redis|array */ public function transaction(callable $callback = null) &#123; $transaction = $this-&gt;client()-&gt;multi(); return is_null($callback) ? $transaction : tap($transaction, $callback)-&gt;exec(); &#125; /** * Evaluate a LUA script serverside, from the SHA1 hash of the script instead of the script itself. * * @param string $script * @param int $numkeys * @param mixed $arguments * @return mixed */ public function evalsha($script, $numkeys, ...$arguments) &#123; return $this-&gt;command('evalsha', [ $this-&gt;script('load', $script), $arguments, $numkeys, ]); &#125; /** * Evaluate a script and return its result. * * @param string $script * @param int $numberOfKeys * @param dynamic $arguments * @return mixed */ public function eval($script, $numberOfKeys, ...$arguments) &#123; return $this-&gt;command('eval', [$script, $arguments, $numberOfKeys]); &#125; /** * Subscribe to a set of given channels for messages. * * @param array|string $channels * @param \Closure $callback * @return void */ public function subscribe($channels, Closure $callback) &#123; $this-&gt;client-&gt;subscribe((array) $channels, function ($redis, $channel, $message) use ($callback) &#123; $callback($message, $channel); &#125;); &#125; /** * Subscribe to a set of given channels with wildcards. * * @param array|string $channels * @param \Closure $callback * @return void */ public function psubscribe($channels, Closure $callback) &#123; $this-&gt;client-&gt;psubscribe((array) $channels, function ($redis, $pattern, $channel, $message) use ($callback) &#123; $callback($message, $channel); &#125;); &#125; /** * Subscribe to a set of given channels for messages. * * @param array|string $channels * @param \Closure $callback * @param string $method * @return void */ public function createSubscription($channels, Closure $callback, $method = 'subscribe') &#123; // &#125; /** * Flush the selected Redis database. * * @return void */ public function flushdb() &#123; if (! $this-&gt;client instanceof RedisCluster) &#123; return $this-&gt;command('flushdb'); &#125; foreach ($this-&gt;client-&gt;_masters() as [$host, $port]) &#123; tap(new Redis)-&gt;connect($host, $port)-&gt;flushDb(); &#125; &#125; /** * Execute a raw command. * * @param array $parameters * @return mixed */ public function executeRaw(array $parameters) &#123; return $this-&gt;command('rawCommand', $parameters); &#125; /** * Run a command against the Redis database. * * @param string $method * @param array $parameters * @return mixed */ public function command($method, array $parameters = []) &#123; try &#123; return parent::command($method, $parameters); &#125; catch (RedisException $e) &#123; if (Str::contains($e-&gt;getMessage(), 'went away')) &#123; $this-&gt;client = $this-&gt;connector ? call_user_func($this-&gt;connector) : $this-&gt;client; &#125; throw $e; &#125; &#125; /** * Disconnects from the Redis instance. * * @return void */ public function disconnect() &#123; $this-&gt;client-&gt;close(); &#125; /** * Apply prefix to the given key if necessary. * * @param string $key * @return string */ private function applyPrefix($key) &#123; $prefix = (string) $this-&gt;client-&gt;getOption(Redis::OPT_PREFIX); return $prefix.$key; &#125; /** * Pass other method calls down to the underlying client. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; return parent::__call(strtolower($method), $parameters); &#125;&#125; Illuminate\Redis\Connections\PredisConnection.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?phpnamespace Illuminate\Redis\Connections;use Closure;use Illuminate\Contracts\Redis\Connection as ConnectionContract;use Predis\Command\ServerFlushDatabase;use Predis\Connection\Aggregate\ClusterInterface;/** * @mixin \Predis\Client * @deprecated Predis is no longer maintained by its original author */class PredisConnection extends Connection implements ConnectionContract&#123; /** * The Predis client. * * @var \Predis\Client */ protected $client; /** * Create a new Predis connection. * * @param \Predis\Client $client * @return void */ public function __construct($client) &#123; $this-&gt;client = $client; &#125; /** * Subscribe to a set of given channels for messages. * * @param array|string $channels * @param \Closure $callback * @param string $method * @return void */ public function createSubscription($channels, Closure $callback, $method = 'subscribe') &#123; $loop = $this-&gt;pubSubLoop(); call_user_func_array([$loop, $method], (array) $channels); foreach ($loop as $message) &#123; if ($message-&gt;kind === 'message' || $message-&gt;kind === 'pmessage') &#123; call_user_func($callback, $message-&gt;payload, $message-&gt;channel); &#125; &#125; unset($loop); &#125; /** * Flush the selected Redis database. * * @return void */ public function flushdb() &#123; if (! $this-&gt;client-&gt;getConnection() instanceof ClusterInterface) &#123; return $this-&gt;command('flushdb'); &#125; foreach ($this-&gt;getConnection() as $node) &#123; $node-&gt;executeCommand(new ServerFlushDatabase); &#125; &#125;&#125; RedisManager Illuminate\Redis\RedisManager.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260&lt;?phpnamespace Illuminate\Redis;use Closure;use Illuminate\Contracts\Redis\Factory;use Illuminate\Redis\Connections\Connection;use Illuminate\Redis\Connectors\PhpRedisConnector;use Illuminate\Redis\Connectors\PredisConnector;use Illuminate\Support\ConfigurationUrlParser;use InvalidArgumentException;/** * @mixin \Illuminate\Redis\Connections\Connection */class RedisManager implements Factory&#123; /** * The application instance. * * @var \Illuminate\Contracts\Foundation\Application */ protected $app; /** * The name of the default driver. * * @var string */ protected $driver; /** * The registered custom driver creators. * * @var array */ protected $customCreators = []; /** * The Redis server configurations. * * @var array */ protected $config; /** * The Redis connections. * * @var mixed */ protected $connections; /** * Indicates whether event dispatcher is set on connections. * * @var bool */ protected $events = false; /** * Create a new Redis manager instance. * * @param \Illuminate\Contracts\Foundation\Application $app * @param string $driver * @param array $config * @return void */ public function __construct($app, $driver, array $config) &#123; $this-&gt;app = $app; $this-&gt;driver = $driver; $this-&gt;config = $config; &#125; /** * Get a Redis connection by name. * * @param string|null $name * @return \Illuminate\Redis\Connections\Connection */ public function connection($name = null) &#123; $name = $name ?: 'default'; if (isset($this-&gt;connections[$name])) &#123; return $this-&gt;connections[$name]; &#125; return $this-&gt;connections[$name] = $this-&gt;configure( $this-&gt;resolve($name), $name ); &#125; /** * Resolve the given connection by name. * * @param string|null $name * @return \Illuminate\Redis\Connections\Connection * * @throws \InvalidArgumentException */ public function resolve($name = null) &#123; $name = $name ?: 'default'; $options = $this-&gt;config['options'] ?? []; if (isset($this-&gt;config[$name])) &#123; return $this-&gt;connector()-&gt;connect( $this-&gt;parseConnectionConfiguration($this-&gt;config[$name]), $options ); &#125; if (isset($this-&gt;config['clusters'][$name])) &#123; return $this-&gt;resolveCluster($name); &#125; throw new InvalidArgumentException("Redis connection [&#123;$name&#125;] not configured."); &#125; /** * Resolve the given cluster connection by name. * * @param string $name * @return \Illuminate\Redis\Connections\Connection */ protected function resolveCluster($name) &#123; return $this-&gt;connector()-&gt;connectToCluster( array_map(function ($config) &#123; return $this-&gt;parseConnectionConfiguration($config); &#125;, $this-&gt;config['clusters'][$name]), $this-&gt;config['clusters']['options'] ?? [], $this-&gt;config['options'] ?? [] ); &#125; /** * Configure the given connection to prepare it for commands. * * @param \Illuminate\Redis\Connections\Connection $connection * @param string $name * @return \Illuminate\Redis\Connections\Connection */ protected function configure(Connection $connection, $name) &#123; $connection-&gt;setName($name); if ($this-&gt;events &amp;&amp; $this-&gt;app-&gt;bound('events')) &#123; $connection-&gt;setEventDispatcher($this-&gt;app-&gt;make('events')); &#125; return $connection; &#125; /** * Get the connector instance for the current driver. * * @return \Illuminate\Contracts\Redis\Connector */ protected function connector() &#123; $customCreator = $this-&gt;customCreators[$this-&gt;driver] ?? null; if ($customCreator) &#123; return $customCreator(); &#125; switch ($this-&gt;driver) &#123; case 'predis': return new PredisConnector; case 'phpredis': return new PhpRedisConnector; &#125; &#125; /** * Parse the Redis connection configuration. * * @param mixed $config * @return array */ protected function parseConnectionConfiguration($config) &#123; $parsed = (new ConfigurationUrlParser)-&gt;parseConfiguration($config); return array_filter($parsed, function ($key) &#123; return ! in_array($key, ['driver', 'username'], true); &#125;, ARRAY_FILTER_USE_KEY); &#125; /** * Return all of the created connections. * * @return array */ public function connections() &#123; return $this-&gt;connections; &#125; /** * Enable the firing of Redis command events. * * @return void */ public function enableEvents() &#123; $this-&gt;events = true; &#125; /** * Disable the firing of Redis command events. * * @return void */ public function disableEvents() &#123; $this-&gt;events = false; &#125; /** * Set the default driver. * * @param string $driver * @return void */ public function setDriver($driver) &#123; $this-&gt;driver = $driver; &#125; /** * Register a custom driver creator Closure. * * @param string $driver * @param \Closure $callback * @return $this */ public function extend($driver, Closure $callback) &#123; $this-&gt;customCreators[$driver] = $callback-&gt;bindTo($this, $this); return $this; &#125; /** * Pass methods onto the default Redis connection. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; return $this-&gt;connection()-&gt;&#123;$method&#125;(...$parameters); &#125;&#125; RedisServiceProvider Illuminate\Redis\RedisServiceProvider.php 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace Illuminate\Redis;use Illuminate\Contracts\Support\DeferrableProvider;use Illuminate\Support\Arr;use Illuminate\Support\ServiceProvider;class RedisServiceProvider extends ServiceProvider implements DeferrableProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton('redis', function ($app) &#123; $config = $app-&gt;make('config')-&gt;get('database.redis', []); return new RedisManager($app, Arr::pull($config, 'client', 'phpredis'), $config); &#125;); $this-&gt;app-&gt;bind('redis.connection', function ($app) &#123; return $app['redis']-&gt;connection(); &#125;); &#125; /** * Get the services provided by the provider. * * @return array */ public function provides() &#123; return ['redis', 'redis.connection']; &#125;&#125; Application Illuminate\Foundation\Application.php 12345678910111213141516171819202122namespace Illuminate\Foundation;class Application extends Container&#123; /** * Register the core class aliases in the container. * * @return void */ public function registerCoreContainerAliases() &#123; foreach ([ 'redis' =&gt; [\Illuminate\Redis\RedisManager::class, \Illuminate\Contracts\Redis\Factory::class], 'redis.connection' =&gt; [\Illuminate\Redis\Connections\Connection::class, \Illuminate\Contracts\Redis\Connection::class], ] as $key =&gt; $aliases) &#123; foreach ($aliases as $alias) &#123; $this-&gt;alias($key, $alias); &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Log]]></title>
    <url>%2F2020%2F05%2F10%2FLaravel-Log%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 源码 Illuminate\Log\Logger.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196&lt;?phpnamespace Illuminate\Log;use Closuore;use Illuminate\Contracts\Events\Dispatcher;use Illuminate\Contracts\Support\Arrayable;use Illuminate\Contracts\Support\Jsonable;use Illuminate\Log\Events\MessageLogged;use Psr\Log\LoggerInterface;use RuntimeException;class Logger implements LoggerInterface&#123; /** * The underlying logger implementation. * * @var \Psr\Log\LoggerInterface */ protected $logger; /** * The event dispatcher instance. * * @var \Illuminate\Contracts\Events\Dispatcher|null */ protected $dispatcher; /** * Create a new log writer instance. * * @param \Psr\Log\LoggerInterface $logger * @param \Illuminate\Contracts\Events\Dispatcher|null $dispatcher * @return void */ public function __construct(LoggerInterface $logger, Dispatcher $dispatcher = null) &#123; $this-&gt;logger = $logger; $this-&gt;dispatcher = $dispatcher; &#125; /** * Log an emergency message to the logs. * * @param string $message * @param array $context * @return void */ public function emergency($message, array $context = []) &#123; $this-&gt;writeLog(__FUNCTION__, $message, $context); &#125; /** * Log a message to the logs. * * @param string $level * @param string $message * @param array $context * @return void */ public function log($level, $message, array $context = []) &#123; $this-&gt;writeLog($level, $message, $context); &#125; /** * Dynamically pass log calls into the writer. * * @param string $level * @param string $message * @param array $context * @return void */ public function write($level, $message, array $context = []) &#123; $this-&gt;writeLog($level, $message, $context); &#125; /** * Write a message to the log. * * @param string $level * @param string $message * @param array $context * @return void */ protected function writeLog($level, $message, $context) &#123; $this-&gt;logger-&gt;&#123;$level&#125;($message = $this-&gt;formatMessage($message), $context); $this-&gt;fireLogEvent($level, $message, $context); &#125; /** * Register a new callback handler for when a log event is triggered. * * @param \Closure $callback * @return void * * @throws \RuntimeException */ public function listen(Closure $callback) &#123; if (! isset($this-&gt;dispatcher)) &#123; throw new RuntimeException('Events dispatcher has not been set.'); &#125; $this-&gt;dispatcher-&gt;listen(MessageLogged::class, $callback); &#125; /** * Fires a log event. * * @param string $level * @param string $message * @param array $context * @return void */ protected function fireLogEvent($level, $message, array $context = []) &#123; // 如果设置了事件分配器，则将参数传递给日志侦听器。 // 这些对于构建概要分析器或其他工具（在给定的“请求”周期内汇总所有日志消息）很有用。 if (isset($this-&gt;dispatcher)) &#123; $this-&gt;dispatcher-&gt;dispatch(new MessageLogged($level, $message, $context)); &#125; &#125; /** * Format the parameters for the logger. * * @param mixed $message * @return mixed */ protected function formatMessage($message) &#123; if (is_array($message)) &#123; return var_export($message, true); &#125; elseif ($message instanceof Jsonable) &#123; return $message-&gt;toJson(); &#125; elseif ($message instanceof Arrayable) &#123; return var_export($message-&gt;toArray(), true); &#125; return $message; &#125; /** * Get the underlying logger implementation. * * @return \Psr\Log\LoggerInterface */ public function getLogger() &#123; return $this-&gt;logger; &#125; /** * Get the event dispatcher instance. * * @return \Illuminate\Contracts\Events\Dispatcher */ public function getEventDispatcher() &#123; return $this-&gt;dispatcher; &#125; /** * Set the event dispatcher instance. * * @param \Illuminate\Contracts\Events\Dispatcher $dispatcher * @return void */ public function setEventDispatcher(Dispatcher $dispatcher) &#123; $this-&gt;dispatcher = $dispatcher; &#125; /** * Dynamically proxy method calls to the underlying logger. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; return $this-&gt;logger-&gt;&#123;$method&#125;(...$parameters); &#125;&#125; Illuminate\Mail\Events\MessageSending.php 123456789101112131415161718192021222324252627282930313233&lt;?phpnamespace Illuminate\Mail\Events;class MessageSending&#123; /** * The Swift message instance. * * @var \Swift_Message */ public $message; /** * The message data. * * @var array */ public $data; /** * Create a new event instance. * * @param \Swift_Message $message * @param array $data * @return void */ public function __construct($message, $data = []) &#123; $this-&gt;data = $data; $this-&gt;message = $message; &#125;&#125; Illuminate\Log\ParsesLogConfiguration.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960namespace Illuminate\Log;use InvalidArgumentException;use Monolog\Logger as Monolog;trait ParsesLogConfiguration&#123; /** * The Log levels. * * @var array */ protected $levels = [ 'debug' =&gt; Monolog::DEBUG, 'info' =&gt; Monolog::INFO, 'notice' =&gt; Monolog::NOTICE, 'warning' =&gt; Monolog::WARNING, 'error' =&gt; Monolog::ERROR, 'critical' =&gt; Monolog::CRITICAL, 'alert' =&gt; Monolog::ALERT, 'emergency' =&gt; Monolog::EMERGENCY, ]; /** * Get fallback log channel name. * * @return string */ abstract protected function getFallbackChannelName(); /** * Parse the string level into a Monolog constant. * * @param array $config * @return int * * @throws \InvalidArgumentException */ protected function level(array $config) &#123; $level = $config['level'] ?? 'debug'; if (isset($this-&gt;levels[$level])) &#123; return $this-&gt;levels[$level]; &#125; throw new InvalidArgumentException('Invalid log level.'); &#125; /** * Extract the log channel from the given configuration. * * @param array $config * @return string */ protected function parseChannel(array $config) &#123; return $config['name'] ?? $this-&gt;getFallbackChannelName(); &#125;&#125; Illuminate\Log\LogServiceProvider 1234567891011121314151617181920&lt;?phpnamespace Illuminate\Log;use Illuminate\Support\ServiceProvider;class LogServiceProvider extends ServiceProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton('log', function ($app) &#123; return new LogManager($app); &#125;); &#125;&#125; Illuminate\Log\LogManager.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?phpnamespace Illuminate\Log;use Closure;use Illuminate\Support\Str;use InvalidArgumentException;use Monolog\Formatter\LineFormatter;use Monolog\Handler\ErrorLogHandler;use Monolog\Handler\FormattableHandlerInterface;use Monolog\Handler\HandlerInterface;use Monolog\Handler\RotatingFileHandler;use Monolog\Handler\SlackWebhookHandler;use Monolog\Handler\StreamHandler;use Monolog\Handler\SyslogHandler;use Monolog\Handler\WhatFailureGroupHandler;use Monolog\Logger as Monolog;use Psr\Log\LoggerInterface;use Throwable;class LogManager implements LoggerInterface&#123; use ParsesLogConfiguration; /** * The application instance. * * @var \Illuminate\Contracts\Foundation\Application */ protected $app; /** * The array of resolved channels. * * @var array */ protected $channels = []; /** * The registered custom driver creators. * * @var array */ protected $customCreators = []; /** * The standard date format to use when writing logs. * * @var string */ protected $dateFormat = 'Y-m-d H:i:s'; /** * Create a new Log manager instance. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public function __construct($app) &#123; $this-&gt;app = $app; &#125; /** * Register a custom driver creator Closure. * * @param string $driver * @param \Closure $callback * @return $this */ public function extend($driver, Closure $callback) &#123; $this-&gt;customCreators[$driver] = $callback-&gt;bindTo($this, $this); return $this; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的又一神器-锁]]></title>
    <url>%2F2020%2F05%2F09%2FMySQL%E7%9A%84%E5%8F%88%E4%B8%80%E7%A5%9E%E5%99%A8-%E9%94%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是锁锁的概述对于MySQL来说，锁是一个很重要的特性，数据库的锁是为了支持对共享资源进行并发访问，提供数据的完整性和一致性，这样才能保证在高并发的情况下，访问数据库的时候，数据不会出现问题。 锁的两个概念在数据库中，lock和latch都可以称为锁，但是意义却不同。 Latch一般称为闩锁（轻量级的锁），因为其要求锁定的时间必须非常短。若持续的时间长，则应用的性能会非常差，在InnoDB引擎中，Latch又可以分为mutex（互斥量）和rwlock（读写锁）。其目的是用来保证并发线程操作临界资源的正确性，并且通常没有死锁检测的机制。 Lock的对象是事务，用来锁定的是数据库中的对象，如表、页、行。并且一般lock的对象仅在事务commit或rollback后进行释放（不同事务隔离级别释放的时间可能不同）。 InnoDB存储引擎中的锁锁的粒度在数据库中，锁的粒度的不同可以分为表锁、页锁、行锁，这些锁的粒度之间也是会发生升级的，锁升级的意思就是讲当前锁的粒度降低，数据库可以把一个表的1000个行锁升级为一个页锁，或者将页锁升级为表锁，下面分别介绍一下这三种锁的粒度（参考自博客：https://blog.csdn.net/baolingye/article/details/102506072）。 表锁表级别的锁定是MySQL各存储引擎中最大颗粒度的锁定机制。该锁定机制最大的特点是实现逻辑非常简单，带来的系统负面影响最小。所以获取锁和释放锁的速度很快。由于表级锁一次会将整个表锁定，所以可以很好的避免困扰我们的死锁问题。 当然，锁定颗粒度大所带来最大的负面影响就是出现锁定资源争用的概率也会最高，致使并大度大打折扣。 使用表级锁定的主要是MyISAM，MEMORY，CSV等一些非事务性存储引擎。 特点：开销小，加锁快；不会出现死锁；锁定粒度大，发生锁冲突的概率最高，并发度最低。 页锁页级锁定是MySQL中比较独特的一种锁定级别，在其他数据库管理软件中也并不是太常见。页级锁定的特点是锁定颗粒度介于行级锁定与表级锁之间，所以获取锁定所需要的资源开销，以及所能提供的并发处理能力也同样是介于上面二者之间。另外，页级锁定和行级锁定一样，会发生死锁。 在数据库实现资源锁定的过程中，随着锁定资源颗粒度的减小，锁定相同数据量的数据所需要消耗的内存数量是越来越多的，实现算法也会越来越复杂。不过，随着锁定资源 颗粒度的减小，应用程序的访问请求遇到锁等待的可能性也会随之降低，系统整体并发度也随之提升。 使用页级锁定的主要是BerkeleyDB存储引擎。 特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般。 行锁行级锁定最大的特点就是锁定对象的粒度很小，也是目前各大数据库管理软件所实现的锁定颗粒度最小的。由于锁定颗粒度很小，所以发生锁定资源争用的概率也最小，能够给予应用程序尽可能大的并发处理能力而提高一些需要高并发应用系统的整体性能。 虽然能够在并发处理能力上面有较大的优势，但是行级锁定也因此带来了不少弊端。由于锁定资源的颗粒度很小，所以每次获取锁和释放锁需要做的事情也更多，带来的消耗自然也就更大了。此外，行级锁定也最容易发生死锁。 特点：开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。 比较表锁我们可以发现，这两种锁的特点基本都是相反的，而从锁的角度来说，表级锁更适合于以查询为主，只有少量按索引条件更新数据的应用，如Web应用；而行级锁则更适合于有大量按索引条件并发更新少量不同数据，同时又有并发查询的应用，如一些在线事务处理（OLTP）系统。 MySQL不同引擎支持的锁的粒度 锁的类型InnoDB存储引擎中存在着不同类型的锁，下面一一介绍一下。 S or X（共享锁、排他锁） 数据的操作其实只有两种，也就是读和写，而数据库在实现锁时，也会对这两种操作使用不同的锁；InnoDB实现了标准的行级锁，也就是共享锁（Shared Lock）和互斥锁（Exclusive Lock）。 共享锁（读锁）（S Lock），允许事务读一行数据。 排他锁（写锁）（X Lock），允许事务删除或更新一行数据。 IS or IX（共享、排他）意向锁 为了允许行锁和表锁共存，实现多粒度锁机制，InnoDB存储引擎支持一种额外的锁方式，就称为意向锁，意向锁在InnoDB中是表级锁，意向锁分为： 意向共享锁：表达一个事务想要获取一张表中某几行的共享锁。 意向排他锁：表达一个事务想要获取一张表中某几行的排他锁。 另外，这些锁之间的并不是一定可以共存的，有些锁之间是不兼容的，所谓兼容性就是指事务 A 获得一个某行某种锁之后，事务B同样的在这个行上尝试获取某种锁，如果能立即获取，则称锁兼容，反之叫冲突。 下面我们再看一下这两种锁的兼容性。 S or X（共享锁、排他锁）的兼容性 IS or IX（共享、排他）意向锁的兼容性 前面小结这里用一个思维导图把前面的概念做一个小结。 一致性非锁定读和一致性锁定读一致性锁定读（Locking Reads）在一个事务中查询数据时，普通的SELECT语句不会对查询的数据进行加锁，其他事务仍可以对查询的数据执行更新和删除操作。因此，InnoDB提供了两种类型的锁定读来保证额外的安全性： SELECT … LOCK IN SHARE MODE SELECT … FOR UPDATE SELECT … LOCK IN SHARE MODE：对读取的行添加S锁，其他事物可以对这些行添加S锁，若添加X锁，则会被阻塞。 SELECT … FOR UPDATE：会对查询的行及相关联的索引记录加X锁，其他事务请求的S锁或X锁都会被阻塞。当事务提交或回滚后，通过这两个语句添加的锁都会被释放。注意：只有在自动提交被禁用时，SELECT FOR UPDATE才可以锁定行，若开启自动提交，则匹配的行不会被锁定。 一致性非锁定读一致性非锁定读（consistent nonlocking read）是指InnoDB存储引擎通过多版本控制（MVVC）读取当前数据库中行数据的方式。如果读取的行正在执行DELETE或UPDATE操作，这时读取操作不会因此去等待行上锁的释放。相反地，InnoDB会去读取行的一个快照。所以，非锁定读机制大大提高了数据库的并发性。 一致性非锁定读是InnoDB默认的读取方式，即读取不会占用和等待行上的锁。在事务隔离级别READ COMMITTED和REPEATABLE READ下，InnoDB使用一致性非锁定读。 然而，对于快照数据的定义却不同。在READ COMMITTED事务隔离级别下，一致性非锁定读总是读取被锁定行的最新一份快照数据。而在REPEATABLE READ事务隔离级别下，则读取事务开始时的行数据版本。 下面我们通过一个简单的例子来说明一下这两种方式的区别。 首先创建一张表; 插入一条数据；1insert into lock_test values(1); 查看隔离级别；1select @@tx_isolation; 下面分为两种事务进行操作。 在REPEATABLE READ事务隔离级别下； 在REPEATABLE READ事务隔离级别下，读取事务开始时的行数据，所以当会话B修改了数据之后，通过以前的查询，还是可以查询到数据的。 在READ COMMITTED事务隔离级别下; 在READ COMMITTED事务隔离级别下，读取该行版本最新的一个快照数据，所以，由于B会话修改了数据，并且提交了事务，所以，A读取不到数据了。 行锁的算法InnoDB存储引擎有3种行锁的算法，其分别是： Record Lock：单个行记录上的锁。 Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。 Next-Key Lock：Gap Lock+Record Lock，锁定一个范围，并且锁定记录本身。 Record Lock：总是会去锁住索引记录，如果InnoDB存储引擎表在建立的时候没有设置任何一个索引，那么这时InnoDB存储引擎会使用隐式的主键来进行锁定。 Next-Key Lock：结合了Gap Lock和Record Lock的一种锁定算法，在Next-Key Lock算法下，InnoDB对于行的查询都是采用这种锁定算法。举个例子10，20，30，那么该索引可能被Next-Key Locking的区间为： 除了Next-Key Locking，还有Previous-Key Locking技术，这种技术跟Next-Key Lock正好相反，锁定的区间是区间范围和前一个值。同样上述的值，使用Previous-Key Locking技术，那么可锁定的区间为： 不是所有索引都会加上Next-key Lock的，这里有一种特殊的情况，在查询的列是唯一索引（包含主键索引）的情况下，Next-key Lock会降级为Record Lock。 接下来，我们来通过一个例子解释一下。 12345678910CREATE TABLE test ( x INT, y INT, PRIMARY KEY(x), // x是主键索引 KEY(y) // y是普通索引);INSERT INTO test select 3, 2;INSERT INTO test select 5, 3;INSERT INTO test select 7, 6;INSERT INTO test select 10, 8; 我们现在会话A中执行如下语句；1SELECT * FROM test WHERE y = 3 FOR UPDATE 我们分析一下这时候的加锁情况。 对于主键x 辅助索引y 用户可以通过以下两种方式来显示的关闭Gap Lock： 将事务的隔离级别设为 READ COMMITED。 将参数innodb_locks_unsafe_for_binlog设置为1。 Gap Lock的作用：是为了阻止多个事务将记录插入到同一个范围内，设计它的目的是用来解决Phontom Problem（幻读问题）。在MySQL默认的隔离级别（Repeatable Read）下，InnoDB就是使用它来解决幻读问题。 幻读：是指在同一事务下，连续执行两次同样的SQL语句可能导致不同的结果，第二次的SQL可能会返回之前不存在的行，也就是第一次执行和第二次执行期间有其他事务往里插入了新的行。 锁带来的问题脏读脏读：在不同的事务下，当前事务可以读到另外事务未提交的数据。另外我们需要注意的是默认的MySQL隔离级别是REPEATABLE READ是不会发生脏读的，脏读发生的条件是需要事务的隔离级别为READ UNCOMMITTED，所以如果出现脏读，可能就是这种隔离级别导致的。 下面我们通过一个例子看一下。 从上面这个例子可以看出，当我们的事务的隔离级别为READ UNCOMMITTED的时候，在会话A还没有提交时，会话B就能够查询到会话A没有提交的数据。 不可重复读不可重复读：是指在一个事务内多次读取同一集合的数据，但是多次读到的数据是不一样的，这就违反了数据库事务的一致性的原则。但是，这跟脏读还是有区别的，脏读的数据是没有提交的，但是不可重复读的数据是已经提交的数据。 我们通过下面的例子来看一下这种问题的发生。 从上面的例子可以看出，在A的一次会话中，由于会话B插入了数据，导致两次查询的结果不一致，所以就出现了不可重复读的问题。 我们需要注意的是不可重复读读取的数据是已经提交的数据，事务的隔离级别为READ COMMITTED，这种问题我们是可以接受的。 如果我们需要避免不可重复读的问题的发生，那么我们可以使用Next-Key Lock算法（设置事务的隔离级别为READ REPEATABLE）来避免，在MySQL中，不可重复读问题就是Phantom Problem，也就是幻像问题。 丢失更新丢失更新：指的是一个事务的更新操作会被另外一个事务的更新操作所覆盖，从而导致数据的不一致。在当前数据库的任何隔离级别下都不会导致丢失更新问题，要出现这个问题，在多用户计算机系统环境下有可能出现这种问题。 如何避免丢失更新的问题呢，我们只需要让事务的操作变成串行化，不要并行执行就可以。 我们一般使用SELECT … FOR UPDATE语句，给操作加上一个排他X锁。 小结这里我们做一个小结，主要是在不同的事务的隔离级别下出现的问题的对照，这样就更加清晰了。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是红黑树？]]></title>
    <url>%2F2020%2F05%2F08%2F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 红黑树是为了解决二叉查找树多次插入新节点而导致的不平衡。怎么理解？ 红黑树在什么情况下需要变色？什么情况下需要旋转？ 二叉查找树要学习红黑树，需要先来理解二叉查找树（Binary Search Tree）。 二叉查找树（BST）具备什么特性呢？ 1.左子树上所有结点的值均小于或等于它的根结点的值。 2.右子树上所有结点的值均大于或等于它的根结点的值。 3.左、右子树也分别为二叉排序树。 下图中这棵树，就是一颗典型的二叉查找树： 这样的数据结构有什么好处呢？我们来试着查找一下值为10的节点。 1.查看根节点9： 2.由于10 &gt; 9，因此查看右孩子13： 3.由于10 &lt; 13，因此查看左孩子11： 4.由于10 &lt; 11，因此查看左孩子10，发现10正是要查找的节点： 这种方式正是二分查找的思想，查找所需的最大次数等同于二叉查找树的高度。 在插入节点的时候也是利用类似的方法，通过一层一层比较大小，找到新节点适合插入的位置。 二叉查找树是个强大的数据结构，但仍然有存在它的缺陷。 缺陷体现在插入新节点的时候。让我们来看看下面这种情形： 假设初始的二叉查找树只有三个节点，根节点值为9，左孩子值为8，右孩子值为12： 接下来我们依次插入如下五个节点：7，6，5，4，3。依照二叉查找树的特性，结果会变成什么样呢？ 好好的二叉树变成瘸子了。这样的形态虽然也符合二叉查找树的特性，但是查找的性能大打折扣，几乎变成了线性。 如何解决二叉查找树多次插入新节点而导致的不平衡呢？我们的主角[红黑树]应运而生了。 红黑树红黑树（Red Black Tree）是一种自平衡的二叉查找树。除了符合二叉查找树的基本特性外，它还具有下列的附加特性： 1.节点是红色或黑色。 2.根节点是黑色。 3.每个叶子节点都是黑色的空节点（NIL节点）。 4.每个红色节点的两个子节点都是黑色。（从每个叶子到根的所有路径上不能有两个连续的红色节点） 5.从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点。 下图中这棵树，就是一颗典型的红黑树： 因为这些规则限制，才保证了红黑树的自平衡。红黑树从根到叶子的最长路径不会超过最短路径的2倍。 当插入或删除节点的时候，红黑权的规则有可能被打破。这时候就需要做出一些调整，来继续维持我们的规则。 什么情况下会破坏红黑树的规则，什么情况下不会破坏规则呢？我们举两个简单的例子： 1.向原红黑树插入值为14的新节点： 由于父节点15是黑色节点，因此这种情况并不会破坏红黑树的规则，无需做任何调整。 2.向原红黑树插入值为21的新节点： 由于父节点22是红色节点，因此这种情况打破了红黑树的规则4（每个红色节点的两个子节点都是黑色），必须进行调整，使之重新符合红黑树的规则。 那么，我们需要做出怎样的调整，才能保证一颗红黑树始终是红黑树呢？ 调整有两种方法: [变色]和[旋转]。而旋转又分成两种形式：[左旋转]和[右旋转]。 变色： 为了重新符合红黑树的规则，尝试把红色节点变为黑色，或者把黑色节点变为红色。 下图所表示的是红黑树的一部分，需要注意节点25并非根节点。因为节点21和节点22连续出现了红色，不符合规则4，所以把节点22从红色变成黑色： 但这样并不算完，因为凭空多出的黑色节点打破了规则5，所以发生连锁反应，需要继续把节点25从黑色变成红色： 此时仍然没有结束，因为节点25和节点27又形成了两个连续的红色节点，需要继续把节点27从红色变成黑色： 左旋转： 逆时针旋转红黑树的两个节点，使得父节点被自己的右孩子取代，而自己成为自己的左孩子。说起来很怪异，大家看下图： 图中，身为右孩子的Y取代了X的位置，而X变成了自己的左孩子。此为左旋转。 右旋转： 顺时针旋转红黑树的两个节点，使得父节点被自己的左孩子取代，而自己成为自己的右孩子。大家看下图： 图中，身为左孩子的Y取代了X的位置，而X变成了自己的右孩子。此为右旋转。 究竟什么时候用到变色，什么时候用到旋转呢？ 红黑树的插入和删除包含很多种情况，每一种情况都有不同的处理方式。在这里我们举一个典型例子，大家体会一下。 我们以刚才插入节点21的情况为例： 首先，我们需要做的是变色，把节点25及其下方的节点变色： 此时节点17和节点25是连续的两个红色节点，那么把节点17变成黑色节点？恐怕不合适。这样一来不但打破了规则4，而且根据规则2（根节点是黑色），也不可能把节点13变成红色节点。 变色已无法解决问题，我们把节点13看做X，把节点17看做Y，像刚才的示意图那样进行左旋转： 由于根节点必须是黑色节点，所以需要变色，变色结果如下： 这样就结束了吗？并没有。因为其中两条路径（17 -&gt; 8 -&gt; 6 -&gt; NIL）的黑色节点个数是4，其他路径的黑色节点个数是3，不符合规则5。 这时候我们需要把节点13看做X，节点8看做Y，像刚才的示意图那样进行右旋转： 最后根据规则来进行变色： 如此一来，我们的红黑树变得重新符合规则。这一个例子的调整过程比较复杂，经历了如下步骤： 变色 -&gt; 左旋转 -&gt; 变色 -&gt; 右旋转 -&gt; 变色 红黑树的应用有很多，其中JDK的集合类TreeMap和TreeSet底层就是红黑树实现的。在Java8中，连HashMap也用到了红黑树。 几点说明： 1.关于红黑树自平衡的调整，插入和删除节点的时候都涉及到很多种Case，由于篇幅原因无法展开来一一列举，有兴趣的朋友可以参考维基百科，里面讲的非常清晰。 2.漫画中红黑树调整过程的示例是一种比较复杂的情形，没太看明白的小伙伴也不必钻牛角尖，关键要懂得红黑树自平衡调整的主体思想。 PHP实现红黑树123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350&lt;?php/** * 红黑树 * 1.节点是红色或黑色 * 2.根是黑色 * 3.所有的叶子节点都是黑色 * 4.每个红色节点必须有两个黑色节点 * 5.从任一节点到其叶子节点的简单路径都包含相同数量的黑色节点 * */class Node&#123; private $id; /** * @var * 1 =&gt; red * 2 =&gt; black */ private $color = 1; private $value = null; public $parent = 0; public $left = 0; public $right = 0; public function __construct($value) &#123; $this-&gt;id = uniqid(); $this-&gt;value = $value; &#125; public function getID() &#123; return $this-&gt;id; &#125; public function getValue() &#123; return $this-&gt;value; &#125; public function setColor($color) &#123; $this-&gt;color = $color; &#125; public function getColor() &#123; return $this-&gt;color; &#125;&#125;class RedBlackTree&#123; public $root = 0; private $nodePool = []; private $nil; public function __construct() &#123; $nilNode = new Node(null); $nilNode-&gt;setColor(2); $this-&gt;addNodeToPool($nilNode-&gt;getID(), $nilNode); $this-&gt;nil = $nilNode-&gt;getID(); $this-&gt;root = $this-&gt;nil; &#125; public function addNodeToPool($id, $object) &#123; $this-&gt;nodePool[$id] = $object; &#125; /** * @param $id * @return Node */ public function getNodeFromPool($id) &#123; return isset($this-&gt;nodePool[$id]) ? $this-&gt;nodePool[$id] : null; &#125; public function find($value) &#123; $tmp = $this-&gt;getNodeFromPool($this-&gt;root); while (!is_null($tmp-&gt;getValue())) &#123; if ($tmp-&gt;getValue() &gt; $value) &#123; $tmp = $this-&gt;getNodeFromPool($tmp-&gt;left); &#125; else if ($tmp-&gt;getValue() &lt; $value) &#123; $tmp = $this-&gt;getNodeFromPool($tmp-&gt;right); &#125; else &#123; return true; &#125; &#125; return false; &#125; public function walk($nodeID) &#123; var_dump($this-&gt;root); var_dump($this-&gt;nodePool); &#125; public function insert($value) &#123; $tmpNode = $this-&gt;getNodeFromPool($this-&gt;root); $prevNode = $tmpNode; while (!is_null($tmpNode-&gt;getValue())) &#123; $prevNode = $tmpNode; if ($tmpNode-&gt;getValue() &gt; $value) &#123; $tmpNode = $this-&gt;getNodeFromPool($tmpNode-&gt;left); &#125; else &#123; $tmpNode = $this-&gt;getNodeFromPool($tmpNode-&gt;right); &#125; &#125; $newNode = new Node($value); $newNode-&gt;left = $this-&gt;nil; $newNode-&gt;right = $this-&gt;nil; $newNode-&gt;parent = $prevNode-&gt;getID(); $this-&gt;addNodeToPool($newNode-&gt;getID(), $newNode); if (is_null($prevNode-&gt;getValue())) &#123; //第一个节点 $newNode-&gt;setColor(2); $this-&gt;root = $newNode-&gt;getID(); &#125; else if ($prevNode-&gt;getValue() &gt; $newNode-&gt;getValue()) &#123; $prevNode-&gt;left = $newNode-&gt;getID(); &#125; else &#123; $prevNode-&gt;right = $newNode-&gt;getID(); &#125; $this-&gt;insertFix($newNode-&gt;getID()); return true; &#125; protected function insertFix($node) &#123; $tmpNode = $this-&gt;getNodeFromPool($node); while (!is_null($tmpNode-&gt;getValue()) &amp;&amp; ($this-&gt;getNodeFromPool($tmpNode-&gt;parent)-&gt;getColor() == 1)) &#123; $grandP = $this-&gt;getNodeFromPool($this-&gt;getNodeFromPool($tmpNode-&gt;parent)-&gt;parent); $parent = $this-&gt;getNodeFromPool($tmpNode-&gt;parent); if ($tmpNode-&gt;parent == $grandP-&gt;left) &#123; $rightUncle = $this-&gt;getNodeFromPool($grandP-&gt;right); if ($rightUncle-&gt;getColor() == 1) &#123; $parent-&gt;setColor(2); $rightUncle-&gt;setColor(2); $grandP-&gt;setColor(1); $tmpNode = $grandP; &#125; else if ($tmpNode-&gt;getID() == $parent-&gt;right) &#123; $this-&gt;leftRotate($tmpNode-&gt;getID()); $tmpNode = $parent; $this-&gt;rightRotate($tmpNode-&gt;parent, true); &#125; else &#123; $this-&gt;rightRotate($tmpNode-&gt;getID(), true); &#125; &#125; else &#123; $leftUncle = $this-&gt;getNodeFromPool($grandP-&gt;left); if ($leftUncle-&gt;getColor() == 1) &#123; $parent-&gt;setColor(2); $leftUncle-&gt;setColor(2); $grandP-&gt;setColor(1); $tmpNode = $grandP; &#125; else if ($tmpNode-&gt;getID() == $parent-&gt;left) &#123; $this-&gt;rightRotate($tmpNode-&gt;getID()); $tmpNode = $parent; $this-&gt;leftRotate($tmpNode-&gt;parent, true); &#125; else &#123; $this-&gt;leftRotate($tmpNode-&gt;getID(), true); &#125; &#125; $this-&gt;getNodeFromPool($this-&gt;root)-&gt;setColor(2); &#125; &#125; protected function leftRotate($nodeID, $changeColor = false) &#123; $node = $this-&gt;getNodeFromPool($nodeID); $parentID = $node-&gt;parent; $parent = $this-&gt;getNodeFromPool($parentID); $grandPID = $parent-&gt;parent; $grandP = $this-&gt;getNodeFromPool($grandPID); if (is_null($grandP-&gt;getValue())) &#123; $this-&gt;root = $nodeID; &#125; else &#123; if ($grandP-&gt;left == $parentID) &#123; $grandP-&gt;left = $nodeID; &#125; else &#123; $grandP-&gt;right = $nodeID; &#125; &#125; if ($changeColor) &#123; $node-&gt;setColor(2); $parent-&gt;setColor(1); &#125; $leftNode = $this-&gt;getNodeFromPool($node-&gt;left); if (!is_null($leftNode-&gt;getValue())) &#123; $leftNode-&gt;parent = $parentID; &#125; $parent-&gt;right = $node-&gt;left; $parent-&gt;parent = $nodeID; $node-&gt;parent = $grandPID; $node-&gt;left = $parentID; &#125; protected function rightRotate($nodeID, $changeColor = false) &#123; $node = $this-&gt;getNodeFromPool($nodeID); $parentID = $node-&gt;parent; $parent = $this-&gt;getNodeFromPool($parentID); $grandPID = $parent-&gt;parent; $grandP = $this-&gt;getNodeFromPool($grandPID); if (is_null($grandP-&gt;getValue())) &#123; $this-&gt;root = $nodeID; &#125; else &#123; if ($grandP-&gt;left == $parentID) &#123; $grandP-&gt;left = $nodeID; &#125; else &#123; $grandP-&gt;right = $nodeID; &#125; &#125; if ($changeColor) &#123; $node-&gt;setColor(2); $parent-&gt;setColor(1); &#125; $rightNode = $this-&gt;getNodeFromPool($node-&gt;right); if (!is_null($rightNode-&gt;getValue())) &#123; $rightNode-&gt;parent = $parentID; &#125; $parent-&gt;left = $node-&gt;right; $parent-&gt;parent = $nodeID; $node-&gt;parent = $grandPID; $node-&gt;right = $parentID; &#125; public function delete($value) &#123; //TODO &#125;&#125;$test = [12, 550, 300, 20, 1, 50, 44, 34, 24, 25, 79, 11, 21, 1000, 3000, 99];$testH = [12, 550, 300, 20, 1, 50, 44, 34, 24, 25, 79, 19, 99];echo '&lt;pre&gt;';$tree = new RedBlackTree();foreach ($test as $value) &#123; $tree-&gt;insert($value);&#125;foreach ($testH as $v) &#123; if ($tree-&gt;find($v)) &#123; echo 'true;'; &#125; else &#123; echo 'false;'; &#125;&#125;// $tree-&gt;walk($tree-&gt;root);]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[图解B树B+树算法]]></title>
    <url>%2F2020%2F05%2F07%2F%E5%9B%BE%E8%A7%A3B%E6%A0%91B-%E6%A0%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： B树在介绍B+树之前，先简单的介绍一下B树，这两种数据结构既有相似之处，也有他们的区别，最后，我们也会对比一下这两种数据结构的区别。 B树概念B树也称B-树，它是一颗多路平衡查找树。二叉树我想大家都不陌生，其实，B树和后面讲到的B+树也是从最简单的二叉树变换而来的，并没有什么神秘的地方，下面我们来看看B树的定义。 每个节点最多有m-1个关键字（可以存有的键值对）。 根节点最少可以只有1个关键字。 非根节点至少有m/2个关键字。 每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。 所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。 每个节点都存有索引和数据，也就是对应的key和value。 所以，根节点的关键字数量范围：1 &lt;= k &lt;= m-1，非根节点的关键字数量范围：m/2 &lt;= k &lt;= m-1。 另外，我们需要注意一个概念，描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。 我们再举个例子来说明一下上面的概念，比如这里有一个5阶的B树，根节点数量范围：1 &lt;= k &lt;= 4，非根节点数量范围：2 &lt;= k &lt;= 4。 下面，我们通过一个插入的例子，讲解一下B树的插入过程，接着，再讲解一下删除关键字的过程。 B树插入插入的时候，我们需要记住一个规则：判断当前结点key的个数是否小于等于m-1，如果满足，直接插入即可，如果不满足，将节点的中间的key将这个节点分为左右两部分，中间的节点放到父节点中即可。 例子：在5阶B树中，结点最多有4个key，最少有2个key（注意：下面的节点统一用一个节点表示key和value）。 插入18，70，50，40 插入22 插入22时，发现这个节点的关键字已经大于4了，所以需要进行分裂，分裂的规则在上面已经讲了，分裂之后，如下。 接着插入23，25，39 分裂，得到下面的。 更过的插入的过程就不多介绍了，相信有这个例子你已经知道怎么进行插入操作了。 B树的删除操作B树的删除操作相对于插入操作是相对复杂一些的，但是，你知道记住几种情况，一样可以很轻松的掌握的。 现在有一个初始状态是下面这样的B树，然后进行删除操作。 删除15，这种情况是删除叶子节点的元素，如果删除之后，节点数还是大于m/2，这种情况只要直接删除即可。 接着，我们把22删除，这种情况的规则：22是非叶子节点，对于非叶子节点的删除，我们需要用后继key（元素）覆盖要删除的key，然后在后继key所在的子支中删除该后继key。对于删除22，需要将后继元素24移到被删除的22所在的节点。 此时发现26所在的节点只有一个元素，小于2个（m/2），这个节点不符合要求，这时候的规则（向兄弟节点借元素）：如果删除叶子节点，如果删除元素后元素个数少于（m/2），并且它的兄弟节点的元素大于（m/2），也就是说兄弟节点的元素比最少值m/2还多，将先将父节点的元素移到该节点，然后将兄弟节点的元素再移动到父节点。这样就满足要求了。 我们看看操作过程就更加明白了。 接着删除28，删除叶子节点，删除后不满足要求，所以，我们需要考虑向兄弟节点借元素，但是，兄弟节点也没有多的节点（2个），借不了，怎么办呢？如果遇到这种情况，首先，还是将先将父节点的元素移到该节点，然后，将当前节点及它的兄弟节点中的key合并，形成一个新的节点。 移动之后，跟兄弟节点合并。 删除就只有上面的几种情况，根据不同的情况进行删除即可。 上面的这些介绍，相信对于B树已经有一定的了解了，接下来的一部分，我们接着讲解B+树，我相信加上B+树的对比，就更加清晰明了了。 B+树B+树概述B+树其实和B树是非常相似的，我们首先看看相同点。 根节点至少一个元素。 非根节点元素范围：m/2 &lt;= k &lt;= m-1。 不同点 B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。 内部结点中的key都按照从小到大的顺序排列，对于内部结点中的一个key，左树中的所有key都小于它，右子树中的key都大于等于它。叶子结点中的记录也按照key的大小排列。 每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。 父节点存有右孩子的第一个元素的索引。 下面我们看一个B+树的例子，感受感受它吧！ 插入操作对于插入操作很简单，只需要记住一个技巧即可：当节点元素数量大于m-1的时候，按中间元素分裂成左右两部分，中间元素分裂到父节点当做索引存储，但是，本身中间元素还是分裂右边这一部分的。 下面以一颗5阶B+树的插入过程为例，5阶B+树的节点最少2个元素，最多4个元素。 插入5，10，15，20 插入25，此时元素数量大于4个了，分裂 接着插入26，30，继续分裂 有了这几个例子，相信插入操作没什么问题了，下面接着看看删除操作。 删除操作对于删除操作是比B树简单一些的，因为叶子节点有指针的存在，向兄弟节点借元素时，不需要通过父节点了，而是可以直接通过兄弟节移动即可（前提是兄弟节点的元素大于m/2），然后更新父节点的索引；如果兄弟节点的元素不大于m/2（兄弟节点也没有多余的元素），则将当前节点和兄弟节点合并，并且删除父节点中的key，下面我们看看具体的实例。 初始状态 删除10，删除后，不满足要求，发现左边兄弟节点有多余的元素，所以去借元素，最后，修改父节点索引。 删除元素5，发现不满足要求，并且发现左右兄弟节点都没有多余的元素，所以，可以选择和兄弟节点合并，最后修改父节点索引。 发现父节点索引也不满足条件，所以，需要做跟上面一步一样的操作。 这样，B+树的删除操作也就完成了，是不是看完之后，觉得非常简单！ B树和B+树总结B+树相对于B树有一些自己的优势，可以归结为下面几点。 单一节点存储的元素更多，使得查询的IO次数更少，所以也就使得它更适合做为数据库MySQL的底层数据结构了。 所有的查询都要查找到叶子节点，查询性能是稳定的，而B树，每个节点都可以查找到数据，所以不稳定。 所有的叶子节点形成了一个有序链表，更加便于查找。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[为什么MySQL用B+树做索引？]]></title>
    <url>%2F2020%2F05%2F07%2F%E4%B8%BA%E4%BB%80%E4%B9%88MySQL%E7%94%A8B-%E6%A0%91%E5%81%9A%E7%B4%A2%E5%BC%95%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： B+树就是从二叉查找树，平衡二叉树和B树这三种数据结构演化来的。怎么理解？ 聚簇索引和非聚簇索引的区别在于主键。怎么理解？ 平衡二叉树又称AVL树。每个节点的左右子树的高度差不能超过1。怎么理解？ 为什么把尽量多的数据放进磁盘块中？ B+树索引按照存储方式的不同分为聚集索引和非聚集索引。为什么？ 为什么要寻找一种单个节点可以存储多个键值和数据的平衡树？ 索引这个词，相信大多数人已经相当熟悉了，很多人都知道MySQL的索引主要以B+树为主，但是要问到为什么用B+树，恐怕很少有人能把前因后果讲述的很完整。本文就来从头到尾介绍下数据库的索引。 索引是一种数据结构，用于帮助我们在大量数据中快速定位到我们想要查找的数据。索引最形象的比喻就是图书的目录了。注意这里的大量，数据量大了索引才显得有意义，如果我想要在[1,2,3,4]中找到4这个数据，直接对全数据检索也很快，没有必要费力气建索引再去查找。索引在MySQL数据库中分三类： B+树索引、Hash索引、全文索引 我们今天要介绍的是工作开发中最常接触到的InnoDB存储引擎中的B+树索引。 要介绍B+树索引，就不得不提二叉查找树，平衡二叉树和B树这三种数据结构。B+树就是从他们仨演化来的。 二叉查找树首先，让我们先看一张图。 从图中可以看到，我们为user表（用户信息表）建立了一个二叉查找树的索引。图中的圆为二叉查找树的节点，节点中存储了键（key）和数据（data）。 键对应user表中的id，数据对应user表中的行数据。二叉查找树的特点就是任何节点的左子节点的键值都小于当前节点的键值，右子节点的键值都大于当前节点的键值。顶端的节点我们称为根节点，没有子节点的节点我们称之为叶节点。 如果我们需要查找id=12的用户信息，利用我们创建的二叉查找树索引，查找流程如下： 1，将根节点作为当前节点，把12与当前节点的键值10比较，12大于10，接下来我们把当前节点的右子节点作为当前节点。 2，继续把12和当前节点的键值13比较，发现12小于13，把当前节点的左子节点作为当前节点。 3，把12和当前节点的键值12对比，12等于12，满足条件，我们从当前节点中取出data，即id=12,name=xm。 利用二叉查找树我们只需要3次即可找到匹配的数据。如果在表中一条条的查找的话，我们需要6次才能找到。 平衡二叉树上面我们讲解了利用二叉查找树可以快速的找到数据。但是，如果上面的二叉查找树是这样的构造： 这个时候可以看到我们的二叉查找树变成了一个链表。 如果我们需要查找id=17的用户信息，我们需要查找7次，也就相当于全表扫描了。 导致这个现象的原因其实是二叉查找树变得不平衡了，也就是高度太高了，从而导致查找效率的不稳定。 为了解决这个问题，我们需要保证二叉查找树一直保持平衡，就需要用到平衡二叉树了。 平衡二叉树又称AVL树，在满足二叉查找树特性的基础上，要求每个节点的左右子树的高度差不能超过1。 下面是平衡二叉树和非平衡二叉树的对比： 由平衡二叉树的构造我们可以发现第一张图中的二叉树其实就是一棵平衡二叉树。 平衡二叉树保证了树的构造是平衡的，当我们插入或删除数据导致平衡二叉树不平衡时，平衡二叉树会进行调整树上的节点来保持平衡。具体的调整方式这里就不介绍了。 平衡二叉树相比于二叉查找树来说，查找效率更稳定，总体的查找速度也更快。 B树因为内存的易失性。一般情况下，我们都会选择将user表中的数据和索引存储在磁盘这种外围设备中。 但是和内存相比，从磁盘中读取数据的速度会慢上百倍千倍甚至万倍，所以，我们应当尽量减少从磁盘中读取数据的次数。另外，从磁盘中读取数据时，都是按照磁盘块来读取的，并不是一条一条的读。 如果我们能把尽量多的数据放进磁盘块中，那一次磁盘读取操作就会读取更多数据，那我们查找数据的时间也会大幅度降低。 如果我们用树这种数据结构作为索引的数据结构，那我们每查找一次数据就需要从磁盘中读取一个节点，也就是我们说的一个磁盘块，我们都知道平衡二叉树可是每个节点只存储一个键值和数据的。 那说明什么？ 说明每个磁盘块仅仅存储一个键值和数据！ 那如果我们要存储海量的数据呢？ 可以想象到二叉树的节点将会非常多，高度也会极其高，我们查找数据时也会进行很多次磁盘IO，我们查找数据的效率将会极低！ 为了解决平衡二叉树的这个弊端，我们应该寻找一种单个节点可以存储多个键值和数据的平衡树。也就是我们接下来要说的B树。 B树（Balance Tree）即为平衡树的意思，下图即是一颗B树。 图中的p节点为指向子节点的指针，二叉查找树和平衡二叉树其实也有，因为图的美观性，被省略了。图中的每个节点称为页，页就是我们上面说的磁盘块，在MySQL中数据读取的基本单位都是页，所以我们这里叫做页更符合MySQL中索引的底层数据结构。 从上图可以看出，B树相对于平衡二叉树，每个节点存储了更多的键值（key）和数据（data），并且每个节点拥有更多的子节点，子节点的个数一般称为阶，上述图中的B树为3阶B树，高度也会很低。 基于这个特性，B树查找数据读取磁盘的次数将会很少，数据的查找效率也会比平衡二叉树高很多。 假如我们要查找id=28的用户信息，那么我们在上图B树中查找的流程如下： 1，先找到根节点也就是页1，判断28在键值17和35之间，我们那么我们根据页1中的指针p2找到页3。 2，将28和页3中的键值相比较，28在26和30之间，我们根据页3中的指针p2找到页8。 3，将28和页8中的键值相比较，发现有匹配的键值28，键值28对应的用户信息为(28,bv)。 B+树B+树是对B树的进一步优化。让我们先来看下B+树的结构图： 根据上图我们来看下B+树和B树有什么不同。 1，B+树非叶子节点上是不存储数据的，仅存储键值，而B树节点中不仅存储键值，也会存储数据。之所以这么做是因为在数据库中页的大小是固定的，InnoDB中页的默认大小是16KB。如果不存储数据，那么就会存储更多的键值，相应的树的阶数（节点的子节点树）就会更大，树就会更矮更胖，如此一来我们查找数据进行磁盘的IO次数又会再次减少，数据查询的效率也会更快。另外，B+树的阶数是等于键值的数量的，如果我们的B+树一个节点可以存储1000个键值，那么3层B+树可以存储1000×1000×1000=10亿个数据。一般根节点是常驻内存的，所以一般我们查找10亿数据，只需要2次磁盘IO。 2，因为B+树索引的所有数据均存储在叶子节点，而且数据是按照顺序排列的。那么B+树使得范围查找，排序查找，分组查找以及去重查找变得异常简单。而B树因为数据分散在各个节点，要实现这一点是很不容易的。 有心的读者可能还发现上图B+树中各个页之间是通过双向链表连接的，叶子节点中的数据是通过单向链表连接的。 其实上面的B树我们也可以对各个节点加上链表。其实这些不是它们之前的区别，是因为在MySQL的InnoDB存储引擎中，索引就是这样存储的。也就是说上图中的B+树索引就是InnoDB中B+树索引真正的实现方式，准确的说应该是聚集索引（聚集索引和非聚集索引下面会讲到）。 通过上图可以看到，在InnoDB中，数据页之间通过双向链表连接以及叶子节点中数据通过单向链表连接的方式可以找到表中所有的数据。 MyISAM中的B+树索引实现与InnoDB中的略有不同。在MyISAM中，B+树索引的叶子节点并不存储数据，而是存储数据的文件地址。 聚集索引 VS 非聚集索引在上节介绍B+树索引的时候，我们提到了图中的索引其实是聚集索引的实现方式。那什么是聚集索引呢？ 在MySQL中，B+树索引按照存储方式的不同分为聚集索引和非聚集索引。 这里我们着重介绍InnoDB中的聚集索引和非聚集索引。 1，聚集索引（聚簇索引）：以InnoDB作为存储引擎的表，表中的数据都会有一个主键，即使你不创建主键，系统也会帮你创建一个隐式的主键。这是因为InnoDB是把数据存放在B+树中的，而B+树的键值就是主键，在B+树的叶子节点中，存储了表中所有的数据。这种以主键作为B+树索引的键值而构建的B+树索引，我们称之为聚集索引。 2，非聚集索引（非聚簇索引）：以主键以外的列值作为键值构建的B+树索引，我们称之为非聚集索引。非聚集索引与聚集索引的区别在于非聚集索引的叶子节点不存储表中的数据，而是存储该列对应的主键，想要查找数据我们还需要根据主键再去聚集索引中进行查找，这个再根据聚集索引查找数据的过程，我们称为回表。 明白了聚集索引和非聚集索引的定义，我们应该明白这样一句话：数据即索引，索引即数据。 利用聚集索引和非聚集索引查找数据前面我们讲解B+树索引的时候并没有去说怎么在B+树中进行数据的查找，主要就是因为还没有引出聚集索引和非聚集索引的概念。下面我们通过讲解如何通过聚集索引以及非聚集索引查找数据表中数据的方式介绍一下B+树索引查找数据方法。 利用聚集索引查找数据 还是这张B+树索引图，现在我们应该知道这就是聚集索引，表中的数据存储在其中。现在假设我们要查找id&gt;=18并且id=18 and id &lt;40，其中id为主键。具体的查找过程如下： 1，一般根节点都是常驻内存的，也就是说页1已经在内存中了，此时不需要到磁盘中读取数据，直接从内存中读取即可。 从内存中读取到页1，要查找这个id&gt;=18 and id &lt;40或者范围值，我们首先需要找到id=18的键值。 从页1中我们可以找到键值18，此时我们需要根据指针p2，定位到页3。 2，要从页3中查找数据，我们就需要拿着p2指针去磁盘中进行读取页3。 从磁盘中读取页3后将页3放入内存中，然后进行查找，我们可以找到键值18，然后再拿到页3中的指针p1，定位到页8。 3，同样的页8也不在内存中，我们需要再去磁盘中将页8读取到内存中。 将页8读取到内存中后。 因为页中的数据是链表进行连接的，而且键值是按照顺序存放的，此时可以根据二分查找法定位到键值18。 此时因为已经到数据页了，此时我们已经找到一条满足条件的数据了，就是键值18对应的数据。 因为是范围查找，而且此时所有的数据又都存在叶子节点，并且是有序排列的，那么我们就可以对页8中的键值依次进行遍历查找并匹配满足条件的数据。 我们可以一直找到键值为22的数据，然后页8中就没有数据了，此时我们需要拿着页8中的p指针去读取页9中的数据。 4，因为页9不在内存中，就又会加载页9到内存中，并通过和页8中一样的方式进行数据的查找，直到将页12加载到内存中，发现41大于40，此时不满足条件。 那么查找到此终止。 最终我们找到满足条件的所有数据为： (18,kl),(19,kl),(22,hj),(24,io),(25,vg),(29,jk),(31,jk),(33,rt),(34,ty),(35,yu),(37,rt),(39,rt)。 总共12条记录。 下面看下具体的查找流程图： 利用非聚集索引查找数据 读者看到这张图的时候可能会蒙，这是啥东西啊？怎么都是数字。 如果有这种感觉，请仔细看下图中红字的解释。什么？还看不懂？那我再来解释下吧。首先，这个非聚集索引表示的是用户幸运数字的索引，此时表结构是这样的。 id name luckyNum 1 zs 23 2 ls 7 在叶子节点中，不再存储所有的数据了，存储的是键值和主键。 对于叶子节点中的x-y，比如1-1。左边的1表示的是索引的键值，右边的1表示的是主键值。如果我们要找到幸运数字为33的用户信息，对应的sql语句为select * from user where luckNum=33。 查找的流程跟聚集索引一样，这里就不详细介绍了。我们最终会找到主键值47，找到主键后我们需要再到聚集索引中查找具体对应的数据信息，此时又回到了聚集索引的查找流程。 下面看下具体的查找流程图： 在MyISAM中，聚集索引和非聚集索引的叶子节点都会存储数据的文件地址。 总结本文从二叉查找树，详细说明了为什么MySQL用B+树作为数据的索引，以及在InnoDB中数据库如何通过B+树索引来存储数据以及查找数据。我们一定要记住这句话：数据即索引，索引即数据。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[B-树和B+树]]></title>
    <url>%2F2020%2F05%2F06%2FB-%E6%A0%91%E5%92%8CB-%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 数据库索引为什么要使用树结构存储呢？ 为什么索引没有使用二叉查找树来实现呢？ B+树的实现细节是什么样？B-树和B+树有什么区别？ 联合索引在B+树中如何存储？ 卫星数据，指的是索引元素所指向的数据记录，比如数据库中的某一行。怎么理解？ B+树的非叶子节点是没有卫星数据的，非叶子节点只起到索引的作用。是什么意思？ 索引MySQL的索引主要是基于Hash表和B+树。 要弄明白B+树，先要了解什么是B-树。需要注意的是，B-树就是B树，中间的横线并不是减号（不要读成B减树）。 二叉查找树数据库索引为什么要使用树结构存储呢？ 因为树的查询效率高，而且可以保持有序。 既然这样，为什么索引没有使用二叉查找树来实现呢？ 其实从算法逻辑上来讲，二叉查找树的查找速度和比较次数都是最小的。但是，我们不得不考虑一个现实问题：磁盘IO。 数据库索引是存储在磁盘上的。当数据量比较大的时候，索引的大小可能有几个G甚至更多。 当我们利用索引查询的时候，能把整个索引全部加载到内存吗？显然不可能。能做的只有逐一加载每一个磁盘页，这里的磁盘页对应着索引树的节点。 如果我们利用二叉查找树作为索引结构，情形是什么样呢？假设树的高度是4，查找的值是10，那么流程如下: 二叉查找树的结构： 第1次磁盘IO： 第2次磁盘IO： 第3次磁盘IO： 第4次磁盘IO： 有没有从中看出，磁盘IO的次数是由什么决定？ 磁盘IO的次数是4次，索引树的高度也是4。所以最坏情况下，磁盘IO次数等于索引树的高度。为了减少磁盘IO次数，我们就需要把原本“瘦高”的树结构变得“矮胖”，这就是B-树的特征之一。 二叉查找树的查找效率是最高的，如果内存能装下完整的树，最好使用二叉查找树，B树是退而求其次的方式。 B树B树索引可以理解成是主要存储于磁盘中的数据结构。 B树是一种多路平衡查找树，它的每一个节点最多包含k个孩子，k被称为B树的阶。k的大小取决于磁盘页的大小。 下面来具体介绍一下B-树（Balance Tree），一个m阶的B树具有如下几个特征： 1.根结点至少有两个子女。 2.每个中间节点都包含k-1个元素和k个孩子，其中m/2 &lt;= k &lt;= m。 3.每一个叶子节点都包含k-1个元素，其中m/2 &lt;= k &lt;= m（B-树叶子节点的元素数量最多可以是阶数-1。比如一颗4阶的B-树，每个节点最多包含有4个孩子、3个元素；最少包含有2个孩子，1个元素）。 4.所有的叶子结点都位于同一层。 5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 我们以一个3阶B-树为例，来看看B-树的具体结构。树中的具体元素和刚才的二叉查找树是一样的。 这棵树中，重点来看(2，6)节点。该节点有两个元素2和6，又有三个孩子1，(3，5)，8。其中1小于元素2，(3，5)在元素2，6之间，8大于(3，5)，正好符合刚刚所列的几条特征。 查询假如要查询的数值是5。 第1次磁盘IO： 在内存中定位（和9比较）： 第2次磁盘IO： 在内存中定位（和2，6比较）： 第3次磁盘IO： 在内存中定位（和3，5比较）： 通过整个流程我们可以看出，B-树在查询中的比较次数其实不比二叉查找树少，尤其当单一节点中的元素数量很多时。 可是相比磁盘IO的速度，内存中的比较耗时几乎可以忽略。所以只要树的高度足够低，IO次数足够少，就可以提升查找性能。 相比之下节点内部元素多一些也没有关系。仅仅是多了几次内存交互，只要不超过磁盘页的大小即可。这就是B-树的优势之一。 插入B-树插入新节点的过程比较复杂，而且分成很多种情况。我们只举一个最典型的例子，假如我们要插入的值是4。 自顶向下查找4的节点位置，发现4应当插入到节点元素3，5之间。 节点3，5已经是两元素节点，无法再增加。父亲节点2，6也是两元素节点，也无法再增加。根节点9是单元素节点，可以升级为两元素节点。于是拆分节点3，5与节点2，6，让根节点9升级为两元素节点4，9。节点6独立为根节点的第二个孩子。 就为了插入一个元素，让整个B树的那么多节点都发生了连锁改变。确实有些麻烦，但也正因为如此，让B-树能够始终维持多路平衡。这也是B-树的一大优势：自平衡。 删除同样只举一个典型例子，删除元素11。 自顶向下查找元素11的节点位置。 删除11后，节点12只有一个孩子，不符合B树规范。因此找出12，13，15三个节点的中位数13，取代节点12，而节点12自身下移成为第一个孩子。（这个过程称为左旋） 应用B-树主要应用于文件系统以及部分数据库索引，比如著名的非关系型数据库MongoDB。 B-树的好处是，虽然查询性能不稳定，但平均的查询速度快一些（不用每次都查找到叶子节点为止）。 而大部分关系型数据库，比如MySQL，则使用B+树作为索引。 B+树B+树是基于B-树的一种变体，有着比B-树更高的查询性能。 先回顾一下B-树的几大特征。一个m阶的B树具有如下几个特征： 1.根结点至少有两个子女。 2.每个中间节点都包含k-1个元素和k个孩子，其中m/2 &lt;= k &lt;= m。 3.每一个叶子节点都包含k-1个元素，其中m/2 &lt;= k &lt;= m。 4.所有的叶子结点都位于同一层。 5.每个节点中的元素从小到大排列，节点当中k-1个元素正好是k个孩子包含的元素的值域分划。 B+树和B-树有一些共同点，但是B+树也具备一些新的特征。 一个m阶的B+树具有如下几个特征： 1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。 具体例子 这是什么怪树？不但节点之间含有重复元素，而且叶子节点还用指针连在一起。 这些正是B+树的特点。首先，每一个父节点的元素都出现在子节点中，是子节点的最大（或最小）元素。 在上面这棵树中，根节点元素8是子节点2，5，8的最大元素，也是叶子节点6，8的最大元素。 根节点元素15是子节点11，15的最大元素，也是叶子节点13，15的最大元素。 需要注意的是，根节点的最大元素（这里是15），也就等同于整个B+树的最大元素。以后无论插入删除多少元素，始终要保持最大元素在根节点当中。 至于叶子节点，由于父节点的元素都出现在子节点，因此所有叶子节点包含了全量元素信息。 并且每一个叶子节点都带有指向下一个节点的指针，形成了一个有序链表。 这是以空间换时间，因为子节点都包含父节点的元素。树的层数和一个节点被重复存储成线性关系。父节点元素在子节点重复出现，增加了少量空间，换来的是范围查询的便利。 B+树还具有一个特点，这个特点是在索引之外，却是至关重要的特点。那就是[卫星数据]的位置。 所谓卫星数据，指的是索引元素所指向的数据记录，比如数据库中的某一行。在B-树中，无论中间节点还是叶子节点都带有卫星数据。 B-树中的卫星数据（Satellite Information）： 而在B+树当中，只有叶子节点带有卫星数据，其余中间节点仅仅是索引，没有任何数据关联。 B+树中的卫星数据（Satellite Information）： 需要补充的是，在数据库的聚集索引（Clustered Index）中，叶子节点直接包含卫星数据。在非聚集索引（NonClustered Index）中，叶子节点带有指向卫星数据的指针。 B+树设计成这样子究竟有什么好处呢？ B+树的好处主要体现在查询性能上。下面我们分别通过单行查询和范围查询来做分析。 在单元素查询的时候，B+树会自顶向下逐层查找节点，最终找到匹配的叶子节点。比如我们要查找的是元素3。 第一次磁盘IO： 第二次磁盘IO： 第三次磁盘IO： 查询流程看起来跟B-树差不多。但其实有两点不同。首先，B+树的中间节点没有卫星数据，所以同样大小的磁盘页可以容纳更多的节点元素。 这就意味着，数据量相同的情况下，B+树的结构比B-树更加“矮胖”，因此查询时IO次数也更少。 其次，B+树的查询必须最终查找到叶子节点，而B-树只要找到匹配元素即可，无论匹配元素处于中间节点还是叶子节点。 因此，B-树的查找性能并不稳定（最好情况是只查根节点，最坏情况是查到叶子节点）。而B+树的每一次查找都是稳定的。 B+树的查询每次都查到叶子节点，所以IO次数稳定。试想一个数据库的查询，有时候执行10毫秒，有时候执行100毫秒，肯定是不太合适的。还不如每次都执行30毫秒。 B-树的范围查找过程 下面我们再来看看范围查询。B-树如何做范围查询呢？只能依靠繁琐的中序遍历。比如我们要查询范围为3到11的元素： 自顶向下，查找到范围的下限（3）： 中序遍历到元素6： 中序遍历到元素8： 中序遍历到元素9： 中序遍历到元素11，遍历结束： B-树的范围查询确实很繁琐。反观B+树的范围查询，则要简单得多，只需要在链表上做遍历即可： B+树的范围查找过程 自顶向下，查找到范围的下限（3）： 通过链表指针，遍历到元素6，8： 通过链表指针，遍历到元素9，11，遍历结束： 比B-树的中序遍历要简单得多。 综合起来，B+树相比B-树的优势有三个： 1.IO次数更少； 2.查询性能稳定； 3.范围查询简便。 至于B+树的插入和删除，过程与B-树大同小异。 总结联合索引就是把多个索引值拼接成一个字符串A，字符串A像普通索引一样保存在索引树中。 最后我们来总结一下， B+树的特征和优势： B+树的特征： 1.有k个子树的中间节点包含有k个元素（B树中是k-1个元素），每个元素不保存数据，只用来索引，所有数据都保存在叶子节点。 2.所有的叶子结点中包含了全部元素的信息，及指向含这些元素记录的指针，且叶子结点本身依关键字的大小自小而大顺序链接。 3.所有的中间节点元素都同时存在于子节点，在子节点元素中是最大（或最小）元素。一开始就要规定好，要么元素在子节点都是最大的要么都是最小的，不能有的是最大的，有的是最小的。 B+树的优势： 1.单一节点存储更多的元素，使得查询的IO次数更少。 2.所有查询都要查找到叶子节点，查询性能稳定。 3.所有叶子节点形成有序链表，便于范围查询。 在节点占用空间恒定的情况下，B+树单个节点的元素更多。比如同样节点大小，B树的每个节点有100个元素，B+树的每个节点就可以装下1000个元素。这样的好处就是树的高度降低了。 为什么MongoDB索引选择B-树，而MySQL选择B+树一、B-树和B+树的区别很明显，我们要想弄清楚原因就要知道B-树和B+树的区别。 1、B-树 B-树是一种自平衡的搜索树，形式很简单： 这就是一颗B-树。针对我们这个问题的最核心的特点如下： （1）多路，非二叉树。 （2）每个节点既保存索引，又保存数据。 （3）搜索时相当于二分查找。 2、B+树 B+树是B-树的变种。 最核心的特点如下： （1）多路非二叉 （2）只有叶子节点保存数据 （3）搜索时相当于二分查找 （4）增加了相邻接点的指向指针。 从上面我们可以看出最核心的区别主要有俩，一个是数据的保存位置，一个是相邻节点的指向。就是这俩造成了MongoDB和MySQL的差别。为什么呢？ 3、B-树和B+树的区别 （1）B+树查询时间复杂度固定是logn，B-树查询复杂度最好是O(1)。 （2）B+树相邻接点的指针可以大大增加区间访问性，可使用在范围查询等，而B-树每个节点key和data在一起，则无法区间查找。 （3）B+树更适合外部存储，也就是磁盘存储。由于内节点无data域，每个节点能索引的范围更大更精确。 （4）注意这个区别相当重要，是基于（1）（2）（3）的，B-树每个节点即保存数据又保存索引，所以磁盘IO的次数很少，B+树只有叶子节点保存，磁盘IO多，但是区间访问比较好。 有了他们的区别之后，现在我们再来解释这个原因就好多了。 二、原因解释想要解释原因，我们还必须要了解一下MongoDB和MySQL的基本概念。 1、MongoDB MongoDB是文档型的数据库，是一种NoSQL，它使用类Json格式保存数据。比如之前我们的表可能有用户表、订单表、购物篮表等等，还要建立他们之间的外键关联关系。但是类Json就不一样了。 我们可以看到这种形式更简单，通俗易懂。那为什么MongoDB使用B-树呢？ MongoDB使用B-树，所有节点都有Data域，只要找到指定索引就可以进行访问，无疑单次查询平均快于MySQL。 2、MySQL MySQL作为一个关系型数据库，数据的关联性是非常强的，区间访问是常见的一种情况，B+树由于数据全部存储在叶子节点，并且通过指针串在一起，这样就很容易的进行区间遍历甚至全部遍历。 这俩区别的核心如果你能看懂B-树和B+树的区别就很容易理解。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次Laravel请求的生命周期]]></title>
    <url>%2F2020%2F04%2F29%2F%E4%B8%80%E6%AC%A1Laravel%E8%AF%B7%E6%B1%82%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 生命周期概览 第一件事Laravel应用的所有请求入口都是public/index.php文件，所有请求都会被web服务器（Apache/Nginx）导向这个文件。index.php文件包含的代码并不多，但是，这里是加载框架其它部分的起点。 index.php文件载入Composer生成的自动加载设置，然后从bootstrap/app.php脚本获取Laravel应用实例，Laravel的第一个动作就是创建服务容器实例。 HTTP/Console内核接下来，请求被发送到HTTP内核或Console内核（分别用于处理Web请求和Artisan命令），这取决于进入应用的请求类型。这两个内核是所有请求都要经过的中央处理器，现在，就让我们聚焦在位于app/Http/Kernel.php的HTTP内核。 HTTP内核继承自Illuminate\Foundation\Http\Kernel类，该类定义了一个bootstrappers数组，这个数组中的类在请求被执行前运行，这些bootstrappers配置了错误处理、日志、检测应用环境以及其它在请求被处理前需要执行的任务。 HTTP内核还定义了一系列所有请求在处理前需要经过的HTTP中间件，这些中间件处理HTTP会话的读写、判断应用是否处于维护模式、验证CSRF令牌等等。 HTTP内核的handle方法签名相当简单：获取一个Request，返回一个Response，可以把该内核想象作一个代表整个应用的大黑盒子，输入HTTP请求，返回HTTP响应。 服务提供者内核启动过程中最重要的动作之一就是为应用载入服务提供者，应用的所有服务提供者都被配置在config/app.php配置文件的providers数组中。首先，所有提供者的register方法被调用，然后，所有提供者被注册之后，boot方法被调用。 服务提供者负责启动框架的所有各种各样的组件，比如数据库、队列、验证器，以及路由组件等，正是因为他们启动并配置了框架提供的所有特性，所以服务提供者是整个Laravel启动过程中最重要的部分。 分发请求一旦应用被启动并且所有的服务提供者被注册，Request将会被交给路由器进行分发，路由器将会分发请求到路由或控制器，同时运行所有路由指定的中间件。 聚焦服务提供者服务提供者是启动Laravel应用中最关键的部分，应用实例被创建后，服务提供者被注册，请求被交给启动后的应用进行处理，整个过程就是这么简单！ 对Laravel应用如何通过服务提供者构建和启动有一个牢固的掌握非常有价值，当然，应用默认的服务提供者存放在app/Providers目录下。 默认情况下，AppServiceProvider是空的，这里是添加自定义启动和服务容器绑定的最佳位置，当然，对大型应用，你可能希望创建多个服务提供者，每一个都有着更加细粒度的启动。 总体流程 Web服务器对HTTP请求的处理流程大体上都是这样的：在某个端口监听请求，请求进入后运行程序，然后将程序运行结果以响应的形式发送出去。 基于Laravel框架构建的Web应用处理HTTP请求的流程也是如此。所有HTTP请求都会被转发到单入口文件public/index.php，处理HTTP请求的核心代码如下（忽略HTTP请求处理之外的代码）： 1234567891011121314151617181920212223$app = new Illuminate\Foundation\Application( realpath(__DIR__.'/../')); // 绑定处理HTTP请求的接口实现到服务容器$app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class);// 从服务容器中解析处理HTTP请求的Kernel实例$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class);// 处理HTTP请求的核心代码$response = $kernel-&gt;handle( $request = Illuminate\Http\Request::capture());// 发送响应$response-&gt;send();// 终止程序，做一些善后及清理工作$kernel-&gt;terminate($request, $response); 在上面这段程序中，首先会创建一个Application实例，作为全局的服务容器，然后将处理请求的核心类Kernel实现实例绑定到该容器中，以便后续通过它处理HTTP请求。我们通过服务器捕获请求并将其传递给Kernel实例进行处理，处理结果是准备好的响应实例，调用该响应实例的send()方法即可将其发送给发起请求的客户端。最后，我们执行Kernel实例上的terminate()终止程序，退出脚本。 以上就是Laravel框架处理HTTP请求的一般流程，所有核心逻辑都位于$kernel-&gt;handle()方法调用中。下面我们就来一探究竟。 服务容器Laravel框架提供了一个功能强大的服务容器，用于管理类之间的依赖关系，关于其底层原理还可以参考学徒到工匠系列中的介绍，这里我们就不深入展开了。服务容器封装了绑定到某个接口的对应实现类的实例化过程，你可以在需要对应实现实例的时候通过接口从容器中获取。 在上面的代码中，$app对应的就是服务容器实例，并且在我们获取到该实例后就注册了Kernel接口及其实现类到容器中：1234$app-&gt;singleton( Illuminate\Contracts\Http\Kernel::class, App\Http\Kernel::class); singleton方法会以单例方式在服务容器中将App\Http\Kernel实例绑定到Illuminate\Contracts\Http\Kernel接口，后续我们要获取App\Http\Kernel实例，就可以通过Illuminate\Contracts\Http\Kernel接口从服务容器中获取，获取方法是$app-&gt;make()：1$kernel = $app-&gt;make(Illuminate\Contracts\Http\Kernel::class); 回到Kernel下面我们就正式进入$kernel-&gt;handle()方法内部看看HTTP请求是被如何处理的。打开Illuminate\Foundation\Http\Kernel（App\Http\Kernel的父类），查看handle方法，可以看到核心处理逻辑通过sendRequestThroughRouter方法实现：12345678910111213protected function sendRequestThroughRouter($request)&#123; $this-&gt;app-&gt;instance('request', $request); Facade::clearResolvedInstance('request'); $this-&gt;bootstrap(); return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125; 在发送请求到路由之前，先调用bootstrap()方法运用应用的启动类：12345678protected $bootstrappers = [ \Illuminate\Foundation\Bootstrap\LoadEnvironmentVariables::class, \Illuminate\Foundation\Bootstrap\LoadConfiguration::class, \Illuminate\Foundation\Bootstrap\HandleExceptions::class, \Illuminate\Foundation\Bootstrap\RegisterFacades::class, \Illuminate\Foundation\Bootstrap\RegisterProviders::class, \Illuminate\Foundation\Bootstrap\BootProviders::class,]; 这些个启动类在路由解析之前执行，相当于对整个应用进行初始化。通过类名就能窥探出对应的操作意图，分别是加载环境变量和全局配置、配置异常处理逻辑、注册门面和服务提供者（根据config/app.php中的providers和alias配置值）、以及执行所有已注册服务提供者的boot方法，具体的实现逻辑我这里就不一一展开的，你可以自己去看下。 然后就是真正的HTTP请求处理了： 1234return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter()); Laravel框架以管道模式来处理HTTP请求，首先通过全局中间件对请求进行处理，如果返回false直接退出，不会做路由解析处理。 全局中间件都校验通过才会将请求分发到路由器进行处理，路由器会将请求URL路径与应用注册的所有路由进行匹配，如果有匹配的路由，则先收集该路由所分配的所有路由中间件，通过这些路由中间件对请求进行过滤，所有路由中间件校验通过才会运行对应的匿名函数或控制器方法，执行相应的请求处理逻辑，最后准备好待发送给客户端的响应。 终止Kernel响应准备就绪后，就会通过$response-&gt;send()发送给发起请求的客户端，之后还要运行$kernel-&gt;terminate()做一些善后清理工作，并最终退出脚本。这些善后清理工作主要包括运行终止中间件，以及注册到服务容器的一些终止回调： 123456public function terminate($request, $response)&#123; $this-&gt;terminateMiddleware($request, $response); $this-&gt;app-&gt;terminate();&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何实现IoC容器和服务提供者是什么概念]]></title>
    <url>%2F2020%2F04%2F27%2F%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0IoC%E5%AE%B9%E5%99%A8%E5%92%8C%E6%9C%8D%E5%8A%A1%E6%8F%90%E4%BE%9B%E8%80%85%E6%98%AF%E4%BB%80%E4%B9%88%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： IoC容器和服务提供者上一节我们的代码还是没有完全达到解耦，假如我们项目里有很多功能用到了这个login功能，我们则在这几个页面反复写。但是突然我们有一天换需求了，觉得数据库记录日志不太好，想要改成文件的，那我们不是每个页面用到login功能的都去替换成new FileLog()吗？那该如何修改呢？ 我们可以借助一个容器，提前把log，user都绑定到Ioc容器中。User的创建交给这个容器去做。比如下面这样的，你在任何地方使用login，都不需要关心是用什么记录日志了，哪怕后期需要修改只需要在IoC容器修改绑定其他记录方式日志就行了。 具体代码实现的思路 1、Ioc容器维护binding数组记录bind方法传入的键值对如：log=&gt;FileLog，user=&gt;User。 2、在ioc-&gt;make(‘user’)的时候，通过反射拿到User的构造函数，拿到构造函数的参数，发现参数是User的构造函数参数log，然后根据log得到FileLog。 3、这时候我们只需要通过反射机制创建$filelog = new FileLog(); 4、通过newInstanceArgs然后再去创建new User($filelog); 123456// 实例化ioc容器$ioc = new Ioc();$ioc-&gt;bind('log','FileLog');$ioc-&gt;bind('user','User');$user = $ioc-&gt;make('user');$user-&gt;login(); 这里的容器就是指Ioc容器，服务提供者就是User。 上一节遗留一个问题，如果参数是接口该怎么处理，其实就是通过IoC容器提前绑定好。 核心IoC容器代码编写123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100interface log&#123; public function write();&#125;// 文件记录日志class FileLog implements Log&#123; public function write() &#123; echo 'file log write...'; &#125;&#125;// 数据库记录日志class DatabaseLog implements Log&#123; public function write() &#123; echo 'database log write...'; &#125;&#125;class User&#123; protected $log; public function __construct(Log $log) &#123; $this-&gt;log = $log; &#125; public function login() &#123; // 登录成功，记录登录日志 echo 'login success...'; $this-&gt;log-&gt;write(); &#125;&#125;class Ioc&#123; public $binding = []; public function bind($abstract, $concrete) &#123; // 这里为什么要返回一个closure呢？因为bind的时候还不需要创建User对象，所以采用closure等make的时候再创建FileLog; $this-&gt;binding[$abstract]['concrete'] = function ($ioc) use ($concrete) &#123; return $ioc-&gt;build($concrete); &#125;; &#125; public function make($abstract) &#123; // 根据key获取binding的值 $concrete = $this-&gt;binding[$abstract]['concrete']; return $concrete($this); &#125; // 创建对象 public function build($concrete) &#123; $reflector = new ReflectionClass($concrete); $constructor = $reflector-&gt;getConstructor(); if(is_null($constructor)) &#123; return $reflector-&gt;newInstance(); &#125; else &#123; $dependencies = $constructor-&gt;getParameters(); $instances = $this-&gt;getDependencies($dependencies); return $reflector-&gt;newInstanceArgs($instances); &#125; &#125; // 获取参数的依赖 protected function getDependencies($paramters) &#123; $dependencies = []; foreach ($paramters as $paramter) &#123; $dependencies[] = $this-&gt;make($paramter-&gt;getClass()-&gt;name); &#125; return $dependencies; &#125;&#125;// 实例化IoC容器$ioc = new Ioc();$ioc-&gt;bind('log','FileLog');$ioc-&gt;bind('user','User');$user = $ioc-&gt;make('user');$user-&gt;login(); 至此，我们的IoC就已经实现了。 Laravel中的服务容器和服务提供者1234567891011121314151617181920212223242526272829$providers = [ Illuminate\Auth\AuthServiceProvider::class, Illuminate\Broadcasting\BroadcastServiceProvider::class, Illuminate\Bus\BusServiceProvider::class, Illuminate\Cache\CacheServiceProvider::class, ...]...// 随便打开一个类比如CacheServiceProvider，这个服务提供者都是通过调用register方法注册到ioc容器中，其中的app就是Ioc容器。// singleton可以理解成我们的上面例子中的bind方法。只不过这里singleton指的是单例模式。class CacheServiceProvider&#123; public function register() &#123; $this-&gt;app-&gt;singleton('cache', function ($app) &#123; return new CacheManager($app); &#125;); $this-&gt;app-&gt;singleton('cache.store', function ($app) &#123; return $app['cache']-&gt;driver(); &#125;); $this-&gt;app-&gt;singleton('memcached.connector', function () &#123; return new MemcachedConnector; &#125;); &#125;&#125; 可以在config目录找到app.php中providers，这个数组定义的都是已经写好的服务提供者。 具体服务提供者register方法是什么时候执行的，我们到讲Laravel生命周期的时候再详细说。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[依赖注入、控制反转、反射各个概念的理解和使用]]></title>
    <url>%2F2020%2F04%2F27%2F%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E3%80%81%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC%E3%80%81%E5%8F%8D%E5%B0%84%E5%90%84%E4%B8%AA%E6%A6%82%E5%BF%B5%E7%9A%84%E7%90%86%E8%A7%A3%E5%92%8C%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 用递归的方式创建参数依赖。怎么理解？ 概念理解我们先来介绍控制反转，依赖注入，这两个概念我们可以认为他们表达的同一种意思，举个通俗的例子，我们用户登录需要提供记录日志的功能，可以选择使用文件或者数据库。下面我们用代码来演示。 1234567891011121314151617181920212223242526272829303132333435363738394041424344// 定义写日志的接口规范interface log&#123; public function write(); &#125;// 文件记录日志class FileLog implements Log&#123; public function write() &#123; echo 'file log write...'; &#125; &#125;// 数据库记录日志class DatabaseLog implements Log&#123; public function write() &#123; echo 'database log write...'; &#125; &#125;// 程序操作类class User &#123; protected $fileLog; public function __construct() &#123; $this-&gt;fileLog = new FileLog(); &#125; public function login() &#123; // 登录成功，记录登录日志 echo 'login success...'; $this-&gt;fileLog-&gt;write(); &#125;&#125;$user = new User();$user-&gt;login(); 上面的写法可以实现记录日志的功能，但是有一个问题，假设现在想用数据库记录日志的话，我们就得修改User类，这份代码没达到解耦合，也不符合编程开放封闭原则，那如何修改呢？我们可以把日志处理类通过构造函数方式传递进去。下面我们试着修改User类的代码。 1234567891011121314151617181920class User &#123; protected $log; public function __construct(Log $log) &#123; $this-&gt;log = $log; &#125; public function login() &#123; // 登录成功，记录登录日志 echo 'login success...'; $this-&gt;log-&gt;write(); &#125;&#125;$user = new User(new DatabaseLog());$user-&gt;login(); 这样想用任何方式记录操作日志都不需要去修改User类了，只需要通过构造函数传递参数就可以实现，其实这就是“控制反转”。不需要自己内容修改，改成由外部传递。这种由外部负责其依赖需求的行为，我们可以称其为 “控制反转（IoC）”。 那什么是依赖注入呢？其实上面的例子也算是依赖注入，不是由自己内部new对象或者实例，通过构造函数，或者方法传入的都属于依赖注入（DI） 。 依赖注入初学Laravel的同学应该都比较好奇，很多对象实例通过方法参数定义就能传递进来，调用的时候不需要我们自己去手动传入。下面举一个Laravel中实际的例子，Request对象会被自动的注入到函数里。 123456789101112131415// routes/web.phpRoute::get('/post/store', 'PostController@store');// App\Http\Controllersclass PostController extends Controller &#123; public function store(Illuminate\Http\Request $request) &#123; $this-&gt;validate($request, [ 'category_id' =&gt; 'required', 'title' =&gt; 'required|max:255|min:4', 'body' =&gt; 'required|min:6', ]); &#125;&#125; 反射理解我们现在已经明白了依赖注入的概念。那Laravel那种用法怎么实现呢？可能有些同学已经想到了这里面肯定会用到反射机制去创建动态Post，然后去调用store方法。 反射的概念其实可以理解成根据类名返回该类的任何信息，比如该类有什么方法，参数，变量等等。我们先来学习下反射要用到的api。拿User举例。 1234567891011121314// 获取User的reflectionClass对象$class = new ReflectionClass(User::class);// 拿到User的构造函数$constructor = $class-&gt;getConstructor();// 拿到User的构造函数的所有依赖参数$dependencies = $constructor-&gt;getParameters();// 创建user对象$user = $reflector-&gt;newInstance();// 创建user对象，需要传递参数的$user = $reflector-&gt;newInstanceArgs($dependencies = []); 这时候我们可以创建一个make方法，传入User，利用反射机制拿到User的构造函数，进而得到构造函数的参数对象。用递归的方式创建参数依赖。最后调用newInstanceArgs方法生成User实例。下面我们用代码去简单模拟下。 1234567891011121314function make($concrete)&#123; // 获得User的反射类 $reflector = new ReflectionClass($concrete); // User构造函数 $constructor = $reflector-&gt;getConstructor(); // User构造函数参数 $dependencies = $constructor-&gt;getParameters(); // 最后生成User return $reflector-&gt;newInstanceArgs($dependencies);&#125;$user = make('User');$user-&gt;login(); 具体代码实现1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556// 注意我们这里需要修改一下User的构造函数// 如果不去修改。反射是不能动态创建接口的，那如果非要用接口该怎么处理呢？// 下一节我们讲Ioc容器的时候会去解决。class User &#123; protected $log; public function __construct(FileLog $log) &#123; $this-&gt;log = $log; &#125; public function login() &#123; // 登录成功，记录登录日志 echo 'login success...'; $this-&gt;log-&gt;write(); &#125;&#125;function make($concrete)&#123; $reflector = new ReflectionClass($concrete); $constructor = $reflector-&gt;getConstructor(); // 为什么这样写的? 主要是递归。比如创建FileLog不需要传入参数。 if(is_null($constructor)) &#123; return $reflector-&gt;newInstance(); &#125; else &#123; // 构造函数依赖的参数 $dependencies = $constructor-&gt;getParameters(); // 根据参数返回实例，如FileLog $instances = $this-&gt;getDependencies($dependencies); return $reflector-&gt;newInstanceArgs($instances); &#125;&#125;function getDependencies($paramters)&#123; $dependencies = []; foreach ($paramters as $paramter) &#123; $dependencies[] = make($paramter-&gt;getClass()-&gt;name); &#125; return $dependencies;&#125;$user = make('User');$user-&gt;login(); 到这里，我们依赖注入，控制翻转，反射也就讲完了。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container tag解析机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-tag%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 简介先说作用，给某一类的绑定分配一个标记来表示他们是一类的，可以通过这个标记取出同一类下面的所有的绑定。 看看怎么用就知道了：123456789101112// 定义两个实体类，都标记名字为currency// 然后使用tagged取出currency就是可以取出abstract的实体对象。public function testTags()&#123; $this-&gt;app-&gt;tag(Rmb::class, 'currency'); $this-&gt;app-&gt;tag(Dollar::class, 'currency'); $currencyArray = $this-&gt;app-&gt;tagged('currency'); $this-&gt;assertTrue($currencyArray[0] instanceof Rmb); $this-&gt;assertTrue($currencyArray[1] instanceof Dollar);&#125; 注意这里：我们绑定的时候还是一个abstract，就是说容器中还没有对象，但是我们tagged取出的时候都变成对象了。因为make可以直接解析类路径，而tagged使用了make方法。 实例测试测试提供类：1234567891011121314151617181920212223242526272829303132333435363738394041class AusDollars&#123; private $amount; public function __construct($amount) &#123; $this-&gt;amount = $amount; &#125;&#125;class Rmb&#123;&#125;class Dollar&#123; public function __construct() &#123; &#125; public function getAmount() &#123; return 1; &#125;&#125;Class Currency&#123; private $dollar; public function __construct(Dollar $dollar) &#123; $this-&gt;dollar = $dollar; &#125; public function getAmount() &#123; return $this-&gt;dollar-&gt;getAmount(); &#125;&#125; 1.测试多个参数情况，以及直接使用类路径。 123456789101112131415public function testTags()&#123; $this-&gt;app-&gt;bind('rmb', Rmb::class); // 多个参数 $this-&gt;app-&gt;tag('rmb', 'currency', 'money'); // 直接使用类路径 $this-&gt;app-&gt;tag(Dollar::class, 'currency', 'money'); $currencyArray = $this-&gt;app-&gt;tagged('money'); $this-&gt;assertTrue($currencyArray[0] instanceof Rmb); $this-&gt;assertTrue($currencyArray[1] instanceof Dollar);&#125; 2.测试使用tag直接绑定有依赖的类路径，会报错。 12345678910111213public function testTagsWithDependency()&#123; $this-&gt;app-&gt;tag(AusDollars::class, 'currency', 'money'); try &#123; $this-&gt;app-&gt;tagged('money'); &#125; catch(\Exception $e) &#123; $this-&gt;assertContains('Unresolvable dependency resolving',$e-&gt;getMessage()); &#125;&#125; 会报这样的错：1`Unresolvable dependency resolving [Parameter #0 [ &lt;required&gt; $amount ]] in class ...` 源码1.tag方法源代码 123456789101112131415161718192021222324/** * Assign a set of tags to a given binding. * * @param array|string $abstracts * @param array|mixed ...$tags * @return void */public function tag($abstracts, $tags)&#123; $tags = is_array($tags) ? $tags : array_slice(func_get_args(), 1); foreach ($tags as $tag) &#123; if (! isset($this-&gt;tags[$tag])) &#123; $this-&gt;tags[$tag] = []; &#125; foreach ((array) $abstracts as $abstract) &#123; $this-&gt;tags[$tag][] = $abstract; &#125; &#125;&#125; 1.0 还是先说参数，传入的$abstracts可以是类路径，也可以是一个绑定的别名或者字符串。如果是后者，需要事先使用bind方法绑定对应的concrete。如果是类路径则可以直接使用，参见前面make方法。 1.1 判断第二个参数$tags是不是一个数组，如果不是数组，他可以是一个参数。 这里可以看到，这里也可以传入多个参数。array_slice会把第二个参数，以及后面所有的参数都转换成一个数组返回。1$tags = is_array($tags) ? $tags : array_slice(func_get_args(), 1); 什么意思呢，举例：123456// 可以这样$this-&gt;app-&gt;tag(Rmb::class, 'currency');// 也可以传入数组$this-&gt;app-&gt;tag(Rmb::class, ['currency', 'money']);// 也可以这样$this-&gt;app-&gt;tag(Rmb::class, 'currency'，‘money’); 最后一种，我们看源码就知道可以这样使用，虽然我感觉可能不是一个好的写法。 1.2 下面就简单了，主要分两步： a.遍历这个tags数组，如果在tags数组（protected $tags = [];）中不存在这个tag那么创建一个空的子数组。 b.遍历前面的第一个参数$abstracts，他会强行转换成一个数组，说明$abstract可以是一个字符串，也可以是一个数组。把当前的abstract对应的值存储到上面我们创建的子数组tag中。 这里我们同时知道了tags数组作用以及存储格式。123456789101112foreach ($tags as $tag) &#123; if (! isset($this-&gt;tags[$tag])) &#123; $this-&gt;tags[$tag] = []; &#125; foreach ((array) $abstracts as $abstract) &#123; $this-&gt;tags[$tag][] = $abstract; &#125;&#125; 这是tags的存储过程。 2.tagged方法源代码，看看以tag标记的一类绑定如何获取。1234567891011121314151617181920/** * Resolve all of the bindings for a given tag. * * @param string $tag * @return iterable */public function tagged($tag)&#123; if (! isset($this-&gt;tags[$tag])) &#123; return []; &#125; return new RewindableGenerator(function () use ($tag) &#123; foreach ($this-&gt;tags[$tag] as $abstract) &#123; yield $this-&gt;make($abstract); &#125; &#125;, count($this-&gt;tags[$tag]));&#125; 2.1 其实很简单，也是两个逻辑： a.先判断当前容器的tags数组中有没有对应的值，如果没有直接返回空数组。 b.如果有，遍历这个子tag数组，分别使用make函数解析这个$abstract。 这里我们就能明白，为什么我们可以不用事先绑定类路径，而直接使用就能绑定成功，因为我们知道make解析的时候，如果在binding数组中找不到对应的值，他会使用build函数直接解析。 但是我们，也看到，这个make解析的时候是没有第二个参数parameters的，说明什么呢，如果这个类路径有自定义的依赖并且这个依赖没有默认值，它是无法实例化的。因为make他需要我们传入第二个参数才能实例化。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container build解析机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-build%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么把concrete存入数组buildStack中，等下用？ 简介build的作用就是根据不同情况生成对象。 实例测试1、直接使用build，没有依赖的闭包函数，如下代码第16行。 12345678910111213141516171819202122232425&lt;?php// 一个普通的类，没有构造函数，没有依赖class Money&#123; public function getAmount() &#123; return 100; &#125;&#125;class ExampleTest extends TestCase&#123; public function testClosure() &#123; // 参数是一个闭包，闭包返回实例对象 $boss = app()-&gt;build(function()&#123; return new Money(); &#125;); $output = $boss-&gt;getAmount(); $this-&gt;assertEquals($output, 100); &#125;&#125; 2、使用make解析，make通过build创建对象，有依赖的闭包函数的测试。 123456789101112131415161718192021222324252627282930&lt;?php// 有构造函数，有依赖class Money&#123; // 依赖 private $amount = 0; public function __construct($amount) &#123; $this-&gt;amount = $amount; &#125; public function getAmount() &#123; return $this-&gt;amount; &#125;&#125;class ExampleTest extends TestCase&#123; public function testClosure() &#123; $this-&gt;app-&gt;bind('money', function($app, $parameters)&#123; return new Money($parameters[0]); &#125;); $boss = app()-&gt;make('money', [$amount = 1000]); &#125;&#125; 3.使用make解析，make通过build对象，有依赖的类路径测试。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php// 有依赖class Money&#123; private $amount = 0; public function __construct($amount) &#123; $this-&gt;amount = $amount; &#125; public function getAmount() &#123; return $this-&gt;amount; &#125;&#125;class Dollar extends Money&#123; //private $amount = 0; public function __construct() &#123; &#125; public function getAmount() &#123; return 1; &#125;&#125;Class Currency&#123; private $dollar; // 依赖一个类 public function __construct(Dollar $dollar) &#123; $this-&gt;dollar = $dollar; &#125; public function getAmount() &#123; return $this-&gt;dollar-&gt;getAmount(); &#125;&#125;public function testFunctionBuildWithDependenceOfClass()&#123; $obj = app()-&gt;make(Currency::class); $this-&gt;assertEquals($obj-&gt;getAmount(), 1);&#125; 我们读通源码后，我们可以解决很多找不到答案的问题，比如： 12345678910111213141516class Money&#123; private $amount = 0; public function __construct($amount) &#123; $this-&gt;amount = $amount; &#125; public function getAmount() &#123; return $this-&gt;amount; &#125;&#125;$obj = app()-&gt;make(Money::class, [$amount =&gt; 1000]); 尝试解析这个类，发现总是提示找不到amount依赖，我们追踪下去会发现，with数组中的parameter是：123array(1) &#123; [0]=&gt;int(1000)&#125; 由此我们知道我们传入的parameter没有key值，正确的做法是： 1$obj = app()-&gt;make(Money::class, ['amount' =&gt; 1000]); 源码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970/** * 实例化给定类型的具体实例 * * @param \Closure|string $concrete * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException *///0 -&gt; 参数public function build($concrete)&#123; // 如果$concrete实际上是闭包，我们将执行这个闭包并返回执行的结果， // 这允许将函数用作解析器以更精细地解析这些对象。 // 1 if ($concrete instanceof Closure) &#123; return $concrete($this, $this-&gt;getLastParameterOverride()); &#125; try &#123; // 2 $reflector = new ReflectionClass($concrete); &#125; catch (ReflectionException $e) &#123; throw new BindingResolutionException("Target class [$concrete] does not exist.", 0, $e); &#125; // 如果该类型不是可实例化的，则开发人员正在尝试解析一个抽象类型， // 例如Interface或Abstract Class，并且没有为抽象注册任何绑定，因此我们需要补救。 if (! $reflector-&gt;isInstantiable()) &#123; return $this-&gt;notInstantiable($concrete); &#125; // 3 $this-&gt;buildStack[] = $concrete; $constructor = $reflector-&gt;getConstructor(); // 如果没有构造函数，则意味着没有依赖关系，那么我们可以立即解析对象的实例， // 而无需从这些容器中解析任何其他类型或依赖关系。 if (is_null($constructor)) &#123; array_pop($this-&gt;buildStack); return new $concrete; &#125; // 4 $dependencies = $constructor-&gt;getParameters(); // 一旦有了所有构造函数的参数，就可以创建每个依赖项实例， // 然后使用反射实例创建此类的新实例，将创建的依赖项注入其中。 try &#123; $instances = $this-&gt;resolveDependencies($dependencies); &#125; catch (BindingResolutionException $e) &#123; array_pop($this-&gt;buildStack); throw $e; &#125; array_pop($this-&gt;buildStack); return $reflector-&gt;newInstanceArgs($instances);&#125; 0.还是从参数说起，传入的实例concrete，可以是闭包函数，可以是一个类路径。还是重新提一下，concrete并不是实体类对象，而是可以产生对象的类或者闭包。和实体对象集合instance有区别。 1.如果这个concrete是一个闭包函数，我们就直接执行这个闭包。1234if ($concrete instanceof Closure) &#123; return $concrete($this, $this-&gt;getLastParameterOverride());&#125; 这里的闭包的形式为：1$concrete($this, $this-&gt;getLastParameterOverride()); 有两个参数，但是不传参数也是可以的。 第二个参数$this-&gt;getLastParameterOverride()，我们看下源代码：123456789/** * Get the last parameter override. * * @return array */protected function getLastParameterOverride()&#123; return count($this-&gt;with) ? end($this-&gt;with) : [];&#125; make解析那章，解析的时候把parameters存入了with数组，这个时候就是使用getLastParameterOverride获取with数组的最后一个值，也就是我们make时候刚刚放入的对象的parameters。 2、创建一个php的ReflectionClass对象，包含类的信息，ReflectionClass针对类，ReflectionObject则是针对对象。 所以这里concrete是一个类路径。正如前面提到的。1$reflector = new ReflectionClass($concrete); 2.1、如果这不是一个可以初始化的类，那么notInstantiable方法会抛出一个异常。1234if (! $reflector-&gt;isInstantiable()) &#123; return $this-&gt;notInstantiable($concrete);&#125; notInstantiable方法源代码：123456789101112131415161718192021222324/** * Throw an exception that the concrete is not instantiable. * 如果具体类不能实例化，就抛出异常 * * @param string $concrete * @return void * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function notInstantiable($concrete)&#123; if (! empty($this-&gt;buildStack)) &#123; $previous = implode(', ', $this-&gt;buildStack); $message = "Target [$concrete] is not instantiable while building [$previous]."; &#125; else &#123; $message = "Target [$concrete] is not instantiable."; &#125; throw new BindingResolutionException($message);&#125; 发现他无非就是组织一个message，然后抛出了一个异常。返回的异常提示是Target … is not instantiable. 3、这里通过php反射机制，用Concrete类产生对象。如何实现呢？如下步骤。 3.1、首先把concrete存入数组buildStack中，等下用。为什么一定要先存入一个数组呢？下面会讲。如果细看上一章，也许你知道。 1$this-&gt;buildStack[] = $concrete; 3.2、然后利用前面得到的反射对象通过getConstructor方法得到他的构造函数，如果构造函数是空的，就是默认没有参数的构造函数，从buildStack取出concrete使用new创建这个对象返回。12345678$constructor = $reflector-&gt;getConstructor();if (is_null($constructor)) &#123; array_pop($this-&gt;buildStack); return new $concrete;&#125; 4、否则就是类里有自定义构造函数，或者说可能构造函数存在依赖的情况。我们要先获取依赖再去创建对象。 4.1 通过构造函数我们获取参数依赖。就是构造函数中的参数，如果没有，返回一个空的数组。 1$dependencies = $constructor-&gt;getParameters(); 在进行下面的分析前，先明确getParameters()会返回的数组的形式，帮助后面的分析，下面为一个例子：1234567891011121314151617181920&lt;?phpclass dollar&#123; public function __construct($import) &#123; &#125; public function getAmount() &#123; return 100; &#125;&#125;$reflect = new ReflectionClass('dollar');$constructor = $reflect-&gt;getConstructor();var_dump($constructor-&gt;getParameters()); 最后他输出的结构是：12345array(1) &#123; [0] =&gt; object(ReflectionParameter)#3 (1) &#123; [&quot;name&quot;]=&gt;string(6) &quot;import&quot; &#125;&#125; 4.2 有了上面的例子。使用resolveDependencies方法解析然后获取这个依赖。（不想看具体实现可以跳过到4.3）1$instances = $this-&gt;resolveDependencies($dependencies); 看下整个源码，然后再一步一步看。1234567891011121314151617181920212223242526272829303132333435363738394041/** * 从ReflectionParameters解析所有依赖项 * * @param array $dependencies * @return array * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolveDependencies(array $dependencies)&#123; $results = []; foreach ($dependencies as $dependency) &#123; // 如果此依赖项覆盖了这个特殊的build，则将其用作值。 // 否则，我们将继续执行这些决议，并让反射尝试确定结果。 if ($this-&gt;hasParameterOverride($dependency)) &#123; $results[] = $this-&gt;getParameterOverride($dependency); continue; &#125; // 如果该类为null，则表示依赖项是字符串或其他一些原始类型， // 由于它不是类，因此我们无法解析，并且由于无处可去，因此我们将抛出错误。 $result = is_null($dependency-&gt;getClass()) ? $this-&gt;resolvePrimitive($dependency) : $this-&gt;resolveClass($dependency); if ($dependency-&gt;isVariadic()) &#123; $results = array_merge($results, $result); &#125; else &#123; $results[] = $result; &#125; &#125; return $results;&#125; 4.2.1 首先遍历这个依赖，然后使用方法$this-&gt;hasParameterOverride($dependency)判断是否参数有覆盖。什么意思呢，看hasParameterOverride源码，如下：123456789101112/** * 确定给定的依赖项是否具有参数替代。 * * @param \ReflectionParameter $dependency * @return bool */protected function hasParameterOverride($dependency)&#123; return array_key_exists( $dependency-&gt;name, $this-&gt;getLastParameterOverride() );&#125; $this-&gt;getLastParameterOverride()上面提到过，获取make时候存入with数组的参数。$dependency-&gt;name是什么，就是构造函数中参数的名字，上面的例子中，就是‘import’。简单说就是我们在make解析的时候是不是传递了这个依赖的值（就是make方法的第二个参数parameters）。 4.2.2 继续，如果有这个覆盖，使用getParameterOverride获取这个依赖的值，存入result数组中。 1$results[] = $this-&gt;getParameterOverride($dependency); 严谨的再看下getParameterOverride怎么实现的： 12345678910/** * Get a parameter override for a dependency. * * @param \ReflectionParameter $dependency * @return mixed */protected function getParameterOverride($dependency)&#123; return $this-&gt;getLastParameterOverride()[$dependency-&gt;name];&#125; 很简单还是通过getLastParameterOverride获取with数组，然后在数组中通过name（这里就是import）获取。 4.2.3 然后continue循环下一个依赖。 4.2.4 如果在with数组中找不到对应的依赖。也就是这个依赖不是我们make时候设定的，故意要传入的parameters，可能是其他的类。那么我们先判断这个依赖类是不是存在于当前代码中。 I. 如果不存在，则使用resolvePrimitive方法，看看上下文绑定中有没有对应的值，再看看依赖自己有没有默认值（具体看下面4.2.5resolvePrimitive方法源码分析）。 II. 如果存在使用resolveClass方法，就是使用make函数解析这个依赖（具体看下面4.2.6resolveClass方法源码）。 12345// 如果该类为null，则表示依赖项是字符串或其他一些原始类型，// 由于它不是类，因此我们无法解析，并且由于无处可去，因此我们将抛出错误。$result = is_null($dependency-&gt;getClass()) ? $this-&gt;resolvePrimitive($dependency) : $this-&gt;resolveClass($dependency); 4.2.5 resolvePrimitive方法源码： 12345678910111213141516171819202122/** * 解析非类提示的原始依赖项。 * * @param \ReflectionParameter $parameter * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolvePrimitive(ReflectionParameter $parameter)&#123; if (! is_null($concrete = $this-&gt;getContextualConcrete('$'.$parameter-&gt;name))) &#123; return $concrete instanceof Closure ? $concrete($this) : $concrete; &#125; if ($parameter-&gt;isDefaultValueAvailable()) &#123; return $parameter-&gt;getDefaultValue(); &#125; $this-&gt;unresolvablePrimitive($parameter);&#125; a. 首先判断这个依赖的name是不是在上下文绑定中（又来了）。 b. 如果这个依赖在上下文绑定中，再次提醒，我们记得上下文绑定有两个类型，一个是闭包，一个是类路径。这里如果是闭包直接执行，如果是类路径，返回类路径。 c. 否则是否存在依赖有默认值，有默认值直接返回默认值。什么意思呢，这里的例子，如果是$import=”100”是这个情况。 d. 都没有那说明没办法解析，执行unresolvablePrimitive方法，直接排除一个无法解析的异常。源码： 1234567891011121314/** * 为无法解析的原始类型抛出异常。 * * @param \ReflectionParameter $parameter * @return void * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function unresolvablePrimitive(ReflectionParameter $parameter)&#123; $message = "Unresolvable dependency resolving [$parameter] in class &#123;$parameter-&gt;getDeclaringClass()-&gt;getName()&#125;"; throw new BindingResolutionException($message);&#125; 4.2.6 resolveClass方法源码： 12345678910111213141516171819202122232425262728293031323334/** * 解析容器中基于类的依赖关系 * * @param \ReflectionParameter $parameter * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolveClass(ReflectionParameter $parameter)&#123; try &#123; return $parameter-&gt;isVariadic() ? $this-&gt;resolveVariadicClass($parameter) : $this-&gt;make($parameter-&gt;getClass()-&gt;name); &#125; // 如果无法解析类实例，则将检查该值是否为可选值， // 如果为可选值，则将返回可选参数值作为依赖项的值，这与使用标量的方式类似。 catch (BindingResolutionException $e) &#123; if ($parameter-&gt;isDefaultValueAvailable()) &#123; return $parameter-&gt;getDefaultValue(); &#125; if ($parameter-&gt;isVariadic()) &#123; return []; &#125; throw $e; &#125;&#125; a.很明显，既然在代码中存在这个类，使用make函数解析这个类。（又进入解析了，又会调用build。）这个时候才是buildstack有值的时候，就是说在resolve函数中，getContextualConcrete才起到了真正的作用，会检查上下文绑定。回看上一章。 b.有一个情况我们要考虑，如果这个类不能被解析，就是解析失败了，（比如：这个类是抽象类）。怎么办，我们上面提过，他会抛出一个BindingResolutionException异常吧，这里捕获这个异常，判断这个依赖$import是不是一个optional的参数，什么意思，还是这个情况 ($import == 100) 有没有默认值，如果有则取他的默认值（100）返回，不解析了，有默认值先用下再说。如果不是，没办法继续抛这个异常。 4.2.7 最后返回包含了所有依赖的result数组，我们前面有种情况，如果有自定义构造方法但是没有传入参数，就是result[]是空，不影响结果。往下看。 4.3 得到了依赖了，我们使用newInstanceArgs方法创建对象不再使用new了，依赖$instances为参数. 4.3.1 这里再次使用array_pop从buildStack取出类。我们一开始为什么要存到buildStack这个数组中，这个时候可以总结了： 逻辑上来说：就是为了给不一样的逻辑情况提供未污染的变量。简单说就是把这个变量放起来，谁先来谁先用。具体情况来说，为了给解析依赖的时候提供一个及时的当前build的concretion。123array_pop($this-&gt;buildStack);return $reflector-&gt;newInstanceArgs($instances); 这就是整个流程。 总结build方法主要是这样的流程： 1、判断是不是闭包，闭包就执行。 2、如果不是闭包，利用php反射，生成php反射对象。 3、这个类有没有自定义构造函数，如果没有，就直接new返回。 4、如果有自定义构造函数。 4.1、我们先看看有没有在make的时候传入第二个参数，有的话获取返回这个依赖。 4.2、没有传入的话，说明不是我们故意要的，有其他的依赖。 a、看看这个依赖能不能解析，不能解析，我们看看上下文绑定有没有，这个依赖的默认值有没有，都没有，没办法抛出异常。 b、要是能解析，就直接解析，返回。 4.3、有了依赖了，使用反射通过依赖生成对象。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container make解析机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-make%E8%A7%A3%E6%9E%90%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： make解析的时候会调用build函数实例化对象。 make($abstract, array $parameters = []); 简介make和resolve都是从容器中解析实例（这个实例是指concrete）出来。简单说就是从容器中把前面bind进去的东西拿出来用。 这里需要明确的是，make解析的时候会调用build函数实例化对象，就是说理论上如果绑定的是一个字符串，Laravel默认这是一个可以实例化对象的类路径。 而我们如果想要绑定一个纯粹的字符串或者数字，我们可以使用闭包函数。让闭包返回我们需要的类型。具体看下面的源码。 把resolve和make放在一起是因为其实在Container类中，make就是resolve的一个包装。 我们看看make方法：很简单直接调用了resolve方法，类似的还有makeWith方法。 12345678910111213/** * 从容器解析给定类型 * * @param string $abstract * @param array $parameters * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */public function make($abstract, array $parameters = [])&#123; return $this-&gt;resolve($abstract, $parameters);&#125; 1234567891011/** * An alias function name for make(). * * @param string $abstract * @param array $parameters * @return mixed */public function makeWith($abstract, array $parameters = [])&#123; return $this-&gt;make($abstract, $parameters);&#125; 源码先整体看下resolve函数源码：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * 从容器解析给定类型 * * @param string $abstract * @param array $parameters * @param bool $raiseEvents * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolve($abstract, $parameters = [], $raiseEvents = true)&#123; $abstract = $this-&gt;getAlias($abstract); $needsContextualBuild = ! empty($parameters) || ! is_null( $this-&gt;getContextualConcrete($abstract) ); // 如果当前正在以单例方式管理类型的实例，我们将仅返回一个现有实例， // 而不是实例化新实例，以便开发人员每次都可以继续使用相同的对象实例。 if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; return $this-&gt;instances[$abstract]; &#125; $this-&gt;with[] = $parameters; $concrete = $this-&gt;getConcrete($abstract); // 我们已经准备好实例化为绑定注册的具体类型的实例。 // 这将实例化类型，并递归地解决其所有“嵌套”依赖项，直到所有问题都解决为止。 if ($this-&gt;isBuildable($concrete, $abstract)) &#123; $object = $this-&gt;build($concrete); &#125; else &#123; $object = $this-&gt;make($concrete); &#125; // 如果我们为此类型定义了任何扩展程序，则需要遍历它们并将其应用于正在构建的对象。 // 这允许扩展服务，例如更改配置或装饰对象。 foreach ($this-&gt;getExtenders($abstract) as $extender) &#123; $object = $extender($object, $this); &#125; // 如果将请求的类型注册为单例，我们将要缓存“内存”中的实例， // 这样我们以后就可以返回它，而无需在每次后续请求上创建对象的全新实例。 if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123; $this-&gt;instances[$abstract] = $object; &#125; if ($raiseEvents) &#123; $this-&gt;fireResolvingCallbacks($abstract, $object); &#125; // 返回之前，我们还将解析标记设置为“ true”，并弹出此构建的参数替代。 // 完成这两件事之后，我们将准备好返回完整构造的类实例。 $this-&gt;resolved[$abstract] = true; array_pop($this-&gt;with); return $object;&#125; 还是从参数说起： 参数$abstract，获取在容器中的服务的名字，或者叫id。 参数$parameters，有些实例对象实例化的时候会需要参数，这个$parameters就是我们传入的参数。 举例：看代码，上一章我们知道，bind只是绑定一个闭包，啥也不干，所以不用传入参数，因为压根没有实例化对象。但是当我们这里要make解析的时候，即实例化Boss::class的时候，我们要把这个Object类型的对象传进去，Boss::class才能实例化。12345678910111213141516&lt;?phpclass Boss()&#123; private $obj; // 这里构造函数需要一个对象才能实例化。 public function __construct(Object $obj) &#123; $this-&gt;obj = $obj; &#125;&#125;app()-&gt;bind('Boss', Boss::class);app()-&gt;make('Boss', [new Object()]); 1.获取$abstract的别名。请参看。1$abstract = $this-&gt;getAlias($abstract); 2.设置一个变量$needsContextualBuild来做标记，标记当前这个解析的实例需不需要上下文绑定。123$needsContextualBuild = ! empty($parameters) || ! is_null( $this-&gt;getContextualConcrete($abstract) ); 在上下文绑定那章我们也说了，上下文绑定其实就是依赖绑定，就是判断当前的make的实例需不需要依赖。满足下面两个条件中的任意一个就需要： a.传入的参数不为空。很好理解，你都传入参数了，这个参数上面刚刚讲了就是为了当前实例化的时候传入作为依赖的。 b.通过函数getContextualConcrete，获取到了当前解析的这个类，是否已经有了上下文绑定的依赖。（就是事先已经使用上下文绑定过了），这个其实虚的没有任何作用，往下细看。 2.1.那让我们看看getContextualConcrete($abstract)方法如何获取事先绑定的上下文依赖的。 getContextualConcrete代码如下：123456789101112131415161718192021222324252627/** * 获取给定抽象类的上下文concrete绑定。 * * @param string $abstract * @return \Closure|string|null */protected function getContextualConcrete($abstract)&#123; if (! is_null($binding = $this-&gt;findInContextualBindings($abstract))) &#123; return $binding; &#125; // 接下来，我们需要查看是否可以在给定抽象类型的别名下绑定上下文绑定。 因此，我们将需要检查此类型是否存在别名，然后对其进行旋转并检查这些别名的上下文绑定。 if (empty($this-&gt;abstractAliases[$abstract])) &#123; return; &#125; foreach ($this-&gt;abstractAliases[$abstract] as $alias) &#123; if (! is_null($binding = $this-&gt;findInContextualBindings($alias))) &#123; return $binding; &#125; &#125;&#125; 2.1.1.首先判断是否在上下文绑定的数组中存在abstract的实例concrete，如果有就返回。直接从数组中找。 2.1.2.如果没有，看看这个$abstractAliases数组里面有没有$abstract别名，这个数组前面“别名”章节我们提过，和$aliases数据保存相反格式，保存abstract和alias关系的数组。注意，后面的数组value值才是别名，键值‘app’是abstract，格式如下：123456789$abstractAliases = [ app = &#123;array&#125; [3] 0 = &quot;Illuminate\Foundation\Application&quot; 1 = &quot;Illuminate\Contracts\Container\Container&quot; 2 = &quot;Illuminate\Contracts\Foundation\Application&quot; blade.compiler = &#123;array&#125; [1] 0 = &quot;Illuminate\View\Compilers\BladeCompiler&quot; ...] 继续看源代码。如果这个数组是空的，直接返回了。 2.1.3.如果这个数组不是空的，遍历所有abstract的别名，这个别名在binding数组中是否存在。 简单说就是abstract如果不在上下文绑定的数组中，那么看看abstract的别名是否在上下文绑定数组中。最后判断一下返回。 2.1.3.1重点来了，我们去看看findInContextualBindings源码:12345678910/** * Find the concrete binding for the given abstract in the contextual binding array. * * @param string $abstract * @return \Closure|string|null */protected function findInContextualBindings($abstract)&#123; return $this-&gt;contextual[end($this-&gt;buildStack)][$abstract] ?? null;&#125; 还记得上下文绑定那章的存储结构就是这样:contextual[when][give]=implement。这里就是取对应的值。 但是我们发现他在取[give]值的时候它使用了end($this-&gt;buildStack)。buildStack是build的实例的堆栈，我们上下文绑定的流程中完全没有这个绑定。也就是说我们从resolve进来你是找不到这个值的，这完全是虚的没有任何作用，getContextualConcrete不会取得任何值。他的存在其实是给build函数创建依赖对象的时候，会递归再次回来make解析依赖类用的。看下一章build方法解析。 总结第二点，其实我们这里主要判断是就是有没有parameters，getContextualConcrete似乎完全不会取得任何值。 3.回到主线resolve函数，如果在数组instances中已经存在这个abstract的对象了并且不需要上下文绑定，直接调用这个instances中的值返回。我们前面章节知道instances数组是保存可以shared的实体对象。既然有了，并且没有依赖，就直接返回。 这里有个问题，如果有依赖，instances中的值为什么不能直接返回，因为依赖可能会变化，仔细想想是不是。你前面使用instance传入的有依赖的对象的参数，和这次我们要求的对象传入的依赖参数，可能是不同的。比如以前存储的new A(‘1’)，这次需要的newA(‘2’)，一个对象参数不同。1234if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; return $this-&gt;instances[$abstract];&#125; 这里有一个问题，通过instance()方法是可以保存任何类型数据的。但是如果instances数组中没有事先存在的值，那么make解析的字符串默认被当做一个类路径的。（后面章节有instace绑定源码分析）举例如下：123456789101112131415// 使用instance存入字符串绑定。成功$this-&gt;app-&gt;instance('money', "11");$re = $this-&gt;app-&gt;make('money'); // success// 通过闭包绑定字符串类型的值 成功$this-&gt;app-&gt;bind('money', function()&#123; return "11";&#125;);$re = $this-&gt;app-&gt;make('money'); // success// 直接绑定字符串，同时instances数组中不存在任何值，11被当做一个类路径处理。失败$this-&gt;app-&gt;bind('money', '11');$re = $this-&gt;app-&gt;make('money'); // fail 4.1前面的条件没成立的话，接下来，把参数parameters存入with数组，前面讲过了，parameters是实例化的时候需要的依赖，所以暂存于with数组。1$this-&gt;with[] = $parameters; 4.2.接下来通过函数getConcrete($abstract)获取concrete。1$concrete = $this-&gt;getConcrete($abstract); 我们看getConcrete源代码:1234567891011121314151617181920212223/** * Get the concrete type for a given abstract. * * @param string $abstract * @return mixed $concrete */protected function getConcrete($abstract)&#123; if (! is_null($concrete = $this-&gt;getContextualConcrete($abstract))) &#123; return $concrete; &#125; // If we don't have a registered resolver or concrete for the type, we'll just // assume each type is a concrete name and will attempt to resolve it as is // since the container should be able to resolve concretes automatically. if (isset($this-&gt;bindings[$abstract])) &#123; return $this-&gt;bindings[$abstract]['concrete']; &#125; return $abstract;&#125; 主要的思路是： a. 看看上下文绑定数组中有没有$abstract对应的concrete值，如果有，太好了，最复杂的情况就是上下文绑定。直接返回就好了。连依赖都已经添加了。（参看上下文绑定存储结构和使用方法） 这里要特别注意，上下文绑定获取的concrete值可以是一个类路径，也可以是一个闭包（看看文档如何使用上下文绑定就知道了，可以传入类路径也可以是闭包。）。但是在后面的处理对两个情况是不一样的。 和上面情况雷同，其实这里getConcrete还是调用了getContextualConcrete，但buildstack中没有值，所以这个是虚的。暂时是没有值的。build解析依赖类的时候递归回来才有这个buildstack值。 b.如果没找到上下文绑定，就是一个普通绑定，就去bindings的数组中看看有没有$abstract对应的concrete值，从而确认是不是以前有绑定过。同样的$concrete可以是一个闭包，也可以是一个类路径。 c.都没有，说明没有绑定！！直接返回$abstract。 这里说明什么呢，我猜想我们是可以不用绑定bind函数，而直接make的，这样的话可以直接把$abstract当做$concrete来解析。12// 实测有效，直接返回Money::class 对象。$boss= app()-&gt;make(Money::class); 这个方法处理的结果也有三种可能： a.上下文绑定的concrete（这个其实没有） b.binding 数组中的concrete c.把$concrete===$abstract相等。 这里的c步骤到底做了什么，怎么处理的？我们往下看代码。第五步。 5.获取解析的对象了。123456789// 我们已经准备好实例化为绑定注册的具体类型的实例。 // 这将实例化类型，并递归地解决其所有“嵌套”依赖项，直到所有问题都解决为止。if ($this-&gt;isBuildable($concrete, $abstract)) &#123; $object = $this-&gt;build($concrete);&#125; else &#123; $object = $this-&gt;make($concrete);&#125; 5.1 首先，我们要看下函数isBuildable函数是什么要求。如果$concrete===$abstract或者 concrete是一个闭包，好办返回true。1234567891011/** * Determine if the given concrete is buildable. * * @param mixed $concrete * @param string $abstract * @return bool */protected function isBuildable($concrete, $abstract)&#123; return $concrete === $abstract || $concrete instanceof Closure;&#125; 5.2 如果是true，那么使用build函数处理这个object。 我们在这里简单说下build具体的会在下一章build源码中分析。 build的作用是这样的： a.如果concrete是闭包，build执行闭包函数。 b.不是闭包，build函数会使用反射产生当前$concrete类的对象。和前面我们的猜想一样。既然$abstract===$concrete，那么直接解析，都不用绑定。 5.3 如果isBuildable返回的是false呢？就是$concrete的值是・类路径・的情况，调用make进入递归。如下give给的不是一个闭包是一个类路径。则进入make。1234$container -&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(S3Filesystem::class); make再去getConcrete函数，去上下文绑定数组和binding数组，查询这个时候这个・类路径下・（就是 abstract）有没有对应的闭包或类路径。但不管怎么样。最后下来要么闭包，要么相等，他都会进入build函数创建对象。 6.到此，我们得到了解析出来的object对象。 然后第六步我们要看看是否有扩展绑定entend的处理，参看0.2章节，执行：12345// 如果我们为此类型定义了任何扩展程序，则需要遍历它们并将其应用于正在构建的对象。 // 这允许扩展服务，例如更改配置或装饰对象。foreach ($this-&gt;getExtenders($abstract) as $extender) &#123; $object = $extender($object, $this);&#125; 7.是否是单例分享的，如果是的话就存入instance，参看0.4章节12345// 如果将请求的类型注册为单例，我们将要缓存“内存”中的实例，// 这样我们以后就可以返回它，而无需在每次后续请求上创建对象的全新实例if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123; $this-&gt;instances[$abstract] = $object;&#125; 8.接着触发各个回调函数，参看0.3章节，执行回调，这个函数就是触发3个地方的回调函数。1$this-&gt;fireResolvingCallbacks($abstract, $object); 9.标记已经解析了。并且把参数从with中pop掉，没用了。这个with在build方法中使用了，在make方法中没有用到。12345// 返回之前，我们还将解析标记设置为“true”，并弹出此构建的参数替代。 // 完成这两件事之后，我们将准备好返回完整构造的类实例。$this-&gt;resolved[$abstract] = true;array_pop($this-&gt;with); 最后返回对象。 总结make（解析）相对复杂。但是主要关注几个大步骤就能明白流程。 1.首先获取最终的别名。 2.设置是否是・上下文绑定・的标记。 3.如果在shared的instances数组中找到了，同时又不是有上下文绑定需求的。直接返回对象。结束程序。 4.否则，把实例化对象所依赖的参数parameters暂存with数组。 5.通过getConcrete方法获取$concrete.注意这里的concrete还不是对象，是类路径或者是一个闭包函数。 6.有了$concrete，如果是闭包，我们利用build函数生成对象。 7.如果是类路径，我们要再递归，看看这个路径下是否还有$concrete的绑定。如果有再递归，像别名一样，找到真正那个。如果没有，使用build函数反射原理生成对象返回，with数组将在build反射中使用。 8.完成对象生成，看看有没有extend扩展。 9.看看是否需要shard，把对象存入instance中。 10.触发各个回调函数。 11.记录这个abstract已经解析过了。 12.把with数组中parameters清空掉。 13.返回对象。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container bind机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-bind%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 闭包函数不触发，它是不会创建对象的。也就是所谓的懒加载。是什么意思？ 简介 Illuminate\Container\Container类的最重要的方法：bind。 绑定是把关系存起来了，只有到make的时候才产生对象。 绑定分为几种： 1、bind把接口和其实现类绑定，当make解析接口的时候创建其实现类的实例对象。 2、singleton把接口和其实现类绑定，当第一次make解析的时候创建实例，后面都返回该实例不再创建。 3、instance把接口和其实现类的实例绑定，直接绑定实例对象。 4、上下文绑定。 5、自动绑定。 6、tag绑定。 7、extends扩展绑定。 实例测试测试1：使用闭包函数返回有依赖的对象。 12345678910111213141516171819class Money&#123; private $amount = 0; public function __construct($amount) &#123; $this-&gt;amount = $amount; &#125; public function getAmount() &#123; return $this-&gt;amount; &#125;&#125;// 注意闭包的形式$this-&gt;app-&gt;bind('money', function($app, $parameters)&#123; return new Money($parameters[0]);&#125;); 测试2：使用闭包函数返回没有依赖的对象。1234567891011class Dollar&#123; public function getAmount() &#123; return 100; &#125;&#125;$this-&gt;app-&gt;bind('dollar', function()&#123; return new Dollar();&#125;); 源码先大概看bind下源代码： 123456789101112131415161718192021222324252627282930313233343536373839/** * 在容器中注册绑定 * 绑定到容器的对象只会被解析一次，之后的调用都返回相同的实例 * * @param string $abstract * @param \Closure|string|null $concrete * @param bool $shared * @return void */public function bind(string $abstract, $concrete = null, bool $shared = false)&#123; // 移除旧的实例 $this-&gt;dropStaleInstances($abstract); // 如果没有给出具体类型，我们将简单地将具体类型设置为抽象类型。之后，要注册为共享的具体类型，而不必强制在两个参数中声明其类。 if (is_null($concrete)) &#123; $concrete = $abstract; &#125; // 如果工厂不是Closure，则意味着它只是一个类名称，该类名称已绑定到此容器中的抽象类型，我们将其包装在其自己的Closure中，以便在扩展时提供更多便利。 if (! $concrete instanceof Closure) &#123; if (! is_string($concrete)) &#123; throw new \TypeError(self::class.'::bind(): Argument #2 ($concrete) must be of type Closure|string|null'); &#125; $concrete = $this-&gt;getClosure($abstract, $concrete); &#125; $this-&gt;bindings[$abstract] = compact('concrete', 'shared'); // 如果抽象类型已在此容器中解析，则将触发反弹侦听器，以便已解析的任何对象都可以通过侦听器回调更新其对象副本。 if ($this-&gt;resolved($abstract)) &#123; $this-&gt;rebound($abstract); &#125;&#125; 参数： 1、首先明确第一个参数$abstract简单说就是id，可以当做是存入容器中的名字。可以是一个字符串，一个类，甚至是一个接口。 2、第二个参数$concrete简单说就是真实的值，可以当做是一个真正存入容器的实体。他可以是一个实现类，实例，或者一个闭包（闭包可以返回一个实现类的实例）。 3、第三个参数控制shared的值。 方法体： 1、绑定前，先清空instances和aliases数组中中存在的同名字的服务。1$this-&gt;dropStaleInstances($abstract); dropStaleInstances($abstract)如下： 12345678910/** * 删除所有过时的实例和别名。 * * @param string $abstract * @return void */protected function dropStaleInstances(string $abstract)&#123; unset($this-&gt;instances[$abstract], $this-&gt;aliases[$abstract]);&#125; 2、然后判断第二个参数$concrete是不是空，如果是空，就视$abstract和$concrete一样。比如：app()-&gt;bind(Boss::class)。 1234if (is_null($concrete))&#123; $concrete = $abstract;&#125; 3、如果当前这个$concrete不是一个闭包。就调用getClosure，返回一个闭包便于后面的操作。1234if (! $concrete instanceof Closure)&#123; $concrete = $this-&gt;getClosure($abstract, $concrete);&#125; 我们去看看这个getClosure方法是怎么返回一个闭包的。 1234567891011121314151617181920/** * 获取要在构建类型时使用的闭包。 * * @param string $abstract * @param string $concrete * @return \Closure */protected function getClosure(string $abstract, string $concrete)&#123; return function ($container, $parameters = []) use ($abstract, $concrete) &#123; if ($abstract == $concrete) &#123; return $container-&gt;build($concrete); &#125; return $container-&gt;resolve( $concrete, $parameters, $raiseEvents = false ); &#125;;&#125; 很简单代码最后直接返回了一个这样形式的闭包：function($container,$parameters=[])。 一些细节： 使用use关键字调用父类就是getClosure传入的$abstract和$concrete两个参数。 如果$abstract和$concrete是一样的，就是如果只有一个参数，或者确实两个参数一样，像这样app-&gt;bind(User::class, User::class)，那么就调用build方法。否则使用resolve方法。（build方法和resolve方法，参看后面章节） 不管怎么样，代码最后直接返回了一个这样形式的闭包：function($container,$parameters=[])。赋值给变量$concrete。而这个闭包内返回的是通过build或者resolve解析的值。 4、我们回到bind方法，上面$concrete得到一个闭包函数后，调用compact把$concrete和$shard（第三个参数判断是否shared）组成一个key分别为concrete和shared的数组，存入binding数组中，而binding数组的key是当前的抽象类。 1$this-&gt;bindings[$abstract] = compact('concrete', 'shared'); 处理后结构是这样的： 1234$binding[$abstract] =&gt; [ 'concrete' =&gt; function($container, $parameters=[]), //getClosure()得到的 'shared' =&gt; true/false, // shared的值是bind的第三个参数] 5、接下来下一句，如果当前的抽象类曾经被解析过。那再次绑定的时候，我们要使用rebound函数触发reboundCallbacks数组中的回调函数。 关于回调函数参看前面章节。 1234if ($this-&gt;resolved($abstract))&#123; $this-&gt;rebound($abstract);&#125; 如何判断当前的$abstract曾经被解析过呢，我们看下resolved函数。12345678910111213141516/** * 确定给定的抽象类型是否已解析。 * * @param string $abstract * @return bool */public function resolved(string $abstract)&#123; if ($this-&gt;isAlias($abstract)) &#123; $abstract = $this-&gt;getAlias($abstract); &#125; return isset($this-&gt;resolved[$abstract]) || isset($this-&gt;instances[$abstract]);&#125; 两个条件： 1.简单判断当前resolved数组中是否存在$abstract。 2.或者instances数组中是存在对应的值。但我们注意，先前在bind方法的第一句$this-&gt;dropStaleInstances($abstract);的时候我们清空了instances对应的$abstract的值，所以这边主要是考虑$abstract的别名在instances中是否存在残留的情况。 总结在bind方法中： 1、首先移除旧的实例，如果参数$concrete不是闭包，是类名，会通过getClosure函数将类名封装进闭包中，返回这个闭包。总之container就要闭包。 注意：build和resolve都是在一个闭包函数中，闭包函数不触发，它是不会创建对象的。也就是所谓的懒加载。关于build和resolve是如何操作的，下几章讲解。 2、然后把返回的闭包函数和share的值组合放入$this-&gt;bindings数组中。 3、最后判断当前这个$abstract是否以前被解析过，如果是，要触发对应的回调函数。 最简单的来说，就是原来在容器中，绑定的是一个id和一个闭包函数的组合。你传入闭包最好，不是闭包，Laravel会转成闭包存起来。 暂时从代码来看，我们可以猜想，最后从容器解析出来的对象是运行这个闭包产生返回的。 那我们就会有这样的猜想了，我们可以通过闭包绑定任何类型的值，因为只要在闭包中返回我们想要的任何类型的值就好了。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container share机制与alias别名]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-share%E6%9C%BA%E5%88%B6%E4%B8%8Ealias%E5%88%AB%E5%90%8D%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： class Application extends Container，Application是Container的子类。Application的$this-alias()调用的是Container父类里的方法。怎么理解？ 别名分两块，一个是Laravel自己注册的，另一种是提供了alias()函数给用户调用。怎么理解？ app()-&gt;alias(‘money’,’alias_money’);是这样使用吗？ Share机制简介Laravel的Container中有个shared机制。 123456789101112/** * Determine if a given type is shared. * * @param string $abstract * @return bool */public function isShared($abstract)&#123; return isset($this-&gt;instances[$abstract]) || (isset($this-&gt;bindings[$abstract]['shared']) &amp;&amp; $this-&gt;bindings[$abstract]['shared'] === true);&#125; 满足shared只要满足两个条件中的任意一个： 1.instances数组中存在，说明这个数组中的所有数据都是shard。我们通过名字就知道存储的是实例化的对象。 2.或者，还未实例化，但是已经绑定在数组bindings中并且参数shard==true的类。 总结通过shared我们知道，share就是一个标记。 1.instances这个实例化的数组中都是shared的。 2.未实例化但是已经绑定的数组binging中要注明sharde是true他才是sharde的。 sharde我猜想首先可以用作单例，和其他类共享单个实例，直接从instance中获取便可以了，总的来说就是一个标记。 Alias别名简介服务别名也相对重要，在很多地方使用。 通过服务绑定的别名，在解析服务的时候，跟不使用别名的效果一致。别名的作用也是为了同时支持全类型的服务绑定名称以及简短的服务绑定名称考虑的。 通俗的讲，假如我们想要创建auth服务，我们既可以这样写：1$this-&gt;app-&gt;make('auth'); 又可以写成：1$this-&gt;app-&gt;make('\Illuminate\Auth\AuthManager::class'); 还可以写成1$this-&gt;app-&gt;make('\Illuminate\Contracts\Auth\Factory::class'); 后面两个服务的名字都是auth的别名，使用别名和使用auth的效果是相同的。 这里特别注意，谁是谁的别名。 已测示例我们用别名alias_money重新命名了Money::class，别名先找到‘money’再去找到Money::class 123456789101112131415161718192021class Money&#123; public function getAmount() &#123; return 100; &#125;&#125;class ExampleTest extends TestCase&#123; public function testClosure() &#123; app()-&gt;bind('money', Money::class); app()-&gt;alias('money', 'alias_money'); $boss= app()-&gt;make('alias_money'); $output = $boss-&gt;getAmount(); $this-&gt;assertEquals($output, 100); &#125;&#125; 服务别名的获取我们看下源码： 1、看看有没有对应的$abstract的别名。如果没有就返回当前$abstract。 2、进一步递归，查看这个别名是否还有别名的别名。 123456789101112/** * Get the alias for an abstract if available. * * @param string $abstract * @return string */public function getAlias($abstract)&#123; return isset($this-&gt;aliases[$abstract]) ? $this-&gt;getAlias($this-&gt;aliases[$abstract]) : $abstract;&#125; 服务别名的实现那么这些别名是如何加载到服务容器里面的呢？ 两种方法： 1、通过调用Container中的alias方法，我们看下源代码： 1234567891011121314151617181920/** * Alias a type to a different name. * * @param string $abstract * @param string $alias * @return void * * @throws \LogicException */public function alias($abstract, $alias)&#123; // 如果发现别名和$abstract一样，抛出异常，别名不能和自己一样。 if ($alias === $abstract) &#123; throw new LogicException("[&#123;$abstract&#125;] is aliased to itself."); &#125; $this-&gt;aliases[$alias] = $abstract; $this-&gt;abstractAliases[$abstract][] = $alias;&#125; 这里有两个数组：aliases和abstractAliases，他们保存一样的数据，但是键值对相反。简单说就是aliases的key值是abstractAliases的value值。把key和value分别存储到对应的数组中。 2、外部配置引入。 其实原理也是一样，使用alias()方法，但是laravel在初始化的时候自己读取配置文件去存入对应数组中。 有两个地方，一个是app.php文件下的alias数组中，还有一个是在laravel/framwork/src/Illuminate/Foundation/Application.php下的registerCoreContainerAliases方法，这个方法在Application初始化的时候会加载。Application是Container的子类，应用容器。后面再讨论。 看部分代码实例：123456789101112131415161718192021222324&lt;?php$aliases = [ 'app' =&gt; [ \Illuminate\Foundation\Application::class, \Illuminate\Contracts\Container\Container::class, \Illuminate\Contracts\Foundation\Application::class ], 'auth' =&gt; [ \Illuminate\Auth\AuthManager::class, \Illuminate\Contracts\Auth\Factory::class ], 'auth.driver' =&gt; [ \Illuminate\Contracts\Auth\Guard::class ], 'blade.compiler' =&gt; [ \Illuminate\View\Compilers\BladeCompiler::class ], 'cache' =&gt; [ \Illuminate\Cache\CacheManager::class, \Illuminate\Contracts\Cache\Factory::class ],...] 运行的registerCoreContainerAliases方法。我们可以看到还是调用了alias()方法。12345678910111213/** * Register the core class aliases in the container. * * @return void */public function registerCoreContainerAliases()&#123; foreach ([$aliases] as $key =&gt; $aliases) &#123; foreach ($aliases as $alias) &#123; $this-&gt;alias($key, $alias); &#125; &#125;&#125; 加载后，服务容器的aliases和abstractAliases数组实例：123456789101112$aliases = [ 'Illuminate\Foundation\Application' = "app" 'Illuminate\Contracts\Container\Container' = "app" 'Illuminate\Contracts\Foundation\Application' = "app" 'Illuminate\Auth\AuthManager' = "auth" 'Illuminate\Contracts\Auth\Factory' = "auth" 'Illuminate\Contracts\Auth\Guard' = "auth.driver" 'Illuminate\View\Compilers\BladeCompiler' = "blade.compiler" 'Illuminate\Cache\CacheManager' = "cache" 'Illuminate\Contracts\Cache\Factory' = "cache" ...］ 1234567891011121314151617$abstractAliases = [ app = &#123;array&#125; [3] 0 = &quot;Illuminate\Foundation\Application&quot; 1 = &quot;Illuminate\Contracts\Container\Container&quot; 2 = &quot;Illuminate\Contracts\Foundation\Application&quot; auth = &#123;array&#125; [2] 0 = &quot;Illuminate\Auth\AuthManager&quot; 1 = &quot;Illuminate\Contracts\Auth\Factory&quot; auth.driver = &#123;array&#125; [1] 0 = &quot;Illuminate\Contracts\Auth\Guard&quot; blade.compiler = &#123;array&#125; [1] 0 = &quot;Illuminate\View\Compilers\BladeCompiler&quot; cache = &#123;array&#125; [2] 0 = &quot;Illuminate\Cache\CacheManager&quot; 1 = &quot;Illuminate\Contracts\Cache\Factory&quot; ...] 我们在这里还是要特别强调： 数组$abstractAliases中，app是abstract，后面跟着的三个数组元素才是‘app’的别名（alias） 1234app = &#123;array&#125; [3] 0 = &quot;Illuminate\Foundation\Application&quot; 1 = &quot;Illuminate\Contracts\Container\Container&quot; 2 = &quot;Illuminate\Contracts\Foundation\Application&quot; 这里的这个结构需要指出的是，不管这个app别名有多少个，这些别名都指向一个abstract，这个abstract又会指向数组binding，binding数组是建立abstract和concrete关系的数组，而这个$abstractAliases和$aliases则是建立abstruc和alias之间关系的数组。 总结别名机制就是用一个别名来命名具体对象，类或者闭包函数。他在Facade中有运用到，以及在容器绑定和解析都有用到。我们只要记住，他存储的两个数组名字： 1.abstractAliases 2.abstracts 我觉得他主要的作用可能就是让代码简洁吧。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container callbacks回调函数机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-callbacks%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在某些操作的节点，比如解析后，插入必要的一些操作。怎么理解？ call_user_func ( callable $callback [, mixed $parameter [, mixed $… ]] ) : mixed; app()-&gt;rebinding(‘money’, Closure);是这样使用吗？ 简介回调函数在容器中，用的也很多。先说作用，在某些操作的节点，比如解析后，插入必要的一些操作。感觉就像hook和事件Event一样。 在Container中，有好几种callbacks：12345protected $reboundCallbacks = []; // 所有注册的回调protected $globalResolvingCallbacks = []; // 所有全局解析回调protected $globalAfterResolvingCallbacks = []; // 所有全局解析之后回调protected $resolvingCallbacks = []; // 所有类的解析回调protected $afterResolvingCallbacks = []; // 所有类的解析之后回调 他们分别出现在不一样的地方被调用。 我们以第一个rebound举例，其他几个大同小异。 实测例子在extend之前rebinding一个回调函数，当extend完成，会输出this is rebinding callbacks12345678910111213141516171819202122232425262728293031323334class Money&#123; public function getAmount()&#123; return 100; &#125;&#125;class Dollar extends Money&#123; public function getAmount() &#123; return 1; &#125;&#125;class ExampleTest extends TestCase&#123; public function testClosure() &#123; app()-&gt;bind('money', Money::class); app()-&gt;rebinding('money', function()&#123; var_dump("this is rebinding callbacks"); &#125;); app()-&gt;extend('money',function()&#123; return new Dollar(); &#125;); $boss= app()-&gt;make('money'); $output = $boss-&gt;getAmount(); $this-&gt;assertEquals($output, 1); &#125;&#125; 源码触发rebound()回调函数的源码如下： 1234567891011121314/** * Fire the "rebound" callbacks for the given abstract type. * * @param string $abstract * @return void */protected function rebound($abstract)&#123; $instance = $this-&gt;make($abstract); foreach ($this-&gt;getReboundCallbacks($abstract) as $callback) &#123; call_user_func($callback, $this, $instance); &#125;&#125; 1.解析当前的对象。 2.然后查看当前容器中是否存在对应的rebound回调函数，如果有，遍历所有对应的回调函数，使用call_user_func执行回调函数。 2.1 看下getReboundCallbacks，获取对应所有的回调函数,是通过reboundCallbacks数组获得。源码如下： 12345678910/** * Get the rebound callbacks for a given type. * * @param string $abstract * @return array */protected function getReboundCallbacks($abstract)&#123; return $this-&gt;reboundCallbacks[$abstract] ?? [];&#125; 3.最后这个rebound()方法我们上一章1.2中知道，它会在extend绑定完成后会调用触发。 回调函数的绑定 我们上面涉及了调用，我们下面看下如何绑定。 回调函数的绑定是通过函数rebinding处理的，很简单，就是把对应的回调函数存入reboundCallbacks数组。 最后一句，如果这个对象已经绑定过了，还会贴心的返回这个对象。123456789101112131415/** * Bind a new callback to an abstract's rebind event. * * @param string $abstract * @param \Closure $callback * @return mixed */public function rebinding($abstract, Closure $callback)&#123; $this-&gt;reboundCallbacks[$abstract = $this-&gt;getAlias($abstract)][] = $callback; if ($this-&gt;bound($abstract)) &#123; return $this-&gt;make($abstract); &#125;&#125; 总结回调函数也很简单，我们只要知道在这个例子中，他通过方法rebinding，把回调函数存储在数组reboundCallbacks中，然后使用rebound以及其他几个函数在不同的地方触发。（extend扩展中触发了。）]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container extend扩展机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-extend%E6%89%A9%E5%B1%95%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： extend()在make()之前调用，里面并没有任何实例化处理，只是判断然后放进两个数组，instances和extenders。是什么判断？ extend的机制就是如果instance中存在实例，就用extend中的闭包执行结果替换掉。如果instances实例列表中不存在就存起来以后备用。怎么理解？ extend($abstract, Closure $closure)第二个闭包参数接不接收参数有什么区别？ 实测实例 实例1：替换依赖的实例对象 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 接口interface Money&#123; public function getAmount();&#125;class Dollar implements Money&#123; public function getAmount() &#123; return 1; &#125;&#125;class Cheque implements Money&#123; public function getAmount() &#123; return 100000; &#125;&#125;// 老板class Boss&#123; private $money; public function __construct(Money $money) &#123; $this-&gt;money = $money; // prints '100000' &#125; public function getA()&#123; return $this-&gt;money-&gt;getAmount(); &#125;&#125;// 老板发钱给员工public function testClosure()&#123; // 1、绑定 app()-&gt;bind('boss', Boss::class); // 老板的钱是支票 $this-&gt;app-&gt;when(Boss::class) -&gt;needs(Money::class) -&gt;give(Cheque::class); // 把支票扩展为美元 app()-&gt;extend(Money::class, function() &#123; // 闭包没有接收参数 return new Dollar(); &#125;); // 2、解析得到老板实例 $boss = app()-&gt;make('boss'); $output = $boss-&gt;getA(); $this-&gt;assertEquals($output, 1); // 实际最后是美元&#125; 本来的Boss实例的依赖Money是一个Cheque对象，最后解析的时候，被替换成了Dollar对象。 实例2：子类替换父类，向下拓展 12345678910111213141516171819202122232425262728293031323334class Money&#123; public function getAmount()&#123; return 100; &#125;&#125;class Dollar extends Money&#123; public function getAmount() &#123; return 1; &#125;&#125;class Cheque extends Money&#123; public function getAmount() &#123; return 100000; &#125;&#125;public function testClosure()&#123; // 父类被替换成子类 app()-&gt;extend(Money::class, function() &#123; // 闭包没有接收参数 return new Dollar(); &#125;); $money= app()-&gt;make(Money::class); $output = $money-&gt;getAmount(); $this-&gt;assertEquals($output, 1);&#125; 实例3：向其他地方拓展 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Money&#123; public function getAmount()&#123; return 100; &#125;&#125;class Dollar extends Money&#123; public function getAmount() &#123; return 1; &#125;&#125;class Cheque extends Money&#123; public function getAmount() &#123; return 100000; &#125;&#125;class Currenty&#123; protected $money; public function __construct(Money $money) &#123; $this-&gt;money = $money; &#125; public function getAmount() &#123; return "harveynorman"; &#125;&#125;public function testClosure()&#123; app()-&gt;bind('money', Money::class); app()-&gt;extend('money', function($money) &#123; // 闭包接收了参数 return new Currenty($money); &#125;); $boss = app()-&gt;make('money'); $output = $boss-&gt;getAmount(); $this-&gt;assertEquals($output, "harveynorman");&#125; extend的第二个参数是闭包，闭包的第一个参数就是extend第一个参数的实例，在这里就是我们事先绑定的Money::class实例。 简介extend方法可以修改解析的服务。例如，当一个服务被解析后，你可以添加额外的代码去修饰或配置这个服务。extend方法接受一个闭包，闭包的唯一参数和返回值都是一个服务： 123$this-&gt;app-&gt;extend(Service::class, function($service) &#123; return new DecoratedService($service);&#125;); extend主要的作用是在解析后，使用一个闭包函数产生的值（通常为当前实体类的子类）替换对应父实体类，从而对其产生扩展影响。这个闭包的参数和返回值都必须是对象。比如：123app()-&gt;extend('Service', function ($service, $app) &#123; return new DecoratedService($service);&#125;); 这里DecoratedService是Service的子类。 更简单来说，当我们从Container容器中取出一个实例后，用这个类的子类实例替换掉当前这个父类实例，达到扩展的作用。 当然这是一种用法。还有一些细节，我们去看下源代码。 源码12345678910111213141516171819202122232425/** * "Extend" an abstract type in the container. * * @param string $abstract * @param \Closure $closure * @return void * * @throws \InvalidArgumentException */public function extend($abstract, Closure $closure)&#123; $abstract = $this-&gt;getAlias($abstract); if (isset($this-&gt;instances[$abstract])) &#123; $this-&gt;instances[$abstract] = $closure($this-&gt;instances[$abstract], $this); $this-&gt;rebound($abstract); &#125; else &#123; $this-&gt;extenders[$abstract][] = $closure; if ($this-&gt;resolved($abstract)) &#123; $this-&gt;rebound($abstract); &#125; &#125;&#125; 1、先获取Container中这个id($abstract)的别名。 2、查看容器已有的实例数组instance里面有没有对应的实例，如果有，直接执行我们extend的这个闭包方法，返回值存入这个数组中，就是替换了原来的实例。 然后使用了rebound()，目的是看看有没有附带的回调函数，触发它，这个我们在回调函数中会提。 这说明extend的时候会触发回调函数。 3、如果instance中没有找到对应的实例，就把这个闭包函数存入extenders数组，做个记录，以后用。 并且如果这个id已经被resolved过了，还要触发rebound函数，触发一些对应的回调函数。 总结extend的机制就是如果instance中存在实例，就用extend中的闭包执行结果替换掉。如果instances实例列表中不存在就存起来以后备用。 某个适用场景可以是：用子类实例替换父类实例达到扩展的作用。 但不管怎么样，都会触发当前存在的回调函数一次。下一章讲一下回调函数。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Container contextual上下文绑定机制]]></title>
    <url>%2F2020%2F04%2F25%2FContainer-Contextual%E4%B8%8A%E4%B8%8B%E6%96%87%E7%BB%91%E5%AE%9A%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使他们运行，就要给所有的外部变量一个一个写一些值进去。这些值的集合就叫上下文。怎么理解？ 上下文绑定把数据存入了这样的数组contextual[PhotoController::class][Filesystem::class] = 闭包函数（也可以是一个类路径）。怎么理解？只有这个数组contextual，在make的时候会用到。 闭包函数可以实现懒加载，怎么理解？ Container类的属性基本都是数组。为什么？ $resolved数组存储的[‘abstractClassName’=&gt;true/false]。$bindings存储的是二维数组[‘abstractClassName’=&gt;[]]。methodBindings存储的是[‘methodName’=&gt;$closure]。$instances存储[‘abstractClassName’=&gt;$instance对象实例]。 $alias数组存储的是[‘别名’=&gt;’abstractClassName’]。$buildStack一维数组[concrete]是要构建的具体类。$with数组是参数的数组。 有三种角色，需要实例化的类A，A的依赖抽象类B，B的具体实现C。怎么理解？ 简介上下文绑定在分析Container源码的时候是一个比较重要的部分，在了解上下文绑定之前，先解释下什么是上下文： 每一段程序都有很多外部变量。只有像Add这种简单的函数才是没有外部变量的。一旦你的一段程序有了外部变量，这段程序就不完整，不能独立运行。你为了使他们运行，就要给所有的外部变量一个一个写一些值进去。这些值的集合就叫上下文。 简单说就是解析一个对象的时候，有些对象是需要外部的一些依赖的。那他在创建的时候就要用到“上下文”把依赖引入。 而上下文绑定的意思就是专门处理实例化时候，有依赖关系情况的一种绑定。 上下文绑定在Laravel文档中给出了相关示例：12345678910111213141516use Illuminate\Support\Facades\Storage;use App\Http\Controllers\PhotoController;use App\Http\Controllers\VideoController;use Illuminate\Contracts\Filesystem\Filesystem;$this-&gt;app-&gt;when(PhotoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return Storage::disk('local'); &#125;);$this-&gt;app-&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return Storage::disk('s3'); &#125;); 这是项目中常会用到的存储功能，得益于Laravel内置集成了FlySystem的Filesystem接口，我们很容易实现多种存储服务的项目。 示例中将用户头像存储到本地，将用户上传的小视频存储到云服务。那么这个时候就需要区分这样不同的使用场景（即上下文或者说环境）。 当用户存储头像（PhotoController::class）需要使用存储服务（Filesystem::class）时，我们将本地存储驱动，作为实现给到PhotoController::class。123function () &#123; return Storage::disk('local');&#125; 而当用户上传视频VideoController::class，需要使用存储服务（Filesystem::class）时，我们则将云服务驱动，作为实现给到VideoController::class。123function () &#123; return Storage::disk('s3');&#125; 实测用例12345678910111213141516171819if (! function_exists('app')) &#123; /** * Get the available container instance. * * @param string|null $abstract * @param array $parameters * @return mixed|\Illuminate\Contracts\Foundation\Application */ function app($abstract = null, array $parameters = []) &#123; if (is_null($abstract)) &#123; return Container::getInstance(); &#125; return Container::getInstance()-&gt;make($abstract, $parameters); &#125;&#125; Illuminate/Container/Container.php 123456789101112131415161718192021222324class Container implements ArrayAccess, ContainerContract&#123; /** * The current globally available container (if any). * * @var static */ protected static $instance; /** * Get the globally available instance of the container. * * @return static */ public static function getInstance() &#123; if (is_null(static::$instance)) &#123; static::$instance = new static; &#125; return static::$instance; &#125;&#125; 提供的类关系： 123456789101112131415161718192021222324252627282930// interface接口moneyinterface Money&#123; public function getAmount();&#125;// 实现类Cheque（支票）class Cheque implements Money&#123; public function getAmount() &#123; return 100000; &#125;&#125;// Boss类class Boss&#123; private $money; public function __construct(Money $money) &#123; $this-&gt;money = $money; // prints '100000' &#125; public function getA() &#123; return $this-&gt;money-&gt;getAmount(); &#125;&#125; 测试1：绑定Boss类，Boss类依赖Money类的一个对象。最后绑定的实现是Cheque类。 123456789101112public function testClosure()&#123; $this-&gt;app-&gt;when(Boss::class) -&gt;needs(Money::class) -&gt;give(Cheque::class); $boss = app()-&gt;make(Boss::class); $output = $boss-&gt;getA(); $this-&gt;assertEquals($output, 100000);&#125; 源码 Illuminate\Container\Util.php 123456789101112131415161718192021222324252627282930313233343536373839&lt;?phpnamespace Illuminate\Container;use Closure;class Util&#123; /** * If the given value is not an array and not null, wrap it in one. * * From Arr::wrap() in Illuminate\Support. * * @param mixed $value * @return array */ public static function arrayWrap($value) &#123; if (is_null($value)) &#123; return []; &#125; return is_array($value) ? $value : [$value]; &#125; /** * Return the default value of the given value. * * From global value() helper in Illuminate\Support. * * @param mixed $value * @return mixed */ public static function unwrapIfClosure($value) &#123; return $value instanceof Closure ? $value() : $value; &#125;&#125; 1、看下when方法。 illuminate\Container\Container.php 1234567891011121314151617/** * Define a contextual binding. * * @param array|string $concrete * @return \Illuminate\Contracts\Container\ContextualBindingBuilder */public function when($concrete)&#123; $aliases = []; foreach (Util::arrayWrap($concrete) as $c) &#123; $aliases[] = $this-&gt;getAlias($c); &#125; return new ContextualBindingBuilder($this, $aliases);&#125; 这个方法直接生成一个ContextualBindingBuilder对象，传入container对象和$concrete。 $concrete在这个例子中就是PhotoController::class和VideoController::class。 我们暂且用PhotoController::class为例。 2、然后进入这个ContextualBindingBuilder类看下。 Illuminate\Contracts\Container\ContextualBindingBuilder.php 12345678910111213141516171819202122&lt;?phpnamespace Illuminate\Contracts\Container;interface ContextualBindingBuilder&#123; /** * Define the abstract target that depends on the context. * * @param string $abstract * @return $this */ public function needs($abstract); /** * Define the implementation for the contextual binding. * * @param \Closure|string $implementation * @return void */ public function give($implementation);&#125; Illuminate\Container\ContextualBindingBuilder.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970&lt;?phpnamespace Illuminate\Container;use Illuminate\Contracts\Container\Container;use Illuminate\Contracts\Container\ContextualBindingBuilder as ContextualBindingBuilderContract;class ContextualBindingBuilder implements ContextualBindingBuilderContract&#123; /** * The underlying container instance. * * @var \Illuminate\Contracts\Container\Container */ protected $container; /** * The concrete instance. * * @var string|array */ protected $concrete; /** * The abstract target. * * @var string */ protected $needs; /** * Create a new contextual binding builder. * * @param \Illuminate\Contracts\Container\Container $container * @param string|array $concrete * @return void */ public function __construct(Container $container, $concrete) &#123; $this-&gt;concrete = $concrete; $this-&gt;container = $container; &#125; /** * Define the abstract target that depends on the context. * * @param string $abstract * @return $this */ public function needs($abstract) &#123; $this-&gt;needs = $abstract; return $this; &#125; /** * Define the implementation for the contextual binding. * * @param \Closure|string $implementation * @return void */ public function give($implementation) &#123; foreach (Util::arrayWrap($this-&gt;concrete) as $concrete) &#123; $this-&gt;container-&gt;addContextualBinding($concrete, $this-&gt;needs, $implementation); &#125; &#125;&#125; 这个类不大，提供了两个方法，needs和give。 先看下needs方法，很简单就是把$abstract存储起来。 这个例子中的$abstract就是Filesystem::class类。 然后返回当前对象，以致可以继续链式操作。123456789101112/** * Define the abstract target that depends on the context. * * @param string $abstract * @return $this */public function needs($abstract)&#123; $this-&gt;needs = $abstract; return $this;&#125; 3、再看下give方法： 12345678910111213/** * Define the implementation for the contextual binding. * * @param \Closure|string $implementation * @return void */public function give($implementation)&#123; foreach (Util::arrayWrap($this-&gt;concrete) as $concrete) &#123; $this-&gt;container-&gt;addContextualBinding($concrete, $this-&gt;needs, $implementation); &#125;&#125; 很简单又重新调用了Container中的addContextualBinding()，这个就是添加上下文绑定的方法，分别传入的是： concrete：PhotoController::class的别名（如果有的话）。 abstract：Filesystem::class。 implementation：闭包Storage::disk(“local”);的返回值。 4、然后我们回到Container看看方法addContextualBinding()。 123456789101112/** * Add a contextual binding to the container. * * @param string $concrete * @param string $abstract * @param \Closure|string $implementation * @return void */public function addContextualBinding($concrete, $abstract, $implementation)&#123; $this-&gt;contextual[$concrete][$this-&gt;getAlias($abstract)] = $implementation;&#125; 也很简单，就是把这些参数存入contextual数组。 （这个特别重要）数组结构形式为： contextual[PhotoController::class][Filesystem::class] = 闭包函数（也可以是一个类路径） 这就完成了一个上下文绑定。说到底和普通绑定雷同，只不过是处理有依赖的对象。 总结当一个类实例化需要一些外部依赖的时候，就要用到上下文绑定。把外部依赖通过needs传递给他。还可以通过give存储when对应的实现（针对抽象类或者接口甚至是子类）。存入到容器中那个负责上下文的那个数组中，这个数组将会在解析的时候（就是取出某个对象的时候，他对应绑定的依赖也会被取出）做判断。 必须指出，我们通过源码观察，（存储的结构：contextual[when][needs] = implement）我们发现这个implement可以传入任何类型的值，理论上来说绑定的时候没有任何问题，但是当解析的时候，他必须是一个闭包或者是needs的子类或实现类，不然它是无法解析的。在build章节中有分析。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的事务隔离级别]]></title>
    <url>%2F2020%2F04%2F23%2FMySQL%E7%9A%84%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 脏读是一个事务在处理过程中读取了另外一个事务未提交的数据。为什么会发生脏读？ 不可重复读，是指一个事务范围内，多次查询某个数据，却得到不同的结果。怎么理解？ 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。怎么理解？ 隔离程度越强，事务的执行效率越低。为什么？ MySQL的默认事务隔离级别是哪个？ 使用过关系型数据库的，应该对事务的概念有所了解，知道事务有ACID四个基本属性：原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）和持久性（Durability），今天我们主要来理解一下事务的隔离性。 什么是事务？ 数据库事务（简称：事务）是数据库管理系统执行过程中的一个逻辑单位，由一个有限的数据库操作序列构成。 事务的概念看上去不难，但是需要注意以下几个点： 1、首先，事务就是要保证一组数据库操作，要么全部成功，要么全部失败； 2、在MySQL中，事务支持是在引擎层实现的； 3、并不是所有引擎都支持事务，如MyISAM就不支持，InnoDB就支持； 今天，我们的主角是隔离性，隔离性是指当多个用户并发操作数据库时，数据库为每一个用户开启不同的事务，这些事务之间相互不干扰，相互隔离。 为什么需要隔离性？如果事务之间不是互相隔离的，可能将会出现以下问题。 1、脏读脏读（dirty read），简单来说，就是一个事务在处理过程中读取了另外一个事务未提交的数据。 这种未提交的数据我们称之为脏数据。依据脏数据所做的操作可能是不正确的。 还记得上节中我们提到的dirty page吗？这种临时处理的未提交的，都是「脏」的。 但是，若该事务未提交成功，最终所有操作都会回滚，小编看到的一分钱也只是镜花水月。比如，你给小编赞赏1分钱，整个事务需要两个步骤： ①给小编账号加一分钱，这时小编看到了，觉得很欣慰；②你的账号减一分钱； 2、不可重复读不可重复读（non-repeatable read），是指一个事务范围内，多次查询某个数据，却得到不同的结果。 在第一个事务中的两次读取数据之间，由于第二个事务的修改，第一个事务两次读到的数据可能就是不一样的。 接着上一个例子，假设你真给小编打赏了一分钱，小编乐得屁颠屁颠地去准备提现，一查，发现真多了一分钱。 在这同时，在我还没有提现成功之前，小编的老婆已经提前将这一分钱支走了，小编此时再次查账，发现一分钱也没了。 脏读和不可重复读区别 二者的区别是，脏读是某一事务读取了另外一个事务未提交的数据，不可重复读是读取了其他事务提交的数据。 其实，有些情况下，不可重复读不是问题，比如，小编提现期间，一分钱被老婆支走了，这不是问题！ 而脏读，是可以通过设置隔离级别避免的。 3、幻读幻读（phantom read），是事务非独立执行时发生的一种现象。 例如事务T1对一个表中所有的行的某个数据项做了从“1”修改为“2”的操作，这时事务T2又对这个表中插入了一行数据项为“1”的数据，并且提交给数据库。 而操作事务T1的用户如果再查看刚刚修改的数据，会发现数据怎么还是1？其实这行是从事务T2中添加的，就好像产生幻觉一样，这就是发生了幻读。 其实上面的解释已经是一个例子了，但是还是要举个例子。 比如，小编准备提取你打赏的一分钱，提取完了，这时又有其他热心网友打赏了一分钱，小编一看，明明已经取出了，怎么又有一分钱！？ 幻读和不可重复读都是读取了另一条已经提交的事务（这点就脏读不同），所不同的是不可重复读查询的都是同一个数据项，而幻读针对的是一批数据整体（比如数据的个数）。 事务的隔离级别为了解决上面可能出现的问题，我们就需要设置隔离级别，也就是事务之间按照什么规则进行隔离，将事务隔离到什么程度。 首先，需要明白一点，隔离程度越强，事务的执行效率越低。 ANSI/ISO SQL定义了4种标准隔离级别： ① Serializable（串行化）：花费最高代价但最可靠的事务隔离级别。 “写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。 事务100%隔离，可避免脏读、不可重复读、幻读的发生。 ② Repeatable read（可重复读，默认级别）：多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的。 但如果这个事务在读取某个范围内的记录时，其他事务又在该范围内插入了新的记录，当之前的事务再次读取该范围的记录时，会产生幻行，这就是幻读。 可避免脏读、不可重复读的发生。但是可能会出现幻读。 ③ Read committed（读已提交）：保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据。 可避免脏读的发生，但是可能会造成不可重复读。 大多数数据库的默认级别就是Read committed，比如Sql Server，Oracle。 ④ Read uncommitted（读未提交）：最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到。 任何情况都无法保证。 隔离级别 下图中是一个很好的例子，分别解释了四种事务隔离级别下，事务B能够读取到的结果。 看着还是有点懵逼？那我们再举个例子。 A，B两个事务，分别做了一些操作，操作过程中，在不同隔离级别下查看变量的值： 隔离级别是串行化，则在事务B执行「将1改成2」的时候，会被锁住。直到事务A提交后，事务B才可以继续执行。 再次总结 读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。读已提交：别人改数据的事务已经提交，我在我的事务中才能读到。可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。串行：我的事务尚未提交，别人就别想改数据。 这4种隔离级别，并行性能依次降低，安全性依次提高。 总的来说，事务隔离级别越高，越能保证数据的完整性和一致性，但是付出的代价却是并发执行效率的低下。 隔离级别的实现事务的机制是通过视图（read-view）来实现的并发版本控制（MVCC），不同的事务隔离级别创建读视图的时间点不同。 可重复读是每个事务重建读视图，整个事务存在期间都用这个视图。 读已提交是每条SQL创建读视图，在每个SQL语句开始执行的时候创建的。隔离作用域仅限该条SQL语句。 读未提交是不创建，直接返回记录上的最新值 串行化隔离级别下直接用加锁的方式来避免并行访问。 这里的视图可以理解为数据副本，每次创建视图时，将当前已持久化的数据创建副本，后续直接从副本读取，从而达到数据隔离效果。 隔离级别的实现我们每一次的修改操作，并不是直接对行数据进行操作。 比如我们设置id为3的行的A属性为0，并不是直接修改表中的数据，而是新加一行。 同时数据表其实还有一些隐藏的属性，比如每一行的事务id，所以每一行数据可能会有多个版本，每一个修改过它的事务都会有一行，并且还会有关联的undo日志，表示这个操作原来的数据是什么，可以用它做回滚。 那么为什么要这么做？ 因为如果我们直接把数据修改了，那么其他事务就用不了原先的值了，违反了事务的一致性。 那么一个事务读取某一行的数据到底返回什么结果呢？ 取决于隔离级别，如果是 Read Committed，那么返回的是最新的事务的提交值，所以未提交的事务修改的值是不会读到的，这就是Read Committed实现的原理。 如果是Read Repeatable级别，那么只能返回发起时间比当前事务早的事务的提交值，和比当前事务晚的删除事务删除的值。这其实就是MVCC方式。 undo logundo log中存储的是老版本数据。假设修改表中id=2的行数据，把Name=’B’修改为Name=’B2’，那么undo日志就会用来存放Name=’B’的记录，如果这个修改出现异常，可以使用undo日志来实现回滚操作，保证事务的一致性。 当一个旧的事务需要读取数据时，为了能读取到老版本的数据，需要顺着undo链找到满足其可见性的记录。当版本链很长时，通常可以认为这是个比较耗时的操作。 假设一个值从1被按顺序改成了2、3、4，在回滚日志里面就会有类似下面的记录。 当前值是4，但是在查询这条记录的时候，不同时刻启动的事务会有不同的read-view。 如图中看到的，在视图A、B、C里面，这一个记录的值分别是1、2、4，同一条记录在系统中可以存在多个版本，就是数据库的多版本并发控制（MVCC）。对于read-viewA，要得到1，就必须将当前值依次执行图中所有的回滚操作得到。 同时你会发现，即使现在有另外一个事务正在将4改成5，这个事务跟read-view A、B、C对应的事务是不会冲突的。 另外，在回滚段中的undo log分为: insert undo log 和update undo log： insert undo log：事务对insert新记录时产生的undolog，只在事务回滚时需要，并且在事务提交后就可以立即丢弃。（谁会对刚插入的数据有可见性需求呢！！） update undo log：事务对记录进行delete和update操作时产生的undo log。不仅在事务回滚时需要，一致性读也需要，所以不能随便删除，只有当数据库所使用的快照中不涉及该日志记录，对应的回滚日志才会被purge线程删除。 何时删除？ 在不需要的时候才删除。也就是说，系统会判断，当没有事务再需要用到这些回滚日志时，回滚日志会被删除。 就是当系统里没有比这个回滚日志更早的read-view的时候。 长事务直观感觉，一个事务花费很长时间不能够结束，就是一个长的事务，简称长事务（Long Transaction）。 长事务是数据库用户经常会碰到且是非常令人头疼的问题。长事务处理需要恰当进行，如处理不当可能引起数据库的崩溃，为用户带来不必要的损失。 根据上面的论述，长事务意味着系统里面会存在很老的事务视图。 由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的undo log都必须保留，这就会导致大量占用存储空间。 在MySQL 5.5及以前的版本，回滚日志是跟数据字典一起放在ibdata文件里的，即使长事务最终提交，回滚段被清理，文件也不会变小。 除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库，这个我们会在后面讲锁的时候展开。 因此，我们要尽量避免长事务。 小结这一节主要是事务的隔离级别，主要需要记住几个隔离级别、了解一下实现方式。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP的static延迟静态绑定功能]]></title>
    <url>%2F2020%2F04%2F21%2FPHP%E7%9A%84static%E5%BB%B6%E8%BF%9F%E9%9D%99%E6%80%81%E7%BB%91%E5%AE%9A%E5%8A%9F%E8%83%BD%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 从这个名字的定义提取出两个关键点，第一点静态，也就是说这个功能只适用于静态属性或静态方法。 第二点延迟绑定，这个根据下面代码就可以很好的理解。 看一下这个例子：12345678910111213141516171819202122232425262728293031class A&#123; static $name = "Tom"; public function printName() &#123; echo self::$name."\n"; self::fun(); &#125; static function fun() &#123; echo "A Class\n"; &#125;&#125;class B extends A&#123; static $name = "Jon"; static function fun() &#123; echo "B Class\n"; &#125;&#125;$obj = new B();$obj-&gt;printName();// 输出结果// Tom// A Class 我在printName函数里面使用了self关键字，self是指向当前类的”指针”，所以很多人会理想的认为输出结果会是这样：12// Join// B Class 是这样的，在定义A类的时候，在函数printName里面使用self关键字调用了静态方法或属性，但是这个函数一旦定义好，A类的静态方法和属性就被绑定到函数了，不要去追究为什么，php就是这么实现的，但是我们现在要实现这样的效果，就是函数定义好后里面使用到的静态方法和属性不要立即绑定死，而是根据最终继承的类来确定绑定。 所以php在5.5以后使用了static关键字来解决这个问题，解决后的代码例子如下：12345678910111213141516171819202122232425262728293031class A&#123; static $name = "Tom"; public function printName() &#123; echo static::$name."\n"; static::fun(); &#125; static function fun() &#123; echo "A Class\n"; &#125;&#125;class B extends A&#123; static $name = "Jon"; static function fun() &#123; echo "B Class\n"; &#125;&#125;$obj = new B();$obj-&gt;printName();// 输出结果// Join// B Class 大家可以在项目中自行挖掘使用场景，比如一个会员父类class Vip，下面两个子类分别是超级会员svip和年费会员yvip，可以在两个子类中分别重写static usergroup()方法或者其他静态属性，父类中使用延迟静态绑定，这样可以写出很优雅的代码。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Throttle]]></title>
    <url>%2F2020%2F04%2F17%2FLaravel-Throttle%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 使用可以使用时间或并发（Laravel-Funnel）来控制队列任务。该功能特性在队列任务与有频率限制的API交互时很有帮助。 通过throttle方法，你可以限定给定类型任务每60秒只运行10次。如果不能获取锁，需要将任务释放回队列以便可以再次执行： 123456789Redis::throttle('key')-&gt;allow(10)-&gt;every(60)-&gt;then(function () &#123; // Job logic... // 1分钟点击了100下，但是1分钟只有10条数据写入文件 // file_put_contents('1.txt', date('Y-m-d H:i:s').PHP_EOL, FILE_APPEND);&#125;, function () &#123; // Could not obtain lock... return $this-&gt;release(10);&#125;); 注：在上面的例子中，key可以是任意可以唯一标识你想要限定访问频率的任务类型的字符串。举个例子，这个键可以基于任务类名和操作Eloquent模型的ID进行构建。 源码 Illuminate\Redis\Limiters\DurationLimiter.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148&lt;?phpnamespace Illuminate\Redis\Limiters;use Illuminate\Contracts\Redis\LimiterTimeoutException;class DurationLimiter&#123; /** * The Redis factory implementation. * * @var \Illuminate\Redis\Connections\Connection */ private $redis; /** * The unique name of the lock. * * @var string */ private $name; /** * The allowed number of concurrent tasks. * * @var int */ private $maxLocks; /** * The number of seconds a slot should be maintained. * * @var int */ private $decay; /** * The timestamp of the end of the current duration. * * @var int */ public $decaysAt; /** * The number of remaining slots. * * @var int */ public $remaining; /** * Create a new duration limiter instance. * * @param \Illuminate\Redis\Connections\Connection $redis * @param string $name * @param int $maxLocks * @param int $decay * @return void */ public function __construct($redis, $name, $maxLocks, $decay) &#123; $this-&gt;name = $name; $this-&gt;decay = $decay; $this-&gt;redis = $redis; $this-&gt;maxLocks = $maxLocks; &#125; /** * Attempt to acquire the lock for the given number of seconds. * * @param int $timeout * @param callable|null $callback * @return mixed * * @throws \Illuminate\Contracts\Redis\LimiterTimeoutException */ public function block($timeout, $callback = null) &#123; $starting = time(); while (! $this-&gt;acquire()) &#123; if (time() - $timeout &gt;= $starting) &#123; throw new LimiterTimeoutException; &#125; usleep(750 * 1000); &#125; if (is_callable($callback)) &#123; return $callback(); &#125; return true; &#125; /** * Attempt to acquire the lock. * * @return bool */ public function acquire() &#123; $results = $this-&gt;redis-&gt;eval( $this-&gt;luaScript(), 1, $this-&gt;name, microtime(true), time(), $this-&gt;decay, $this-&gt;maxLocks ); $this-&gt;decaysAt = $results[1]; $this-&gt;remaining = max(0, $results[2]); return (bool) $results[0]; &#125; /** * Get the Lua script for acquiring a lock. * * KEYS[1] - The limiter name * ARGV[1] - Current time in microseconds * ARGV[2] - Current time in seconds * ARGV[3] - Duration of the bucket * ARGV[4] - Allowed number of tasks * * @return string */ protected function luaScript() &#123; return &lt;&lt;&lt;'LUA'local function reset() redis.call('HMSET', KEYS[1], 'start', ARGV[2], 'end', ARGV[2] + ARGV[3], 'count', 1) return redis.call('EXPIRE', KEYS[1], ARGV[3] * 2)endif redis.call('EXISTS', KEYS[1]) == 0 then return &#123;reset(), ARGV[2] + ARGV[3], ARGV[4] - 1&#125;endif ARGV[1] &gt;= redis.call('HGET', KEYS[1], 'start') and ARGV[1] &lt;= redis.call('HGET', KEYS[1], 'end') then return &#123; tonumber(redis.call('HINCRBY', KEYS[1], 'count', 1)) &lt;= tonumber(ARGV[4]), redis.call('HGET', KEYS[1], 'end'), ARGV[4] - redis.call('HGET', KEYS[1], 'count') &#125;endreturn &#123;reset(), ARGV[2] + ARGV[3], ARGV[4] - 1&#125;LUA; &#125;&#125; Illuminate\Redis\Limiters\DurationLimiterBuilder.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&lt;?phpnamespace Illuminate\Redis\Limiters;use Illuminate\Contracts\Redis\LimiterTimeoutException;use Illuminate\Support\InteractsWithTime;class DurationLimiterBuilder&#123; use InteractsWithTime; /** * The Redis connection. * * @var \Illuminate\Redis\Connections\Connection */ public $connection; /** * The name of the lock. * * @var string */ public $name; /** * The maximum number of locks that can obtained per time window. * * @var int */ public $maxLocks; /** * The amount of time the lock window is maintained. * * @var int */ public $decay; /** * The amount of time to block until a lock is available. * * @var int */ public $timeout = 3; /** * Create a new builder instance. * * @param \Illuminate\Redis\Connections\Connection $connection * @param string $name * @return void */ public function __construct($connection, $name) &#123; $this-&gt;name = $name; $this-&gt;connection = $connection; &#125; /** * Set the maximum number of locks that can obtained per time window. * * @param int $maxLocks * @return $this */ public function allow($maxLocks) &#123; $this-&gt;maxLocks = $maxLocks; return $this; &#125; /** * Set the amount of time the lock window is maintained. * * @param int $decay * @return $this */ public function every($decay) &#123; $this-&gt;decay = $this-&gt;secondsUntil($decay); return $this; &#125; /** * Set the amount of time to block until a lock is available. * * @param int $timeout * @return $this */ public function block($timeout) &#123; $this-&gt;timeout = $timeout; return $this; &#125; /** * Execute the given callback if a lock is obtained, otherwise call the failure callback. * * @param callable $callback * @param callable|null $failure * @return mixed * * @throws \Illuminate\Contracts\Redis\LimiterTimeoutException */ public function then(callable $callback, callable $failure = null) &#123; try &#123; return (new DurationLimiter( $this-&gt;connection, $this-&gt;name, $this-&gt;maxLocks, $this-&gt;decay ))-&gt;block($this-&gt;timeout, $callback); &#125; catch (LimiterTimeoutException $e) &#123; if ($failure) &#123; return $failure($e); &#125; throw $e; &#125; &#125;&#125; Illuminate\Redis\Connections\Connection.php 12345678910111213141516171819202122232425262728&lt;?phpnamespace Illuminate\Redis\Connections;use Closure;use Illuminate\Contracts\Events\Dispatcher;use Illuminate\Redis\Events\CommandExecuted;use Illuminate\Redis\Limiters\ConcurrencyLimiterBuilder;use Illuminate\Redis\Limiters\DurationLimiterBuilder;use Illuminate\Support\Traits\Macroable;abstract class Connection&#123; use Macroable &#123; __call as macroCall; &#125; /** * Throttle a callback for a maximum number of executions over a given duration. * * @param string $name * @return \Illuminate\Redis\Limiters\DurationLimiterBuilder */ public function throttle($name) &#123; return new DurationLimiterBuilder($this, $name); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel中通过Macroable宏来扩展类的能力]]></title>
    <url>%2F2020%2F04%2F15%2FLaravel%E4%B8%AD%E9%80%9A%E8%BF%87Macroable%E5%AE%8F%E6%9D%A5%E6%89%A9%E5%B1%95%E7%B1%BB%E7%9A%84%E8%83%BD%E5%8A%9B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 闭包函数为Closure类的实例对象。怎么理解？ $new_closure = Closure::bind($closure, new ClassName(), ClassName::class);和$new_closure = $closure-&gt;bindTo(new ClassName(), ClassName::class);有什么区别？ PHP闭包中的绑定bindTo和bind123456789101112131415161718192021final class Closure &#123; // 用于禁止实例化 private function __construct() &#123; &#125; // 复制一个闭包，绑定指定的$this对象和类作用域。这个方法是 Closure::bindTo() 的静态版本 static function bind ( Closure $closure , object $newthis [, mixed $newscope = 'static' ] ) : Closure // 复制当前闭包对象，绑定指定的$this对象和类作用域。 public function bindTo ( object $newthis [, mixed $newscope = 'static' ] ) : Closure // 当尝试以调用函数的方式调用一个对象时，__invoke() 方法会被自动调用。 public function __invoke ([ $... ] ) : mixed // Temporarily binds the closure to newthis, and calls it with any given parameters. // 一次性的，绑定$this，并可以传入参数，直接发起调用 // @since 7.0 function call ($newThis, ...$parameters) &#123;&#125; // 将给定的函数转化为匿名函数，可传入函数名 public static function fromCallable (callable $callable) &#123;&#125;&#125; fromCallable等价于： 12$reflexion = new ReflectionFunction('addDiscount');$closure = $reflexion-&gt;getClosure(); bindTo和bind函数的功能相同，一个是静态调用，一个实例调用，请看下面的示例： 创建一个匿名函数： 12345$clo = function ($name) &#123; echo $name;&#125;;var_dump($clo); 结果为：1234567object(Closure)#1 (1) &#123; ["parameter"]=&gt; array(1) &#123; ["$name"]=&gt; string(10) "&lt;required&gt;" &#125;&#125; 由此可见$clo为Closure类的实例对象。所以Closure类是不能使用通过构造函数来实例化，也没这个必要，所以构造函数被定义为私有的。 所以上面说的实例调用是指$clo-&gt;bindTo($newthis, $newscope)，静态调用是指Closure::bind($clo, $newthis, $newscope)都能够得到一个新的闭包。 那么，它的使用场景是什么？ 有时候我们在闭包内部想要访问某个类或者对象的属性和方法，但是它们是由访问修饰符控制的，也就存在作用域的问题。 并且想要使用$this来访问的话，必须是在对象的内部，鉴于这些问题，我们有必要来操作一下闭包，使其具有这些能力。 1、具有“本类内部”同等效果的作用域 2、将$this传递到闭包里面，绑定到具体的实例，可使用$this访问。 看例子：123456789101112131415161718192021222324252627class Test &#123; public static $name = "rao"; protected static $color = "red"; private static $height = "188"; public $age = 12; protected $sex = 1; private $weight = 100; function a() &#123; $fun = function ()&#123; var_dump(Test::$name); var_dump(Test::$color); var_dump(Test::$height); var_dump($this-&gt;age); var_dump($this-&gt;sex); var_dump($this-&gt;weight); &#125;; var_dump($fun); $fun(); &#125;&#125;(new Test())-&gt;a(); 打印： 1234567891011121314151617object(Closure)#2 (1) &#123; ["this"]=&gt; object(Test)#1 (3) &#123; ["age"]=&gt; int(12) ["sex":protected]=&gt; int(1) ["weight":"Test":private]=&gt; int(100) &#125;&#125;string(3) "rao"string(3) "red"string(3) "188"int(12)int(1)int(100) 由于$fun是定义在类的内部，于是它已经具备了这两个能力，这叫自动绑定。如果不想被自动绑定$this，可以使用静态闭包： 12345$fun = static function ()&#123; var_dump(Test::$name); var_dump(Test::$color); var_dump(Test::$height);&#125;; 但是”本类内部“的功能还在。 但是对于一个外来的闭包，是不具备这些能力的。 $fun2不在类里面定义。 12345678$fun2 = function ()&#123; var_dump(Test::$name); // 可以访问 var_dump(Test::$color); // 无法访问 var_dump(Test::$height); // 无法访问 var_dump($this-&gt;age); // 无法访问 var_dump($this-&gt;sex); // 无法访问 var_dump($this-&gt;weight); // 无法访问&#125;; 好，我们来使用bind()方法。 12345$fun22 = Closure::bind($fun2, new Test(), Test::class);// 或者 $fun22 = $fun2-&gt;bindTo(new Test(), Test::class);var_dump($fun22);$fun22(); 打印： 1234567891011121314151617object(Closure)#3 (1) &#123; ["this"]=&gt; object(Test)#2 (3) &#123; ["age"]=&gt; int(12) ["sex":protected]=&gt; int(1) ["weight":"Test":private]=&gt; int(100) &#125;&#125;string(3) "rao"string(3) "red"string(3) "188"int(12)int(1)int(100) 如果只想绑定$this的话，PHP7.0以后可以直接使用call，绑定并调用。 1$fun2-&gt;call(new Test()); 和上面的结果一模一样，这就是bind和bindTo的作用。当然根据需要也可以只赋予某一种能力。newthis需要绑定到匿名函数的对象，或者NULL创建未绑定的闭包。 newscope想要绑定给闭包的类作用域，或者‘static’表示不改变。如果传入一个对象，则使用这个对象的类型名。 类作用域用来决定在闭包中$this对象的 私有、保护方法的可见性。 这种操作一般用在框架里面，来扩展类或者实例的功能。 比如Laravel框架中的Illuminate\Support\Traits\Macroable宏。Laravel提供的Macroable可以在不改变类结构的情况为其扩展功能 Macroable我们以Illuminate\Support\Traits\Macroable为例分析。 通过trait可以很方便的在任何类中使用。 Laravel提供的Macroable可以在不改变类结构的情况下为其扩展功能。也就是为一个类动态注入一些方法，并且和该类本身的方法拥有同样的作用域和调用方式。 Macroable的核心是基于匿名函数的绑定功能。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104trait Macroable&#123; /** * The registered string macros. * * @var array */ protected static $macros = []; /** * Register a custom macro. * * @param string $name * @param object|callable $macro * * @return void */ public static function macro($name, $macro) &#123; static::$macros[$name] = $macro; &#125; /** * Mix another object into the class. * * @param object $mixin * @return void * * @throws \ReflectionException */ public static function mixin($mixin) &#123; $methods = (new ReflectionClass($mixin))-&gt;getMethods( ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED ); foreach ($methods as $method) &#123; $method-&gt;setAccessible(true); static::macro($method-&gt;name, $method-&gt;invoke($mixin)); &#125; &#125; /** * Checks if macro is registered. * * @param string $name * @return bool */ public static function hasMacro($name) &#123; return isset(static::$macros[$name]); &#125; /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public static function __callStatic($method, $parameters) &#123; if (! static::hasMacro($method)) &#123; throw new BadMethodCallException(sprintf( 'Method %s::%s does not exist.', static::class, $method )); &#125; if (static::$macros[$method] instanceof Closure) &#123; return call_user_func_array(Closure::bind(static::$macros[$method], null, static::class), $parameters); &#125; return call_user_func_array(static::$macros[$method], $parameters); &#125; /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public function __call($method, $parameters) &#123; if (! static::hasMacro($method)) &#123; throw new BadMethodCallException(sprintf( 'Method %s::%s does not exist.', static::class, $method )); &#125; $macro = static::$macros[$method]; if ($macro instanceof Closure) &#123; return call_user_func_array($macro-&gt;bindTo($this, static::class), $parameters); &#125; return call_user_func_array($macro, $parameters); &#125;&#125; 我们可以看到执行绑定是在__callStatic和__call里面，如果一个类想要借助Macroable来提升能力，基本操作是： 1、use Macroable; 2、调用macro添加一个方法到$macros macro可以添加匿名函数和对象，之所能通过调用匿名函数的方式调用对象，前提是该对象要实现__invoke()方法，也就是说，调用这个对象的入口是__invoke()方法。 例如： 123456789101112131415class Foo&#123; use Macroable;&#125;final class Join&#123; public function __invoke(...$string) &#123; return implode('-', $string); &#125;&#125;Foo::macro('join', new Join()); 或者 123Foo::macro('join', function(...$string)&#123; return implode('-', $string);&#125;); 3、或者调用mixin将一个对象包含的全部方法都注册到当前类中。 使用了反射类获取到public和protected的方法，并且将protected方法设置为可访问，最后调用了这些方法，将返回值注入到 $macros；我们知道注册进去的都是可以被当作闭包调用的，因此我们反射的这个对象里面的方法的返回值应该是闭包，例如： 123456789101112131415161718192021final class Str&#123; public function join() &#123; // 返回匿名函数 return function(...$string)&#123; return implode('-', $string); &#125;; &#125; public function split() &#123; // 返回匿名函数 return function(string $string)&#123; return explode('-', $string); &#125;; &#125;&#125;// 执行注入mixin(new Str()) 为了更便捷的扩展一个类的功能，macro，mixin，hasMacro三个方法都被设计为静态调用，可以通过类直接调用来扩展方法。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Macroable]]></title>
    <url>%2F2020%2F04%2F12%2FLaravel-Macroable%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Macro的中文是什么意思？ static延迟静态绑定是什么意思？Traits中使用static是什么意思？ Macroable Traits维护一个string=&gt;obj/callable的数组并提供静态写入macro和查询hasMacro函数。怎么理解？ __call()函数可以直接调用吗？(new Test(‘construct_param’))-&gt;__call(‘method’, ‘parameter’);可以这样写吗？ 简介计算机科学里的宏（Macro），是一种批量处理的称谓。一般说来，宏是一种规则或模式，或称语法替换，用于说明某一特定输入（通常是字符串）如何根据预定义的规则转换成对应的输出（通常也是字符串)。这种替换在预编译时进行，称作宏展开。它能使日常工作变得更容易。 今天我们讲讲Laravel中的宏操作。 源码Laravel中通过Macroable宏来扩展类的能力 使用macro 123456789101112131415161718class Father&#123; // 通过增加魔术方法__invoke我们就可以把对象当做闭包来使用了。 public function __invoke() &#123; echo __CLASS__; &#125;&#125;class Child&#123; use \Illuminate\Support\Traits\Macroable;&#125;// 增加了宏指令之后，我们就能调用Child对象中不存在的方法了Child::macro('show', new Father);// 输出:Father(new Child)-&gt;show(); 1234567891011121314class Child&#123; use \Illuminate\Support\Traits\Macroable; protected $name = 'father';&#125;// 闭包的特殊处理，需要做的就是绑定$this, 如Child::macro('show', function () &#123; echo $this-&gt;name;&#125;);// 输出:father(new Child)-&gt;show(); mixin 12345678910111213141516171819202122232425262728293031323334353637383940// 实际使用class Father&#123; public function say() &#123; return function () &#123; echo 'say'; &#125;; &#125; public function show() &#123; return function () &#123; echo 'show'; &#125;; &#125; protected function eat() &#123; return function () &#123; echo 'eat'; &#125;; &#125;&#125;class Child&#123; use \Illuminate\Support\Traits\Macroable;&#125;// 批量绑定宏指令Child::mixin(new Father);$child = new Child;// 输出:say$child-&gt;say();// 输出:show$child-&gt;show();// 输出:eat$child-&gt;eat(); 源码PHP的static延迟静态绑定功能 Illuminate\Support\Traits\Macroable.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117&lt;?phpnamespace Illuminate\Support\Traits;use Closure;use ReflectionClass;use ReflectionMethod;use BadMethodCallException;trait Macroable&#123; /** * The registered string macros. * * @var array */ protected static $macros = []; /** * Register a custom macro. * * @param string $name * @param object|callable $macro * * @return void */ public static function macro($name, $macro) &#123; static::$macros[$name] = $macro; &#125; /** * Mix another object into the class. * * @param object $mixin * @param bool $replace * @return void * * @throws \ReflectionException */ public static function mixin($mixin, $replace = true) &#123; $methods = (new ReflectionClass($mixin))-&gt;getMethods( ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED ); foreach ($methods as $method) &#123; if ($replace || ! static::hasMacro($method-&gt;name)) &#123; $method-&gt;setAccessible(true); static::macro($method-&gt;name, $method-&gt;invoke($mixin)); &#125; &#125; &#125; /** * Checks if macro is registered. * * @param string $name * @return bool */ public static function hasMacro($name) &#123; return isset(static::$macros[$name]); &#125; /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public static function __callStatic($method, $parameters) &#123; if (! static::hasMacro($method)) &#123; throw new BadMethodCallException(sprintf( 'Method %s::%s does not exist.', static::class, $method )); &#125; $macro = static::$macros[$method]; if ($macro instanceof Closure) &#123; return call_user_func_array(Closure::bind($macro, null, static::class), $parameters); &#125; return $macro(...$parameters); &#125; /** * Dynamically handle calls to the class. * * @param string $method * @param array $parameters * @return mixed * * @throws \BadMethodCallException */ public function __call($method, $parameters) &#123; if (! static::hasMacro($method)) &#123; throw new BadMethodCallException(sprintf( 'Method %s::%s does not exist.', static::class, $method )); &#125; $macro = static::$macros[$method]; if ($macro instanceof Closure) &#123; return call_user_func_array($macro-&gt;bindTo($this, static::class), $parameters); &#125; return $macro(...$parameters); &#125;&#125; Macroable::macro方法 1234public static function macro($name, $macro)&#123; static::$macros[$name] = $macro;&#125; 很简单的代码，根据参数的注释，$macro可以传一个闭包或者对象，之所以可以传对象，多亏了PHP中的魔术方法。 Macroable::mixin方法 这个方法是把一个对象的方法的返回结果注入到原对象中。12345678910111213public static function mixin($mixin, $replace = true)&#123; $methods = (new ReflectionClass($mixin))-&gt;getMethods( ReflectionMethod::IS_PUBLIC | ReflectionMethod::IS_PROTECTED ); foreach ($methods as $method) &#123; if ($replace || ! static::hasMacro($method-&gt;name)) &#123; $method-&gt;setAccessible(true); static::macro($method-&gt;name, $method-&gt;invoke($mixin)); &#125; &#125;&#125; 在上面的代码可以看出mixin可以将一个类的方法绑定到宏类中。需要注意的就是，方法必须是返回一个闭包类型。 Macroable::hasMacro方法 1234public static function hasMacro($name)&#123; return isset(static::$macros[$name]);&#125; 这个方法就比较简单没什么复杂可言，就判断是否存在宏指令。通常是使用宏指令之前判断一下。 Macroable::__call和Macroable::__callStatic方法 正是由于这两个方法，我们才能进行宏操作，两个方法除了执行方式不同，代码大同小异。这里讲一下__call。123456789101112131415161718public function __call($method, $parameters)&#123; // 如果不存在这个宏指令，直接抛出异常 if (! static::hasMacro($method)) &#123; throw new BadMethodCallException("Method &#123;$method&#125; does not exist."); &#125; // 得到存储的宏指令 $macro = static::$macros[$method]; // 闭包做一点点特殊的处理 if ($macro instanceof Closure) &#123; return call_user_func_array($macro-&gt;bindTo($this, static::class), $parameters); &#125; // 不是闭包，比如对象的时候，直接通过这种方法运行，但是要确保对象有`__invoke`方法 return call_user_func_array($macro, $parameters);&#125; 在上面的操作中我们绑定宏时，在闭包中可以通过$this来调用Child的属性，是因为在__call方法中我们使用Closure::bindTo方法。 官网对Closure::bindTo的解释：复制当前闭包对象，绑定指定的$this对象和类作用域。 Laravel中对类增加宏指令Laravel中很多类都使用了宏这个trait。 比如Illuminate\Filesystem\Filesystem::class，我们想为这个类增加一个方法，但不会动到里面的代码。 Illuminate\Filesystem\Filesystem.php 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace Illuminate\Filesystem;use ErrorException;use FilesystemIterator;use Illuminate\Contracts\Filesystem\FileNotFoundException;use Illuminate\Support\Traits\Macroable;use Symfony\Component\Finder\Finder;class Filesystem&#123; use Macroable; /** * Determine if a file or directory exists. * * @param string $path * @return bool */ public function exists($path) &#123; return file_exists($path); &#125; /** * Determine if a file or directory is missing. * * @param string $path * @return bool */ public function missing($path) &#123; return ! $this-&gt;exists($path); &#125;&#125; 我们只需要到App\Providers\AppServiceProvider::register方法增加宏指令（你也可以专门新建一个服务提供者专门处理）。 App\Providers\AppServiceProvider.php 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\Providers;use Illuminate\Support\Facades\Schema;use Illuminate\Support\ServiceProvider;use Illuminate\Filesystem\Filesystem;class AppServiceProvider extends ServiceProvider&#123; /** * Register any application services. * * @return void */ public function register() &#123; // &#125; /** * Bootstrap any application services. * * @return void */ public function boot() &#123; Filesystem::macro('readFile', function ($fileName, $useIncludePath = null, $context = null)&#123; readfile($fileName, $useIncludePath, $context); &#125;); &#125;&#125; 然后增加一条测试路由，测试我们新增加的方法。 12345&lt;?phpRoute::get('/', function (\Illuminate\Filesystem\Filesystem $filesystem)&#123; $filesystem-&gt;readFile(__DIR__.'/../.env.example');&#125;); 然后打开浏览器运行，你就会发现，我们的代码可以正常的运行了并输出结果了。 MacroableLaravel提供的Macroable可以在不改变类结构的情况为其扩展功能，本文将教你从零开始构建一个Macroable。 Macroable的核心是基于匿名函数的绑定功能，先来回顾下匿名函数的绑定功能。 预备知识PHP可通过匿名函数的绑定功能来扩展类或者实例的功能。 定义类： 123class Foo&#123;&#125; 定义匿名函数： 123$join = function(...$string)&#123; return implode('-', $string);&#125; 使用bindTo为类的实例添加join功能：123$foo = new Foo();$bindFoo = $join-&gt;bindTo($foo, Foo::class);$bindFoo('a', 'b', 'c'); // "a-b-c" PHP7之后引入了call方法更高效的实现了该功能：12$foo = new Foo();$join-&gt;call($foo, 'a', 'b', 'c'); // "a-b-c" 对于本例而言，使用bind方法进行静态绑定更贴合实际场景：12$bindClass = \Closure::bind($join, null, Foo::class);$bindClass('a', 'b', 'c'); // "a-b-c" 如果还没看懂的话，可以参考我之前写的PHP核心特性-匿名函数。 通过匿名函数扩展类的功能了解了匿名函数的绑定功能后，就可以对其进行简单的封装了。首先，定义一个数组用来保存要添加的功能列表123456789101112&lt;?phptrait Macroable &#123; // 保存要扩展的功能 protected static $macros = []; // 添加要扩展功能 public static function macro($name, $macro) &#123; static::$macros[$name] = $macro; &#125;&#125; macros属性保存了要添加的功能名及实现，在类中使用该Trait：1234class Foo &#123; use Macroable;&#125; 添加join功能：123Foo::macro('join', function(...$string)&#123; return implode('-', $string);&#125;); join功能及对应的实现已经保存到了macros数组中。接下来是调用join方法：1Foo::join('a', 'b', 'c') 由于Foo中的join静态方法不存在，会自动将方法名和参数转发到__callStatic魔术方法中。因此，在魔术方法中手动调用绑定的匿名函数即可：1234567891011public static function __callStatic($name, $parameters)&#123; // 获取匿名函数 $macro = static::$macros[$name]; // 绑定到类 $bindClass = \Closure::bind($macro, null, static::class); // 调用并返回调用结果 return $bindClass(...$parameters);&#125; 测试：1echo Foo::join('a', 'b', 'c'); // a-b-c 动态扩展与静态扩展的实现原理完全一样：12345678public function __call($name, $parameters) &#123; // 获取匿名函数 $macro = static::$macros[$name]; // 调用并返回调用结果 return $macro-&gt;call($this, ...$parameters);&#125; 测试：12$foo = new Foo();echo $foo-&gt;join('a', 'b', 'c'); // 'a-b-c' 通过对象实例来扩展类的功能之前，我们通过匿名函数的方式扩展类的功能：123Foo::macro('join', function(...$string)&#123; return implode('-', $string);&#125;); 现在，我们考虑如何通过对象的方式来实现同样的功能。首先，将匿名函数改造成类：1234567final class Join&#123; public function __invoke(...$string) &#123; return implode('-', $string); &#125;&#125; 当以函数的方式调用该类时，就会激活__invoke方法：12$join = new Join();$join('a', 'b', 'c'); // a-b-c 现在，将Join的实例添加到类中，实现同样的效果1Foo::macro('join', new Join()); 只需要对原有的__callStatic 方法增加一层判断即可。如果是匿名函数则绑定该匿名函数并调用，如果是对象则以函数的方式调用对象，激活对象的__invoke 方法。123456789101112131415161718192021222324public function __call($name, $parameters) &#123; $macro = static::$macros[$name]; if($macro instanceof Closure)&#123; return $macro-&gt;call($this, ...$parameters); &#125; return $macro(...$parameters);&#125;public static function __callStatic($name, $parameters)&#123; $macro = static::$macros[$name]; // 闭包 if($macro instanceof Closure)&#123; $bindClass = \Closure::bind($macro, null, static::class); return $bindClass(...$parameters); &#125; // 对象实例，则激活该对象 return $macro(...$parameters);&#125; 测试1Foo::join('a', 'b', 'c'); // a-b-c 同时扩展多个方法最后，Laravel的Macroable还实现了同时扩展多个方法。 原理其实很简单，将功能类似的方法定义在一个类中123456789101112131415161718final class Str&#123; public function join() &#123; // 返回匿名函数 return function(...$string)&#123; return implode('-', $string); &#125;; &#125; public function split() &#123; // 返回匿名函数 return function(string $string)&#123; return explode('-', $string); &#125;; &#125;&#125; 每个方法都返回了匿名函数，我们只需要将每个匿名函数添加到$macros列表中即可，只需要用到PHP的反射功能即可实现。1234567891011121314public static function mixin($mixin) &#123; // 通过反射获取对象的 ReflectionMethod 列表 $methods = (new \ReflectionClass($mixin))-&gt;getMethods( \ReflectionMethod::IS_PUBLIC | \ReflectionMethod::IS_PROTECTED ); // 遍历 ReflectionMethod 列表，依次保存到 $macros 中 foreach ($methods as $method) &#123; $method-&gt;setAccessible(true); // 依次激活该对象的每个方法，每个方法返回的匿名函数刚好保存在 $macros 中 static::macro($method-&gt;name, $method-&gt;invoke($mixin)); &#125;&#125; 测试123Foo::mixin(new Str());Foo::join('a', 'b', 'c');Foo::split('a-b-c'); 当然，这个功能没多大作用，还不如直接用Trait来的直观方便。 利用Laravel Macroable特性优化多态参数传递的技巧分享准备如果我们现在需要设计这样一个接口：获取指定文章的所有评论Or获取指定视频的所有评论。 我们有三张表：视频表：videos文章表：posts评论表：comments评论表中有这两个字段：commentable_type、commentable_id 分别存储评论主体信息。他们之间的模型关系为多态关联，就不再多解释了，哈哈。 当接收到这个需求的时候，你可能会困惑，主体不确定该怎么去设计呢。通过 commentable_type 判断是什么模型，然后再根据确定的类型和 commentable_id 获取到具体的对象吗？此时你脑中的代码是什么样子的呢，反正当时我的脑子里面是一堆乱糟糟的代码，哈哈。现在就来给大家介绍这种优雅的实现方式。 获取可评论对象 首先我们利用macro给Request定义一个commentable：1234567891011121314151617Request::macro(('commentable'), function(bool $required = false)&#123; if (!request()-&gt;has('commentable_type')) &#123; return $required ? abort(422, '目标对象不存在') : null; &#125; $model = request()-&gt;get('commentable_type'); $model = Relation::getMorphedModel($model) ?? $mode; $commentable = call_user_func([$model, 'find'], request()-&gt;get('commentable_id')); if (!$commentable)&#123; return $required ? abort(422, '目标对象不存在') : null; &#125; return $commentable;&#125;); 可以看到，目标对象的转换就是通过commentable_type，commentable_id这两个参数来的，这段代码不是很难，大家研究一下就看懂哒。可以在服务提供者中定义。 控制器123456789101112131415class CommentController extends Controller&#123; /** * Display a listing of the resource. * * @param \Illuminate\Http\Request $request * * @return \Illuminate\Http\Resources\Json\AnonymousResourceCollection */ public function index(Request $request) &#123; return CommentResource::collection($request-&gt;commentable(true)-&gt;comments()-&gt;get()); &#125;&#125; 大家会发现现在已经可以通过 $request-&gt;commentable(true)来获取可评论对象了，但是少了验证，但是这个验证该怎么写呢，现在我们来看一下。 验证规则12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class Polymorphic extends Rule&#123; /** * @var string */ protected $name; /** * @var string */ protected $message; /** * Create a new rule instance. * * @param string $name * @param string|null $message */ public function __construct(string name, string $message = null) &#123; $this-&gt;name = $name; $this-&gt;message = $message; &#125; /** * Determine if the validation rule passes. * * @param string $attribute * @param mixed $value * * @return bool */ public function passes($attribute, $value) &#123; $model = request()-&gt;get(\sprintf('%s_type'), $this-&gt;name); $model = Relation::getMorphedModel($model) ?? $mode; return \class_exists($model) &amp;&amp; (bool) \call_user_func([$model, 'find'], \request()-&gt;get(\sprintf('%s_id'), $this-&gt;name))); &#125; /** * Get the validation error message. * * @return string */ public function message() &#123; return $this-&gt;message ?: '未指定目标对象或目标不存在'; &#125;&#125; 现在规则定义好了，我们来使用：1234567891011121314151617/** * Display a listing of the resource. * * @param \Illuminate\Http\Request $request * * @return \Illuminate\Http\Resources\Json\AnonymousResourceCollection * * @throws \Illuminate\Validation\ValidationException */public function index(Request $request)&#123; $this-&gt;validate($request, [ 'commentable_id' =&gt; ['required', new Polymorphic('commentable', '未指定评论对象或对象不存在')], ]); return CommentResource::collection($request-&gt;commentable(true)-&gt;comments()-&gt;get());&#125; 宏（Macros）宏是一种挂接到框架并扩展某些附加功能而无需显式继承该类的方法。许多Illuminate组件都使用了Macroable特性，该特性允许您为类扩展更多功能。如果我们深入研究代码并了解其特征，则可以看到静态属性$macros。该静态属性的作用是全局访问。如果将宏分配给Collection类，则所有Collection实例将能够访问同一宏。 使用方法注册宏 通过调用静态方法macro($name，$macro)将宏绑定到类中。该方法从字面上通过键$name将$macro（关闭执行功能）绑定到$macros数组中。用它可以扩展更多用法，例如，像文档中所述的Collection类。请注意，这通常是在服务提供者中完成的。 macro详解 我们还可以看到__call和__callStatic魔术方法。只要在类上调用了不可访问的方法，PHP就会自动调用这两个魔术方法。 我们想重写它以查看宏是否存在（static :: hasMacro（$ macro），如果存在，则从数组中解析 macro 并调用它。 macro 通常是个可以被任何类调用的闭包。 请注意，如果愿意，可以通过调用 mixin 方法在另一个对象中建立宏。 您可能没有注意到，在 Closure 中宏调用 $this 将访问该类本身的当前实例。 这怎么可能？ 我如何使用$this访问Closure 中的对象的属性和方法？ 好吧，PHP 的闭包中有一种称为 bindTo 的方法，而 Laravel 则利用了这种方法。 它将当前宏对象绑定到 Closure ，因此 $this 引用类本身，而不是 Closure。 冲突 如果使用 Macroable 特性的类具有 __call 方法，则将发生冲突。 两种方法都不能被调用，因此当我们使用 Macroable 时，我们应该将 Macroable 的 __call 方法重命名为其他名称，但是请确保在对象的__call 方法中调用你重命名的方法。 可以在 Cache\Repository 类中看到示例。 我们导入 trait，同时将 __call 重命名为 macrocrock。 然后在 Repository 的__call 中，如果类具有宏，请确保调用 macroCall 方法 ，否则默认调用 b 本地方法，这样既可解决冲突。 注意:不要过度使用它。如果您有很多宏，或者有一些非常复杂的逻辑，那么继承类并执行相应的逻辑要比用宏扩展服务提供者要好得多。 我比较喜欢使用一个宏来检查 Request 类，以确定是否选中了表单中的复选框：123Request::macro('checked', function ($attribute) &#123; return in_array($this-&gt;input($attribute, false), [true, 1, '1', 'on']);&#125;);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Cache]]></title>
    <url>%2F2020%2F04%2F12%2FLaravel-Cache%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： use Macroable {__call as macroCall;}为什么这样写？ CacheManager维护了一个[string=&gt;Repository对象]的数组，并管理了各种Cache种类，是一个工厂。怎么理解？ 源码文件结构 Cache门面 Illuminate\Support\Facades\Cache.php 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace Illuminate\Support\Facades;/** * @method static \Illuminate\Contracts\Cache\Repository store(string|null $name = null) * @method static bool has(string $key) * @method static bool missing(string $key) * @method static mixed get(string $key, mixed $default = null) * @method static mixed pull(string $key, mixed $default = null) * @method static bool put(string $key, $value, \DateTimeInterface|\DateInterval|int $ttl = null) * @method static bool add(string $key, $value, \DateTimeInterface|\DateInterval|int $ttl = null) * @method static int|bool increment(string $key, $value = 1) * @method static int|bool decrement(string $key, $value = 1) * @method static bool forever(string $key, $value) * @method static mixed remember(string $key, \DateTimeInterface|\DateInterval|int $ttl, \Closure $callback) * @method static mixed sear(string $key, \Closure $callback) * @method static mixed rememberForever(string $key, \Closure $callback) * @method static bool forget(string $key) * @method static \Illuminate\Contracts\Cache\Store getStore() * * @see \Illuminate\Cache\CacheManager * @see \Illuminate\Cache\Repository */class Cache extends Facade&#123; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return 'cache'; &#125;&#125; CacheServiceProvider Illuminate\Cache\CacheServiceProvider.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpnamespace Illuminate\Cache;use Illuminate\Contracts\Support\DeferrableProvider;use Illuminate\Support\ServiceProvider;use Symfony\Component\Cache\Adapter\Psr16Adapter;class CacheServiceProvider extends ServiceProvider implements DeferrableProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton('cache', function ($app) &#123; return new CacheManager($app); &#125;); $this-&gt;app-&gt;singleton('cache.store', function ($app) &#123; return $app['cache']-&gt;driver(); &#125;); $this-&gt;app-&gt;singleton('cache.psr6', function ($app) &#123; return new Psr16Adapter($app['cache.store']); &#125;); $this-&gt;app-&gt;singleton('memcached.connector', function () &#123; return new MemcachedConnector; &#125;); &#125; /** * Get the services provided by the provider. * * @return array */ public function provides() &#123; return [ 'cache', 'cache.store', 'cache.psr6', 'memcached.connector', ]; &#125;&#125; 工厂 Illuminate\Contracts\Cache\Factory.php 1234567891011121314&lt;?phpnamespace Illuminate\Contracts\Cache;interface Factory&#123; /** * Get a cache store instance by name. * * @param string|null $name * @return \Illuminate\Contracts\Cache\Repository */ public function store($name = null);&#125; Illuminate\Cache\Repository.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609610611612613614615616617618619620621622623624625626627628629630631632633634635636637638639640641642643644645646647648649650651652653654655656namespace Illuminate\Cache;use ArrayAccess;use BadMethodCallException;use Closure;use DateTimeInterface;use Illuminate\Cache\Events\CacheHit;use Illuminate\Cache\Events\CacheMissed;use Illuminate\Cache\Events\KeyForgotten;use Illuminate\Cache\Events\KeyWritten;use Illuminate\Contracts\Cache\Repository as CacheContract;use Illuminate\Contracts\Cache\Store;use Illuminate\Contracts\Events\Dispatcher;use Illuminate\Support\Carbon;use Illuminate\Support\InteractsWithTime;use Illuminate\Support\Traits\Macroable;/** * @mixin \Illuminate\Contracts\Cache\Store */class Repository implements ArrayAccess, CacheContract&#123; use InteractsWithTime; use Macroable &#123; __call as macroCall; &#125; /** * The cache store implementation. * * @var \Illuminate\Contracts\Cache\Store */ protected $store; /** * The event dispatcher implementation. * * @var \Illuminate\Contracts\Events\Dispatcher */ protected $events; /** * The default number of seconds to store items. * * @var int|null */ protected $default = 3600; /** * Create a new cache repository instance. * * @param \Illuminate\Contracts\Cache\Store $store * @return void */ public function __construct(Store $store) &#123; $this-&gt;store = $store; &#125; /** * Determine if an item exists in the cache. * * @param string $key * @return bool */ public function has($key) &#123; return ! is_null($this-&gt;get($key)); &#125; /** * Determine if an item doesn't exist in the cache. * * @param string $key * @return bool */ public function missing($key) &#123; return ! $this-&gt;has($key); &#125; /** * Retrieve an item from the cache by key. * * @param string $key * @param mixed $default * @return mixed */ public function get($key, $default = null) &#123; if (is_array($key)) &#123; return $this-&gt;many($key); &#125; $value = $this-&gt;store-&gt;get($this-&gt;itemKey($key)); // If we could not find the cache value, we will fire the missed event and get // the default value for this cache value. This default could be a callback // so we will execute the value function which will resolve it if needed. if (is_null($value)) &#123; $this-&gt;event(new CacheMissed($key)); $value = value($default); &#125; else &#123; $this-&gt;event(new CacheHit($key, $value)); &#125; return $value; &#125; /** * Retrieve multiple items from the cache by key. * * Items not found in the cache will have a null value. * * @param array $keys * @return array */ public function many(array $keys) &#123; $values = $this-&gt;store-&gt;many(collect($keys)-&gt;map(function ($value, $key) &#123; return is_string($key) ? $key : $value; &#125;)-&gt;values()-&gt;all()); return collect($values)-&gt;map(function ($value, $key) use ($keys) &#123; return $this-&gt;handleManyResult($keys, $key, $value); &#125;)-&gt;all(); &#125; /** * &#123;@inheritdoc&#125; */ public function getMultiple($keys, $default = null) &#123; $defaults = []; foreach ($keys as $key) &#123; $defaults[$key] = $default; &#125; return $this-&gt;many($defaults); &#125; /** * Handle a result for the "many" method. * * @param array $keys * @param string $key * @param mixed $value * @return mixed */ protected function handleManyResult($keys, $key, $value) &#123; // If we could not find the cache value, we will fire the missed event and get // the default value for this cache value. This default could be a callback // so we will execute the value function which will resolve it if needed. if (is_null($value)) &#123; $this-&gt;event(new CacheMissed($key)); return isset($keys[$key]) ? value($keys[$key]) : null; &#125; // If we found a valid value we will fire the "hit" event and return the value // back from this function. The "hit" event gives developers an opportunity // to listen for every possible cache "hit" throughout this applications. $this-&gt;event(new CacheHit($key, $value)); return $value; &#125; /** * Retrieve an item from the cache and delete it. * * @param string $key * @param mixed $default * @return mixed */ public function pull($key, $default = null) &#123; return tap($this-&gt;get($key, $default), function () use ($key) &#123; $this-&gt;forget($key); &#125;); &#125; /** * Store an item in the cache. * * @param string $key * @param mixed $value * @param \DateTimeInterface|\DateInterval|int|null $ttl * @return bool */ public function put($key, $value, $ttl = null) &#123; if (is_array($key)) &#123; return $this-&gt;putMany($key, $value); &#125; if ($ttl === null) &#123; return $this-&gt;forever($key, $value); &#125; $seconds = $this-&gt;getSeconds($ttl); if ($seconds &lt;= 0) &#123; return $this-&gt;forget($key); &#125; $result = $this-&gt;store-&gt;put($this-&gt;itemKey($key), $value, $seconds); if ($result) &#123; $this-&gt;event(new KeyWritten($key, $value, $seconds)); &#125; return $result; &#125; /** * &#123;@inheritdoc&#125; */ public function set($key, $value, $ttl = null) &#123; return $this-&gt;put($key, $value, $ttl); &#125; /** * Store multiple items in the cache for a given number of seconds. * * @param array $values * @param \DateTimeInterface|\DateInterval|int|null $ttl * @return bool */ public function putMany(array $values, $ttl = null) &#123; if ($ttl === null) &#123; return $this-&gt;putManyForever($values); &#125; $seconds = $this-&gt;getSeconds($ttl); if ($seconds &lt;= 0) &#123; return $this-&gt;deleteMultiple(array_keys($values)); &#125; $result = $this-&gt;store-&gt;putMany($values, $seconds); if ($result) &#123; foreach ($values as $key =&gt; $value) &#123; $this-&gt;event(new KeyWritten($key, $value, $seconds)); &#125; &#125; return $result; &#125; /** * Store multiple items in the cache indefinitely. * * @param array $values * @return bool */ protected function putManyForever(array $values) &#123; $result = true; foreach ($values as $key =&gt; $value) &#123; if (! $this-&gt;forever($key, $value)) &#123; $result = false; &#125; &#125; return $result; &#125; /** * &#123;@inheritdoc&#125; */ public function setMultiple($values, $ttl = null) &#123; return $this-&gt;putMany(is_array($values) ? $values : iterator_to_array($values), $ttl); &#125; /** * Store an item in the cache if the key does not exist. * * @param string $key * @param mixed $value * @param \DateTimeInterface|\DateInterval|int|null $ttl * @return bool */ public function add($key, $value, $ttl = null) &#123; if ($ttl !== null) &#123; if ($this-&gt;getSeconds($ttl) &lt;= 0) &#123; return false; &#125; // If the store has an "add" method we will call the method on the store so it // has a chance to override this logic. Some drivers better support the way // this operation should work with a total "atomic" implementation of it. if (method_exists($this-&gt;store, 'add')) &#123; $seconds = $this-&gt;getSeconds($ttl); return $this-&gt;store-&gt;add( $this-&gt;itemKey($key), $value, $seconds ); &#125; &#125; // If the value did not exist in the cache, we will put the value in the cache // so it exists for subsequent requests. Then, we will return true so it is // easy to know if the value gets added. Otherwise, we will return false. if (is_null($this-&gt;get($key))) &#123; return $this-&gt;put($key, $value, $ttl); &#125; return false; &#125; /** * Increment the value of an item in the cache. * * @param string $key * @param mixed $value * @return int|bool */ public function increment($key, $value = 1) &#123; return $this-&gt;store-&gt;increment($key, $value); &#125; /** * Decrement the value of an item in the cache. * * @param string $key * @param mixed $value * @return int|bool */ public function decrement($key, $value = 1) &#123; return $this-&gt;store-&gt;decrement($key, $value); &#125; /** * Store an item in the cache indefinitely. * * @param string $key * @param mixed $value * @return bool */ public function forever($key, $value) &#123; $result = $this-&gt;store-&gt;forever($this-&gt;itemKey($key), $value); if ($result) &#123; $this-&gt;event(new KeyWritten($key, $value)); &#125; return $result; &#125; /** * Get an item from the cache, or execute the given Closure and store the result. * * @param string $key * @param \DateTimeInterface|\DateInterval|int|null $ttl * @param \Closure $callback * @return mixed */ public function remember($key, $ttl, Closure $callback) &#123; $value = $this-&gt;get($key); // If the item exists in the cache we will just return this immediately and if // not we will execute the given Closure and cache the result of that for a // given number of seconds so it's available for all subsequent requests. if (! is_null($value)) &#123; return $value; &#125; $this-&gt;put($key, $value = $callback(), $ttl); return $value; &#125; /** * Get an item from the cache, or execute the given Closure and store the result forever. * * @param string $key * @param \Closure $callback * @return mixed */ public function sear($key, Closure $callback) &#123; return $this-&gt;rememberForever($key, $callback); &#125; /** * Get an item from the cache, or execute the given Closure and store the result forever. * * @param string $key * @param \Closure $callback * @return mixed */ public function rememberForever($key, Closure $callback) &#123; $value = $this-&gt;get($key); // If the item exists in the cache we will just return this immediately // and if not we will execute the given Closure and cache the result // of that forever so it is available for all subsequent requests. if (! is_null($value)) &#123; return $value; &#125; $this-&gt;forever($key, $value = $callback()); return $value; &#125; /** * Remove an item from the cache. * * @param string $key * @return bool */ public function forget($key) &#123; return tap($this-&gt;store-&gt;forget($this-&gt;itemKey($key)), function ($result) use ($key) &#123; if ($result) &#123; $this-&gt;event(new KeyForgotten($key)); &#125; &#125;); &#125; /** * &#123;@inheritdoc&#125; */ public function delete($key) &#123; return $this-&gt;forget($key); &#125; /** * &#123;@inheritdoc&#125; */ public function deleteMultiple($keys) &#123; $result = true; foreach ($keys as $key) &#123; if (! $this-&gt;forget($key)) &#123; $result = false; &#125; &#125; return $result; &#125; /** * &#123;@inheritdoc&#125; */ public function clear() &#123; return $this-&gt;store-&gt;flush(); &#125; /** * Begin executing a new tags operation if the store supports it. * * @param array|mixed $names * @return \Illuminate\Cache\TaggedCache * * @throws \BadMethodCallException */ public function tags($names) &#123; if (! method_exists($this-&gt;store, 'tags')) &#123; throw new BadMethodCallException('This cache store does not support tagging.'); &#125; $cache = $this-&gt;store-&gt;tags(is_array($names) ? $names : func_get_args()); if (! is_null($this-&gt;events)) &#123; $cache-&gt;setEventDispatcher($this-&gt;events); &#125; return $cache-&gt;setDefaultCacheTime($this-&gt;default); &#125; /** * Format the key for a cache item. * * @param string $key * @return string */ protected function itemKey($key) &#123; return $key; &#125; /** * Get the default cache time. * * @return int|null */ public function getDefaultCacheTime() &#123; return $this-&gt;default; &#125; /** * Set the default cache time in seconds. * * @param int|null $seconds * @return $this */ public function setDefaultCacheTime($seconds) &#123; $this-&gt;default = $seconds; return $this; &#125; /** * Get the cache store implementation. * * @return \Illuminate\Contracts\Cache\Store */ public function getStore() &#123; return $this-&gt;store; &#125; /** * Fire an event for this cache instance. * * @param string $event * @return void */ protected function event($event) &#123; if (isset($this-&gt;events)) &#123; $this-&gt;events-&gt;dispatch($event); &#125; &#125; /** * Get the event dispatcher instance. * * @return \Illuminate\Contracts\Events\Dispatcher */ public function getEventDispatcher() &#123; return $this-&gt;events; &#125; /** * Set the event dispatcher instance. * * @param \Illuminate\Contracts\Events\Dispatcher $events * @return void */ public function setEventDispatcher(Dispatcher $events) &#123; $this-&gt;events = $events; &#125; /** * Determine if a cached value exists. * * @param string $key * @return bool */ public function offsetExists($key) &#123; return $this-&gt;has($key); &#125; /** * Retrieve an item from the cache by key. * * @param string $key * @return mixed */ public function offsetGet($key) &#123; return $this-&gt;get($key); &#125; /** * Store an item in the cache for the default time. * * @param string $key * @param mixed $value * @return void */ public function offsetSet($key, $value) &#123; $this-&gt;put($key, $value, $this-&gt;default); &#125; /** * Remove an item from the cache. * * @param string $key * @return void */ public function offsetUnset($key) &#123; $this-&gt;forget($key); &#125; /** * Calculate the number of seconds for the given TTL. * * @param \DateTimeInterface|\DateInterval|int $ttl * @return int */ protected function getSeconds($ttl) &#123; $duration = $this-&gt;parseDateInterval($ttl); if ($duration instanceof DateTimeInterface) &#123; $duration = Carbon::now()-&gt;diffInRealSeconds($duration, false); &#125; return (int) $duration &gt; 0 ? $duration : 0; &#125; /** * Handle dynamic calls into macros or pass missing methods to the store. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; if (static::hasMacro($method)) &#123; return $this-&gt;macroCall($method, $parameters); &#125; return $this-&gt;store-&gt;$method(...$parameters); &#125; /** * Clone cache repository instance. * * @return void */ public function __clone() &#123; $this-&gt;store = clone $this-&gt;store; &#125;&#125; RedisStore Illuminate\Cache\RedisStore.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306namespace Illuminate\Cache;use Illuminate\Contracts\Cache\LockProvider;use Illuminate\Contracts\Redis\Factory as Redis;class RedisStore extends TaggableStore implements LockProvider&#123; /** * The Redis factory implementation. * * @var \Illuminate\Contracts\Redis\Factory */ protected $redis; /** * A string that should be prepended to keys. * * @var string */ protected $prefix; /** * The Redis connection that should be used. * * @var string */ protected $connection; /** * Create a new Redis store. * * @param \Illuminate\Contracts\Redis\Factory $redis * @param string $prefix * @param string $connection * @return void */ public function __construct(Redis $redis, $prefix = '', $connection = 'default') &#123; $this-&gt;redis = $redis; $this-&gt;setPrefix($prefix); $this-&gt;setConnection($connection); &#125; /** * Retrieve an item from the cache by key. * * @param string|array $key * @return mixed */ public function get($key) &#123; $value = $this-&gt;connection()-&gt;get($this-&gt;prefix.$key); return ! is_null($value) ? $this-&gt;unserialize($value) : null; &#125; /** * Retrieve multiple items from the cache by key. * * Items not found in the cache will have a null value. * * @param array $keys * @return array */ public function many(array $keys) &#123; $results = []; $values = $this-&gt;connection()-&gt;mget(array_map(function ($key) &#123; return $this-&gt;prefix.$key; &#125;, $keys)); foreach ($values as $index =&gt; $value) &#123; $results[$keys[$index]] = ! is_null($value) ? $this-&gt;unserialize($value) : null; &#125; return $results; &#125; /** * Store an item in the cache for a given number of seconds. * * @param string $key * @param mixed $value * @param int $seconds * @return bool */ public function put($key, $value, $seconds) &#123; return (bool) $this-&gt;connection()-&gt;setex( $this-&gt;prefix.$key, (int) max(1, $seconds), $this-&gt;serialize($value) ); &#125; /** * Store multiple items in the cache for a given number of seconds. * * @param array $values * @param int $seconds * @return bool */ public function putMany(array $values, $seconds) &#123; $this-&gt;connection()-&gt;multi(); $manyResult = null; foreach ($values as $key =&gt; $value) &#123; $result = $this-&gt;put($key, $value, $seconds); $manyResult = is_null($manyResult) ? $result : $result &amp;&amp; $manyResult; &#125; $this-&gt;connection()-&gt;exec(); return $manyResult ?: false; &#125; /** * Store an item in the cache if the key doesn't exist. * * @param string $key * @param mixed $value * @param int $seconds * @return bool */ public function add($key, $value, $seconds) &#123; $lua = "return redis.call('exists',KEYS[1])&lt;1 and redis.call('setex',KEYS[1],ARGV[2],ARGV[1])"; return (bool) $this-&gt;connection()-&gt;eval( $lua, 1, $this-&gt;prefix.$key, $this-&gt;serialize($value), (int) max(1, $seconds) ); &#125; /** * Increment the value of an item in the cache. * * @param string $key * @param mixed $value * @return int */ public function increment($key, $value = 1) &#123; return $this-&gt;connection()-&gt;incrby($this-&gt;prefix.$key, $value); &#125; /** * Decrement the value of an item in the cache. * * @param string $key * @param mixed $value * @return int */ public function decrement($key, $value = 1) &#123; return $this-&gt;connection()-&gt;decrby($this-&gt;prefix.$key, $value); &#125; /** * Store an item in the cache indefinitely. * * @param string $key * @param mixed $value * @return bool */ public function forever($key, $value) &#123; return (bool) $this-&gt;connection()-&gt;set($this-&gt;prefix.$key, $this-&gt;serialize($value)); &#125; /** * Get a lock instance. * * @param string $name * @param int $seconds * @param string|null $owner * @return \Illuminate\Contracts\Cache\Lock */ public function lock($name, $seconds = 0, $owner = null) &#123; return new RedisLock($this-&gt;connection(), $this-&gt;prefix.$name, $seconds, $owner); &#125; /** * Restore a lock instance using the owner identifier. * * @param string $name * @param string $owner * @return \Illuminate\Contracts\Cache\Lock */ public function restoreLock($name, $owner) &#123; return $this-&gt;lock($name, 0, $owner); &#125; /** * Remove an item from the cache. * * @param string $key * @return bool */ public function forget($key) &#123; return (bool) $this-&gt;connection()-&gt;del($this-&gt;prefix.$key); &#125; /** * Remove all items from the cache. * * @return bool */ public function flush() &#123; $this-&gt;connection()-&gt;flushdb(); return true; &#125; /** * Begin executing a new tags operation. * * @param array|mixed $names * @return \Illuminate\Cache\RedisTaggedCache */ public function tags($names) &#123; return new RedisTaggedCache( $this, new TagSet($this, is_array($names) ? $names : func_get_args()) ); &#125; /** * Get the Redis connection instance. * * @return \Illuminate\Redis\Connections\Connection */ public function connection() &#123; return $this-&gt;redis-&gt;connection($this-&gt;connection); &#125; /** * Set the connection name to be used. * * @param string $connection * @return void */ public function setConnection($connection) &#123; $this-&gt;connection = $connection; &#125; /** * Get the Redis database instance. * * @return \Illuminate\Contracts\Redis\Factory */ public function getRedis() &#123; return $this-&gt;redis; &#125; /** * Get the cache key prefix. * * @return string */ public function getPrefix() &#123; return $this-&gt;prefix; &#125; /** * Set the cache key prefix. * * @param string $prefix * @return void */ public function setPrefix($prefix) &#123; $this-&gt;prefix = ! empty($prefix) ? $prefix.':' : ''; &#125; /** * Serialize the value. * * @param mixed $value * @return mixed */ protected function serialize($value) &#123; return is_numeric($value) &amp;&amp; ! in_array($value, [INF, -INF]) &amp;&amp; ! is_nan($value) ? $value : serialize($value); &#125; /** * Unserialize the value. * * @param mixed $value * @return mixed */ protected function unserialize($value) &#123; return is_numeric($value) ? $value : unserialize($value); &#125;&#125; RedisLock Illuminate\Cache\Lock.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147&lt;?phpnamespace Illuminate\Cache;use Illuminate\Contracts\Cache\Lock as LockContract;use Illuminate\Contracts\Cache\LockTimeoutException;use Illuminate\Support\InteractsWithTime;use Illuminate\Support\Str;abstract class Lock implements LockContract&#123; use InteractsWithTime; /** * The name of the lock. * * @var string */ protected $name; /** * The number of seconds the lock should be maintained. * * @var int */ protected $seconds; /** * The scope identifier of this lock. * * @var string */ protected $owner; /** * Create a new lock instance. * * @param string $name * @param int $seconds * @param string|null $owner * @return void */ public function __construct($name, $seconds, $owner = null) &#123; if (is_null($owner)) &#123; $owner = Str::random(); &#125; $this-&gt;name = $name; $this-&gt;owner = $owner; $this-&gt;seconds = $seconds; &#125; /** * Attempt to acquire the lock. * * @return bool */ abstract public function acquire(); /** * Release the lock. * * @return bool */ abstract public function release(); /** * Returns the owner value written into the driver for this lock. * * @return string */ abstract protected function getCurrentOwner(); /** * Attempt to acquire the lock. * * @param callable|null $callback * @return mixed */ public function get($callback = null) &#123; $result = $this-&gt;acquire(); if ($result &amp;&amp; is_callable($callback)) &#123; try &#123; return $callback(); &#125; finally &#123; $this-&gt;release(); &#125; &#125; return $result; &#125; /** * Attempt to acquire the lock for the given number of seconds. * * @param int $seconds * @param callable|null $callback * @return bool * * @throws \Illuminate\Contracts\Cache\LockTimeoutException */ public function block($seconds, $callback = null) &#123; $starting = $this-&gt;currentTime(); while (! $this-&gt;acquire()) &#123; usleep(250 * 1000); if ($this-&gt;currentTime() - $seconds &gt;= $starting) &#123; throw new LockTimeoutException; &#125; &#125; if (is_callable($callback)) &#123; try &#123; return $callback(); &#125; finally &#123; $this-&gt;release(); &#125; &#125; return true; &#125; /** * Returns the current owner of the lock. * * @return string */ public function owner() &#123; return $this-&gt;owner; &#125; /** * Determines whether this lock is allowed to release the lock in the driver. * * @return bool */ protected function isOwnedByCurrentProcess() &#123; return $this-&gt;getCurrentOwner() === $this-&gt;owner; &#125;&#125; Illuminate\Cache\RedisLock 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?phpnamespace Illuminate\Cache;class RedisLock extends Lock&#123; /** * The Redis factory implementation. * * @var \Illuminate\Redis\Connections\Connection */ protected $redis; /** * Create a new lock instance. * * @param \Illuminate\Redis\Connections\Connection $redis * @param string $name * @param int $seconds * @param string|null $owner * @return void */ public function __construct($redis, $name, $seconds, $owner = null) &#123; parent::__construct($name, $seconds, $owner); $this-&gt;redis = $redis; &#125; /** * Attempt to acquire the lock. * * @return bool */ public function acquire() &#123; if ($this-&gt;seconds &gt; 0) &#123; return $this-&gt;redis-&gt;set($this-&gt;name, $this-&gt;owner, 'EX', $this-&gt;seconds, 'NX') == true; &#125; else &#123; return $this-&gt;redis-&gt;setnx($this-&gt;name, $this-&gt;owner) === 1; &#125; &#125; /** * Release the lock. * * @return bool */ public function release() &#123; return (bool) $this-&gt;redis-&gt;eval(LuaScripts::releaseLock(), 1, $this-&gt;name, $this-&gt;owner); &#125; /** * Releases this lock in disregard of ownership. * * @return void */ public function forceRelease() &#123; $this-&gt;redis-&gt;del($this-&gt;name); &#125; /** * Returns the owner value written into the driver for this lock. * * @return string */ protected function getCurrentOwner() &#123; return $this-&gt;redis-&gt;get($this-&gt;name); &#125;&#125; CacheManager Illuminate\CacheManager.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313namespace Illuminate\Cache;use Closure;use Illuminate\Contracts\Cache\Factory as FactoryContract;use Illuminate\Contracts\Cache\Store;use Illuminate\Contracts\Events\Dispatcher as DispatcherContractuse Illuminate\Support\Arr;use InvalidArgumentException;/** * @mixin \Illuminate\Contracts\Cache\Repository */class CacheManager implements FactoryContract&#123; /** * The application instance. * * @var \Illuminate\Contracts\Foundation\Application */ protected $app; /** * The array of resolved cache stores. * * @var array */ protected $stores = []; /** * The registered custom driver creators. * * @var array */ protected $customCreators = []; /** * Create a new Cache manager instance. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public function __construct($app) &#123; $this-&gt;app = $app; &#125; /** * Get a cache store instance by name, wrapped in a repository. * * @param string|null $name * @return \Illuminate\Contracts\Cache\Repository */ public function store($name = null) &#123; $name = $name ?: $this-&gt;getDefaultDriver(); return $this-&gt;stores[$name] = $this-&gt;get($name); &#125; /** * Get a cache driver instance. * * @param string|null $driver * @return \Illuminate\Contracts\Cache\Repository */ public function driver($driver = null) &#123; return $this-&gt;store($driver); &#125; /** * Attempt to get the store from the local cache. * * @param string $name * @return \Illuminate\Contracts\Cache\Repository */ protected function get($name) &#123; return $this-&gt;stores[$name] ?? $this-&gt;resolve($name); &#125; /** * Resolve the given store. * * @param string $name * @return \Illuminate\Contracts\Cache\Repository * * @throws \InvalidArgumentException */ protected function resolve($name) &#123; $config = $this-&gt;getConfig($name); if (is_null($config)) &#123; throw new InvalidArgumentException("Cache store [&#123;$name&#125;] is not defined."); &#125; if (isset($this-&gt;customCreators[$config['driver']])) &#123; return $this-&gt;callCustomCreator($config); &#125; else &#123; $driverMethod = 'create'.ucfirst($config['driver']).'Driver'; if (method_exists($this, $driverMethod)) &#123; return $this-&gt;&#123;$driverMethod&#125;($config); &#125; else &#123; throw new InvalidArgumentException("Driver [&#123;$config['driver']&#125;] is not supported."); &#125; &#125; &#125; /** * Call a custom driver creator. * * @param array $config * @return mixed */ protected function callCustomCreator(array $config) &#123; return $this-&gt;customCreators[$config['driver']]($this-&gt;app, $config); &#125; /** * Create an instance of the array cache driver. * * @param array $config * @return \Illuminate\Cache\Repository */ protected function createArrayDriver(array $config) &#123; return $this-&gt;repository(new ArrayStore($config['serialize'] ?? false)); &#125; /** * Create an instance of the file cache driver. * * @param array $config * @return \Illuminate\Cache\Repository */ protected function createFileDriver(array $config) &#123; return $this-&gt;repository(new FileStore($this-&gt;app['files'], $config['path'], $config['permission'] ?? null)); &#125; /** * Create an instance of the Null cache driver. * * @return \Illuminate\Cache\Repository */ protected function createNullDriver() &#123; return $this-&gt;repository(new NullStore); &#125; /** * Create an instance of the Redis cache driver. * * @param array $config * @return \Illuminate\Cache\Repository */ protected function createRedisDriver(array $config) &#123; $redis = $this-&gt;app['redis']; $connection = $config['connection'] ?? 'default'; return $this-&gt;repository(new RedisStore($redis, $this-&gt;getPrefix($config), $connection)); &#125; /** * Create an instance of the database cache driver. * * @param array $config * @return \Illuminate\Cache\Repository */ protected function createDatabaseDriver(array $config) &#123; $connection = $this-&gt;app['db']-&gt;connection($config['connection'] ?? null); return $this-&gt;repository( new DatabaseStore( $connection, $config['table'], $this-&gt;getPrefix($config) ) ); &#125; /** * Create a new cache repository with the given implementation. * * @param \Illuminate\Contracts\Cache\Store $store * @return \Illuminate\Cache\Repository */ public function repository(Store $store) &#123; return tap(new Repository($store), function ($repository) &#123; $this-&gt;setEventDispatcher($repository); &#125;); &#125; /** * Set the event dispatcher on the given repository instance. * * @param \Illuminate\Cache\Repository $repository * @return void */ protected function setEventDispatcher(Repository $repository) &#123; if (! $this-&gt;app-&gt;bound(DispatcherContract::class)) &#123; return; &#125; $repository-&gt;setEventDispatcher( $this-&gt;app[DispatcherContract::class] ); &#125; /** * Re-set the event dispatcher on all resolved cache repositories. * * @return void */ public function refreshEventDispatcher() &#123; array_map([$this, 'setEventDispatcher'], $this-&gt;stores); &#125; /** * Get the cache prefix. * * @param array $config * @return string */ protected function getPrefix(array $config) &#123; return $config['prefix'] ?? $this-&gt;app['config']['cache.prefix']; &#125; /** * Get the cache connection configuration. * * @param string $name * @return array */ protected function getConfig($name) &#123; return $this-&gt;app['config']["cache.stores.&#123;$name&#125;"]; &#125; /** * Get the default cache driver name. * * @return string */ public function getDefaultDriver() &#123; return $this-&gt;app['config']['cache.default']; &#125; /** * Set the default cache driver name. * * @param string $name * @return void */ public function setDefaultDriver($name) &#123; $this-&gt;app['config']['cache.default'] = $name; &#125; /** * Unset the given driver instances. * * @param array|string|null $name * @return $this */ public function forgetDriver($name = null) &#123; $name = $name ?? $this-&gt;getDefaultDriver(); foreach ((array) $name as $cacheName) &#123; if (isset($this-&gt;stores[$cacheName])) &#123; unset($this-&gt;stores[$cacheName]); &#125; &#125; return $this; &#125; /** * Register a custom driver creator Closure. * * @param string $driver * @param \Closure $callback * @return $this */ public function extend($driver, Closure $callback) &#123; $this-&gt;customCreators[$driver] = $callback-&gt;bindTo($this, $this); return $this; &#125; /** * Dynamically call the default driver instance. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; return $this-&gt;store()-&gt;$method(...$parameters); &#125;&#125; 缓存缓存使用原子锁 注：要使用这个功能，应用必须使用Memcached、Redis缓存驱动作为应用默认的缓存驱动，此外，所有服务器必须和同一台中央缓存服务器进行通信。 原子锁允许你对分布式锁进行操作而不必担心竞争条件，例如，Laravel Forge使用原子锁来确保在一台服务器上同时只有一个远程任务在执行，你可以通过Cache::lock方法来创建和管理锁： 12345if (Cache::lock('foo', 10)-&gt;get()) &#123; // Lock acquired for 10 seconds... Cache::lock('foo')-&gt;release();&#125; get方法还可以接收一个闭包，在闭包执行之后，Laravel会自动释放锁： 123Cache::lock('foo')-&gt;get(function () &#123; // Lock acquired indefinitely and automatically released...&#125;); 如果锁在你请求的时候无效，可以告知Laravel等待直到锁有效。如果锁在指定限制时间内无法获取，会抛出Illuminate\Contracts\Cache\LockTimeoutException异常： 1234567891011121314151617use Illuminate\Contracts\Cache\LockTimeoutException;$lock = Cache::lock('foo', 10);try &#123; $lock-&gt;block(5); // Lock acquired after waiting maximum of 5 seconds...&#125; catch (LockTimeoutException $e) &#123; // Unable to acquire lock...&#125; finally &#123; optional($lock)-&gt;release();&#125;Cache::lock('foo', 10)-&gt;block(5, function () &#123; // Lock acquired after waiting maximum of 5 seconds...&#125;); 管理跨进程的锁 有时候，你可能想要在一个进程中获取锁，在另一个进程中释放锁。例如，你可以在Web请求期间获取锁，然后在该请求触发的某个队列任务最后释放这把锁。在这种场景下，你应该传递锁的域「所有者令牌」到队列任务以便该任务可以使用给定令牌重新实例化锁： 1234567891011// 在控制器中...$podcast = Podcast::find($id);$lock = Cache::lock('foo', 120);if ($result = $lock-&gt;get()) &#123; ProcessPodcast::dispatch($podcast, $lock-&gt;owner());&#125;// 在 ProcessPodcast 任务中...Cache::restoreLock('foo', $this-&gt;owner)-&gt;release(); 如果你想要在不管当前所有者的情况下释放锁，可以使用forceRelease方法：1Cache::lock('foo')-&gt;forceRelease(); 缓存标签 注：缓存标签目前不支持file或database缓存驱动，此外，当使用多标签的缓存被设置为永久存储时，使用Memcached驱动的缓存有着最佳性能表现，因为Memcached会自动清除陈旧记录。 存储被打上标签的缓存项缓存标签允许你给相关缓存项打上同一个标签以便于后续清除这些缓存值，被打上标签的缓存可以通过传递一个被排序的标签数组来访问。例如，我们可以通过以下方式在添加缓存的时候设置标签：12Cache::tags(['people', 'artists'])-&gt;put('John', $john, $seconds);Cache::tags(['people', 'authors'])-&gt;put('Anne', $anne, $seconds); 访问被打上标签的缓存项要获取被打上标签的缓存项，传递同样的有序标签数组到tags方法然后使用你想要获取的key来调用get方法： 12$john = Cache::tags(['people', 'artists'])-&gt;get('John');$anne = Cache::tags(['people', 'authors'])-&gt;get('Anne'); 移除被打上标签的数据项你可以同时清除被打上同一标签/标签列表的所有缓存项，例如，以下语句会移除被打上people或authors标签的所有缓存： 1Cache::tags(['people', 'authors'])-&gt;flush(); 这样，上面设置的Anne和John缓存项都会从缓存中移除。 相反，以下语句只移除被打上authors标签的语句，所以只有Anne会被移除而John不会：1Cache::tags('authors')-&gt;flush(); 源码 Illuminate\Cache\TaggableStore.php 12345678910111213141516171819&lt;?phpnamespace Illuminate\Cache;use Illuminate\Contracts\Cache\Store;abstract class TaggableStore implements Store&#123; /** * Begin executing a new tags operation. * * @param array|mixed $names * @return \Illuminate\Cache\TaggedCache */ public function tags($names) &#123; return new TaggedCache($this, new TagSet($this, is_array($names) ? $names : func_get_args())); &#125;&#125; Illuminate\Cache\TaggedCache.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123namespace Illuminate\Cache;use Illuminate\Contracts\Cache\Store;class TaggedCache extends Repository&#123; use RetrievesMultipleKeys &#123; putMany as putManyAlias; &#125; /** * The tag set instance. * * @var \Illuminate\Cache\TagSet */ protected $tags; /** * Create a new tagged cache instance. * * @param \Illuminate\Contracts\Cache\Store $store * @param \Illuminate\Cache\TagSet $tags * @return void */ public function __construct(Store $store, TagSet $tags) &#123; parent::__construct($store); $this-&gt;tags = $tags; &#125; /** * Store multiple items in the cache for a given number of seconds. * * @param array $values * @param int|null $ttl * @return bool */ public function putMany(array $values, $ttl = null) &#123; if ($ttl === null) &#123; return $this-&gt;putManyForever($values); &#125; return $this-&gt;putManyAlias($values, $ttl); &#125; /** * Increment the value of an item in the cache. * * @param string $key * @param mixed $value * @return void */ public function increment($key, $value = 1) &#123; $this-&gt;store-&gt;increment($this-&gt;itemKey($key), $value); &#125; /** * Decrement the value of an item in the cache. * * @param string $key * @param mixed $value * @return void */ public function decrement($key, $value = 1) &#123; $this-&gt;store-&gt;decrement($this-&gt;itemKey($key), $value); &#125; /** * Remove all items from the cache. * * @return bool */ public function flush() &#123; $this-&gt;tags-&gt;reset(); return true; &#125; /** * &#123;@inheritdoc&#125; */ protected function itemKey($key) &#123; return $this-&gt;taggedItemKey($key); &#125; /** * Get a fully qualified key for a tagged item. * * @param string $key * @return string */ public function taggedItemKey($key) &#123; return sha1($this-&gt;tags-&gt;getNamespace()).':'.$key; &#125; /** * Fire an event for this cache instance. * * @param string $event * @return void */ protected function event($event) &#123; parent::event($event-&gt;setTags($this-&gt;tags-&gt;getNames())); &#125; /** * Get the tag set instance. * * @return \Illuminate\Cache\TagSet */ public function getTags() &#123; return $this-&gt;tags; &#125;&#125; Illuminate\Cache\TagSet.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;?phpnamespace Illuminate\Cache;use Illuminate\Contracts\Cache\Store;class TagSet&#123; /** * The cache store implementation. * * @var \Illuminate\Contracts\Cache\Store */ protected $store; /** * The tag names. * * @var array */ protected $names = []; /** * Create a new TagSet instance. * * @param \Illuminate\Contracts\Cache\Store $store * @param array $names * @return void */ public function __construct(Store $store, array $names = []) &#123; $this-&gt;store = $store; $this-&gt;names = $names; &#125; /** * Reset all tags in the set. * * @return void */ public function reset() &#123; array_walk($this-&gt;names, [$this, 'resetTag']); &#125; /** * Reset the tag and return the new tag identifier. * * @param string $name * @return string */ public function resetTag($name) &#123; $this-&gt;store-&gt;forever($this-&gt;tagKey($name), $id = str_replace('.', '', uniqid('', true))); return $id; &#125; /** * Get a unique namespace that changes when any of the tags are flushed. * * @return string */ public function getNamespace() &#123; return implode('|', $this-&gt;tagIds()); &#125; /** * Get an array of tag identifiers for all of the tags in the set. * * @return array */ protected function tagIds() &#123; return array_map([$this, 'tagId'], $this-&gt;names); &#125; /** * Get the unique tag identifier for a given tag. * * @param string $name * @return string */ public function tagId($name) &#123; return $this-&gt;store-&gt;get($this-&gt;tagKey($name)) ?: $this-&gt;resetTag($name); &#125; /** * Get the tag identifier key for a given tag. * * @param string $name * @return string */ public function tagKey($name) &#123; return 'tag:'.$name.':key'; &#125; /** * Get all of the tag names in the set. * * @return array */ public function getNames() &#123; return $this-&gt;names; &#125;&#125; Illuminate\Cache\RedisTaggedCache.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198&lt;?phpnamespace Illuminate\Cache;class RedisTaggedCache extends TaggedCache&#123; /** * Forever reference key. * * @var string */ const REFERENCE_KEY_FOREVER = 'forever_ref'; /** * Standard reference key. * * @var string */ const REFERENCE_KEY_STANDARD = 'standard_ref'; /** * Store an item in the cache. * * @param string $key * @param mixed $value * @param \DateTimeInterface|\DateInterval|int|null $ttl * @return bool */ public function put($key, $value, $ttl = null) &#123; if ($ttl === null) &#123; return $this-&gt;forever($key, $value); &#125; $this-&gt;pushStandardKeys($this-&gt;tags-&gt;getNamespace(), $key); return parent::put($key, $value, $ttl); &#125; /** * Increment the value of an item in the cache. * * @param string $key * @param mixed $value * @return void */ public function increment($key, $value = 1) &#123; $this-&gt;pushStandardKeys($this-&gt;tags-&gt;getNamespace(), $key); parent::increment($key, $value); &#125; /** * Decrement the value of an item in the cache. * * @param string $key * @param mixed $value * @return void */ public function decrement($key, $value = 1) &#123; $this-&gt;pushStandardKeys($this-&gt;tags-&gt;getNamespace(), $key); parent::decrement($key, $value); &#125; /** * Store an item in the cache indefinitely. * * @param string $key * @param mixed $value * @return bool */ public function forever($key, $value) &#123; $this-&gt;pushForeverKeys($this-&gt;tags-&gt;getNamespace(), $key); return parent::forever($key, $value); &#125; /** * Remove all items from the cache. * * @return bool */ public function flush() &#123; $this-&gt;deleteForeverKeys(); $this-&gt;deleteStandardKeys(); return parent::flush(); &#125; /** * Store standard key references into store. * * @param string $namespace * @param string $key * @return void */ protected function pushStandardKeys($namespace, $key) &#123; $this-&gt;pushKeys($namespace, $key, self::REFERENCE_KEY_STANDARD); &#125; /** * Store forever key references into store. * * @param string $namespace * @param string $key * @return void */ protected function pushForeverKeys($namespace, $key) &#123; $this-&gt;pushKeys($namespace, $key, self::REFERENCE_KEY_FOREVER); &#125; /** * Store a reference to the cache key against the reference key. * * @param string $namespace * @param string $key * @param string $reference * @return void */ protected function pushKeys($namespace, $key, $reference) &#123; $fullKey = $this-&gt;store-&gt;getPrefix().sha1($namespace).':'.$key; foreach (explode('|', $namespace) as $segment) &#123; $this-&gt;store-&gt;connection()-&gt;sadd($this-&gt;referenceKey($segment, $reference), $fullKey); &#125; &#125; /** * Delete all of the items that were stored forever. * * @return void */ protected function deleteForeverKeys() &#123; $this-&gt;deleteKeysByReference(self::REFERENCE_KEY_FOREVER); &#125; /** * Delete all standard items. * * @return void */ protected function deleteStandardKeys() &#123; $this-&gt;deleteKeysByReference(self::REFERENCE_KEY_STANDARD); &#125; /** * Find and delete all of the items that were stored against a reference. * * @param string $reference * @return void */ protected function deleteKeysByReference($reference) &#123; foreach (explode('|', $this-&gt;tags-&gt;getNamespace()) as $segment) &#123; $this-&gt;deleteValues($segment = $this-&gt;referenceKey($segment, $reference)); $this-&gt;store-&gt;connection()-&gt;del($segment); &#125; &#125; /** * Delete item keys that have been stored against a reference. * * @param string $referenceKey * @return void */ protected function deleteValues($referenceKey) &#123; $values = array_unique($this-&gt;store-&gt;connection()-&gt;smembers($referenceKey)); if (count($values) &gt; 0) &#123; foreach (array_chunk($values, 1000) as $valuesChunk) &#123; call_user_func_array([$this-&gt;store-&gt;connection(), 'del'], $valuesChunk); &#125; &#125; &#125; /** * Get the reference key for the segment. * * @param string $segment * @param string $suffix * @return string */ protected function referenceKey($segment, $suffix) &#123; return $this-&gt;store-&gt;getPrefix().$segment.':'.$suffix; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Collection]]></title>
    <url>%2F2020%2F04%2F12%2FLaravel-Collection%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 集合是“macroable”的，怎么理解？ new static是什么意思？ get_class()函数是什么意思？ 简介Illuminate\Support\Collection类为处理数组数据提供了流式、方便的封装。例如，查看下面的代码，我们使用辅助函数collect创建一个新的集合实例，为每一个元素运行strtoupper函数，然后移除所有空元素： 12345$collection = collect(['taylor', 'abigail', null])-&gt;map(function ($name) &#123; return strtoupper($name);&#125;)-&gt;reject(function ($name) &#123; return empty($name);&#125;); 正如你所看到的，Collection类允许你使用方法链对底层数组执行匹配和移除操作，通常，每个Collection方法都会返回一个新的Collection实例。 创建集合正如上面所提到的，辅助函数collect为给定数组返回一个新的Illuminate\Support\Collection实例，所以，创建集合很简单：1$collection = collect([1, 2, 3]); 注：默认情况下，Eloquent查询的结果总是返回Collection实例。 扩展集合集合是“macroable”的，这意味着我们可以在运行时动态添加方法到Collection类，例如，下面的代码添加了toUpper方法到Collection类：12345678910111213use Illuminate\Support\Str;Collection::macro('toUpper', function () &#123; return $this-&gt;map(function ($value) &#123; return Str::upper($value); &#125;);&#125;);$collection = collect(['first', 'second']);$upper = $collection-&gt;toUpper();// ['FIRST', 'SECOND'] 通常，我们需要在服务提供者中声明集合宏。 懒集合简介为了继续完善功能已经很强大的Collection类，LazyCollection类使用了PHP的生成器，从而可以通过极低的内存处理极大的数据集。 例如，假设你的应用需要通过Laravel提供的集合方法来解析并处理几个GB大小的日志文件，这个时候就可以使用懒集合（LazyCollection），它不会一次性将整个文件读入内存，而是每次只读取文件的一小部分：1234567891011121314use App\LogEntry;use Illuminate\Support\LazyCollection;LazyCollection::make(function () &#123; $handle = fopen('log.txt', 'r'); while (($line = fgets($handle)) !== false) &#123; yield $line; &#125;&#125;)-&gt;chunk(4)-&gt;map(function ($lines) &#123; return LogEntry::fromLines($lines);&#125;)-&gt;each(function (LogEntry $logEntry) &#123; // Process the log entry...&#125;); 或者，假设你需要迭代10000个Eloquent模型实例，使用传统的Laravel集合，所有10000个Eloquent模型实例必须一次性加载到内存中： 123$users = App\User::all()-&gt;filter(function ($user) &#123; return $user-&gt;id &gt; 500;&#125;); 而现在，查询构建器的cursor方法会返回一个LazyCollection实例，这样一来，我们仍然只需对数据库做一次查询，但是一次只会加载一个Eloquent模型实例到内存。在这个例子中，filter回调只有在迭代到每个独立用户时才会执行，从而大幅降低对内存的占用：1234567$users = App\User::cursor()-&gt;filter(function ($user) &#123; return $user-&gt;id &gt; 500;&#125;);foreach ($users as $user) &#123; echo $user-&gt;id;&#125; 创建懒集合要创建一个懒集合实例，需要传递一个PHP生成器函数到集合的make方法：123456789use Illuminate\Support\LazyCollection;LazyCollection::make(function () &#123; $handle = fopen('log.txt', 'r'); while (($line = fgets($handle)) !== false) &#123; yield $line; &#125;&#125;); new static无论是new static()还是new self()都是new一个对象，这两个方法new出来的对象有什么区别呢？说白了就是new出来的到底是同一个类的实例还是不同类的实例。 为了探究上面的问题，我们先上一段简单的代码。 1234567891011121314151617class Father&#123; public function getNewFather() &#123; return new self(); &#125; public function getNewCaller() &#123; return new static(); &#125;&#125; $f = new Father(); var_dump(get_class($f-&gt;getNewFather())); // Fathervar_dump(get_class($f-&gt;getNewCaller())); // Father 这里无论是getNewFather还是getNewCaller都是返回的Father这个实例，到这里貌似new self()还是new static()是没有区别的，我们接着走。123456789class Sun1 extends Father&#123; &#125; $sun1 = new Sun1(); var_dump($sun1-&gt;getNewFather()); // object(Father)#4 (0) &#123; &#125;var_dump($sun1-&gt;getNewCaller()); // object(Sun1)#4 (0) &#123; &#125; 这里我们发现了getNewFather返回的是Father的实例，而getNewCaller返回的是调用者的实例。 他们的区别只有在继承中才能体现出来、如果没有任何继承、那么二者没有任何区别。 然后new self()返回的实例是不会变的，无论谁去调用，都返回的一个类的实例，而new static则是由调用者决定的。 LazyCollection Illuminate\Support\LazyCollection.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109namespace Illuminate\Support;use ArrayIterator;use Closure;use Illuminate\Support\Traits\EnumeratesValues;use Illuminate\Support\Traits\Macroable;use IteratorAggregate;use stdClass;class LazyCollection implements Enumerable&#123; use EnumeratesValues, Macroable; /** * The source from which to generate items. * * @var callable|static */ public $source; /** * Create a new lazy collection instance. * * @param mixed $source * @return void */ public function __construct($source = null) &#123; if ($source instanceof Closure || $source instanceof self) &#123; $this-&gt;source = $source; &#125; elseif (is_null($source)) &#123; $this-&gt;source = static::empty(); &#125; else &#123; $this-&gt;source = $this-&gt;getArrayableItems($source); &#125; &#125; /** * Create a new instance with no items. * * @return static */ public static function empty() &#123; return new static([]); &#125; /** * Create a new instance by invoking the callback a given amount of times. * * @param int $number * @param callable|null $callback * @return static */ public static function times($number, callable $callback = null) &#123; if ($number &lt; 1) &#123; return new static; &#125; $instance = new static(function () use ($number) &#123; for ($current = 1; $current &lt;= $number; $current++) &#123; yield $current; &#125; &#125;); return is_null($callback) ? $instance : $instance-&gt;map($callback); &#125; /** * Create an enumerable with the given range. * * @param int $from * @param int $to * @return static */ public static function range($from, $to) &#123; return new static(function () use ($from, $to) &#123; for (; $from &lt;= $to; $from++) &#123; yield $from; &#125; &#125;); &#125; /** * Get all items in the enumerable. * * @return array */ public function all() &#123; if (is_array($this-&gt;source)) &#123; return $this-&gt;source; &#125; return iterator_to_array($this-&gt;getIterator()); &#125; /** * Eager load all items into a new lazy collection backed by an array. * * @return static */ public function eager() &#123; return new static($this-&gt;all()); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-tap]]></title>
    <url>%2F2020%2F04%2F10%2FLaravel-tap%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： tap()的实现，不再需要临时变量。怎么理解？ 在本文，我们将讨论Laravel中的tap。我们将详细讨论tap帮助函数和collection中的tap方法。 Tap帮助函数旧的实现方式Laravel5.3提出了一个tap函数。这是一个非常奇怪的函数，受Ruby的启发，允许你去tap成链。这是tap助手函数的基本实现。 123456function tap($value, $callback)&#123; $callback($value); return $value;&#125; 需要传一个值和一个回调到方法中，值作为回调的参数，回调将执行，最后值被返回。让我们看看我们如何以有意义的方式使用它。例如：12345678&lt;?php$photo = App\Photo::find(1);return tap($photo, function($photo) &#123; $photo-&gt;validated = true; $photo-&gt;save();&#125;); 在上面的例子中，我们传递一个参数（Photo模型）和一个回调函数，该函数简单地将validated设置为true并保存模型。这个函数然后将Photo模型实例返回给调用者。 新的实现方式在最新版本中，更高级的tap来了。它引入了更短的使用方式。这里是tap函数的新实现。12345678910function tap($value, $callback = null)&#123; if (is_null($callback)) &#123; return new HigherOrderTapProxy($value); &#125; $callback($value); return $value;&#125; 回调函数现在是可选的。你还可以链式使用参数中的多个方法，这里其实也就是PhotoModel中支持的方法。例如：1234567&lt;?php$photo = App\Photo::find(1);return tap($photo)-&gt;update([ 'validated' =&gt; 'true',]) 我们能够将任何模型的方法通过tap链式调用。此更新方法通常返回true或false，但是这里使用了tap函数。在这种情况下，它将返回Photo模型。tap可以帮助你返回作为参数传递的对象。 它是如何工作的tap是一个非常有用的功能，但有时它很难理解它是如何工作的。这里来解释它是如何工作的。 如果没有给出回调函数，因为它是可选的，Laravel将返回HigherOrderTapProxy的新实例。在HigherOrderTapProxy类中定义了调用魔术方法。调用魔术方法是由语言动态调用的（所谓的方法在类中没有定义）。因为除了调用魔术方法，HigherOrderTapProxy类中没有定义方法，所以每次使用tap函数任何方法调用时都会调用它。在调用魔术方法中，我们的更新方法或任何我们调用的方法将被参数调用，并且它将返回我们最初传递给tap函数的参数。 Illuminate/Support/HigherOrderTapProxy.php 1234567891011121314151617181920212223242526272829303132333435363738&lt;?phpnamespace Illuminate\Support;class HigherOrderTapProxy&#123; /** * The target being tapped. * * @var mixed */ public $target; /** * Create a new tap proxy instance. * * @param mixed $target * @return void */ public function __construct($target) &#123; $this-&gt;target = $target; &#125; /** * Dynamically pass method calls to the target. * * @param string $method * @param array $parameters * @return mixed */ public function __call($method, $parameters) &#123; $this-&gt;target-&gt;&#123;$method&#125;(...$parameters); return $this-&gt;target; &#125;&#125; 在上面的代码中，target属性是我们在tap中传递的参数。 Laravel collection中的tap方法Laravel还在collection类中有一个tap方法，可让你在特定的地方传入参数到tap中，并对这些结果进行处理。tap不会影响主要collection的结果。这对调试代码和查找在处理集合时出现错误的地方很有帮助。我们用一个例子来解释这个方法。初始化以下数组。123456789101112131415161718192021222324252627282930313233343536373839404142$photos = [ [ 'file_name' =&gt; 'wallpaper', 'validated' =&gt; true, 'extension' =&gt; 'jpg' ], [ 'file_name' =&gt; 'spring', 'validated' =&gt; true, 'extension' =&gt; 'png' ], [ 'file_name' =&gt; 'flowers', 'validated' =&gt; false, 'extension' =&gt; 'jpg' ], [ 'file_name' =&gt; 'mac', 'validated' =&gt; true, 'extension' =&gt; 'png' ], [ 'file_name' =&gt; 'books', 'validated' =&gt; false, 'extension' =&gt; 'jpg' ], [ 'file_name' =&gt; 'mobiles', 'validated' =&gt; false, 'extension' =&gt; 'jpg' ], [ 'file_name' =&gt; 'glass', 'validated' =&gt; false, 'extension' =&gt; 'png' ], [ 'file_name' =&gt; 'fruit', 'validated' =&gt; true, 'extension' =&gt; 'jpg' ],]; 现在让我们尝试在这个数组上使用tap方法。首先，我们必须将这个数组转换为一个集合，然后在特定点处tap这个集合。123456return collect($photos) -&gt;where('validated', true) -&gt;tap(function ($validated) &#123; return var_dump($validated-&gt;pluck('file_name')); &#125;);&#125;); 上面的代码将会输出以下结果：1234wallpaperspringmacfruit tap VS Pipe（管道）在Laravel中，也有类似的方法叫管道。它们在某种意义上是相似的，因为它们都在集合管道中使用。tap和pipe之间有一个区别。tap允许你使用数据，但不会修改原始返回值。另一方面，pipe根据返回值修改数据。例如：123456return collect($photos) -&gt;where('validated', true) -&gt;pipe(function ($validated) &#123; return $validated-&gt;where('extension', 'jpg')-&gt;pluck('file_name'); &#125;);&#125;); 输出结果为：12wallpaperfruit 另一方面，如果我们像这样使用上面的代码：123456return collect($photos) -&gt;where('validated', true) -&gt;tap(function ($validated) &#123; return $validated-&gt;where('extension', 'jpg')-&gt;pluck('file_name'); &#125;);&#125;); 它将返回验证设置为true的所有照片数组。 结果为：12345678910111213141516171819200: &#123; file_name: &quot;wallpaper&quot;, validated: true, extension: &quot;jpg&quot;&#125;,1: &#123; file_name: &quot;spring&quot;, validated: true, extension: &quot;png&quot;&#125;,3: &#123; file_name: &quot;mac&quot;, validated: true, extension: &quot;png&quot;&#125;,7: &#123; file_name: &quot;fruit&quot;, validated: true, extension: &quot;jpg&quot;&#125; 1234$user = User::find(1);$data = [...];$user-&gt;update($data);$user-&gt;notify(); 如果用tap，可以：1tap(User::find(1))-&gt;update($data)-&gt;notify(); 写起来更简洁。 执行中间操作从一个简单的例子开始，提取Laravel的AuthenticateSession@handle()的一些代码：12345$response = $next($request); $this-&gt;storePasswordHashInSession($request); return $response; 使用tap()帮助函数：123return tap($next($request), function () use ($request) &#123; $this-&gt;storePasswordHashInSession($request);&#125;); 另外的一个简单的例子，让我们看看Illuminate\Cache\Repository下的pull方法，此函数将从指定键的缓存中获取值，并将其删除。pull方法的实现：12345678public function pull($key, $default = null)&#123; $value = $this-&gt;get($key, $default); $this-&gt;forget($key) // returns a boolean; return $value;&#125; 上面的例子中，$this-&gt;forget()返回一个布尔值，所以要使我们的函数返回原始值，需要将其储存到临时变量$value中。以下是tap()的实现，不再需要临时变量：123456public function pull($key, $default = null)&#123; return tap($this-&gt;get($key, $default), function ($value) use ($key) &#123; $this-&gt;forget($key); &#125;);&#125; 恢复状态Eloquent的create和update方法支持[‘timestamps’=&gt;false]选项。如果这被实现成链式方法，结果的可读性会更好。123456789101112// Method defined in App\Model that App\Message extends.public function keepingTimestamps(callable $callback)&#123; try &#123; $timestamps = $this-&gt;timestamps; $this-&gt;timestamps = false; return tap($this, $callback); &#125; finally &#123; $this-&gt;timestamps = $timestamps; &#125;&#125; 现在Message模型可以链式使用以上的方法：123request()-&gt;user()-&gt;latestMessage-&gt;keepingTimestamps(function ($message) &#123; $message-&gt;markRead(); // updates a 'read_at' timestamp instead&#125;); // returns the latestMessage 如果你写的代码有DB::transaction()相同的模式，你可以在Laravel 5.4使用tap() 帮助函数重写。 CollectionLaravel 5.4中也可以在Collection类中使用tap()方法。你可以在任何地方使用，而不需要破坏链式。对于Laravel 5.3及更早的版本，你只需要复制粘贴五行代码的方法作为Collection macro到你项目的AppServiceProvider@boot()即可。 这里有一个例子，用于Laravel网站支持英语和法语。取代月份的语言翻译文件，使用Carbon列出一年每个月份的&#60;option&#62;。因此这个模型的修饰方法：12345678910111213141516171819public function monthOptions()&#123; return collect(range(1, 12)) -&gt;keyByValue() // custom Collection macro -&gt;tap(function () &#123; if (App::getLocale() === 'fr') &#123; setlocale(LC_TIME, 'fr_CA'); &#125; &#125;) -&gt;map(function ($month) &#123; return sprintf('%02d - %s', $month, Carbon::now()-&gt;month($month)-&gt;formatLocalized('%B')); &#125;) -&gt;tap(function () &#123; if (App::getLocale() === 'fr') &#123; setlocale(LC_TIME, ''); &#125; &#125;);&#125; 对于更多的语言支持，设置/恢复状态将提取到其他方法，使其更加可读。 使用Collection tap()处理控制台命令进度条这是在集合中最典型的用例。你甚至可以在handle()处理过程中保持其方法链。12345678910111213141516171819202122232425public function handle()&#123; Club::findOrFail($this-&gt;option('club')) -&gt;members() -&gt;subscribed() -&gt;get() -&gt;tap(function ($members) &#123; $this-&gt;output-&gt;progressStart($members-&gt;count()); &#125;) -&gt;each(function ($member) &#123; Mail::to($member)-&gt;queue(new Newsletter($member, $this-&gt;matchReport()); $this-&gt;output-&gt;progressAdvance(); &#125;) -&gt;tap(function () &#123; $this-&gt;output-&gt;progressFinish(); &#125;);&#125; public function matchReport()&#123; return once(function () &#123; return MatchReport::ofRound($this-&gt;option('round'))-&gt;firstOrFail(); &#125;);&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Funnel]]></title>
    <url>%2F2020%2F04%2F10%2FLaravel-Funnel%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： ConcurrencyLimiterBuilder是干什么用的？为什么用Builder结尾？ 使用频率限制 队列可以指定可以同时处理给定任务的最大进程数量。这个功能在队列任务正在编辑一次只能由一个任务进行处理的资源时很有用。例如，使用funnel方法你可以给定类型任务一次只能由一个工作进程进行处理： 1234567Redis::funnel('key')-&gt;limit(1)-&gt;then(function () &#123; // Job logic...&#125;, function () &#123; // Could not obtain lock... return $this-&gt;release(10);&#125;); 源码12345678910111213141516171819202122232425262728&lt;?phpnamespace Illuminate\Redis\Connections;use Closure;use Illuminate\Contracts\Events\Dispatcher;use Illuminate\Redis\Events\CommandExecuted;use Illuminate\Redis\Limiters\ConcurrencyLimiterBuilder;use Illuminate\Redis\Limiters\DurationLimiterBuilder;use Illuminate\Support\Traits\Macroable;abstract class Connection&#123; use Macroable &#123; __call as macroCall; &#125; /** * Funnel a callback for a maximum number of simultaneous executions. * * @param string $name * @return \Illuminate\Redis\Limiters\ConcurrencyLimiterBuilder */ public function funnel($name) &#123; return new ConcurrencyLimiterBuilder($this, $name); &#125;&#125; Illuminate\Contracts\Redis\LimiterTimeoutException.php 12345678910&lt;?phpnamespace Illuminate\Contracts\Redis;use Exception;class LimiterTimeoutException extends Exception&#123; //&#125; Illuminate\Redis\Limiters\ConcurrencyLimiter.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166&lt;?phpnamespace Illuminate\Redis\Limiters;use Exception;use Illuminate\Contracts\Redis\LimiterTimeoutException;use Illuminate\Support\Str;class ConcurrencyLimiter&#123; /** * The Redis factory implementation. * * @var \Illuminate\Redis\Connections\Connection */ protected $redis; /** * The name of the limiter. * * @var string */ protected $name; /** * The allowed number of concurrent tasks. * * @var int */ protected $maxLocks; /** * The number of seconds a slot should be maintained. * * @var int */ protected $releaseAfter; /** * Create a new concurrency limiter instance. * * @param \Illuminate\Redis\Connections\Connection $redis * @param string $name * @param int $maxLocks * @param int $releaseAfter * @return void */ public function __construct($redis, $name, $maxLocks, $releaseAfter) &#123; $this-&gt;name = $name; $this-&gt;redis = $redis; $this-&gt;maxLocks = $maxLocks; $this-&gt;releaseAfter = $releaseAfter; &#125; /** * Attempt to acquire the lock for the given number of seconds. * * @param int $timeout * @param callable|null $callback * @return bool * * @throws \Illuminate\Contracts\Redis\LimiterTimeoutException * @throws \Exception */ public function block($timeout, $callback = null) &#123; $starting = time(); $id = Str::random(20); while (! $slot = $this-&gt;acquire($id)) &#123; if (time() - $timeout &gt;= $starting) &#123; throw new LimiterTimeoutException; &#125; usleep(250 * 1000); &#125; if (is_callable($callback)) &#123; try &#123; return tap($callback(), function () use ($slot, $id) &#123; $this-&gt;release($slot, $id); &#125;); &#125; catch (Exception $exception) &#123; $this-&gt;release($slot, $id); throw $exception; &#125; &#125; return true; &#125; /** * Attempt to acquire the lock. * * @param string $id A unique identifier for this lock * @return mixed */ protected function acquire($id) &#123; $slots = array_map(function ($i) &#123; return $this-&gt;name.$i; &#125;, range(1, $this-&gt;maxLocks)); return $this-&gt;redis-&gt;eval(...array_merge( [$this-&gt;lockScript(), count($slots)], array_merge($slots, [$this-&gt;name, $this-&gt;releaseAfter, $id]) )); &#125; /** * Get the Lua script for acquiring a lock. * * KEYS - The keys that represent available slots * ARGV[1] - The limiter name * ARGV[2] - The number of seconds the slot should be reserved * ARGV[3] - The unique identifier for this lock * * @return string */ protected function lockScript() &#123; return &lt;&lt;&lt;'LUA'for index, value in pairs(redis.call('mget', unpack(KEYS))) do if not value then redis.call('set', KEYS[index], ARGV[3], "EX", ARGV[2]) return ARGV[1]..index endendLUA; &#125; /** * Release the lock. * * @param string $key * @param string $id * @return void */ protected function release($key, $id) &#123; $this-&gt;redis-&gt;eval($this-&gt;releaseScript(), 1, $key, $id); &#125; /** * Get the Lua script to atomically release a lock. * * KEYS[1] - The name of the lock * ARGV[1] - The unique identifier for this lock * * @return string */ protected function releaseScript() &#123; return &lt;&lt;&lt;'LUA'if redis.call('get', KEYS[1]) == ARGV[1]then return redis.call('del', KEYS[1])else return 0endLUA; &#125;&#125; ConcurrencyLimiterBuilder Illuminate\Redis\Limiters\ConcurrencyLimiterBuilder.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121&lt;?phpnamespace Illuminate\Redis\Limiters;use Illuminate\Contracts\Redis\LimiterTimeoutException;use Illuminate\Support\InteractsWithTime;class ConcurrencyLimiterBuilder&#123; use InteractsWithTime; /** * The Redis connection. * * @var \Illuminate\Redis\Connections\Connection */ public $connection; /** * The name of the lock. * * @var string */ public $name; /** * The maximum number of entities that can hold the lock at the same time. * * @var int */ public $maxLocks; /** * The number of seconds to maintain the lock until it is automatically released. * * @var int */ public $releaseAfter = 60; /** * The amount of time to block until a lock is available. * * @var int */ public $timeout = 3; /** * Create a new builder instance. * * @param \Illuminate\Redis\Connections\Connection $connection * @param string $name * @return void */ public function __construct($connection, $name) &#123; $this-&gt;name = $name; $this-&gt;connection = $connection; &#125; /** * Set the maximum number of locks that can obtained per time window. * * @param int $maxLocks * @return $this */ public function limit($maxLocks) &#123; $this-&gt;maxLocks = $maxLocks; return $this; &#125; /** * Set the number of seconds until the lock will be released. * * @param int $releaseAfter * @return $this */ public function releaseAfter($releaseAfter) &#123; $this-&gt;releaseAfter = $this-&gt;secondsUntil($releaseAfter); return $this; &#125; /** * Set the amount of time to block until a lock is available. * * @param int $timeout * @return $this */ public function block($timeout) &#123; $this-&gt;timeout = $timeout; return $this; &#125; /** * Execute the given callback if a lock is obtained, otherwise call the failure callback. * * @param callable $callback * @param callable|null $failure * @return mixed * * @throws \Illuminate\Contracts\Redis\LimiterTimeoutException */ public function then(callable $callback, callable $failure = null) &#123; try &#123; return (new ConcurrencyLimiter( $this-&gt;connection, $this-&gt;name, $this-&gt;maxLocks, $this-&gt;releaseAfter ))-&gt;block($this-&gt;timeout, $callback); &#125; catch (LimiterTimeoutException $e) &#123; if ($failure) &#123; return $failure($e); &#125; throw $e; &#125; &#125;&#125; Illuminate\Support\InteractsWithTime.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364&lt;?phpnamespace Illuminate\Support;use DateInterval;use DateTimeInterface;trait InteractsWithTime&#123; /** * Get the number of seconds until the given DateTime. * * @param \DateTimeInterface|\DateInterval|int $delay * @return int */ protected function secondsUntil($delay) &#123; $delay = $this-&gt;parseDateInterval($delay); return $delay instanceof DateTimeInterface ? max(0, $delay-&gt;getTimestamp() - $this-&gt;currentTime()) : (int) $delay; &#125; /** * Get the "available at" UNIX timestamp. * * @param \DateTimeInterface|\DateInterval|int $delay * @return int */ protected function availableAt($delay = 0) &#123; $delay = $this-&gt;parseDateInterval($delay); return $delay instanceof DateTimeInterface ? $delay-&gt;getTimestamp() : Carbon::now()-&gt;addRealSeconds($delay)-&gt;getTimestamp(); &#125; /** * If the given value is an interval, convert it to a DateTime instance. * * @param \DateTimeInterface|\DateInterval|int $delay * @return \DateTimeInterface|int */ protected function parseDateInterval($delay) &#123; if ($delay instanceof DateInterval) &#123; $delay = Carbon::now()-&gt;add($delay); &#125; return $delay; &#125; /** * Get the current system time as a UNIX timestamp. * * @return int */ protected function currentTime() &#123; return Carbon::now()-&gt;getTimestamp(); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP管道插件League\Pipeline]]></title>
    <url>%2F2020%2F04%2F06%2FPHP%E7%AE%A1%E9%81%93%E6%8F%92%E4%BB%B6League-Pipeline%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 责任链模式是什么样子的？属于什么类型模式？ Pipeline设计模式水管太长，只要有一处破了，就会漏水了，而且不利于复杂环境弯曲转折使用。所以我们都会把水管分成很短的一节一节管道，然后最大化的让管道大小作用不同，因地制宜，组装在一起，满足各种各样的不同需求。 由此得出Pipeline的设计模式，就是将复杂冗长的流程 (processes) 截成各个小流程，小任务。每个最小量化的任务就可以复用，通过组装不同的小任务，构成复杂多样的流程（processes）。 最后将「输入」引入管道，根据每个小任务对输入进行操作（加工、过滤），最后输出满足需要的结果。 gulpgulp是基于NodeJS的自动任务运行器，她能自动化地完成Javascript、sass、less等文件的测试、检查、合并、压缩、格式化、浏览器自动刷新、部署文件生成，并监听文件在改动后重复指定的这些步骤。在实现上，她借鉴了Unix操作系统的管道（pipe）思想，前一级的输出，直接变成后一级的输入，使得在操作上非常简单。 12345678910111213141516171819202122var gulp = require('gulp');var less = require('gulp-less');var minifyCSS = require('gulp-csso');var concat = require('gulp-concat');var sourcemaps = require('gulp-sourcemaps');gulp.task('css', function()&#123; return gulp.src('client/templates/*.less') .pipe(less()) .pipe(minifyCSS()) .pipe(gulp.dest('build/css'))&#125;);gulp.task('js', function()&#123; return gulp.src('client/javascript/*.js') .pipe(sourcemaps.init()) .pipe(concat('app.min.js')) .pipe(sourcemaps.write()) .pipe(gulp.dest('build/js'))&#125;);gulp.task('default', [ 'html', 'css', 'js' ]); 上面的两个task主要是将less、所有js文件进行解析、压缩、输出等流程操作，然后存到对应的文件夹下；每一步操作的输出就是下一步操作的输入，犹如管道的流水一般。 Illuminate\Pipeline12345678910111213141516171819202122232425&lt;?phpclass Demo &#123; public function demo(Request $request) &#123; $pipe1 = function ($payload, Closure $next) &#123; $payload = $payload + 1; return $next($payload); &#125;; $pipe2 = function ($payload, Closure $next) &#123; $payload = $payload * 3; return $next($payload); &#125;; $pipeline = new Pipeline(); $pipeline-&gt;send(8) -&gt;through([$pipe1, $pipe2]) -&gt;then(function ($data) &#123; return $data; &#125;); // 27 &#125;&#125; League\Pipeline安装1composer require league/pipeline 使用两个角色 Pipelines实现为不变的stage链。当你pipe一个新的stage时，将使用添加的stage创建一个新pipeline。这使得pipelines易于重用，并将副作用最小化。 1、pipeline 2、stage Closure 在管道中，stage可以是满足可调用类型提示的任何类型。所以闭包和任何可调用的东西都是可以的。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?phpnamespace app\api\controller;use League\Pipeline\Pipeline;use League\Pipeline\PipelineBuilder;class Test&#123; public function testPipeline() &#123; // 创建两个闭包函数 $stage1 = function ($payload) &#123; return $payload + 1; &#125;; $stage2 = function ($payload) &#123; return $payload * 3; &#125;; // 正常使用 $pipeline1 = (new Pipeline) -&gt;pipe($stage1) -&gt;pipe($stage2); $callback1 = $pipeline1-&gt;process(10); print_r($callback1.PHP_EOL); // 33 // 使用魔术方法 $pipeline2 = (new Pipeline()) -&gt;pipe($stage1) -&gt;pipe($stage2); $callback2 = $pipeline2(3); print_r($callback2.PHP_EOL); // 12 // 使用Builder // 因为pipelines本身是不可变的，所以引入PipelineBuilder来便利pipeline的分布式组合。 // PipelineBuilder收集stages并允许在任何给定时间创建pipeline。 $builder = new PipelineBuilder(); $pipeline3 = $builder -&gt;add($stage1) -&gt;add($stage2) -&gt;build(); $callback3 = $pipeline3(6); print_r($callback3.PHP_EOL); // 21 &#125;&#125; Class 基于类的stage也是可以的。可以实现StageInterface，以确保您拥有正确的方法签名以实现__invoke方法。 123456789101112131415161718192021222324252627&lt;?phpuse League\Pipeline\Pipeline;use League\Pipeline\StageInterface;class TimesTwoStage implements StageInterface&#123; public function __invoke($payload) &#123; return $payload * 2; &#125;&#125;class AddOneStage implements StageInterface&#123; public function __invoke($payload) &#123; return $payload + 1; &#125;&#125;$pipeline = (new Pipeline) -&gt;pipe(new TimesTwoStage) -&gt;pipe(new AddOneStage);// Returns 21$pipeline-&gt;process(10); Reuse 因为PipelineInterface是StageInterface的扩展，所以pipeline可以作为stage重用。这将创建一个高度组合的模型，以创建复杂的执行模式，同时保持较低的认知负载。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;?phpuse League\Pipeline\Pipeline;use League\Pipeline\StageInterface;class TimesTwoStage implements StageInterface&#123; public function __invoke($payload) &#123; return $payload * 2; &#125;&#125;class AddOneStage implements StageInterface&#123; public function __invoke($payload) &#123; return $payload + 1; &#125;&#125;class DivisionFourStage implements StageInterface&#123; public function __invoke($payload) &#123; return $payload / 4; &#125;&#125;class ReduceThreeStage implements StageInterface&#123; public function __invoke($payload) &#123; return $payload - 3; &#125;&#125;$pipeline1 = (new Pipeline) -&gt;pipe(new TimesTwoStage) -&gt;pipe(new AddOneStage);$pipeline2 = (new Pipeline) -&gt;pipe(new ReduceThreeStage) -&gt;pipe($pipeline1) -&gt;pipe(new DivisionFourStage);$pipeline2-&gt;process(12); // 4.75 Exception 这个包在处理异常时是完全透明的。在任何情况下，此包都不会捕获异常或使错误静音。在stage内或在pipeline处理有效负载时，应根据具体情况处理Exception。 1234567891011121314151617181920212223&lt;?phpnamespace app\api\controller;use League\Pipeline\Pipeline;use LogicException;class Test&#123; function testException() &#123; $pipeline = (new Pipeline)-&gt;pipe(function () &#123; throw new LogicException('这个阶段出错了'); &#125;); try &#123; $pipeline-&gt;process(10); &#125; catch(LogicException $e) &#123; // Handle the exception. echo $e-&gt;getMessage(); // 这个阶段出错了 &#125; &#125;&#125; 源码整个插件就这几个文件： Pipeline StageInterface.php 12345678910111213141516&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;interface StageInterface&#123; /** * Process the payload. * * @param mixed $payload * * @return mixed */ public function __invoke($payload);&#125; PipelineInterface.php 1234567891011121314&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;interface PipelineInterface extends StageInterface&#123; /** * Create a new pipeline with an appended stage. * * @return static */ public function pipe(callable $operation): PipelineInterface;&#125; 该接口主要是利用链式编程的思想，不断添加管道「pipe」，然后增加一个魔术方法，来让传入的参数运转起来。 先看看这个魔术方法的作用：1mixed __invoke ([ $... ] ) 当尝试以调用函数的方式调用一个对象时，__invoke()方法会被自动调用。 如：12345678910111213&lt;?phpclass CallableClass &#123; function __invoke($x) &#123; var_dump($x); &#125;&#125;$obj = new CallableClass;$obj(5);var_dump(is_callable($obj)); 返回结果：123int(5)bool(true)Pipeline 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;class Pipeline implements PipelineInterface&#123; /** * @var callable[] */ private $stages = []; /** * @var ProcessorInterface */ private $processor; public function __construct(ProcessorInterface $processor = null, callable ...$stages) &#123; $this-&gt;processor = $processor ?? new FingersCrossedProcessor; $this-&gt;stages = $stages; &#125; public function pipe(callable $stage): PipelineInterface &#123; $pipeline = clone $this; $pipeline-&gt;stages[] = $stage; return $pipeline; &#125; public function process($payload) &#123; return $this-&gt;processor-&gt;process($payload, ...$this-&gt;stages); &#125; public function __invoke($payload) &#123; return $this-&gt;process($payload); &#125;&#125; 其中核心类Pipeline的作用主要就是两个： 1、添加组装各个管道「pipe」；2、组装后，引水流动，执行sprocess($payload)，输出结果。 Processor 接好各种管道后，那就要「引水入渠」了。该插件提供了两个基础执行类，比较简单，直接看代码就能懂。 FingersCrossedProcessor.php 按照$stages数组顺序，遍历执行管道方法，再将结果传入下一个管道，让「水」一层层「流动」起来 12345678910111213141516&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;class FingersCrossedProcessor implements ProcessorInterface&#123; public function process($payload, callable ...$stages) &#123; foreach ($stages as $stage) &#123; $payload = $stage($payload); &#125; return $payload; &#125;&#125; InterruptibleProcessor.php 增加一个额外的「过滤网」，经过每个管道后的结果，都需要check，一旦满足则终止，直接输出结果。 1234567891011121314151617181920212223242526272829303132&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;class InterruptibleProcessor implements ProcessorInterface&#123; /** * @var callable */ private $check; public function __construct(callable $check) &#123; $this-&gt;check = $check; &#125; public function process($payload, callable ...$stages) &#123; $check = $this-&gt;check; foreach ($stages as $stage) &#123; $payload = $stage($payload); if (true !== $check($payload)) &#123; return $payload; &#125; &#125; return $payload; &#125;&#125; ProcessorInterface.php 12345678910111213141516&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;interface ProcessorInterface&#123; /** * Process the payload using multiple stages. * * @param mixed $payload * * @return mixed */ public function process($payload, callable ...$stages);&#125; 我们完全也可以利用该接口，实现我们的方法来组装管道和「过滤网」。 PipelineBuilder 最后提供了一个Builder，这个也很好理解： PipelineBuilderInterface.php 12345678910111213141516171819&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;interface PipelineBuilderInterface&#123; /** * Add an stage. * * @return self */ public function add(callable $stage): PipelineBuilderInterface; /** * Build a new Pipeline object. */ public function build(ProcessorInterface $processor = null): PipelineInterface;&#125; PipelineBuilder.php 123456789101112131415161718192021222324252627&lt;?phpdeclare(strict_types=1);namespace League\Pipeline;class PipelineBuilder implements PipelineBuilderInterface&#123; /** * @var callable[] */ private $stages = []; /** * @return self */ public function add(callable $stage): PipelineBuilderInterface &#123; $this-&gt;stages[] = $stage; return $this; &#125; public function build(ProcessorInterface $processor = null): PipelineInterface &#123; return new Pipeline($processor, ...$this-&gt;stages); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel Pipeline组件的实现]]></title>
    <url>%2F2020%2F04%2F06%2FLaravel-Pipeline%E7%BB%84%E4%BB%B6%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： (new Pipeline)是什么意思？ Laravel框架中有一个非常有趣的功能，就是HTTP中间件，我们在定义路由的时候，通过中间件对访问进行过滤。来自外部的请求首先经过全局中间件，若通过，则会继续穿过层层路由组所设置的中间件，再到达目的路由，当然，目的路由也可能定义了个中间件，通过后，该路由的处理对象（如控制器），得到的就是一个经过过滤的请求了。 开始本文当然不是讨论中间件如何使用，而是其实现的基础。Laravel框架中有一个组件叫做Illuminate\Pipeline，意味“管道”，我们看看下面这个代码示例：12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;?phpuse Illuminate\Pipeline\Pipeline;use Closure;$pipe1 = function ($poster, Closure $next) &#123; $poster += 1; echo "pipe1: $poster\n"; return $next($poster);&#125;;$pipe2 = function ($poster, Closure $next) &#123; if ($poster &gt; 7) &#123; return $poster; &#125; $poster += 3; echo "pipe2: $poster\n"; return $next($poster);&#125;;$pipe3 = function ($poster, Closure $next) &#123; $result = $next($poster); echo "pipe3: $result\n"; return $result * 2;&#125;;$pipe4 = function ($poster, Closure $next) &#123; $poster += 2; echo "pipe4 : $poster\n"; return $next($poster);&#125;;$pipes = [$pipe1, $pipe2, $pipe3, $pipe4];function dispatcher($poster, $pipes)&#123; echo "result: " . (new Pipeline)-&gt;send($poster)-&gt;through($pipes)-&gt;then(function ($poster) &#123; echo "received: $poster\n"; return 3; &#125;) . "\n";&#125;echo "==&gt; action 1:\n";dispatcher(5, $pipes);echo "==&gt; action 2:\n";dispatcher(7, $pipes); 上述代码执行结果如下：12345678910==&gt; action 1:pipe1: 6pipe2: 9pipe4 : 11received: 11pipe3: 3result: 6==&gt; action 2:pipe1: 8result: 8 流程概览Pipeline 组件实现了一个过滤流程: 原始数据 ---> 【前置管道】 ---> 目标处理逻辑 ---> 【后置管道】 ---> 结果数据 通过这种机制，可以将目标处理逻辑与过滤、认证等机制的代码分离开来，这样我们就更容易让代码清晰和易于维护。通过前置、后置管道，在其中“放置”我们需要过滤的逻辑即可，如上述代码，虽然只是一个简单的示例，就已经能够看得出，整个流程的动向，譬如我们在上面示例中准备了四个过滤组件（中间件）：pipe1、pipe2、pipe3、pipe4，其中1、2、4是前置，3为后置。 输入的原始数据为5，执行过程首先通过1号过滤组件，然后是2号，再然后是4号，到达目标处理逻辑后，再通过3号过滤组件，最终输出结果。 输入原始数据为7，同样是先经过1号过滤组件，随后是2号，不过在2号中，直接返回了结果，这意味着过程被拦截，不再继续向下传递数据，至此结束并返回结果。 Laravel框架中，原始数据是一个Request对象，通过所定义的前置中间件，开发者可在中间件中获取Request的信息，比如用户的Session/Cookie以及Header等，验证数据是否完备等等，不完备或不符合要求的，则被拦截并返回一个响应告知。若能正常通过则继续传递至最终的处理逻辑，如控制器的某个方法或者一个匿名函数。通过这种模式，我们就实现了请求校验和业务逻辑的分离，而且这样十分便于开发和维护。 实现Pipeline这个组件的功能十分明确，实现这种类似功能的肯定不少，选择其作为代表分析，原因就是其实现的方式非常简洁、有力，不但其实现原理如此，面对开发人员，它的调用方式也十分清晰，利用匿名函数使得前置与后置的调用都很直观，本文分析的重点就在这里。 实现的思路即使有了，在没有很好地基础之前，估计也很难去完成。当然很多人愿意去阅读其代码，这样就少走了不少弯路，在这里，我的建议也是这样。不过，很多人看到源码也很迷惑，因为中间存在着非常多的回调，只要基础不够扎实，就很容易在期间产生诸多困惑。 不过，逐步分析和对基础知识的补完，就会发现再复杂的框架也不过是零碎的功能有序的构建起来的。 array_reduce的妙用12345678910public function then(Closure $destination)&#123; $firstSlice = $this-&gt;getInitialSlice($destination); $callable = array_reduce( array_reverse($this-&gt;pipes), $this-&gt;getSlice(), $firstSlice ); return $callable($this-&gt;passable);&#125; 上面的代码就是Pipeline启动过程的起点，当然在调用then方法之前我们还有必要调用send和through，send是传递初始数据，through则是传递需要通过的中间件构成的数组。 then方法接受一个要求匿名函数的参数，该参数所接受的匿名函数，就是用于整个流程的逻辑处理部分的，数据穿过层层中间件，最终到达这里，所以该匿名函数可接受一个参数，就是经过过滤的数据啦。该方法囊括着所有功能，但是代码不过几行，因此肯定有额外的调度过程。 代码中首先映入眼帘的就是$this-&gt;getInitialSlice()，该方法顾名思义，创建了一个初始化用的Slice，这块我们先不细说，因为随后就是本文的重点，亦是组件实现的核心功能：array_reduce 函数！。 其作用本质就是通过用户自定义的方式去将一个数组合并成单一的一个值，因此该函数要求三个参数：待合并的数组、用于合并逻辑的回调函数、初始合并的值（亦或者特殊情境下的最终值），用于合并逻辑的回调须接受两个参数值，分别是上一次处理逻辑处理的结果（第一次不存在处理结果，则默认为空，若设置了array_reduce的第三个参数，则以该参数为初始值）和待处理的数组项。 Pipeline组件恰到好处的使用了它。我们看得到，Pipeline首先将我们用于处理的中间件数组通过array_reverse取相反顺序（至于为什么这么做后面你们就知道了），传递至array_reduce 的第一个参数。第三个参数作为array_reduce认定的默认处理对象，Pipeline用的是先前通过getInitalSlice获取到的（实际上是用户传进来的目标逻辑处理函数）作为值传递。 然后就是本文第二个介绍的重点，array_reduce所接受的第二个参数，通过调用$this-&gt;getSlice()获取的一个匿名函数！ 实现的核心array_reduce的第二个参数要求传递一个回调函数用于处理数组合并，$this-&gt;getSlice()返回的正是这个处理函数，我相信你们一定看到了getSlice返回的值，那么我就将这个匿名函数单独拿出来：1234567891011function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; if ($pipe instanceof Closure) &#123; return call_user_func($pipe, $passable, $stack); &#125; // 省略了一部分，该部分是针对中间件 “类”而不是中间件匿名函数的， // 先前例子中我们用的都是以匿名函数作为数组传递进来的，因此只会进入上面那个条件， // 当然Laravel框架中，传递进来的则基本是中间件对象的类名，这段省略的代码， // 和上面那个if中的本质的区别就是，省略的代码中包含了中间件类的实例化过程并调用的是其handle方法而不是直接调用函数，仅此~~ &#125;;&#125;; 我知道大家看到的代码有很多行，但是实际上就只有一行return function() { … };，被执行的也只有它。对于一些初学者，很容易产生一种错觉：那个返回的function会在return前执行。既然是错觉，那就意味着不会被执行，而是作为一个值被返回，可能会被后续某个地方所调用！可能会被后续某个地方所调用！可能会被后续某个地方所调用！这里只是个值！重要的事情说三遍。 虽说会被后面所调用，但我们依旧要在这里提一下这个被返回的匿名函数，在这里，它又有着另一个名称：闭包。闭包是由匿名函数（也成闭包函数）构成的一个整体，和普通的匿名函数有所不同，闭包中一定存在引用了外部数据并在内部操作的情况。 这里需要注意，返回的不仅仅是个匿名函数，更是一个闭包，该闭包中引用了两个外部值，分别是array_reduce提供给第二参数中的回调的两个参数，即数组合并结果和当前待合并的值。 第一次执行时，$stack就是我们的目标处理逻辑代码段，$pipe则是第一个中间件； 第二次执行时，$stack是第一次执行所返回的闭包，$pipe则是第二个中间件，随后以此类推。 最后一次执行，返回的结果仍旧是一个闭包，该闭包中所引用的外部数据是倒数第二次的执行返回的闭包，$pipe是最后一个中间件。随后，该闭包在then方法中被调用，传递进了我们通过send方法传递的值。 上面的描述可能异常抽象，我们让其变得稍微直观一些，我会将所有遍历每一次执行带来的变化体现出来。不过为了方便理解，我需要改一下示例代码，去掉中间的条件判断，因为我们现在重点是理解这个流程而不是其功能，新的代码与执行结果如下：1234567891011121314151617181920212223&lt;?phpuse Illuminate\Pipeline\Pipeline;$pipes = [ function ($poster, $callback) &#123; $poster += 1; return $callback($poster); &#125;, function ($poster, $callback) &#123; $result = $callback($poster); return $result - 1; &#125;, function ($poster, $callback) &#123; $poster += 2; return $callback($poster); &#125;];echo (new Pipeline)-&gt;send(0)-&gt;through($pipes)-&gt;then(function ($poster) &#123; return $poster;&#125;); // 执行输出为 2 上述代码，我们定义了三个中间件，同时我们的目标逻辑代码并没做什么特殊的事情，这样我们就可以专注在执行流程上。下面便于分析，我做了一份伪代码以及等式方便理解： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152poster = 0f^0 = f(z)-&gt;&#123; z &#125; // 定义目标处理逻辑f^1 = f(z, y)-&gt;&#123; f^y( z + 1 ) &#125; // 定义中间件 1f^2 = f(z, y)-&gt;&#123; result = f^y(z); result - 1 &#125; // 定义中间件 2f^3 = f(z, y)-&gt;&#123; f^y( z + 2 ) &#125; // 定义中间件 3f^getSlice = f(y, x)-&gt;&#123; f(z)-&gt;&#123; call( f^x(z, y) ) &#125;&#125;callback = array_reduce([f^3, f^2, f^1], f^getSlice, f^0);callback(poster)&gt;&gt;&gt; 执行上述过程exec^1: // 第一次进行 reduce，y 是目标逻辑片段，x 是最后一个中间件，被闭包引用， // 闭包则作为合并结果返回，在此定义为 f^a。 y = f^0(z); x = f^3; f^a = f(z)-&gt;&#123; call( f^x(z, y) ) &#125;exec^2: // 第二次进行，y 是上次处理返回的闭包（即 f^a），x 是第二个中间件，再次生成闭包返回。 y = f^a; x = f^2; f^b = f(z)-&gt;&#123; call( f^x(z, y) ) &#125;exec^3: // 第三次也是最后一次合并，同第二次。现在三个数组项被合并， // 合并结果为最后一次合并所返回的闭包。 y = f^b; x = f^1; f^c = f(z)-&gt;&#123; call( f^x(z, y) ) &#125;exec^4: // 该闭包（最后一次合并结果）返回后，被调用，第一个参数为 z = poster = 1，开始执行。 // 该闭包的 z 参数即为 1，其余如 x、y 值见 exec^3。 call( f^c(0) ) = call( f^1(0, f^b) )exec^5: // 继续等式替换 call( f^b(0 + 1) ) = call( f^2(0 + 1, f^a) )exec^6: // 根据上已执行过程返回结果，已执行至中间件 2 的回调，继续等式替换 result = f^a(0 + 1); result - 1exec^7: result = call( f^3(0 + 1 , f^0) ); result - 1exec^8: result = call( f^0(0 + 1 + 2) ); result - 1exec^9: result = 3; result - 1// 处理结果result: 2 分析根据伪代码，和执行过程，我们能了解到先前通过array_reverse反序排列的中间件，由于在本文中，此处闭包逆向传递下去的特性（因为所引用的外部参数中，是前一执行结果所返回的闭包），实际上依旧是按顺序执行的，我们在这里也看到了如何利用该特性，实现前置和后置调用的原理以及拦截的原理。 前置调用时，先处理自上传递下来的结果，随后调用下一个（由中间件构成的）闭包。后置调用时，先调用下一个（有中间件构成的）闭包，里面仍旧可能无数的引用，直到其中的目标处理逻辑，最终返回结果，再处理。 拦截的原理就更简单了，由于拦截只存在于前置中间件，而前置中间件是先处理，然后调用传递进来的闭包并返回其值，而若这个值不是来自于一个闭包调用的结果，就意味着肯定中间不存在调用关系，也就根本不会执行到闭包中的下一个中间件。 总结以上就是整个Pipeline以及中间件的实现，我知道很多人依旧十分纠结，内心充满困惑。我仍旧建议老老实实，从 array_reduce 这个函数的实际功能着手，然后把每一步执行过程，写下来，慢慢的就明白了。这篇文章不仅仅只是Laravel组件的一个讲解，更多是从中发现PHP的一些基础概念和知识，要知道在强大的PHP框架也是用PHP写出的，本质上仍旧是在一个大的基础上构建的小世界而已。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Pipeline]]></title>
    <url>%2F2020%2F04%2F05%2FLaravel-Pipeline%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 责任链模式是什么样子的？属于什么类型模式？ array_reduce的第一个参数数组是闭包函数集合，第三个参数是闭包。怎么理解？ 为什么要用array_reverse反转闭包集合？ Laravel中管道设计模式的使用——中间件实现原理探究管道模式可以看作责任链模式的一种具体实现。 所谓管道（Pipeline）设计模式就是将数据传递到一个任务序列中，管道扮演着流水线的角色，数据在这里被处理然后传递到下一个步骤。 使用管道有很多好处，尤其是在单个任务中编写复杂处理代码时管道为我们提供了极大的便利，而且可以在管道中轻松添加、移除或者替换阶段任务。 Laravel在框架中的很多地方用到了Pipeline设计模式，这意味着所有我们需要实现管道设计模式的地方已然是应用底层的一部分了。 我们可以使用Laravel的内部组件在框架顶层构建自己的功能。今天的教程我们将讨论管道设计模式以及如何使用Laravel的内部管道。 什么是管道设计模式管道模式用于将复杂的进程分解成多个独立的子任务。每个独立的任务都是可复用的，因此这些任务可以被组合成复杂的进程。 这种模式允许你将庞大的进程分解成更小的子任务，这些子任务将数据进行处理并将处理后的结果传递给下一个子任务。就像流水线一样，有条不紊，从原料加工到成品，实现一道完整的工序。 管道中的每一个任务都会接受并返回同一类型的数据，这样子任务可以在管道中被添加、移除或者替换，而不影响其它子任务。 如果你熟悉Unix系统的话，你可能对管道并不陌生，因为在shell命令中我们经常会使用管道命令，例如： 1cat helloworld.txt | grep "hello world" | rev | &gt; output.txt 在这个例子中，我们读取文件内容，并在其中查询字符串“hello world”，反转字符串，并最终将其添加到output.txt文件中。 如何使用管道模式Laravel在框架中的很多地方使用了管道设计模式，最常见的就是中间件的实现。 当请求最终到达控制器动作被处理前，会先经过一系列的中间件。每个中间件都有一个独立的职责，例如，设置Cookie、判断是否登录以及阻止CSRF攻击等等。 每个阶段都会对请求进行处理，如果请求通过就会被传递给下一个处理，不通过就会返回相应的HTTP响应。 这种机制使得我们很容易在请求最终到达应用代码前添加处理操作，当然如果不需要这个处理操作你也可以随时移除而不影响请求的生命周期。 管道模式的优点管道模式有很多优点： 首先，将复杂的处理流程分解成独立的子任务，从而方便测试每个子任务； 其次，被分解的子任务可以被不同的处理进程复用，避免代码冗余； 最后，在复杂进程中添加、移除和替换子任务非常轻松，对已存在的进程没有任何影响。 管道模式的缺点当然，管道模式也有缺点： 虽然每个子任务变得简单了，但是当你再度尝试将这些子任务组合成完整进程时有一定复杂性； 此外你还需要保证独立子任务测试通过后整体的流程能正常工作，这有一定的不确定性； 最后，当你看到的都是一个个子任务时，对理解整体流程带来困难（盲人摸象的故事想必大家很熟悉，正是此理）。 如何使用Laravel的管道使用Laravel提供的管道很简单，首先需要创建一个新的Illuminate\Pipeline\Pipeline对象，并将其注入到某个Illuminate\Contracts\Container\Container的实例： 1$pipeline = app('Illuminate\Pipeline\Pipeline'); 接下来将你想要传递的对象发送这个管道：1$pipeline-&gt;send($request); 然后将其传递到接受并处理请求的任务数组：1$pipeline-&gt;through($middleware); 最后运行管道任务并编写回调处理：123$pipeline-&gt;then(function ($request) &#123; // Do something&#125;); 这就是中间件的基本工作原理：接收HTTP请求，让请求经过定义好的路由中间件，最后到达目的地进行处理。 结论管道设计模式很有用，中间件只是一个特别的例子，Laravel在框架底层中充分利用了该设计模式，当然你也可以在自己的项目中使用Laravel提供的管道。 Laravel管道流原理Laravel管道流原理强烈依赖array_reduce函数，我们先来了解下array_reduce函数的使用。 array_reducearray_reduce()将回调函数callback迭代地作用到array数组中的每一个单元中，从而将数组简化为单一的值。 1mixed array_reduce ( array $array , callable $callback [, mixed $initial = NULL ] ) 1.array 输入的array。 2.callback 1mixed callback ( mixed $carry , mixed $item ) $carry包括上次迭代的值，如果本次迭代是第一次，那么这个值是initial，item携带了本次迭代的值 3.initial 如果指定了可选参数initial，该参数将在处理开始前使用，或者当处理结束，数组为空时的最后一个结果。 从文档说明可以看出，array_reduce函数是把数组的每一项，都通过给定的callback函数来简化的。 那我们就来看看是怎么简化的。 12345$arr = ['AAAA', 'BBBB', 'CCCC'];$res = array_reduce($arr, function($carry, $item)&#123; return $carry . $item;&#125;); 给定的数组长度为3，故总迭代三次。 第一次迭代时$carry=null，$item=AAAA返回AAAA第二次迭代时$carry=AAAA，$item=BBBB返回AAAABBBB第三次迭代时$carry=AAAABBBB，$item=CCCC返回AAAABBBBCCCC 这种方式将数组简化为一串字符串AAAABBBBCCCC 带初始值的情况12345$arr = ['AAAA', 'BBBB', 'CCCC'];$res = array_reduce($arr, function($carry, $item)&#123; return $carry . $item;&#125;, 'INITIAL-'); 第一次迭代时（$carry = INITIAL-），（$item = AAAA）返回INITIAL-AAAA第二次迭代时（$carry = INITIAL-AAAA），（$item = BBBB）， 返回INITIAL-AAAABBBB第三次迭代时（$carry = INITIAL-AAAABBBB），（$item = CCCC），返回INITIAL-AAAABBBBCCCC 这种方式将数组简化为一串字符串INITIAL-AAAABBBBCCCC 闭包12345678$arr = ['AAAA', 'BBBB', 'CCCC'];// 没带初始值$res = array_reduce($arr, function($carry, $item)&#123; return function() use ($item)&#123; // 这里只use了item return strtolower($item) . '-'; &#125;;&#125;); 第一次迭代时，$carry：null，$item=AAAA，返回一个use了$item=AAAA的闭包第二次迭代时，$carry：use了$item=AAAA的闭包，$item=BBBB，返回一个use了$item=BBBB的闭包第三次迭代时，$carry：use了$item=BBBB的闭包，$item=CCCC，返回一个use了$item=CCCC的闭包 这种方式将数组简化为一个闭包，即最后返回的闭包，当我们执行这个闭包时$res()得到返回值CCCC- 上面这种方式只use($item)，每次迭代返回的闭包在下次迭代时，我们都没有用起来。只是又重新返回了一个use了当前item值的闭包。 闭包USE闭包123456789$arr = ['AAAA'];$res = array_reduce($arr, function($carry, $item)&#123; return function () use ($carry, $item) &#123; if (is_null($carry)) &#123; return 'Carry IS NULL' . $item; &#125; &#125;;&#125;); 注意，此时的数组长度为1，并且没有指定初始值。 由于数组长度为1，故只迭代一次，返回一个use($carry = null, $item = ‘AAAA’)的闭包，当我们执行$res()这个闭包时，得到的结果为Carry IS NULLAAAA。 接下来我们重新改造下：123456789101112$arr = ['AAAA', 'BBBB'];$res = array_reduce($arr, function($carry, $item)&#123; return function () use ($carry, $item) &#123; if (is_null($carry)) &#123; return 'Carry IS NULL' . $item; &#125; if ($carry instanceof \Closure) &#123; return $carry() . $item; &#125; &#125;;&#125;); 我们新增了一个条件判断，若当前迭代的值是一个闭包，返回该闭包的执行结果。 第一次迭代时，$carry的值为null，$item的值为AAAA，返回一个闭包。123456789// 伪代码function () use ($carry = null, $item = AAAA) &#123; if (is_null($carry)) &#123; return 'Carry IS NULL' . $item; &#125; if ($carry instanceof \Closure) &#123; return $carry() . $item; &#125;&#125; 假设我们直接执行该闭包，将会返回Carry IS NULLAAAA的结果。 第二次迭代时，$carry的值为上述返回的闭包（伪代码），$item的值为BBBB，返回一个闭包，当我们执行这个闭包时，满足$carry instanceof \Closure，得到结果Carry IS NULLAAAABBBB。 Laravel中的array_reverse大致了解了array_reverse函数的使用后，我们来瞅瞅laravel管道流里使用array_reverse的情况。 php内置方法array_reduce把所有要通过的中间件都通过callback方法并压缩为一个Closure。最后再执行Initial。 Laravel中通过全局中间件的核心代码如下：12345678910111213141516// Illuminate\Foundation\Http\Kernel.phpprotected function sendRequestThroughRouter($request)&#123; return (new Pipeline($this-&gt;app)) -&gt;send($request) -&gt;through($this-&gt;app-&gt;shouldSkipMiddleware() ? [] : $this-&gt;middleware) -&gt;then($this-&gt;dispatchToRouter());&#125;protected function dispatchToRouter()&#123; return function ($request) &#123; $this-&gt;app-&gt;instance('request', $request); return $this-&gt;router-&gt;dispatch($request); &#125;;&#125; 正如我前面说的，我们发送一个$request对象通过middleware中间件数组，最后再执行dispatchToRouter方法。 假设有两个全局中间件，我们来看看这两个中间件是如何通过管道压缩为一个Closure的。12Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class,App\Http\Middleware\AllowOrigin::class, // 自定义中间件 Illuminate\Pipeline\Pipeline为laravel的管道流核心类。 在Illuminate\Pipeline\Pipeline的then方法中，$destination为上述的dispatchToRouter闭包，pipes为要通过的中间件数组，passable为Request对象。1234567public function then(Closure $destination)&#123; $pipeline = array_reduce( array_reverse($this-&gt;pipes), $this-&gt;carry(), $this-&gt;prepareDestination($destination) ); return $pipeline($this-&gt;passable);&#125; array_reverse函数将中间件数组的每一项都通过$this-&gt;carry()，初始值为上述dispatchToRouter 方法返回的闭包。12345678910111213141516171819202122232425protected function prepareDestination(Closure $destination)&#123; return function ($passable) use ($destination) &#123; return $destination($passable); &#125;;&#125;protected function carry()&#123; return function ($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; if ($pipe instanceof Closure) &#123; return $pipe($passable, $stack); &#125; elseif (! is_object($pipe)) &#123; //解析中间件参数 list($name, $parameters) = $this-&gt;parsePipeString($pipe); $pipe = $this-&gt;getContainer()-&gt;make($name); $parameters = array_merge([$passable, $stack], $parameters); &#125; else &#123; $parameters = [$passable, $stack]; &#125; return $pipe-&gt;&#123;$this-&gt;method&#125;(...$parameters); &#125;; &#125;;&#125; 第一次迭代时，返回一个闭包，use了$stack和$pipe，$stack的值为初始值闭包，$pipe为中间件类名，此处是App\Http\Middleware\AllowOrigin::class（注意array_reverse函数把传进来的中间件数组倒叙了）。 假设我们直接运行该闭包，由于此时$pipe是一个String类型的中间件类名，只满足!is_object($pipe)这个条件，我们将直接从容器中make一个该中间件的实例出来，在执行该中间件实例的handle方法（默认$this-&gt;method为handle）。并且将request对象和初始值作为参数，传给这个中间件。1234public function handle($request, Closure $next)&#123; //......&#125; 在这个中间件的handle方法中，当我们直接执行return $next($request)时，相当于我们开始执行array_reduce函数的初始值闭包了，即上述的dispatchToRouter方法返回的闭包。1234567protected function dispatchToRouter()&#123; return function ($request) &#123; $this-&gt;app-&gt;instance('request', $request); return $this-&gt;router-&gt;dispatch($request); &#125;;&#125; 好，假设结束。在第二次迭代时，也返回一个use了$stack和$pipe的闭包，$stack的值为我们第一次迭代时返回的闭包，$pipe 为中间件类名，此处是Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class。 两次迭代结束，回到then方法中，我们手动执行了第二次迭代返回的闭包。1return $pipeline($this-&gt;passable); 当执行第二次迭代返回的闭包时，当前闭包use的$pipe为Illuminate\Foundation\Http\Middleware\CheckForMaintenanceMode::class，同样只满足!is_object($pipe)这个条件，我们将会从容器中make出CheckForMaintenanceMode中间件的实例，在执行该实例的handle方法，并且把第一次迭代返回的闭包作为参数传到handle方法中。 当我们在CheckForMaintenanceMode中间件的handle方法中执行return $next($request)时，此时的$next为我们第一次迭代返回的闭包，将回到我们刚才假设的流程那样。从容器中make 一个App\Http\Middleware\AllowOrigin实例，在执行该实例的handle方法，并把初始值闭包作为参数传到AllowOrigin中间件的handle方法中。当我们再在AllowOrigin中间件中执行return $next($request)时，代表我们所有中间件都通过完成了，接下来开始执行dispatchToRouter。 1.中间件是区分先后顺序的，从这里你应该能明白为什么要把中间件用array_reverse倒叙了。 2.并不是所有中间件在运行前都已经实例化了的，用到的时候才去向容器取。 3.中间件不执行$next($request)后续所有中间件无法执行。 Pipeline Illuminate\Contracts\Pipeline\Hub.php 123456789101112131415&lt;?phpnamespace Illuminate\Contracts\Pipeline;interface Hub&#123; /** * Send an object through one of the available pipelines. * * @param mixed $object * @param string|null $pipeline * @return mixed */ public function pipe($object, $pipeline = null);&#125; Illuminate\Contracts\Pipeline\Pipeline.php 12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace Illuminate\Contracts\Pipeline;use Closure;interface Pipeline&#123; /** * Set the traveler object being sent on the pipeline. * * @param mixed $traveler * @return $this */ public function send($traveler); /** * Set the stops of the pipeline. * * @param dynamic|array $stops * @return $this */ public function through($stops); /** * Set the method to call on the stops. * * @param string $method * @return $this */ public function via($method); /** * Run the pipeline with a final destination callback. * * @param \Closure $destination * @return mixed */ public function then(Closure $destination);&#125; Illuminate\Pipeline\PipelineServiceProvider.php 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace Illuminate\Pipeline;use Illuminate\Contracts\Pipeline\Hub as PipelineHubContract;use Illuminate\Contracts\Support\DeferrableProvider;use Illuminate\Support\ServiceProvider;class PipelineServiceProvider extends ServiceProvider implements DeferrableProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton( PipelineHubContract::class, Hub::class ); &#125; /** * Get the services provided by the provider. * * @return array */ public function provides() &#123; return [ PipelineHubContract::class, ]; &#125;&#125; Illuminate\Pipeline\Pipeline.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244namespace Illuminate\Pipeline;use Closure;use Illuminate\Contracts\Container\Container;use Illuminate\Contracts\Pipeline\Pipeline as PipelineContract;use RuntimeException;use Throwable;class Pipeline implements PipelineContract&#123; /** * The container implementation. * * @var \Illuminate\Contracts\Container\Container */ protected $container; /** * The object being passed through the pipeline. * * @var mixed */ protected $passable; /** * The array of class pipes. * * @var array */ protected $pipes = []; /** * The method to call on each pipe. * * @var string */ protected $method = 'handle'; /** * Create a new class instance. * * @param \Illuminate\Contracts\Container\Container|null $container * @return void */ public function __construct(Container $container = null) &#123; $this-&gt;container = $container; &#125; /** * Set the object being sent through the pipeline. * * @param mixed $passable * @return $this */ public function send($passable) &#123; $this-&gt;passable = $passable; return $this; &#125; /** * Set the array of pipes. * * @param array|mixed $pipes * @return $this */ public function through($pipes) &#123; $this-&gt;pipes = is_array($pipes) ? $pipes : func_get_args(); return $this; &#125; /** * Set the method to call on the pipes. * * @param string $method * @return $this */ public function via($method) &#123; $this-&gt;method = $method; return $this; &#125; /** * Run the pipeline with a final destination callback. * * @param \Closure $destination * @return mixed */ public function then(Closure $destination) &#123; $pipeline = array_reduce( array_reverse($this-&gt;pipes()), $this-&gt;carry(), $this-&gt;prepareDestination($destination) ); return $pipeline($this-&gt;passable); &#125; /** * Run the pipeline and return the result. * * @return mixed */ public function thenReturn() &#123; return $this-&gt;then(function ($passable)&#123; return $passable; &#125;); &#125; /** * Get the final piece of the Closure onion. * * @param \Closure $destination * @return \Closure */ protected function prepareDestination(Closure $destination) &#123; return function ($passable) use ($destination) &#123; try &#123; return $destination($passable); &#125; catch (Throwable $e) &#123; return $this-&gt;handleException($passable, $e); &#125; &#125; &#125; /** * Get a Closure that represents a slice of the application onion. * * @return \Closure */ protected function carry() &#123; return function($stack, $pipe) &#123; return function ($passable) use ($stack, $pipe) &#123; try &#123; if (is_callable($pipe)) &#123; // If the pipe is a callable, then we will call it directly, but otherwise we // will resolve the pipes out of the dependency container and call it with // the appropriate method and arguments, returning the results back out. return $pipe($passable, $stack); &#125; elseif (! is_object($pipe)) &#123; [$name, $parameters] = $this-&gt;parsePipeString($pipe); // If the pipe is a string we will parse the string and resolve the class out // of the dependency injection container. We can then build a callable and // execute the pipe function giving in the parameters that are required. $pipe = $this-&gt;getContainer()-&gt;make($name); $parameters = array_merge([$passable, $stack], $parameters); &#125; else &#123; // If the pipe is already an object we'll just make a callable and pass it to // the pipe as-is. There is no need to do any extra parsing and formatting // since the object we're given was already a fully instantiated object. $parameters = [$passable, $stack]; &#125; $carry = method_exists($pipe, $this-&gt;method) ? $pipe-&gt;&#123;$this-&gt;method&#125;(...$parameters) : $pipe(...$parameters); return $this-&gt;handleCarry($carry); &#125; catch (Throwable $e) &#123; return $this-&gt;handleException($passable, $e); &#125; &#125; &#125; &#125; /** * Parse full pipe string to get name and parameters. * * @param string $pipe * @return array */ protected function parsePipeString($pipe) &#123; [$name, $parameters] = array_pad(explode(':', $pipe, 2), 2, []); if (is_string($parameters)) &#123; $parameters = explode(',', $parameters); &#125; return [$name, $parameters]; &#125; /** * Get the array of configured pipes. * * @return array */ protected function pipes() &#123; return $this-&gt;pipes; &#125; /** * Get the container instance. * * @return \Illuminate\Contracts\Container\Container * * @throws \RuntimeException */ protected function getContainer() &#123; if (! $this-&gt;container) &#123; throw new RuntimeException('A container instance has not been passed to the Pipeline.'); &#125; return $this-&gt;container; &#125; /** * Handle the value returned from each pipe before passing it to the next. * * @param mixed $carry * @return mixed */ protected function handleCarry($carry) &#123; return $carry; &#125; /** * Handle the given exception. * * @param mixed $passable * @param \Throwable $e * @return mixed * * @throws \Throwable */ protected function handleException($passable, Throwable $e) &#123; throw $e; &#125;&#125; 1.管道处理的核心方法then，实际上是一个非常有用的PHP函数array_reduce($array, $callback, $initial)的应用，只不过待处理数组变成了可调用的中间件函数（字符串或closure表示的）； 2.处理函数因为有额外参数$passable（即Request实例）需要传入，所以多包了一层闭包函数【注：关于多层包含的闭包函数，在Python装饰器原理中可以充分理解，尤其是阮一峰的逐步递进写完善的装饰器过程】； 3.初始值也是一个闭包函数，这个是真正的response响应函数。 $this-&gt;method = ‘handle’ 这个方法名，可通过via函数修改。 中间件类方法handle($request, Closure $next)有2个参数，这个对应闭包处理过后的中间件函数的返回值 1return $pipe($passable, $stack)。 Laravel中间件逻辑，是闭包函数强大功能的一大体现。于是我们使用闭包函数，以函数式编程风格实现简化版的中间件流程：12345678910111213141516171819202122232425262728293031function f1($f)&#123; return function($x) use ($f)&#123; echo 'middleware 1 begin.'.PHP_EOL; $x += 1; $x = $f($x); echo 'middleware 1 end.'.PHP_EOL; return $x; &#125;;&#125;function f2($f)&#123; return function($x) use($f)&#123; echo 'middleware 2 begin: '.PHP_EOL; $x += 2; $x = $f($x); echo 'middleware 2 end.'.PHP_EOL; return $x; &#125;;&#125;function respond()&#123; return function($x)&#123; echo 'Generate some response.'.PHP_EOL; return $x; &#125;;&#125;$x = 1;$response = f2(f1(respond()))($x);echo $response; 输出： 123456middleware 2 begin:middleware 1 begin.Generate some response.middleware 1 end.middleware 2 end.4 可以看出为什么Laravel的Pipeline的实现需要反转中间件数组。 高阶函数的实现，可以通过层层传递“函数名字符串”的原始方法来实现，但是通过闭包函数实现更加简单。 array_reduce写法12345678910111213141516171819202122232425262728293031$f1 = function($x, $f)&#123; echo 'middleware 1 begin.'.PHP_EOL; $x += 1; $x = $f($x); echo 'middleware 1 end.'.PHP_EOL; return $x; &#125;;$f2 = function($x, $f)&#123; echo 'middleware 2 begin: '.PHP_EOL; $x += 2; $x = $f($x); echo 'middleware 2 end.'.PHP_EOL; return $x;&#125;;$respond = function($x)&#123; echo 'Generate some response.'.PHP_EOL; return $x;&#125;;$middlewares = [$f1, $f2];$initial = $respond;$foo = array_reduce($middlewares, function($stack, $item)&#123; return function($request) use ($stack, $item)&#123; return $item($request, $stack); &#125;;&#125;, $initial);$x = 1;echo $foo($x); 输出： 12345middleware 2 begin:middleware 1 begin.Generate some response.middleware 1 end.middleware 2 end.]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Dispatcher]]></title>
    <url>%2F2020%2F04%2F03%2FLaravel-Dispatcher%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Dispatcher类维护一个$listeners[]数组。$this-&gt;listeners[$event][]=closure;怎么理解？ listen($events,$listener)往$listeners[]数组里写。dispatch();函数执行闭包。怎么理解？ 源码Laravel Event-事件系统的启动与运行源码分析 Illuminate\Contracts\Events\Dispatcher.php 接口 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?phpnamespace Illuminate\Contracts\Events;interface Dispatcher&#123; /** * Register an event listener with the dispatcher. * * @param string|array $events * @param mixed $listener * @return void */ public function listen($events, $listener); /** * Determine if a given event has listeners. * * @param string $eventName * @return bool */ public function hasListeners($eventName); /** * Register an event subscriber with the dispatcher. * * @param object|string $subscriber * @return void */ public function subscribe($subscriber); /** * Dispatch an event until the first non-null response is returned. * * @param string|object $event * @param mixed $payload * @return array|null */ public function until($event, $payload = []); /** * Dispatch an event and call the listeners. * * @param string|object $event * @param mixed $payload * @param bool $halt * @return array|null */ public function dispatch($event, $payload = [], $halt = false); /** * Register an event and payload to be fired later. * * @param string $event * @param array $payload * @return void */ public function push($event, $payload = []); /** * Flush a set of pushed events. * * @param string $event * @return void */ public function flush($event); /** * Remove a set of listeners from the dispatcher. * * @param string $event * @return void */ public function forget($event); /** * Forget all of the queued listeners. * * @return void */ public function forgetPushed();&#125; Illuminate\Events\Dispatcher.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569570571572573574575576577578579580581582583584585586587588589590591592593594595596597598599600601602603604605606607608609&lt;?phpnamespace Illuminate\Events;use Exception;use Illuminate\Container\Container;use Illuminate\Contracts\Broadcasting\Factory as BroadcastFactory;use Illuminate\Contracts\Broadcasting\ShouldBroadcast;use Illuminate\Contracts\Container\Container as ContainerContract;use Illuminate\Contracts\Events\Dispatcher as DispatcherContract;use Illuminate\Contracts\Queue\ShouldQueue;use Illuminate\Support\Arr;use Illuminate\Support\Str;use Illuminate\Support\Traits\Macroable;use ReflectionClass;class Dispatcher implements DispatcherContract&#123; use Macroable; /** * The IoC container instance. * * @var \Illuminate\Contracts\Container\Container */ protected $container; /** * The registered event listeners. * * @var array */ protected $listeners = []; /** * The wildcard listeners. * * @var array */ protected $wildcards = []; /** * The cached wildcard listeners. * * @var array */ protected $wildcardsCache = []; /** * The queue resolver instance. * * @var callable */ protected $queueResolver; /** * Create a new event dispatcher instance. * * @param \Illuminate\Contracts\Container\Container|null $container * @return void */ public function __construct(ContainerContract $container = null) &#123; $this-&gt;container = $container ?: new Container; &#125; /** * Register an event listener with the dispatcher. * * @param string|array $events * @param \Closure|string $listener * @return void */ public function listen($events, $listener) &#123; foreach ((array) $events as $event) &#123; if (Str::contains($event, '*')) &#123; $this-&gt;setupWildcardListen($event, $listener); &#125; else &#123; $this-&gt;listeners[$event][] = $this-&gt;makeListener($listener); &#125; &#125; &#125; /** * Setup a wildcard listener callback. * * @param string $event * @param \Closure|string $listener * @return void */ protected function setupWildcardListen($event, $listener) &#123; $this-&gt;wildcards[$event][] = $this-&gt;makeListener($listener, true); $this-&gt;wildcardsCache = []; &#125; /** * Determine if a given event has listeners. * * @param string $eventName * @return bool */ public function hasListeners($eventName) &#123; return isset($this-&gt;listeners[$eventName]) || isset($this-&gt;wildcards[$eventName]) || $this-&gt;hasWildcardListeners($eventName); &#125; /** * Determine if the given event has any wildcard listeners. * * @param string $eventName * @return bool */ public function hasWildcardListeners($eventName) &#123; foreach ($this-&gt;wildcards as $key =&gt; $listeners) &#123; if (Str::is($key, $eventName)) &#123; return true; &#125; &#125; return false; &#125; /** * Register an event and payload to be fired later. * * @param string $event * @param array $payload * @return void */ public function push($event, $payload = []) &#123; $this-&gt;listen($event.'_pushed', function () use ($event, $payload) &#123; $this-&gt;dispatch($event, $payload); &#125;); &#125; /** * Flush a set of pushed events. * * @param string $event * @return void */ public function flush($event) &#123; $this-&gt;dispatch($event.'_pushed'); &#125; /** * Register an event subscriber with the dispatcher. * * @param object|string $subscriber * @return void */ public function subscribe($subscriber) &#123; $subscriber = $this-&gt;resolveSubscriber($subscriber); $events = $subscriber-&gt;subscribe($this); if (is_array($events)) &#123; foreach ($events as $event =&gt; $listeners) &#123; foreach ($listeners as $listener) &#123; $this-&gt;listen($event, $listener); &#125; &#125; &#125; &#125; /** * Resolve the subscriber instance. * * @param object|string $subscriber * @return mixed */ protected function resolveSubscriber($subscriber) &#123; if (is_string($subscriber)) &#123; return $this-&gt;container-&gt;make($subscriber); &#125; return $subscriber; &#125; /** * Fire an event until the first non-null response is returned. * * @param string|object $event * @param mixed $payload * @return array|null */ public function until($event, $payload = []) &#123; return $this-&gt;dispatch($event, $payload, true); &#125; /** * Fire an event and call the listeners. * * @param string|object $event * @param mixed $payload * @param bool $halt * @return array|null */ public function dispatch($event, $payload = [], $halt = false) &#123; // When the given "event" is actually an object we will assume it is an event // object and use the class as the event name and this event itself as the // payload to the handler, which makes object based events quite simple. [$event, $payload] = $this-&gt;parseEventAndPayload( $event, $payload ); if ($this-&gt;shouldBroadcast($payload)) &#123; $this-&gt;broadcastEvent($payload[0]); &#125; $responses = []; foreach ($this-&gt;getListeners($event) as $listener) &#123; $response = $listener($event, $payload); // If a response is returned from the listener and event halting is enabled // we will just return this response, and not call the rest of the event // listeners. Otherwise we will add the response on the response list. if ($halt &amp;&amp; ! is_null($response)) &#123; return $response; &#125; // If a boolean false is returned from a listener, we will stop propagating // the event to any further listeners down in the chain, else we keep on // looping through the listeners and firing every one in our sequence. if ($response === false) &#123; break; &#125; $responses[] = $response; &#125; return $halt ? null : $responses; &#125; /** * Parse the given event and payload and prepare them for dispatching. * * @param mixed $event * @param mixed $payload * @return array */ protected function parseEventAndPayload($event, $payload) &#123; if (is_object($event)) &#123; [$payload, $event] = [[$event], get_class($event)]; &#125; return [$event, Arr::wrap($payload)]; &#125; /** * Determine if the payload has a broadcastable event. * * @param array $payload * @return bool */ protected function shouldBroadcast(array $payload) &#123; return isset($payload[0]) &amp;&amp; $payload[0] instanceof ShouldBroadcast &amp;&amp; $this-&gt;broadcastWhen($payload[0]); &#125; /** * Check if event should be broadcasted by condition. * * @param mixed $event * @return bool */ protected function broadcastWhen($event) &#123; return method_exists($event, 'broadcastWhen') ? $event-&gt;broadcastWhen() : true; &#125; /** * Broadcast the given event class. * * @param \Illuminate\Contracts\Broadcasting\ShouldBroadcast $event * @return void */ protected function broadcastEvent($event) &#123; $this-&gt;container-&gt;make(BroadcastFactory::class)-&gt;queue($event); &#125; /** * Get all of the listeners for a given event name. * * @param string $eventName * @return array */ public function getListeners($eventName) &#123; $listeners = $this-&gt;listeners[$eventName] ?? []; $listeners = array_merge( $listeners, $this-&gt;wildcardsCache[$eventName] ?? $this-&gt;getWildcardListeners($eventName) ); return class_exists($eventName, false) ? $this-&gt;addInterfaceListeners($eventName, $listeners) : $listeners; &#125; /** * Get the wildcard listeners for the event. * * @param string $eventName * @return array */ protected function getWildcardListeners($eventName) &#123; $wildcards = []; foreach ($this-&gt;wildcards as $key =&gt; $listeners) &#123; if (Str::is($key, $eventName)) &#123; $wildcards = array_merge($wildcards, $listeners); &#125; &#125; return $this-&gt;wildcardsCache[$eventName] = $wildcards; &#125; /** * Add the listeners for the event's interfaces to the given array. * * @param string $eventName * @param array $listeners * @return array */ protected function addInterfaceListeners($eventName, array $listeners = []) &#123; foreach (class_implements($eventName) as $interface) &#123; if (isset($this-&gt;listeners[$interface])) &#123; foreach ($this-&gt;listeners[$interface] as $names) &#123; $listeners = array_merge($listeners, (array) $names); &#125; &#125; &#125; return $listeners; &#125; /** * Register an event listener with the dispatcher. * * @param \Closure|string $listener * @param bool $wildcard * @return \Closure */ public function makeListener($listener, $wildcard = false) &#123; if (is_string($listener)) &#123; return $this-&gt;createClassListener($listener, $wildcard); &#125; if (is_array($listener) &amp;&amp; isset($listener[0]) &amp;&amp; is_string($listener[0])) &#123; return $this-&gt;createClassListener($listener, $wildcard); &#125; return function ($event, $payload) use ($listener, $wildcard) &#123; if ($wildcard) &#123; return $listener($event, $payload); &#125; return $listener(...array_values($payload)); &#125;; &#125; /** * Create a class based listener using the IoC container. * * @param string $listener * @param bool $wildcard * @return \Closure */ public function createClassListener($listener, $wildcard = false) &#123; return function ($event, $payload) use ($listener, $wildcard) &#123; if ($wildcard) &#123; return call_user_func($this-&gt;createClassCallable($listener), $event, $payload); &#125; return call_user_func_array( $this-&gt;createClassCallable($listener), $payload ); &#125;; &#125; /** * Create the class based event callable. * * @param array|string $listener * @return callable */ protected function createClassCallable($listener) &#123; [$class, $method] = is_array($listener) ? $listener : $this-&gt;parseClassCallable($listener); if ($this-&gt;handlerShouldBeQueued($class)) &#123; return $this-&gt;createQueuedHandlerCallable($class, $method); &#125; return [$this-&gt;container-&gt;make($class), $method]; &#125; /** * Parse the class listener into class and method. * * @param string $listener * @return array */ protected function parseClassCallable($listener) &#123; return Str::parseCallback($listener, 'handle'); &#125; /** * Determine if the event handler class should be queued. * * @param string $class * @return bool */ protected function handlerShouldBeQueued($class) &#123; try &#123; return (new ReflectionClass($class))-&gt;implementsInterface( ShouldQueue::class ); &#125; catch (Exception $e) &#123; return false; &#125; &#125; /** * Create a callable for putting an event handler on the queue. * * @param string $class * @param string $method * @return \Closure */ protected function createQueuedHandlerCallable($class, $method) &#123; return function () use ($class, $method) &#123; $arguments = array_map(function ($a) &#123; return is_object($a) ? clone $a : $a; &#125;, func_get_args()); if ($this-&gt;handlerWantsToBeQueued($class, $arguments)) &#123; $this-&gt;queueHandler($class, $method, $arguments); &#125; &#125;; &#125; /** * Determine if the event handler wants to be queued. * * @param string $class * @param array $arguments * @return bool */ protected function handlerWantsToBeQueued($class, $arguments) &#123; $instance = $this-&gt;container-&gt;make($class); if (method_exists($instance, 'shouldQueue')) &#123; return $instance-&gt;shouldQueue($arguments[0]); &#125; return true; &#125; /** * Queue the handler class. * * @param string $class * @param string $method * @param array $arguments * @return void */ protected function queueHandler($class, $method, $arguments) &#123; [$listener, $job] = $this-&gt;createListenerAndJob($class, $method, $arguments); $connection = $this-&gt;resolveQueue()-&gt;connection( $listener-&gt;connection ?? null ); $queue = method_exists($listener, 'viaQueue') ? $listener-&gt;viaQueue() : $listener-&gt;queue ?? null; isset($listener-&gt;delay) ? $connection-&gt;laterOn($queue, $listener-&gt;delay, $job) : $connection-&gt;pushOn($queue, $job); &#125; /** * Create the listener and job for a queued listener. * * @param string $class * @param string $method * @param array $arguments * @return array */ protected function createListenerAndJob($class, $method, $arguments) &#123; $listener = (new ReflectionClass($class))-&gt;newInstanceWithoutConstructor(); return [$listener, $this-&gt;propagateListenerOptions( $listener, new CallQueuedListener($class, $method, $arguments) )]; &#125; /** * Propagate listener options to the job. * * @param mixed $listener * @param mixed $job * @return mixed */ protected function propagateListenerOptions($listener, $job) &#123; return tap($job, function ($job) use ($listener) &#123; $job-&gt;tries = $listener-&gt;tries ?? null; $job-&gt;retryAfter = method_exists($listener, 'retryAfter') ? $listener-&gt;retryAfter() : ($listener-&gt;retryAfter ?? null); $job-&gt;timeout = $listener-&gt;timeout ?? null; $job-&gt;timeoutAt = method_exists($listener, 'retryUntil') ? $listener-&gt;retryUntil() : null; &#125;); &#125; /** * Remove a set of listeners from the dispatcher. * * @param string $event * @return void */ public function forget($event) &#123; if (Str::contains($event, '*')) &#123; unset($this-&gt;wildcards[$event]); &#125; else &#123; unset($this-&gt;listeners[$event]); &#125; foreach ($this-&gt;wildcardsCache as $key =&gt; $listeners) &#123; if (Str::is($event, $key)) &#123; unset($this-&gt;wildcardsCache[$key]); &#125; &#125; &#125; /** * Forget all of the pushed listeners. * * @return void */ public function forgetPushed() &#123; foreach ($this-&gt;listeners as $key =&gt; $value) &#123; if (Str::endsWith($key, '_pushed')) &#123; $this-&gt;forget($key); &#125; &#125; &#125; /** * Get the queue implementation from the resolver. * * @return \Illuminate\Contracts\Queue\Queue */ protected function resolveQueue() &#123; return call_user_func($this-&gt;queueResolver); &#125; /** * Set the queue resolver implementation. * * @param callable $resolver * @return $this */ public function setQueueResolver(callable $resolver) &#123; $this-&gt;queueResolver = $resolver; return $this; &#125;&#125; Illuminate\Events\EventServiceProvider.php 1234567891011121314151617181920212223&lt;?phpnamespace Illuminate\Events;use Illuminate\Contracts\Queue\Factory as QueueFactoryContract;use Illuminate\Support\ServiceProvider;class EventServiceProvider extends ServiceProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton('events', function ($app) &#123; return (new Dispatcher($app))-&gt;setQueueResolver(function () use ($app) &#123; return $app-&gt;make(QueueFactoryContract::class); &#125;); &#125;); &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP实现反转链表]]></title>
    <url>%2F2020%2F04%2F02%2FPHP%E5%AE%9E%E7%8E%B0%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题：]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高性能应用的策略]]></title>
    <url>%2F2020%2F04%2F02%2F%E9%AB%98%E6%80%A7%E8%83%BD%E5%BA%94%E7%94%A8%E7%9A%84%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： Listing 5-1 manual.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;?php$time1 = microtime(true);$memory1 = memory_get_usage();$a_string = (function () &#123; $output = ''; for ($counter = 0; $counter &lt; 10; $counter++) &#123; usleep(10); $output .= 'a'; &#125;; return $output;&#125;)(); $memory2 = memory_get_usage();$time2 = microtime(true);$b_string = (function () &#123; $output = ''; for ($counter = 0; $counter &lt; 10; $counter++) &#123; usleep(100); $output .= str_repeat('abc',1000); &#125;; return $output;&#125;)(); $memory3 = memory_get_usage();$time3 = microtime(true);echo "1st function : ".($time2-$time1)." secs, ". ($memory2-$memory1)." bytes\n";echo "2nd function : ".($time3-$time2)." secs, ". ($memory3-$memory2)." bytes\n";echo ("Peak memory usage : ". memory_get_peak_usage()." bytes\n"); Listing 5-2 manual-output.txt 1231st function : 0.0007178783416748 secs, 40 bytes2nd function : 0.0016269683837891 secs, 32768 bytesPeak memory usage : 392504 bytes 如您所见，第二个函数比第一个函数需要更长的时间。现在，您知道使脚本变慢的问题是第二个循环，您可以通过删除usleep语句并完全删除该循环并使用str_repeat(‘abc’，1000000)填充字符串来解决此问题。 记忆化如果您已经编程了一段时间，尤其是在Web领域，那么您将遇到缓存的概念。缓存是一个过程，通过该过程，您可以获取“昂贵的”计算结果，存储结果，然后在下次调用该计算时使用存储的结果，而不必再次运行计算本身。昂贵意味着运行时间长，占用大量内存，进行大量外部API调用或出于成本或性能原因而希望将其最小化的任何其他操作。缓存失效是您选择从缓存中删除项目的过程。例如，如果要花费很多精力来生成新闻网站的首页，则需要缓存该页面，这样就不必在每次访问者访问网站时都生成它。但是，一旦发生下一个重大故事，您将要更新首页，并且您不希望访问者点击缓存的版本并获取旧消息，因此您将使缓存“无效”并重新生成页面。如果您曾经参与编写或使用缓存系统，那么毫无疑问，您会根据Phil Karlton的说法熟悉以下说法（或至少了解它的来历）： 在计算机科学中，只有两件困难的事情：命名事物，缓存无效化和一次性错误。 您已经研究了递归如何减少一次性错误，并且没有人希望解决命名问题，那么如何解决缓存失效呢？举起手来，如果你认为函数编程有其窍门。好，金星为您服务！确实如此，诀窍是永远不要使缓存无效。问题解决了！我实际上是认真的。函数式编程提供了一种称为备忘录的技术，该技术植根于纯函数固有的属性中。在较早的理论章节中，您研究了纯函数如何具有参照透明性。给定一组特定的输入参数，纯函数将始终产生相同的返回值，并且（对于该组输入）该函数可以简单地由返回值替换。这听起来应该有点像缓存：对于给定的一组输入（例如，您的新闻报道），您想用其返回值（缓存的输出）替换（运行昂贵）功能。获取纯函数的输出并将其缓存的过程是备忘录，这只是缓存的一种特殊情况。假设您正在记忆一个昂贵的功能，并将结果缓存到磁盘。每次使用不同的参数运行该函数时，您可能会得到不同的结果。您要消除的是在同一参数上多次运行该函数的成本，因为每次（纯）函数都可以保证获得相同的结果。因此，您可以缓存结果，例如，通过创建代表所使用输入参数的哈希并将其用作文件名来存储该运行的返回值。下次运行该函数时，将再次对输入参数进行哈希处理，查看是否存在该名称的缓存文件，如果存在则返回其内容（而不是重新运行昂贵的函数）。到目前为止，这是典型的缓存。但是，如何避免不得不使缓存无效？答案是你不知道。记忆有效地为您做到了。您的功能是纯净的，这意味着没有副作用。因此，如果在您的虚构新闻网站上有新故事中断，则该故事的详细信息将仅通过（纯）功能通过该功能的输入参数创建您的首页。例如，您可能将一系列标题作为一个参数。突然，您的参数的哈希值已更改，因此备注函数将无法在具有该哈希值的磁盘上找到文件，因此将运行完整功能并将新结果缓存到以新哈希值命名的文件中的磁盘上值。回顾一下，作为您唯一的输入是参数，如果所有参数均未更改，则必须可以使用缓存。但是，如果参数已更改，则将没有相应的缓存文件，因此无需使其无效。当然，旧的缓存文件仍然存在，因此当您不小心发布错误地声称这本书是垃圾的故事时，您可以立即将其撤回，该功能将返回使用旧的缓存文件，因为哈希将再次出现匹配参数。到现在为止还挺好。但是，函数式编程并没有止于其优点，哦，不。如果您正在考虑如何编写函数来进行记忆，请停止操作。通常，您不需要。您可以简单地将函数包装在另一个为您自动记住的函数中。这样的包装器函数易于编写，因为您所关心的只是纯函数的输入和输出，而不是其内部的功能。因此，让我们来看一个备忘录的示例。在清单5-3中，您会将纯函数的结果缓存到磁盘。为简便起见，将不纯磁盘功能分成单独的功能，而不是煮一些IO monad，但是您当然可以根据需要这样做。 Listing 5-3 memoize.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106&lt;?php# We're going to cache our results on disk, so let's# define a directory and file prefixdefine('CACHE_PREFIX', sys_get_temp_dir().'/memo-cache-');# This is a helper function to read a cached file# from disk. I've broken it out as a separate function# as it is necessarily impure. You can replace it# with an IO monad or similar in production if you wish$get_value = function($hash) &#123; # return null if the file doesn't exist if (!file_exists(CACHE_PREFIX.$hash)) &#123; return null; &#125; # read the file into $value $value = file_get_contents(CACHE_PREFIX.$hash); # return null if the file exists but couldn't be read if ($value === false) &#123; return null; &#125; # return our value if all is good return $value;&#125;;# Likewise, this is an impure helper function to write# the value to a cache file.$store_value = function($hash, $value) &#123; if (file_put_contents(CACHE_PREFIX.$hash, $value) === false) &#123; $value = null; &#125; # return the value that was stored, or null if the # storage failed return $value;&#125;;# Finally, this is our actual memoization function.# It returns a closure which is a "memoized" version# of the function you call it on, i.e. a version# of your function which automatically caches return# values and automatically uses those cached values# without further coding from you.# $func is the function (closure or other callable) that# you want to memoize$memoize = function($func) use ($get_value, $store_value)&#123; # We're returning a memoized function return function() use ($func, $get_value, $store_value) &#123; # Get the parameters you (the end user) call # your memoized function with $params = func_get_args(); # Get a unique hash of those parameters, to # use as our cache's key. We needs to convert # the params array to a string first, we use # json_encode rather than serialize here as # it is a lot faster in most cases $hash = sha1( json_encode( $params ) ); # Check the cache for any return value that # has already been cached for that particular # set of input parameters (as identified by # its hash) $value = $get_value($hash); # If there was no pre-cached version available, # $value will be null. We check this with the ?? # null coalescing operator, returning either : # a) the cached $value if it's not null, or # b) the results of actually calling the user # function. Note that we wrap the call in the # $store_value function to cache the results, # and $store_value passes the value back # through as its result and so it is also # returned to the user in this case return $value ?? $store_value( $hash, call_user_func_array($func, $params) ); &#125;;&#125;; 首先，您的备忘录功能通过将输入参数编码为JSON来使输入参数具有唯一的字符串表示形式。 例如，如果您想知道为什么不简单使用implode（“ |”，$ params），请考虑以下两个函数调用： 12func("Hello","|There");func("Hello|","There"); 这将导致两者实际上都被编码为Hello || There，因此实际上被视为相同的一组参数。如果可以保证，可以使用带有粘合字符的爆破该字符永远不会出现在您的参数中，但是通常以防万一，最好使用防御性代码并使用适当的序列化功能。您可以使用PHP的serialize（）函数代替json_encode因为在某些工作负载下它可能会更快。两者都具有一些极端的情况，您可能需要在选择一种情况之前就熟悉一下这些情况，例如，serialize（）无法使用某些类型的对象。有关这两者的更多信息，请参见PHP手册。一旦有了输入的字符串表示形式，就需要将其转换为另一个适合用作文件名的字符串。您的JSON字符串可能包含对文件无效的字符名称，因此您将为其创建一个SHA1哈希。 MD5散列的创建速度会稍快一些，但发生散列冲突的可能性更大（对于两个不同的输入会生成相同的散列）。即使SHA1也会发生冲突，尽管风险通常很小。如果您绝对无法解决冲突，那么您将需要编写一些代码来解析序列化的字符串并替换无效字符，依此类推，以一致的方式确保对缓存介质（文件例如，写入磁盘的名称长度）。现在，您有了哈希（或其他描述输入参数的独特方式）。然后，您尝试从缓存中加载以哈希为名称的文件内容。如果您无法读取它（通常是因为它不存在，因为这是您第一次使用这些参数调用），则可以使用call_user_func_array（）运行纯函数，获取其返回值并创建缓存文件，最后返回所获取的值你返回值。如果您可以读取文件，则只需返回内容作为返回值，然后跳过执行该函数。您会注意到这里没有使用任何形式的严格输入。如果您从pure函数返回的值是一个int（例如），那么当您第一次运行pure函数时，您会将其写入磁盘并将int返回给调用者。但是，在随后的运行中，您将缓存文件的内容作为字符串获取并返回，因此返回值为字符串。如果在应用程序中键入很重要，则始终可以将值序列化到磁盘，并在读回时再次将其反序列化。现在让我们看一个如何实际使用此备忘功能的示例。您将使用另一个经典的示例任务，即一种算法来生成斐波那契数列。我正在使用此功能，因为它是一个简短易懂的功能，而且恰好是递归的。记忆可用于任何功能，无论是否具有递归功能，但它通常特别有用，因为如前所述，递归功能通常会占用大量资源。如果您不熟悉斐波那契数列，它是一系列数字，其中前两个（如果从零开始，则为三个）之后的每个数字都是前两个数字的和，因此： 10, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946 and so on… 该算法采用整数n并计算序列中的第n个数字。因此，$fibonacci（7）将返回13（13是上一个序列中的第7个数字，从0开始）。您将创建两个函数：该函数的标准版本和包装在早期$ memoize函数中的一个版本。 通常，您将只创建一个函数并将其包装在$ memoize中。 但是，正如我想演示一个递归调用该记忆版本的递归版本（并将其与未记忆形式进行对比），您将在此处创建两个。 而且对于现代人来说，斐波那契并不是一项特别繁重的任务PC，您将以usleep语句的形式添加一些人为的“费用”，以使每次计算花费的时间更长。 这将说明备忘录对真正长时间运行的功能的影响。 参见清单5-4和清单5-5。 Listing 5-4 memo_example.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php# Get our memoize function and helpersrequire('memoize.php');# Define a plain old recursive fibonacci function$fibonacci = function ($n) use (&amp;$fibonacci) &#123; usleep(100000); # make this time-expensive! return ($n &lt; 2) ? $n : $fibonacci($n - 1) + $fibonacci($n - 2); &#125;;# Define the same fibonacci function again in exactly the# same way (except for the name), but this time wrap the# function body in a call to $memoize to get a memoized version$memo_fibonacci = $memoize( function ($n) use (&amp;$memo_fibonacci) &#123; usleep(100000); return ($n &lt; 2) ? $n : $memo_fibonacci($n - 1) + $memo_fibonacci($n - 2); &#125;);# Let's define a timer function, to time a run of a function,# and return the parameters, results and timings.$timer = function($func, $params) &#123; $start_time = microtime(true); $results = call_user_func_array($func, $params); $time_taken = round(microtime(true) - $start_time, 2); return [ "Param" =&gt; implode($params), "Result" =&gt; $results, "Time" =&gt; $time_taken ];&#125;;# And now let's do a set of runs of both our# ordinary function and it's memoized sister.# I've added an extra * parameter to the# non-memoized runs so that you can spot them# easier in the output (the '*' isn't used# by the fibonacci functions, it's just passed# through to the output of the timer function)print_r( $timer( $fibonacci, [6, '*'] ) );print_r( $timer( $memo_fibonacci, [6] ) );print_r( $timer( $fibonacci, [6, '*'] ) );print_r( $timer( $memo_fibonacci, [6] ) );print_r( $timer( $memo_fibonacci, [10] ) );print_r( $timer( $memo_fibonacci, [11] ) );print_r( $timer( $memo_fibonacci, [8] ) ); Listing 5-5. memo_example-output.txt 123456789101112131415161718192021222324252627282930313233343536373839404142Array( [Param] =&gt; 6* [Result] =&gt; 8 [Time] =&gt; 2.5)Array( [Param] =&gt; 6 [Result] =&gt; 8 [Time] =&gt; 0.7)Array( [Param] =&gt; 6* [Result] =&gt; 8 [Time] =&gt; 2.5)Array( [Param] =&gt; 6 [Result] =&gt; 8 [Time] =&gt; 0)Array( [Param] =&gt; 10 [Result] =&gt; 55 [Time] =&gt; 0.4)Array( [Param] =&gt; 11 [Result] =&gt; 89 [Time] =&gt; 0.1)Array( [Param] =&gt; 8 [Result] =&gt; 21 [Time] =&gt; 0) 如果查看清单5-5中的第一次运行的输出，您会看到标准函数需要2.5秒才能计算出第六个斐波那契数，而备忘录版本仅需0.7秒。当然，它们应该在第一轮操作相同，因为尚未缓存任何内容。好吧，由于您的函数是递归的，因此实际上您每次计算都会多次调用该函数，并且由于已记忆的版本会使用相同的参数多次调用自身，因此将使用缓存。第三次运行表明，下次使用参数6再次调用标准函数仍需要2.5秒，这很明显，因为它不进行缓存。但是，在6上调用记忆版本需要0秒（向下舍入！），因为计算中的每个递归调用都将命中缓存。接下来计算第十个数字，您只需花费0.4秒。这比计算第6个数字要快，因为它们共享一些步骤（每个人都需要计算第1、2、3等个数字），这些步骤已经被缓存了，而第10个数字只需要实际计算第7、8、9和最后10个数字。下一轮进一步展示了这一点。现在，计算第11个数字仅需0.1秒（因为它只有一个未缓存的函数调用），而最后一次计算第8个数字的运行时间为0秒，因为它是从生成第10个数字起已经在缓存中。如果您第二次调用该脚本，则会发现所有使用备注功能的运行都在0秒内完成，因为您的缓存已经存在所有需要的值，因为您已至少一次生成了所有这些值。除非有人改变了数学的基本原理，否则您可以永久保留高速缓存，因为高速缓存的结果对于给定的输入始终是正确的。如果您想知道高速缓存的外观，则运行/ tmp / memo-cache- *可以得到清单5-6的输出。如您所见，有12个文件，这很有意义，因为您计算了第11个斐波那契数（从0开始计数），因此使用12个不同的参数调用了记忆功能。 Listing 5-6. cache_files.txt 123456789101112131415161718192021222324252627282930313233343536::::::::::::::/tmp/memo-cache-10ae24979c5028fa873651bca338152dc04842455::::::::::::::/tmp/memo-cache-1184f5b8d4b6dd08709cf1513f26744167065e0d0::::::::::::::/tmp/memo-cache-1fb0856518ee0490ff78e43d1b6dae12ad6ec68621::::::::::::::/tmp/memo-cache-2499831338ca5dc8c44f3d063e076799bea9bdff1::::::::::::::/tmp/memo-cache-3ad009a144b1e8e065a75ca775c76b2fc2e5ff7689::::::::::::::/tmp/memo-cache-4a0a63ce33cc030f270c607ea7bf90a6717572bb8::::::::::::::/tmp/memo-cache-7a60554107407bfe358bedce2bfcb95c90a8ea0d34::::::::::::::/tmp/memo-cache-8f4e345e7cd51e4e633816f5a52a47df465da1893::::::::::::::/tmp/memo-cache-bd703dc0b11593277a5a82dd893f2880b8d0f32a13::::::::::::::/tmp/memo-cache-e9310b0c165be166c43d717718981dd6c9379fbe55::::::::::::::/tmp/memo-cache-f1e31df9806ce94c5bdbbfff9608324930f4d3f12::::::::::::::/tmp/memo-cache-f629ae44b7b3dcfed444d363e626edf411ec69a81 在这些示例中，您缓存到了磁盘，这使您可以创建持久的缓存，该缓存可以在重新启动后幸存下来并由多个进程使用。 但是，有时磁盘速度太慢，并且如果您的函数参数经常更改，您可能只想在单个脚本运行期间进行缓存。 另一种方法是在内存中缓存，实际上PHP提供了一种创建变量的方法，这些变量的作用类似于全局变量，但仅限于给定的函数，非常适合在脚本的一次运行中进行缓存。 这些称为静态变量，如果您不熟悉它们，清单5-7（和清单5-8）是静态变量（$ sta）与全局参数（$ glo），参数（$ 参数）和普通函数作用域（$ nor）变量。 Listing 5-7. static.php 123456789101112131415161718192021222324&lt;?php$my_func = function ($par) &#123; static $sta; global $glo; var_dump( "static : ". $sta += 1 ); var_dump( "global : ". $glo += 1 ); var_dump( "param : ". $par += 1 ); var_dump( "normal : ". $nor += 1 ); return $sta;&#125;;while ( $my_func(1) &lt; 5) &#123; echo "-----\n"; &#125;;echo "*****\n";var_dump( "static : ". $sta );var_dump( "global : ". $glo );var_dump( "param : ". $par );var_dump( "normal : ". $nor ); Listing 5-8. static-output.txt 1234567891011121314151617181920212223242526272829string(10) &quot;static : 1&quot;string(10) &quot;global : 1&quot;string(10) &quot;param : 2&quot;string(10) &quot;normal : 1&quot;-----string(10) &quot;static : 2&quot;string(10) &quot;global : 2&quot;string(10) &quot;param : 2&quot;string(10) &quot;normal : 1&quot;-----string(10) &quot;static : 3&quot;string(10) &quot;global : 3&quot;string(10) &quot;param : 2&quot;string(10) &quot;normal : 1&quot;-----string(10) &quot;static : 4&quot;string(10) &quot;global : 4&quot;string(10) &quot;param : 2&quot;string(10) &quot;normal : 1&quot;-----string(10) &quot;static : 5&quot;string(10) &quot;global : 5&quot;string(10) &quot;param : 2&quot;string(10) &quot;normal : 1&quot;*****string(9) &quot;static : &quot;string(10) &quot;global : 5&quot;string(9) &quot;param : &quot;string(9) &quot;normal : &quot; 如您所见，即使每次都使用相同的参数（1）调用my_func，每次$sta的值也不同。 因此，尽管您无法从函数外部的任何范围访问它，但通常仍将其视为“副作用”，因为对于函数的任何特定调用，您都无法确定其处于何种状态（在这种情况下， 不知道该函数已被调用多少次）。 那么，如何在功能程序中使用静态变量？ 答案是，小心。 让我们看一个示例（参见清单5-9）。 您将创建备忘录功能的一个版本，该版本使用静态数组来保存缓存而不是写入磁盘。 Listing 5-9. memoize-mem.php 12345678910111213141516&lt;?php$memoize = function($func)&#123; return function() use ($func) &#123; static $cache; $params = func_get_args(); $hash = sha1( json_encode( $params ) ); $cache["$hash"] = $cache["$hash"] ?? call_user_func_array($func, $params); return $cache["$hash"]; &#125;;&#125;; 因此，您放入$ cache数组中的所有内容，然后再从中读取，完全取决于您使用（通过散列）调用函数的参数，而放入其中的则是该函数的值。您对static变量的使用实际上是参照透明的，因此在这种情况下，您不会产生任何潜在的副作用。 如果调用与以前相同的memoize-example.php脚本，但改用此基于内存的备忘录功能，则会得到清单5-10的输出。 Listing 5-10. memo_mem_example-output.txt 123456789101112131415161718192021222324252627282930313233343536373839404142Array( [Param] =&gt; 6* [Result] =&gt; 8 [Time] =&gt; 2.51)Array( [Param] =&gt; 6 [Result] =&gt; 8 [Time] =&gt; 0.7)Array( [Param] =&gt; 6* [Result] =&gt; 8 [Time] =&gt; 2.51)Array( [Param] =&gt; 6 [Result] =&gt; 8 [Time] =&gt; 0)Array( [Param] =&gt; 10 [Result] =&gt; 55 [Time] =&gt; 0.4)Array( [Param] =&gt; 11 [Result] =&gt; 89 [Time] =&gt; 0.1)Array( [Param] =&gt; 8 [Result] =&gt; 21 [Time] =&gt; 0) 如您所见，它的输出与基于文件的示例完全相同。实际上，它的运行速度要快一点，因为您没有在进行磁盘I / O，但是在这里四舍五入到最接近的0.1秒。与基于磁盘的示例相比，唯一的不同之处在于，如果您第二次运行该脚本，您将再次获得此输出（而不是用于记忆调用的全零），因为用于缓存的静态变量为脚本结束时销毁。除了基于磁盘和基于会话的内存缓存之外，还有一种替代方法是普通的RAM磁盘。在Linux类型的系统上，有一个名为tmpfs的文件系统，该文件系统允许您创建和使用存储在其中的文件。内存而不是磁盘。这些虚拟文件的行为和操作类似于磁盘上的普通文件，因此可以像使用普通“磁盘上”文件一样，允许不同的PHP进程读取和写入文件中的缓存数据。 tmpfs带来的好处是双重的。首先，它很快，其次，一切都是暂时的。因为文件保存在内存中，所以没有机械硬盘可以等待，因此I / O非常快。而且由于它们保留在内存中，因此它们只是临时的，如果您尚未删除它们，则在重新启动后会消失。另一个优点是，它们是普通文件，不是特定于PHP的技术，因此可以根据需要从其他软件进行访问。您可以使用与普通文件和流相同的方式来访问tmpfs文件系统上的文件。它们在内存中的事实对您的PHP脚本是透明的。较早的基于文件的示例将与RAM磁盘完美配合。要在Linux上创建tmpfs文件系统，请首先在磁盘上创建一个目录，用于将存储设备“附加”到文件系统。然后将存储设备安装在该位置并开始使用它。清单5-11中的shell脚本（清单5-12中的输出）给出了安装和卸下tmpfs RAM磁盘的示例。 Listing 5-11. ramdisk.sh 1234567#!/usr/bin/env bashmkdir /tmp/myMemoryDrivesudo mount -t tmpfs /mnt/tmpfs /tmp/myMemoryDrivephp -r "file_put_contents('/tmp/myMemoryDrive/test.txt',\"Hello\n\");"cat /tmp/myMemoryDrive/test.txtsudo umount /mnt/tmpfscat /tmp/myMemoryDrive/test.txt Listing 5-12. ramdisk-output.txt 12Hellocat: /tmp/myMemoryDrive/test.txt: No such file or directory 在清单5-11中，您在/ tmp / myMemoryDrive中创建一个目录来附加存储设备，然后将其安装在该目录中。您可以执行一行PHP来演示如何像创建其他任何文件一样创建内存文件，然后将其编入目录，该文件应输出Hello。最后，您卸载了设备并尝试再次保存文件，但是正如您所期望的，文件已经消失了。它永远不会保存到物理磁盘。您可以使用mount命令挂载tmpfs设备，如您每次引导系统或每次使用它们时所显示的那样，也可以将其添加到fstab文件中，以使其在每次系统引导时自动创建。无论以哪种方式安装它，在关闭或重新启动时，请始终记住它及其中的所有文件都会被破坏。由于tmpfs的运行方式与普通文件系统相同，因此您需要确保设置了相关的文件许可权，以允许所有应用程序对其进行访问（或阻止那些不应该使用能够干预）。还请记住，如果系统内存不足，则可能会发生内存交换到磁盘的情况，因此在这种情况下，数据可能会暂时碰到硬盘，在某些情况下，此后可以从磁盘恢复。请始终考虑您选择的任何缓存系统的安全性。如果出于性能原因考虑使用tmpfs代替物理硬盘，则还应记住，现代操作系统（包括现代Linux）可以使用主动内存缓存来访问磁盘。这意味着操作系统透明地将经常读取的基于磁盘的文件缓存到动态分配的未使用的内存中（通常您甚至不知道）以提高明显的物理磁盘性能。在这些情况下，当您从tmpfs内存磁盘读取某些文件并遍历目录树时，可能不会看到预期的性能改进。写磁盘和访问较少的文件通常不会被缓存，因此在这种情况下，tmpfs仍然可以为您带来预期的收益。在Windows中，没有内置的方法来创建基于内存的文件系统。存在用于创建RAM磁盘的各种第三方软件，但尚未标准化，并且大多数应用程序需要GUI才能在每个系统上手动设置磁盘。接下来列出的Wikipedia页面为您提供了更多指示，以供您探索是否仍然感兴趣。 记忆化的缺点如您所见，通过记忆进行缓存通常是一件好事，但正如我母亲一直说的：“您可以拥有太多的好东西。”在默认情况下，开始记忆所有功能的诱惑可能会蔓延开来，但与所有其他功能一样，首先要考虑一些折衷。记住的函数会带来一些开销，用于每次运行时检查缓存版本是否可用以及获取或存储生成的任何缓存版本。如果您要记住要加快脚本的执行速度，并且您的缓存与前面的主要示例一样位于磁盘上，那么磁盘I / O会花费额外的时间（与内存存储或实际上许多仅用于计算的功能相比，这通常很慢）可能比运行中低复杂度功能所需的时间更长。当然，如果您要缓存以优化低内存系统，减少对外部API的调用次数或将其他与时间无关的资源使用量降到最低，那么这可能是可以接受的折衷方案。使用备注进行缓存时，要考虑的另一个考虑因素是某些数据的短暂性是否会限制您从中获得的成本价值。例如，如果您的功能的参数之一是客户ID，但您的客户很少对您的网上商店进行多次访问/购买，则对该功能的任何缓存都可能仅在那一次访问期间受益。与更一般的缓存情况相比，使用纯函数记忆化的好处之一是，您不必担心缓存失效，因为您的缓存永远不会无效。但是，这导致了诱惑，便简单地忘记了缓存而将其保留，从编程的角度来看这是完全可以的。您的代码将继续以正确的输出正常运行。但是，您的系统管理员可能很快就会出现并开始询问您是否真的需要昂贵的SAN上的所有磁盘空间。磁盘空间的成本可能超过脚本的有限加速。在这些情况下，您有三个选择。•删除备忘录：接受一些运行时间更长的脚本。•缓存到磁盘上的内存或每个会话文件，而不是长期磁盘上：这样可以在一次访问中加快多个呼叫的速度，但会暂时占用一些内存。•执行某种形式的缓存逐出：删除已存在一个月以上的缓存文件。 懒惰评估懒惰评估是一种艺术，它仅进行最少的工作即可获得所需的结果。PHP程序员应该自然而然地做到这一点！ 考虑以下伪代码： 1if ( do_something_easy() OR do_something_hard() ) &#123; return &#125; 该代码说明“如果do_something_easy（）或do_something_hard（）为true，则返回。”因此，要确定是否应返回，可以调用两个函数，如果其中一个返回true，则知道要返回。但是，请考虑一下，如果do_something_easy（）返回true，则do_something_hard（）返回什么都无所谓，因为无论如何您都将返回。因此，在运行do_something_easy（）之后，实际上没有必要运行第二个函数调用，并且您可以节省这样做的开销。相反，如果返回的是false，则需要运行第二个，但是，与第一个同时自动调用两者的情况相比，您的情况不会更糟。这称为惰性评估；您只评估需要的内容，而没有声明更多。在评估布尔表达式时，PHP使用一种称为短路评估的惰性评估类型，这取决于逻辑运算符的先例。因此，如果要从这样的表达式中调用函数以确保您不会使短路短路，那么除了注意手册中的以下几页之外，您无需执行其他任何操作！ 迭代器但是，您可以采用这种惰性求值的概念，并将其应用到您的函数中以加快执行速度。在上一章中介绍的功能组合示例中，通常会获取一个数据数组，对其进行处理，将该数组传递给下一个函数，然后执行其他操作，等等。即使实际上不需要数组中的所有数据，也通常将其传递给整个数组，然后将函数和转换应用于整个数组。您看过array_filter，它确实使用某些过滤器函数将数组的大小缩减为某些元素，但是即使那样，过滤器函数也将应用于数组的每个单个元素。如果只需要前10个匹配元素并且有100个匹配元素，那么您就浪费了时间，在找到前10个匹配元素之后应用filter函数，还需要执行其他步骤，例如使用array_slice将结果100缩减为10 。PHP有一个称为生成器的有用语言工具，它在PHP 5.5中引入。生成器允许您创建函数，该函数返回有点像数组的东西，但是其数据是在访问元素时“实时”生成的。您可以使用生成器来创建仅执行最少必需工作的惰性函数。将生成器功能链接在一起时，执行将向后执行。考虑如下三个标准函数的伪链： array_filter some_function(); array_filter another_function(); array_slice 0, 10; 首先将对整个数组进行过滤，然后对整个结果再次进行过滤，然后将第二个结果减少到十个项目。 在基于生成器的系统中，您可以编写如下所示的链： lazy_filter some_function(); lazy_filter another_function(); lazy_slice 0, 10; 它看起来是一样的，但是执行时，操作实际上是从lazy_slice开始，它会拉动整个链中的值。 slice函数从第二个过滤器请求值，直到有十个为止。每次第二个过滤器收到一个值请求时，它都会向第一个过滤器请求值，并向它们应用another_function（）直到匹配为止。并且，每当第一个过滤器获取一个值请求时，它都会从数组中获取值，并对它们应用some_function（）直到获得匹配。因此，当lazy_slice获得其十个值时，这两个lazy_filter函数仅足够多次调用了它们（可能昂贵的）过滤函数，以生成那十个，而不是（不必要）生成原始数据的所有项。稍后，您将看到一个发电机的基本示例。但是在您这样做之前，让我们创建一个函数以重复调用一个函数。当您查看时间时，同一台PC上无关的任务可能会暂时降低脚本的运行速度。多次运行脚本或函数可以限制这种暂时性的延迟对基准计时编号的影响。参见清单5-13。 Listing 5-13 repeat.php 12345678910111213&lt;?php// 为了获得基准测试结果，最好重复运行该函数，以最大程度地降低任何外部变慢的影响。// 以下函数仅使用参数$ args调用函数$func $n次，并返回上一次调用的返回值。$repeat = function ($func, $n, ...$args) &#123; for ($i=0; $i &lt; $n; $i++) &#123; $result = $func(...$args); &#125; return $result;&#125;; 现在，让我们看一个生成器的简单示例（请参见清单5-14，输出如清单5-15所示）。生成器是具有yield语句而不是return语句的函数。 与普通函数在返回时会丢失其状态不同，yield的函数会保持其状态直到下一次调用。PHP具有一个名为range（）的本地函数，该函数返回从$ start到$ end的数字数组，并带有可选的$ step值。 您将创建一个生成器版本gen_range（），该版本会产生相同的输出，但会产生延迟。 您将使用相同的参数调用这两者，以生成介于1到1000万之间的第四个数字，然后在得到一个可被123整除的数字时退出运行函数。 Listing 5-14 generators.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php# Get our repeat functionrequire('repeat.php');# PHP's native function range() takes a# $start int, $end in and $step value, and# returns an array of ints from $start to $end# stepping up by $step each time. We'll create# a generator version that takes the same# parameters and does the same task, called gen_range()function gen_range($start, $end, $step) &#123; for ($i = $start; $i &lt;= $end; $i += $step) &#123; # yield turns this function into a generator yield $i; &#125;&#125;;# We'll create a function to run either range() or# gen_range() (as specified in $func) with the# same paramters, and to iterate through the# returned values until we find a number exactly# divisible by 123 (which in this case is 369)$run = function ($func) &#123; # Get a range from 1 to ten million in steps of 4, # so 1,4,9,13,18,...,9999989,9999993,9999997 foreach ( $func(1, 10000000, 4) as $n ) &#123; if ($n % 123 == 0) &#123; # exit the function once we've found one, reporting # back the memory in use (as it will be freed once # we have returned). return memory_get_usage(); &#125;; &#125;;&#125;;# A function to get the time/memory use for the runs$profile = function ($func, ...$args) &#123; $start = [ "mem" =&gt; memory_get_usage(), "time" =&gt; microtime(true) ]; $end = [ "mem" =&gt; $func(...$args), "time" =&gt; microtime(true) ]; return [ "Memory" =&gt; $end["mem"] - $start["mem"], "Time" =&gt; $end["time"] - $start["time"] ];&#125;;# Finally let's run each of range() and gen_range() 100 times,# and output the time taken for each and memory usedEcho "*** range() ***\n";print_r ( $profile($repeat, $run, 100, 'range') );Echo "*** gen_range() ***\n";print_r ( $profile($repeat, $run, 100, 'gen_range') ); Listing 5-15. generators-output.txt 123456789101112*** range() ***Array( [Memory] =&gt; 134222280 [Time] =&gt; 8.9564578533173)*** gen_range() ***Array( [Memory] =&gt; 4952 [Time] =&gt; 0.0016660690307617) 因此，如您所见，惰性版本使用的内存量比正常的range（）函数少得多。这是因为range（）必须在开始迭代之前生成值的整个数组通过foreach遍历它们，而gen_range（）仅保存序列中的当前值。 gen_range（）所花费的时间也少得多，因为一旦您达到369，就完成了，而range（）必须甚至在开始之前就生成序列中的每个单个值。注意，使用的内存是$ run函数返回时返回的值memory_get_usage，这对于您的函数来说可能只是每个函数中使用的最大内存量。因此，这就是生成器的外观。现在，让我们看一下如何在功能组合中使用它们，以最大程度地减少功能链要做的工作量。您将创建一个脚本，该脚本需要莎士比亚的名副其实的完整著作（作为纯文本文件），获得提及英雄一词的行，并获得任何长度超过60个字符的行，然后返回前三个匹配项。清单5-16展示了如何以一种非延迟的方式进行操作，清单5-17中显示了输出。 Listing 5-16. filter.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192&lt;?php# Borrow some functions from Chapter 3,# and our repeat functionrequire('../Chapter 3/compose.php');require('../Chapter 3/partial_generator.php');require('repeat.php');# A helper function to fix parameters from the right,# as we'll otherwise call partial(reverse()) a lot below.$partial_right = function ($func, ...$params) &#123; return partial(reverse($func), ...$params);&#125;;# Get the start time, to see how long the script takes$start_time = microtime(true);# A function to return true if $word is in $str# (not comprehensive, but matches a word bounded# by non-A-Z chars, so matches "hero" but not "heroes")$match_word = function($word, $str) &#123; return preg_match("/[^a-z]$&#123;word&#125;[^a-z]/i", $str);&#125;;# A function to return true if $str is longer than $len chars$longer_than = function($len, $str) &#123; return strlen($str) &gt; $len;&#125;;# A partial function, fixing hero as the word to search for$match_hero = partial($match_word, 'hero');# Another partial function, picking out strings longer than 60 chars$over_sixty = partial($longer_than, 60);# A partial function which uses array_filter to apply $match_hero# to all elements of an array and return only those with 'hero' in$filter_hero = $partial_right('array_filter', $match_hero );# Similarly, we'll filter an array with the $over_sixty function$filter_sixty = $partial_right('array_filter', $over_sixty );# A function to grab the first 3 elements from an array$first_three = $partial_right('array_slice', 3, 0);# Let's now compose the function above to create a# function which grabs the first three long# sentences mentioning hero.$three_long_heros = compose( $filter_hero, $filter_sixty, $first_three );# Finally, let's actually call our composed function 100 times# on the contents of all_shakespeare.txt# Note that calling file() as a parameter means that it is# only evaluated once (and not 100 times), so the time for disk# IO won't be a major element of our timings$result = $repeat( $three_long_heros, file('all_shakespeare.txt'), 100 );# Print out the result of the last call (which should be the# same as all of the rest, as all of our composed functions are# pure and are called on exactly the same input parameter)print_r($result);# and the time takenecho 'Time taken : '.(microtime(true) - $start_time); Listing 5-17. filter-output.txt 12345678Array([0] =&gt; Enter DON PEDRO, DON JOHN, LEONATO, FRIAR FRANCIS, CLAUDIO, BENEDICK, HERO,BEATRICE, and Attendants[1] =&gt; Sweet Hero! She is wronged, she is slandered, she is undone.[2] =&gt; Think you in your soul the Count Claudio hath wronged Hero?)Time taken : 6.2691030502319 这为您提供了三行所需的信息，在我的薄弱笔记本电脑上运行100次大约需要6秒钟。 清单5-18懒惰地重写了此脚本，输出如清单5-19所示。 Listing 5-18. lazy_filter.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110&lt;?php# Again we'll borrow some functions from Chapter 3,# and our repeat functionrequire('../Chapter 3/compose.php');require('../Chapter 3/partial_generator.php');require('repeat.php');# and start timing$start_time = microtime(true);# We'll now define a lazy version of array_filter, using# a generator (note the yield statement)$lazy_filter = function ($func, $array) &#123;# Loop through the array foreach ($array as $item) &#123; # Call the function on the array item, and # if it evaluates to true, return the item if ( $func($item) ) &#123; yield $item; &#125; &#125;;&#125;;# The following functions are exactly the same as# in the non-lazy filter.php example$match_word = function($word, $str) &#123; return preg_match("/[^a-z]$&#123;word&#125;[^a-z]/i", $str);&#125;;$longer_than = function($len, $str) &#123; return strlen($str) &gt; $len;&#125;;$match_hero = partial($match_word, 'hero');$over_sixty = partial($longer_than, 60);# Our $filter_hero function is almost the same,# but note that it calls $lazy_filter instead of# array_filter (and it uses partial() rather than# $partial_right, as I've implemented $lazy_filter# with the parameters in the opposite order to# array_filter.$filter_hero = partial($lazy_filter, $match_hero );# Again $filter_sixty uses $lazy_filter rather than array_filter$filter_sixty = partial($lazy_filter, $over_sixty );# As the output from filter_sixty will be a generator object# rather than an array, we can't use array_slice to# get the first three items (as data doesn't exist in a# generator until you call for it). Instead, we'll create# a $gen_slice function which calls the generator $n times# and returns the $n returned values as an array. We'll take# advantage of that fact that a generator is an iterable object,# and so has current() and next() methods to get each value.# We'll practice our recursion, rather than just using# a for loop!$gen_slice = function ($n, $output = [], $generator) use (&amp;$gen_slice) &#123; $output[] = $generator-&gt;current(); $generator-&gt;next(); if ($n &gt; 1) &#123; $output = $gen_slice(--$n, $output, $generator); &#125;return $output;&#125;;# $first_three uses $gen_slice rather than array_slice$first_three = partial($gen_slice, 3, []);# We'll compose them together, repeatedly call them# and output the results using exactly the same# code as in the non-lazy version$three_long_heros = compose( $filter_hero, $filter_sixty, $first_three );$result = $repeat( $three_long_heros, file('all_shakespeare.txt'), 100 );print_r($result);echo 'Time taken : '.(microtime(true) - $start_time); Listing 5-19. lazy_filter-output.txt 12345678Array([0] =&gt; Enter DON PEDRO, DON JOHN, LEONATO, FRIAR FRANCIS, CLAUDIO, BENEDICK, HERO,BEATRICE, and Attendants[1] =&gt; Sweet Hero! She is wronged, she is slandered, she is undone.[2] =&gt; Think you in your soul the Count Claudio hath wronged Hero?)Time taken : 2.1842160224915 您得到相同的结果，但仅需2秒钟，大约快了三倍。 那么，这是如何工作的呢？ 好吧，您的lazy_filter不会返回任何数据，而是“产生”一个生成器对象。 该对象实现了PHP的迭代器接口，因此诸如foreach之类的功能会自动知道如何使用它，就好像它是任何其他可迭代的数据类型一样。 当您使用gen_slice（）函数时，这一点变得尤为明显。该函数不是假装您正在使用数组，而是仅调用生成器对象的current（）和next（）方法来请求下三个数据。 如果您不熟悉迭代器，则PHP手册的以下部分将对您进行分类。 顺便说一句，当我编写以前的脚本时，我首先使用compose语句命名了它链接在一起的三个功能，然后向后进行工作以找出实现它们所需的功能。 在进行功能编程时，您经常会发现这种模式。 声明式的性质使其适用于自上而下的程序设计方法。 懒惰评估的缺点生成器很棒，并且惰性评估通常是一个非常有用的工具。 但是，正如您可能期望的那样，值得一提的是可能会有不利之处。 如果再次运行您的generators.php示例，但是这次不是寻找一个可被123整除的数字，而是使用值9999989，清单5-20和清单5-21显示了发生的情况。 Listing 5-20. generators2-output.txt 123456789101112*** range() ***Array( [Memory] =&gt; 134222280 [Time] =&gt; 26.05708694458)*** gen_range() ***Array( [Memory] =&gt; 4952 [Time] =&gt; 41.604923009872) 标准range（）函数需要26秒，但是您的gen_range（）惰性函数几乎将其翻了一番，达到41秒。为什么？好的，发电机中存在固有的开销。寻找一个可以被9999989整除的数字（在这种情况下，它本身就是数字）意味着您必须一直进行直到找到数字序列的末尾为止。但是您必须对序列中的每个数字都调用一个函数（通过foreach），而不是对range（）进行一次函数调用，而且每次函数调用都会产生少量开销。此外，您要调用的函数是由您用PHP编写的，而不是由整个PHP核心开发人员团队使用C编写的，因此，高度优化的代码要少得多。因此，通常会出现一个问题，即与最初进行全面评估相比，生成器的时间效率较低。通常这是最小的，并且在评估过程即将结束时，并且如果您的运行输入值“分散”了，即使其中一些花费的时间比完整的评估方法花费的时间更长，通常也可以总体上领先。不过，始终值得考虑您的用例，并确保根据实际数据对代码进行性能分析。 不过，这也不是个坏消息。 如果查看一下内存使用情况的数字，您会发现它们与第一个示例中的数字完全相同，在第一个示例中，您寻找的数字可以被123整除。在这种情况下，您可能会考虑由于 如果您正在使用内存受限的设备，则每次更改值（而不是预先生成所有值）都值得偶尔的额外执行时间。 并行编程在写书的漫长过程中，我经常希望自己的双手可以同时写不同的章节。这样一来，我完成本书的速度就会快两倍。不幸的是，当我意识到我微不足道的大脑一次只能跟踪一组单词时，我的狡猾计划受到了挫败。幸运的是，现代计算机并没有我这么有限，可以一次执行并跟踪许多任务。计算机以各种方式（并行计算，多任务，多线程，多处理等）执行此操作，但是它们全都归结为一件事：您同时执行的次数越多，完成任务的速度就越快。不过，即使您同时执行不同的操作，即使拥有现代PC的智能功能，也可以确保一切顺利。资源争用，死锁，争用条件：当多个线程或进程试图同时访问相同的资源（变量，数据，文件，硬件等）时，这些都是发生的事情。像这样的编程中最难的部分可能是在考虑脚本执行在不同路径上可能发生的所有可能性。函数式编程可以使此操作更容易。当您的程序需要执行并行任务时，它们将剥离一些线程，子进程或类似任务以完成任务，并且它们通常会合并结果或在线程或进程返回时采取某些措施。如果您使用本书中介绍的功能原理编写这些任务工作程序，则每个工作程序都可以成为一连串的纯函数，其中：•任务仅取决于其给定的输入（例如函数的参数），而不取决于外部状态。•由于不受其他任务的影响，因此可以很容易地对任务进行单独推理。这意味着您不必（过多）担心其他任务在做什么，它们可能正在使用的所需资源等，等等。您的任务具有调用时所需要的一切作为输入的一部分，并且它将返回其输出以供父脚本使用，以担心处理/存储等问题。即使它不是严格的函数，也可以像编写脚本一样编写工作脚本，接受来自父文件的输入，就好像它是参数一样，并返回单个最后返回给父级的值，就像返回值一样。PHP并非自然而然地用于并行编程，但是有多种实现并行计算的方法，可以在需要时将其付诸实践。也许最简单的方法是使用PHP的内置过程控制功能并行启动多个PHP脚本来完成工作。让我们看一个以这种方式使用流程控制的示例。您将创建一个程序来对莎士比亚的完整作品进行一些分析。您将创建一个以正常线性方式进行分析的函数，以及一个生成的函数多个“客户端” PHP工作程序脚本并行进行分析。首先，您将看到主要的parallel.php控制脚本，然后是并行版本中使用的client.php脚本，最后您将看到functions.php脚本，其中包含各种分析和并行化功能。您的脚本将从文本中挑选出符合特定条件的单词，将这些单词在整个文本中出现的次数相加，然后报告该集合中出现次数最多的十个单词。您将重复每个功能100次以对其进行基准测试。 Listing 5-21. parallel.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;?php# Get a set of functions that we'll look at shortlyrequire('functions.php');# The text to work on.$shakespeare = file_get_contents('all_shakespeare.txt');# How many times we're going to run each function, for# benchmarking purposes$repeats = 100;# Compose our single process "standard" function.$analyze_single = compose( $only_letters_and_spaces, # simplify the text 'strtolower', # all lowercase, please $analyze_words, # do the analysis $sort_results, # sort the results 'array_reverse', # get the results in descending order $top_ten # return the top ten results);# Run the single process version $repeats time on $shakespeare input# Time the runs$checkpoint1 = microtime(true);print_r( $repeat($analyze_single, $repeats, $shakespeare) );$checkpoint2 = microtime(true);# Now create a parallel process version$analyze_parallel = compose ( $launch_clients, # Launch a set of client processes to do # the analysis $report_clients, # Tell us how many clients were launched $get_results, # Get the results back from the clients $combine_results, # Combine their results into one set $sort_results, # sort the combined results 'array_reverse', # get the results in descending order $top_ten # return the top ten results);# Run the parallel version and time it$checkpoint3 = microtime(true);print_r ( $repeat($analyze_parallel, $repeats, $shakespeare) );$checkpoint4 = microtime(true);# Finally, dump the timings for comparisonvar_dump( 'Single : '.($checkpoint2 - $checkpoint1));var_dump( 'Parallel : '.($checkpoint4- $checkpoint3)); 在$ analyse_parallel组合中，$ launch_clients函数将并行启动清单5-22中的脚本多次运行。 Listing 5-22. client.php 1234567891011121314151617181920212223242526272829303132333435&lt;?phprequire('functions.php');# Get the chunk of text for the client to analyze# by reading the contents of STDIN which are piped to# this script by the fwrite($clients[$key]["pipes"][0], $string)# line in the $launch_clients function in the parent process$string = stream_get_contents(STDIN);# Compose a function to do the analysis. This is the same# as the first three steps of the single process analysis# function, with a step to encode the results as JSON at# the end so we can safely pass them back$client_analyze = compose( $only_letters_and_spaces, 'strtolower', $analyze_words, 'json_encode');# Run the function and write the results to STDOUT,# which will be read by the stream_get_contents($client["pipes"][1])# line in the $get_results function in the parent process. In most cases# you can use echo to write to STDOUT, but sometimes it can be# redirected, and so explicitly writing like this is better practicefwrite(STDOUT, $client_analyze($string) ); 最后，清单5-23显示了functions.php脚本，该脚本实现了您在先前脚本中组成的所有功能。 我将它们分开，以使脚本更易于阅读，也因为两个脚本都可以访问许多脚本。 Listing 5-23. functions.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225&lt;?php# Borrow some utility functions from previous examplesrequire('../Chapter 3/compose.php');require('repeat.php');# To simplify our analysis, replace anything that's not# a letter with a space.$only_letters_and_spaces = function($string) &#123; return preg_replace('/[^A-Za-z]+/', ' ', $string);&#125;;# This is the "expensive" deliberately un-optimized function# that does our "analysis".$analyze_words = function ($string) &#123; # Split our text into an array, one word per element $array = preg_split('/ /i', $string, -1, PREG_SPLIT_NO_EMPTY); # Filter our array for words that... $filtered = array_filter($array, function ($word) &#123; return ( # ... contain any of the letters from the word shakespeare preg_match('/[shakespeare]/', $word) != false) # ... AND has at least 1 character in common with this sentence &amp;&amp; (similar_text($word, 'William is the best bard bar none') &gt; 1) # ... AND sound like the word "bard" &amp;&amp; (metaphone($word) == metaphone('bard')) # ... AND have more than three characters in them &amp;&amp; ( (strlen($word) &gt; 3 ) ); &#125;); # Finally, count up the number of times each of the filtered # words appears in the analyzed text, and return that return array_count_values($filtered);&#125;;# Slice the top 10 items off the top of the array$top_ten = function ($array) &#123; return array_slice($array, 0 ,10);&#125;;# Sort the results numerically# asort mutates the array, so we wrap it in a function$sort_results = function($array) &#123; asort($array, SORT_NUMERIC); return $array;&#125;;# The following functions manage the execution of parallel client scripts# A function to split the text into chunks and launch the# appropriate number of clients to process it$launch_clients = function ($string) &#123; # Split the string into chunks of 1 million characters, # a value which I found by trial and error to give the # best results on this machine for this process $strings = str_split($string, 1000000); # An array to hold the resource identifiers for the client scripts $clients = []; # Descriptors for "pipes" to read/write the data to/from our client # scripts $descriptors = [ 0 =&gt; ["pipe", "r"], #STDIN, to get data 1 =&gt; ["pipe", "w"] #STDOUT, to send data ]; # Iterate through the chunks... foreach ($strings as $key =&gt; $string) &#123; # $key will be the array index, 0, 1, 2, 3... etc. # We'll use it as a handy way to number our clients # Define the command that runs the client $command = "php client.php"; # Open the clients with proc_open. This returns a resource identifier. # We'll store it, although our script won't actually use it. $clients[$key]["resource"] = proc_open( $command, $descriptors, $clients[$key]["pipes"] ); # Note the third parameter above is a variable passed by reference. # This is used by proc_open to store an array of file pointers # identifying PHP's end of the pipes that are created. # We use that info here to write our text chunk to. This writes # it to STDOUT, and our client script reads it in through STDIN # at its end of the pipe. fwrite($clients[$key]["pipes"][0], $string); # Close the pipe now we're done writing to this client. fclose($clients[$key]["pipes"][0]); &#125;; # Once all of the clients have been launched, return their # resource identifiers and pipe details return $clients;&#125;;# Simple impure function to report how many clients were# launched. You could use a writer monad instead if you wanted$report_clients = function ($clients) &#123; # The escape code at the end minimizes our output when # when running the script many times, by going up one line # and overwriting the output each time. echo("Launched ".sizeof($clients)." clients\n\033[1A"); return $clients;&#125;;# A function to get the results back from the clients.# The clients will send a JSON encoded array back to us$get_results = function ($clients) &#123; # An array to gather the results. Each clients' result # will be stored as an element of the array $results = []; # Iterate through the client resource identifiers foreach ($clients as $key =&gt; $client) &#123; # Clients write output to STDOUT, which corresponds to the # STDIN Pipe at our end. We'll read that JSON data and # decode it to a PHP array. Each client's results will be # stored as a separate element of the $results array. $results[] = json_decode( stream_get_contents($client["pipes"][1]), true); # We've done reading from the client, so we can close the pipe. fclose($clients[$key]["pipes"][1]); &#125;; # And finally return all of the results from all of the clients return $results;&#125;;# This function takes the results array from $get_results above and# combines it into a single array$combine_results = function ($results) &#123;# Reduce and return the input array by... return array_reduce($results, function($output, $array) &#123; #... iterating over each individual clients results array # and either creating or adding the count for each word to # the output depending on whether that word already exists in # the output foreach ($array as $word =&gt; $count) &#123; isset($output[$word]) ? $output[$word] += $count : $output[$word] = $count ; &#125; # return $output through to the next iteration of array_reduce return $output; &#125;, []); # starting with a blank array [] as output&#125;; 让我们运行parallel.php看看会发生什么（参见清单5-24）。 Listing 5-24. parallel-output.txt 1234567891011121314151617181920212223242526272829Array( [beard] =&gt; 76 [bright] =&gt; 43 [buried] =&gt; 43 [bred] =&gt; 36 [breed] =&gt; 35 [bird] =&gt; 34 [bride] =&gt; 30 [broad] =&gt; 15 [bread] =&gt; 15 [board] =&gt; 15)Launched 4 clientsAArray( [beard] =&gt; 76 [bright] =&gt; 43 [buried] =&gt; 43 [bred] =&gt; 36 [breed] =&gt; 35 [bird] =&gt; 34 [bride] =&gt; 30 [broad] =&gt; 15 [bread] =&gt; 15 [board] =&gt; 15)string(24) &quot;Single : 48.808692932129&quot;string(25) &quot;Parallel : 25.10250711441&quot; 如您所见，从单个流程版本和并行流程版本的分析中都可以得到相同的结果，但是并行版本大约需要执行一半的时间。 如您所做的那样，将文本分块可以并行地给您提供四个客户端流程来分析所有文本。 考虑到两个版本的函数使用的是完全相同的昂贵函数（$ analyze_words），您可能想知道为什么有四个客户端在四分之一的时间内都没有完成。 原因是要并行运行需要大量的设置，包括以下内容：•将文本分成大块•启动新的PHP流程•写入和读取过程管道•最后将结果组合在一起因此，如果您想进一步加快速度，难道您不能简单地同时增加更多的客户吗？ 让我们尝试一下，将文本分成100,000个字符的块，这需要38个客户端来并行计算（请参见清单5-25）。 Listing 5-25. parallel-output2.txt 1234567891011121314151617181920212223242526272829Array( [beard] =&gt; 76 [bright] =&gt; 43 [buried] =&gt; 43 [bred] =&gt; 36 [breed] =&gt; 35 [bird] =&gt; 34 [bride] =&gt; 30 [broad] =&gt; 15 [bread] =&gt; 15 [board] =&gt; 15)Launched 38 clientsArray( [beard] =&gt; 76 [bright] =&gt; 43 [buried] =&gt; 43 [bred] =&gt; 36 [breed] =&gt; 35 [bird] =&gt; 34 [bride] =&gt; 30 [broad] =&gt; 15 [bread] =&gt; 15 [board] =&gt; 15)string(24) &quot;Single : 49.230798959732&quot;string(26) &quot;Parallel : 145.74519586563&quot; 在这种情况下，您的速度从原来的两倍提高到了将近三倍！这再次是因为协调所有客户端并将结果汇​​总在一起的开销。因此，使用这种技术，并行处理的数量通常会达到最佳效果。这在很大程度上取决于手头的任务，对于具有以下特征的功能，您可能会获得更好的结果：•不需要大量后处理的功能（例如，来自不同客户的结果的顺序或内容无关紧要）•设置便宜的功能（例如，最少的处理以拆分输入数据，最少的数据传输到客户端）•运行时间更长的功能（与函数执行时间相比，时间开销最小）如您所见，没有很多额外的代码来管理并行化，就不会提高速度。在进入并行化代码阶段之前，您可以做很多事情加快执行速度，包括以下步骤：•使用懒惰求值，首先对单词进行计数和排序（便宜的操作）然后将分析作为生成器功能的一部分•重新排列array_filter中的操作以利用PHP的延迟评估，在调用更昂贵的preg_match之前，先使用strlen等廉价函数对数据进行缩减•预先计算metaphone（’bard’）并存储在变量中，而不是每次都计算•用便宜的strpbrk PHP函数替换preg_match如果这不足以使您达到性能目标，并且需要并行运行，则可以做一些其他事情来加快并行版本的速度（我还没有这样做）为了使代码简单和节省书中的空间）。•仅在每个脚本中包括所需的功能，也许使用构建步骤来内联它们。•直接在共享内存中传递数据，而不是通过管道传递数据，这样可以更快。•不要等待每个客户端发送数据之后再继续从下一个客户端读取数据，以无阻塞的方式反复遍历它们，直到每个客户端都准备好数据为止。 使用并行脚本很难进行惰性求值，因为每个脚本都以适合其本地输入的顺序返回数据，而不一定代表整个数据。例如，使用此脚本，每个客户都可以计算自己的最佳结果，但是您不能只接受您收到的前十个结果，因为它们可能不是莎士比亚作品中前十个，而仅仅是那些经过分析并先返回。如您所见，并行化工作需要一些思考，即使函数式编程通过消除考虑副作用的额外负担来帮助您。还请考虑一下，如果您的一个客户未能完成或挂起，我什至没有涉及该怎么办，您将了解为什么只有在真正必要时才考虑使用此类技术。 多线程编程多线程编程的工作方式与您在上一节中介绍的多进程示例类似。关键区别在于并行执行发生在同一流程而不是单独的流程中。 PHP不是多线程的；但是，使用Pthreads扩展可以实现多线程。 Pthreads是基于OOP的可靠实现，其性能可以明显优于多进程脚本。但是，由于线程在同一进程中共存，因此实​​现起来比多进程代码更复杂。另外，请注意，Pthreads扩展只能与PHP的“线程安全”版本一起使用，该版本与许多PHP扩展都不兼容。 Linux上的大多数程序包管理器都不包含线程安全版本，因此将要求您手动编译PHP（如果需要自己编译PHP的信息，请参阅附录A），或者对于Windows，则需要下载线程安全的可执行文件。从PHP网站。尽管如此，采用前面所示的函数式编程原理仍可以帮助您绕过多线程编程常见的一些问题领域。可以在Pthreads网站上找到有关扩展的更多信息和使用示例。 标准PHP库（SPL）在本章的开头，我讨论了一个事实，即PHP存在一些明显的性能问题，这是因为为用户提供易于使用和通用的数据结构和功能所需的开销。如果您发现这种开销开始限制脚本，则可以调用的标准端口库是标准PHP库（SPL），它是包含通用和深奥的数据结构和功能的核心PHP扩展。它们旨在解决常见的编程问题，尽管与PHP较常见的结构（如普通的PHP数组类型）相比，需要使用更多的思想。没有什么是独家的SPL中的函数式编程，但是您可以在本书中介绍的函数式技术中使用一些有用的函数和结构。因此，例如，如果您发现传递大量数据导致脚本达到内存限制，则可能需要查看SplFixedArray类。它有一些限制（您只能使用整数作为索引，并且必须预先指定数组的长度），但是提供了比普通数组使用更少内存的更快实现。如果您不熟悉SPL中的某些数据结构（例如堆，链接列表等），那么计算机科学的大多数基本介绍（或使用更传统的语言进行编程）都可以为您提供帮助。 SPL还包含用于常见的基于迭代器的任务的函数和类，您可以将它们与之前查看的生成器一起使用。 清单5-26中的示例脚本向您介绍了iterator_to_array函数，SplFixedArray结构和FilterIterator类。 Listing 5-26. spl.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152&lt;?php# Borrow our simple generator examplefunction gen_range($start, $end, $step) &#123; for ($i = $start; $i &lt;= $end; $i += $step) &#123; yield $i; &#125;&#125;;# Call the generator...$gen_obj = gen_range(1,10,1);# ... and check what we have is a generator objectprint_r($gen_obj);# Generators are iterators, so when we need a full array# of data instead of a generator, we can convert# it to an array using SPL's iterator_to_array function$array = iterator_to_array($gen_obj);print_r($array);# An SplFixedArray is SPLs fixed size array data structure.# Let's create an empty SPL fixed array and a standard PHP array.# Note we need to specify a size for the SPL array$spl_array = new SplFixedArray(10000);$std_array = [];# Let's create a function to fill an array with data. As both# array types can be written to in the same way, we can# use the same function here for both$fill_array = function($array, $i = 0) use (&amp;$fill_array) &#123; # recursively fill the $array with data if ($i &lt; 10000) &#123; $array[$i] = $i * 2; return $fill_array($array, ++$i); &#125;; return ($array);&#125;;# Let's do some operations with the arrays. We'll measure# the memory in use before and after each operation.$mem1 = memory_get_usage();# Fill the standard array with data$std_array = $fill_array($std_array);$mem2 = memory_get_usage(); # 528384 bytes# Fill the SPL array with data$spl_array = $fill_array($spl_array);$mem3 = memory_get_usage(); # 0 bytes# It took no memory to fill!# This is because this type of array allocates all of its memory# up-front when you create it# Create a new SPL array and fill with data$spl_array2 = new SplFixedArray(10000);$spl_array2 = $fill_array($spl_array2);$mem4 = memory_get_usage(); # 163968 bytes# This time it did, as we declared it within the section we# were measuring# Create a new empty standard array$std_array2 = [];$mem5 = memory_get_usage(); # 56 bytes - a small amount# Create a new empty SPL array$spl_array3 = new SplFixedArray(10000);$mem6 = memory_get_usage(); # 163968 bytes - for an empty array!# This shows that you need to use it with care. A Standard# array may use more memory for the same amount of data, but# the memory also shrinks with the array contents too.echo "Filled Standard Array : ".($mem2 - $mem1). " bytes \n";echo "1st Filled SPLFixedArray : ".($mem3 - $mem2). " bytes \n";echo "2nd Filled SPLFixedArray : ".($mem4 - $mem3). " bytes \n";echo "Empty Standard Array : ".($mem5 - $mem4). " bytes \n";echo "Empty SPLFixedArray : ".($mem6 - $mem5). " bytes \n";# The SPL provides various iterator classes that you can extend# to work with iterable structures like the SPLFixedArray and# generators# Let's create a class to filter for values that are divisible by threeclass by_three extends FilterIterator &#123; # We extend the FilterIterator class, and implement the accept() class # with our filtering function public function accept() &#123; $value = $this-&gt;current(); if ($value % 3 == 0) &#123; # return true to include the value in the output return true; &#125; # or false to filter it out return false; &#125;&#125;;# Let's use it to filter our previous SPL array$nums = new by_three($spl_array);var_dump(iterator_count($nums)); # int(3334) (~third of the array is returned) 总结在本章中，您研究了性能改进领域中函数编程的一些常见应用程序。 即使您不会全力以赴地用功能代码编写应用程序，也可以挑选出导致瓶颈的关键功能，并牢记功能原理进行重写，这可以使您将这些提高性能的技术应用于代码的这些部分。 当然，如果您确实以一种功能样式从头开始编写应用程序，那么在发现问题功能时应用备忘等技术便可以快速简便地完成。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在面向对象和面向过程中使用函数式编程]]></title>
    <url>%2F2020%2F03%2F31%2F%E5%9C%A8%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E5%92%8C%E9%9D%A2%E5%90%91%E8%BF%87%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 到目前为止，您已经了解了什么是函数式编程以及如何使用它来解决一些常见的编程问题的基础知识。在本章中，您将了解如何将功能代码放入现有或新应用程序中。具体来说，您将看到以下内容： 如何构造函数式应用程序以及使其充分发挥功能 如何以及何时混合和匹配范式，例如功能和面向对象的编程 PHP范式的历史函数的引用透明性（referential transparency） 基础初学程序设计时，比较容易混淆的两个概念是数学函数（math function）和程序中使用的函数。 在数学函数中 y=f(x)，一个输入值有固定的输出值。例如，无论计算多少次，sinπ 的结果总是 0。如果 f(x)=x/2，那么 f(10) 无论计算 100 次还是 1000 次，其结果都是 5. 程序设计中的函数却不具备这种稳定的特性，因为函数的执行不仅依赖于输入值，而且会受到全局变量，输入文件，类的成员变量等诸多因素的影响。如下：1234int counter = 0;int count()&#123; return ++counter;&#125; 此函数输入没有输入值，但每次都返回不同的结果。当然，就像数学函数那样，程序中函数还可以设计成“对同一输入值每次都返回相同结果”的形式。 函数的返回值只依赖于其输入值，这种特性就称为引用透明性（referential transparency） 动态规划的缓存显然，动态规划所使用的制表法（也即缓存）只能应用于具有引用透明性的函数。如果外在因素使相同输入值返回不同结果值，则不能缓存。 也即缓存对应的 map，实现的是同一个输入（key），同一个输出（value），而不可能出现同一个输入，可以得到不同的输出，也即输出结果的不确定性。 使事情简单明了的最佳方法是将您的代码分为功能和非功能代码块。 一个明显的安排是用功能代码编写业务逻辑，高性能算法等，并将其夹在不纯的OO或过程代码之间以处理输入和输出，如图7-1所示。 通过这样的安排，您可以使用干净的功能代码块来进行推理和测试，并且当问题确实发生时，更容易找出它们可能位于的位置。 当您面对使用功能性技术更新现有代码库时，一种好的方法是首先确定适合图7-1中间部分的代码部分，然后优先确定它们的优先级。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;?php# Create a class to encapsulate a valueclass my_class&#123; # The value we want to encapsulate private $value = 0; # Constructor to set the value (or default to -1) public function __construct($initial_value = -1) &#123; $this-&gt;value = $initial_value; &#125; # Method to get the value public function get_value() &#123; return $this-&gt;value; &#125; # Method to set the value public function set_value($new_value) &#123; $this-&gt;value = $new_value; &#125;&#125;# Let's create a new object with a value of 20$my_object = new my_class(20);# Check the valuevar_dump ($my_object-&gt;get_value()); # int(20)# Demonstrate we can mutate the value to 30$my_object-&gt;set_value(30);var_dump ($my_object-&gt;get_value()); # int (30)# Now let's create a function which doubles the value# of the object. Note that the function parameter# doesn't have a "&amp;" to indicate it's passed by reference$double_object = function ($an_object) &#123; # Get the value from $an_object, double it and set it back $an_object-&gt;set_value( $an_object-&gt;get_value() * 2 ); # return the object return $an_object;&#125;;# Now we call the function on our $my_object object from# above, and assign the returned object to a new variable$new_object = $double_object($my_object);# Check that the returned object has double the value (30)# of the object we passed in as a parametervar_dump( $new_object-&gt;get_value() ); # int(60)# Let's just check the value on the original objectvar_dump( $my_object-&gt;get_value()); # int(60)# It's also changed. Let's var_dump the original object# and returned object, and check their object reference number# (look for the number after the #)var_dump ($my_object); # #1var_dump ($new_object); # #1# They're both the same. Just for clarity, create a new# object from scratch and check it's reference number$last_object = new my_class();var_dump ($last_object); # #3 (#2 was our closure object $double_object) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354&lt;?php# use our trusty compose functioninclude('../Chapter 3/compose.php');# The same class as before, but with an added static methodclass new_class&#123; private $value = 0; public function __construct($initial_value = -1) &#123; $this-&gt;value = $initial_value; &#125; public function get_value() &#123; return $this-&gt;value; &#125; public function set_value($new_value) &#123; $this-&gt;value = $new_value; &#125; # a static method to halve the provided value public static function halve($value) &#123; return $value / 2; &#125;&#125;# Let's create a new object with an initial value of 25$my_object = new new_class(73.4);# Let's stack some math functions together including our# static method above$do_math = compose ( 'acosh', 'new_class::halve', 'floor');# Now let's actually do the math. We set the object value# to the result of $do_math being called on the original value.$my_object-&gt;set_value( $do_math( $my_object-&gt;get_value() ) );# Show that our object value has been changed. Note that nothing changed# while we were in our functional (compose) code.var_dump ( $my_object-&gt;get_value() ); # float(2) 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?php# use our trusty compose functioninclude('../Chapter 3/compose.php');# The same class as previouslyclass my_class&#123; private $value = 0; public function __construct($initial_value = -1) &#123; $this-&gt;value = $initial_value; &#125; public function get_value() &#123; return $this-&gt;value; &#125; public function set_value($new_value) &#123; $this-&gt;value = $new_value; &#125;&#125;# A function to triple the value of the object$triple_object = function ($an_object) &#123; # First clone it to make sure we don't mutate the object that # $an_object refers to $cloned_object = clone $an_object; # Then set the value to triple the current value $cloned_object-&gt;set_value( $cloned_object-&gt;get_value() * 3 ); # and return the new object return $cloned_object;&#125;;# A function to multiply the value of the object by Pi.# Again we clone the object first and return the mutated clone$multiply_object_by_pi = function ($an_object) &#123; $cloned_object = clone $an_object; $cloned_object-&gt;set_value( $cloned_object-&gt;get_value() * pi() ); return $cloned_object;&#125;;# Let's create an object encapsulating the value 10.$my_object = new my_class(10);# We'll compose the above functions together$more_maths = compose( $triple_object, $multiply_object_by_pi, $triple_object);# and then call that composition on our object.var_dump ( $more_maths($my_object) );# Let's check our original object remains unchangedvar_dump ($my_object); 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150&lt;?php# Create a class to represent an immutable array# Make the clas "final" so that it can't be extended to add# methods to mutate our arrayfinal class const_array &#123; # Our array property, we use a private property to prevent # outside access private $stored_array; # Our constructor is the one and only place that we set the value # of our array. We'll use a type hint here to make sure that we're # getting an array, as it's the only "way in" to set/change the # data, our other methods can be sure they are then only dealing # with an array type public function __construct(array $an_array) &#123; # PHP allows us to call the __construct method of an already created # object whenever we want as if it was a normal method. We # don't want this, as it would allow our array to be over written # with a new one, so we'll throw an exception if it occurs if (isset($this-&gt;stored_array)) &#123; throw new BadMethodCallException( 'Constructor called on already created object' ); &#125;; # And finally store the array passed in as our immutable array. $this-&gt;stored_array = $an_array; &#125; # A function to get the array public function get_array() &#123; return $this-&gt;stored_array; &#125; # We don't want people to be able to set additional properties on this # object, as it de facto mutates it by doing so. So we'll throw an # exception if they try to public function __set($key,$val) &#123; throw new BadMethodCallException( 'Attempted to set a new property on immutable class.' ); &#125; # Likewise, we don't want people to be able to unset properties, so # we'll do the same again. As it happens, we don't have any public # properties, and the methods above stop the user adding any, so # it's redundant in this case, but here for completeness. public function __unset($key) &#123; throw new BadMethodCallException( 'Attempted to unset a property on immutable object.' ); &#125;&#125;# Let's create a normal array$mutable_array = ["country" =&gt; "UK", "currency" =&gt; "GBP", "symbol" =&gt; "£"];# and create an const_array object from it$immutable_array = new const_array($mutable_array);var_dump ($immutable_array);# Let's mutate our original array$mutable_array["currency"] = "EURO";# our const_array is unaffectedvar_dump ($immutable_array);# We can read the array values like normalforeach ( $immutable_array-&gt;get_array() as $key =&gt; $value) &#123; echo "Key [$key] is set to value [$value] \n\n";&#125;;# And use dereferencing to get individual elementsecho "The currency symbol is ". $immutable_array-&gt;get_array()["symbol"]."\n\n";# Need to copy it? Just clone it like any other object, and the methods# which make it immutable will be cloned too.$new_array = clone $immutable_array;var_dump ($new_array);# The following operations aren't permitted though, and will throw exceptions# $immutable_array-&gt;stored_array = [1,2,3];# BadMethodCallException: Attempted to set a new property on immutable class# $immutable_array-&gt;__construct([1,2,3]);# BadMethodCallException: Constructor called on already created object# unset($immutable_array-&gt;get_array);# BadMethodCallException: Attempted to unset a property on immutable object.# $immutable_array-&gt;new_prop = [1,2,3];# BadMethodCallException: Attempted to set a new property on immutable class# $test = new const_array();# TypeError: Argument 1 passed to const_array::__construct()# must be of the type array, none given# class my_mutable_array extends const_array &#123;## function set_array ($new_array) &#123;## $this-&gt;stored_array = $new_array;## &#125;## &#125;;# Fatal error: Class my_mutable_array may not inherit from final# class (const_array)# Unfortunately, there is no practical way to stop us overwriting the object# completely, either by unset()ing it or by assigning a new value to the# object variable, such as by creating a new const_array on it$immutable_array = new const_array([1,2,3]);var_dump($immutable_array); # new values stored 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?php# Get our compose functionrequire '../Chapter 3/compose.php';# This class will provide a set of methods to work with taxclass tax_functions &#123; # Store the rate of tax private $tax_rate; # Our constructor sets the tax rate initially public function __construct($rate) &#123; $this-&gt;tax_rate = $rate; &#125; # Provide a method to set the tax rate at any point public function set_rate($rate) &#123; $this-&gt;tax_rate = $rate; &#125; # A method to add tax at the $tax_rate to the $amount public function add_tax($amount) &#123; return $amount * (1 + $this-&gt;tax_rate / 100); &#125; # A method to round the $amount down to the nearest penny public function round_to($amount) &#123; return floor($amount * 100) / 100; &#125; # A function to format the $amount for display public function display_price($amount) &#123; return '£'.$amount.' inc '.$this-&gt;tax_rate.'% tax'; &#125;&#125;# So let's create an object for our program containing the# methods, with the tax rate set at 10%$funcs = new tax_functions(10);# Now let's compose our methods into a flow that adds tax, rounds# the figure and then formats it for display.# Note that to pass a method of an object as a callable, you need# to give an array of the object and method name. If you are using# static class methods, you can use the class::method notation instead$add_ten_percent = compose ( [$funcs, 'add_tax'], [$funcs, 'round_to'], [$funcs, 'display_price'] );# We've composed our $add_ten_percent function, but we may not want to use it# until much later in our script.# In the mean-time, another programmer inserts the following line in our# code in between...$funcs-&gt;set_rate(-20);# and then we try to use our $add_ten_percent function to add# tax to 19.99, hopefully getting the answer £21.98 inc 10% taxvar_dump( $add_ten_percent(19.99) ); # £15.99 inc -20% tax 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?php# Grab our compose functionrequire('../Chapter 3/compose.php');# Define some maths functions$add_two = function ( $a ) &#123; return $a + 2;&#125;;$triple = function ( $a ) &#123; return $a * 3;&#125;;# Now we're going to create a "dirty" function to do some logging.$log_value = function ( $value ) &#123; # Do our impure stuff. echo "Impure Logging : $value\n"; # Oops, we mutated the parameter value... $value = $value * 234; # ...and returned it even more mutated return $value.' is a number';&#125;;# Now we're going to create a higher-order function which returns a# wrapped function which executes our impure function but returns# the original input parameter rather than any output from our impure# function. Note that we must pass $value to $impure_func by value and# not by reference (&amp;) to ensure it doesn't mess with it. Also see# the sections on the mutability of objects if you pass those through,# as the same concerns will apply here.$transparent = function ($impure_func) &#123; return function ($value) use ($impure_func) &#123; $impure_func($value); return $value; &#125;;&#125;;# Compose the maths functions together, with the $log_value impure function# made transparent by our wrapper function$do_sums = compose( $add_two, $transparent($log_value), $triple, $transparent($log_value) );# We should get the expected resultvar_dump( $do_sums(5) ); # 21 123456789101112131415161718192021&lt;?php# This is some typical procedural codeecho ("a is $a\n");$number = $a + 5;$number = $number * 2;for ($i = 0; $i &lt; 5; $i++) &#123; echo "We're doing procedural stuff here\n";&#125;;$b = 50;# Note the addition of a return statement.return $number; 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;?php# First set some variables in global scope$a = 25;$b = 0;# Do a simple require of the file.$return_value = require "procedural.php";var_dump ( $return_value ); #60 - the script operated on our $a value of 25var_dump ( $a ); # 25var_dump ( $b ); # 50 - the script has mutated $b in the global scope# Reset $b$b = 0;# This function executes the file as if it were a function, within the# scope of the function. You can pass in a set of parameters as an array,# and the extract line creates variables in the function scope which# the code in the file can access. Finally, it requires the file and# returns the files return value as its own.$file_as_func = function ($filename, $params) &#123; extract ($params); return require $filename;&#125;;# We'll call it on our procedural.php file, with a couple of parameters# that have the same name but different values to our global $a and $bvar_dump ( $file_as_func( 'procedural.php', ['a'=&gt;50, 'b'=&gt;100] ) ); # 110# this clearly operated on our parameter "a" and not the global $avar_dump ( $a ); # 25var_dump ( $b ); # 0 - unchanged this time]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用函数式开发商业逻辑]]></title>
    <url>%2F2020%2F03%2F31%2F%E7%94%A8%E5%87%BD%E6%95%B0%E5%BC%8F%E5%BC%80%E5%8F%91%E5%95%86%E4%B8%9A%E9%80%BB%E8%BE%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 在本章中，您将了解函数式编程的其他一些常见用法。您将首先查看功能代码如何帮助您管理程序中实现的业务逻辑。然后，您将了解什么是基于事件的编程，以及函数式编程如何帮助您应对管理传入事件的复杂性并保持数据流的顺畅。最后，您将快速了解异步编程，并了解为什么函数式编程在该领域也是有用的工具。 处理业务逻辑 Listing 6-1 business_data.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&lt;?php# First let's create core business data.# Rather than just define arrays, we're going to create functions# that return arrays. We'll discuss why in the chapter.# Every sale is either local, within our own country, or beyond$locations = function () &#123; return [ 'local', 'country', 'global' ];&#125;;# Each category of products that we sell has a different tax rate,# and that rate varies depending on where our purchaser is located$rates = function () &#123; return [ 'clothes' =&gt; [ 'local' =&gt; 0, 'country' =&gt; 5, 'global' =&gt; 10 ], 'books' =&gt; [ 'local' =&gt; 0, 'country' =&gt; 5, 'global' =&gt; 5 ], 'cheeses' =&gt; [ 'local' =&gt; 20, 'country' =&gt; 17.5, 'global' =&gt; 2 ] ];&#125;;# A list of our products, with their category and price$products = function () &#123; return [ 'T-shirt' =&gt; [ 'Category' =&gt; 'clothes', 'Price' =&gt; 15.99 ], 'Shorts' =&gt; [ 'Category' =&gt; 'clothes', 'Price' =&gt; 9.99 ], 'The Dictionary' =&gt; [ 'Category' =&gt; 'books', 'Price' =&gt; 4.99 ], 'War and Peace' =&gt; [ 'Category' =&gt; 'books', 'Price' =&gt; 29.45 ], 'Camembert' =&gt; [ 'Category' =&gt; 'cheeses', 'Price' =&gt; 3.50 ], 'Brie' =&gt; [ 'Category' =&gt; 'cheeses', 'Price' =&gt; 7.00 ] ];&#125;;# We only sell in dollars, but we format the prices differently# depending on the location of the purchaser.$price_formats = function () &#123; return [ 'local' =&gt; [ 'symbol' =&gt; '$', 'separator' =&gt; '.' ], 'country' =&gt; [ 'symbol' =&gt; '$', 'separator' =&gt; '.' ], 'global' =&gt; [ 'symbol' =&gt; 'USD ', 'separator' =&gt; ',' ] ];&#125;; Listing 6-2 business_logic.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889&lt;?php# Now we're going to create a set of functions which describe our business# logic. We're going to keep them as simple as possible, and reference# other functions within this file where possible to keep a# "single source of truth" for when we need to update them.# Load our business datarequire('business_data.php');# Fetch the details of a single product from the list of products$get_product_details = function ($product) use ($products) &#123; return $products()[$product];&#125;;# Get the category name from the details of a single product$get_category = function ($product_details) &#123; return $product_details['Category'];&#125;;# Get the tax rate for a category of products based on the location# of the purchaser$get_tax_rate = function ($category, $location) use ($rates)&#123; return $rates()[$category][$location];&#125;;# Get the net (tax exclusive) price of a product by name.$get_net_price = function ($product) use ($get_product_details) &#123; return $get_product_details($product)["Price"];&#125;;# Roll the above functions together to create a function that gets# the gross (tax inclusive) price for a certain quantity of products# based on the location of our purchaser.# Note that the tax is rounded using the PHP_ROUND_HALF_DOWN constant# to indicate the particular rounding method.$get_gross_price = function ($product, $quantity, $location) use ( $get_net_price, $get_tax_rate, $get_category, $get_product_details ) &#123; return round( $get_net_price($product) * $quantity * ( 1 + ( $get_tax_rate( $get_category( $get_product_details($product) ), $location) /100 ) ), 2, PHP_ROUND_HALF_DOWN );&#125;;# A function to get the actual amount of tax charged. Note that this doesn't# simply use the tax rate, as the actual amount charged may differ depending on# the rounding performed and any future logic added to $get_gross_price.# Instead we call $get_net_price and $get_gross_price and return the difference.$get_tax_charged = function ($product, $quantity, $location) use ($get_gross_price, $get_net_price) &#123; return $get_gross_price($product, $quantity, $location) - ( $quantity * $get_net_price($product) );&#125;;# Finally, a function to format a string to display the price, based# on the purchasers location.$format_price = function ($price, $location) use ($price_formats) &#123; $format = $price_formats()[$location]; return $format["symbol"] . str_replace('.', $format["separator"], (string) $price );&#125;; Listing 6-3 shopping.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384&lt;?php# Import our set of pure functions which encapsulate our business logic.require('business_logic.php');# Now we can use them in our not so pure, not so functional code, safe in the# knowledge that they (should) provide us with consistent, correct results# regardless of what we do to the global or external state here.# Let's generate a shopping cart of products for a user in Bolivia$cart = ['Brie' =&gt; 3, 'Shorts' =&gt; 1, 'The Dictionary' =&gt; 2 ];$user = ["location" =&gt; 'global'];# One common function is to list the contents of the cart. Let's do# that hereecho "Your shopping cart contains :\n\n";echo "Item - Quantity - Net Price Each - Total Price inc. Tax\n";echo "=======================================================\n\n";foreach ($cart as $product =&gt; $quantity) &#123; $net_price = $get_net_price($product); $total = $get_gross_price($product, $quantity, $user["location"]); echo "$product - $quantity - $net_price - $total \n";&#125;;echo "=======================================================\n\n";# In a confirmation e-mail we may want to just list a (formatted) total price...$total_price = array_reduce( array_keys($cart), # loop through the cart and add gross price for each item function ($running_total, $product) use ( $user, $get_gross_price, $cart ) &#123; return $running_total + $get_gross_price( $product, $cart[$product], $user["location"] );&#125;, 0);echo "Thank you for your order.\n";echo $format_price($total_price, $user["location"]).' will ';echo "be charged to your card when your order is dispatched.\n\n";# And on the backend system we may have a routine that keeps details of# all the tax charged, ready to send to the Government. Let's create a# summary of the tax for this order.$tax_summary = array_reduce( array_keys($cart), # Loop through each item and add the tax charged to the relevant category function ($taxes, $product) use ( $user, $get_tax_charged, $cart, $get_category, $get_product_details ) &#123; $category = $get_category($get_product_details($product)); $tax = $get_tax_charged($product, $cart[$product], $user["location"]); isset($taxes[$category]) ? $taxes[$category] =+ $tax : $taxes[$category] = $tax; return $taxes;&#125;, []);echo "Tax Summary for this order :\n\n";var_dump($tax_summary); 基于事件的编程 Listing 6-5 install_event.txt 12345678910111213141516171819202122# Install the libevent library and it header filessudo apt-get install libevent-2.0-5 libevent-dev# Ensure that PECL (which comes as part of the PEAR package)# and the phpize command which PECL needs are installedsudo apt-get install php-pear php-dev# Install the event extensionsudo pecl install event# Finally make the extension available to the PHP CLI binary# by editing php.inisudo nano /etc/php/7.0/cli/php.ini# and adding the following line in the section where other .so# extensions are includeextension=event.so Listing 6-6 server_functions.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232&lt;?php# We'll create a set of functions that implement the logic that should# occur in response to the events that we'll handle.# Use our trusty partial function generatorrequire('../Chapter 3/partial_generator.php');# A generic function to output an HTTP header. $req is an object representing# the current HTTP request, which ensures that our function deals with the# right request at all times.$header = function ($name, $value, $req) &#123; $req-&gt;addHeader( $name , $value, EventHttpRequest::OUTPUT_HEADER );&#125;;# We are going to be serving different types of content (html, images etc.)# so we need to output a content header each time. Let's create a# partial function based on $header...$content_header = partial($header, 'Content-Type' );# and then make it specific for each type of content...$image_header = partial($content_header, "image/jpeg");$text_header = partial($content_header, "text/plain; charset=ISO-8859-1");$html_header = partial($content_header, "text/html; charset=utf-8");# The following function creates a "buffer" to hold our $content and# then sends it to the browser along with an appropriate HTTP status# code (Let's assume our requests always work fine so send 200 for everything).# Note that it's a pure function right up until we call sendReply. You could# return the EventBuffer instead, and wrap it all into an IO or Writer monad to# put the impure sendReply at the end if you wish.$send_content = function($req, $content) &#123; $output = new EventBuffer; $output-&gt;add($content); $req-&gt;sendReply(200, "OK", $output);&#125;;# The input parameters for our maths functions are held in the URI parameters.# The URI is held in the $req request object as a string. Let's get the# URI and parse out the parameters into an associative array.$parse_uri_params = function ($req) &#123; $uri = $req-&gt;getUri(); parse_str ( # Grab just the parameters (everything after the ?) substr( $uri, strpos( $uri, '?' ) + 1 ), # and parse it into $params array $params ); return $params;&#125;;# Get the URI "value" parameter$current_value = function($req) use ($parse_uri_params) &#123; return $parse_uri_params($req)["value"];&#125;;# Get the URL "amount" parameter$amount = function($req) use ($parse_uri_params) &#123; return $parse_uri_params($req)["amount"];&#125;;# A function to send the results of one of our maths functions which follow.$send_sum_results = function($req, $result) use ( $html_header, $send_content) &#123; # Create some HTML output, with the current result, plus some links # to perform more maths functions. Note the uri parameters contain # all of the state needed for the function to give a deterministic, # reproducable result each time. We also include some links to # the other utility functions. When you visit them, note that you # can use your browser back button to come back to the maths functions # and carry on where you left off, as the parameters the functions # need are provided by the URI parameters and no "state" has been # altered of lost $output = &lt;&lt;&lt;ENDCONTENT &lt;p&gt;&lt;b&gt;The current value is : $result&lt;/b&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/add?value=$result&amp;amount=3"&gt;Add 3&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/add?value=$result&amp;amount=13"&gt;Add 13&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/add?value=$result&amp;amount=50"&gt;Add 50&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/subtract?value=$result&amp;amount=2"&gt;Subtract 2&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/subtract?value=$result&amp;amount=5"&gt;Subtract 5&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/multiply?value=$result&amp;amount=2"&gt;Multiply by 2&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/multiply?value=$result&amp;amount=4"&gt;Multiply by 4&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/divide?value=$result&amp;amount=2"&gt;Divide by 2&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/divide?value=$result&amp;amount=3"&gt;Divide by 3&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;a href="/floor?value=$result"&gt;Floor&lt;/a&gt;&lt;/p&gt; &lt;p&gt;&lt;A href="/show_headers"&gt;[Show headers]&lt;/a&gt;&amp;nbsp; &lt;a href="/really/cute"&gt;[Get cat]&lt;/a&gt;&amp;nbsp; &lt;a href="/close_server"&gt;[Close down server]&lt;/a&gt;&lt;/p&gt;ENDCONTENT; # Send the content header and content. $html_header($req); $send_content($req, $output);&#125;;# These are our key maths functions. Each one operates like a good Functional# function by only using the values supplied as input parameters, in this# case as part of $req. We call a couple of helper functions ($current_value# and $amount) to help extract those values, $req isn't necessarily# immutable (we could alter values or call methods), but we'll use# our discipline to keep it so right up until we're ready to send_contents.# While we don't formally "return" a value, $send_sum_results effectively# acts a return statement for us. Any return value would simply go back to# libevent (which is the caller, and it just ignore it).# If we want to keep to strictly using explicit return statements, we could# wrap this in another function that does the same as $send_sum_results, (and# for the same reason wouldn't have a return statement) or we could create an# Writer monad or similar to gather the results and only output to the browser# at the end. For this simple example we'll go with using $send_sum_results# though for simplicity and clarity.$add = function ($req) use ($send_sum_results, $current_value, $amount) &#123; $send_sum_results($req, $current_value($req) + $amount($req) );&#125;;$subtract = function ($req) use ($send_sum_results, $current_value, $amount) &#123; $send_sum_results($req, $current_value($req) - $amount($req) );&#125;;$multiply = function ($req) use ($send_sum_results, $current_value, $amount) &#123; $send_sum_results($req, $current_value($req) * $amount($req) );&#125;;$divide = function ($req) use ($send_sum_results, $current_value, $amount) &#123; $send_sum_results($req, $current_value($req) / $amount($req) );&#125;;$floor = function ($req) use ($send_sum_results, $current_value) &#123; $send_sum_results($req, floor($current_value($req)) );&#125;;# Now we'll define some utility functions# Grab the HTTP headers from the current request and return them as an array$get_input_headers = function ($req) &#123; return $req-&gt;getInputHeaders();&#125;;# A recursive function to loop through an array of headers and return# an HTML formatted string$format_headers = function ($headers, $output = '') use (&amp;$format_headers) &#123; # if we've done all the headers, return the $output if (!$headers) &#123; return $output; &#125; else &#123; # else grab a header off the top of the array, add it to the # $output and recursively call this function on the remaining headers. $output .= '&lt;pre&gt;'.array_shift($headers).'&lt;/pre&gt;'; return $format_headers($headers, $output); &#125;;&#125;;# Use the function above to format the headers of the current request for# viewing$show_headers = function ($req) use ($html_header, $send_content, $format_headers) &#123; $html_header($req); $send_content($req, $format_headers( $req-&gt;getInputHeaders() ) );&#125;;# Let's handle all requests, so there are no 404's$default_handler = function ($req) use ($html_header, $send_content) &#123; $html_header($req); $output = '&lt;h1&gt;This is the default response&lt;/h1&gt;'; $output .= '&lt;p&gt;Why not try &lt;a href="/add?value=0&amp;amount=0"&gt;some math&lt;/a&gt;&lt;/p&gt;'; $send_content($req, $output);&#125;;# Ensure that there are sufficient supplies of cat pictures available# in all corners of the Internet$send_cat = function($req) use ($image_header, $send_content) &#123; # Note we send a different header so that the browser knows # a binary image is coming $image_header($req); # An impure function, you could alway use an IO monad or # embed the image binary data here! $send_content($req, file_get_contents('cat.jpg'));&#125;;# A function to shut down the web server script by visiting a particular URI.$close_server = function($req, $base) use ($html_header, $send_content) &#123; $html_header($req); $send_content($req, '&lt;h1&gt;Server is now shutting down&lt;/h1&gt;'); $base-&gt;exit();&#125;; Listing 6-7 web_server.php 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;?php# Let's get all of our functions that implement our# business logicrequire('server_functions.php');# Now we're ready to build up our event framework# First we create an "EventBase", which is libevent's vehicle for holding# and polling a set of events.$base = new EventBase();# Then we add an EventHttp object to the base, which is the Event# extension's helper for HTTP connections/events.$http = new EventHttp($base);# We'll choose to respond to just GET HTTP requests$http-&gt;setAllowedMethods( EventHttpRequest::CMD_GET );# Next we'll tie our functions we created above to specific URIs using# function callbacks. We've created them all as anonymous/closure functions# and so we just bind the variable holding them to the URI. We# could use named functions if we want, suppling the name in "quotes".# In fact, you can use any kind of callable here. All will be called# with the EventHttpRequest object representing the current request as# the first paramter. If you need other parameters here for your callback,# you can specify them as an optional third parameter below.# Our set of maths functions...$http-&gt;setCallback("/add", $add);$http-&gt;setCallback("/subtract", $subtract);$http-&gt;setCallback("/multiply", $multiply);$http-&gt;setCallback("/divide", $divide);$http-&gt;setCallback("/floor", $floor);# A function to shut down the server, which needs access to the server $base$http-&gt;setCallback("/close_server", $close_server, $base);# A utility function to explore the headers your browser is sending$http-&gt;setCallback("/show_headers", $show_headers);# And a compulsory function for all internet connected devices$http-&gt;setCallback("/really/cute", $send_cat);# Finally we'll add a default function callback to handle all other URIs.# You could, in fact, just specify this default handler and not those# above, and then handle URIs as you wish from inside this function using# it as a router function.$http-&gt;setDefaultCallback($default_handler);# We'll bind our script to an address and port to enable it to listen for# connections. In this case, 0.0.0.0 will bind it to the localhost, and# we'll choose port 12345$http-&gt;bind("0.0.0.0", 12345);# Then we start our event loop using the loop() function of our base. Our# script will remain in this loop indefinitely, servicing http requests# with the functions above, until we exit it by killing the script or,# more ideally, calling $base-&gt;exit() as we do in the close_server()# function above.$base-&gt;loop();# We'll only hit this point in the script if some code has called# $base-&gt;exit();echo "Server has been gracefully closed\n";]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP7的函数式编程]]></title>
    <url>%2F2020%2F03%2F31%2FPHP7%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 函数式编程函数式编程是一种声明式编程范式，它将代码抽象为纯的，不可变的，无副作用的函数，从而使程序员可以将这些函数组合在一起，从而使程序易于推理。 函数式编程的函数通常称为纯函数，具有几个重要特征，可以用PHP的语法模仿但不强制使用。纯函数具有以下特征： 引用透明 无副作用 没有外部依赖性 在接下来的几章中，我将详细讨论这些函数的含义，但它们归结为一个功能齐全的小型“黑盒子”，该函数接受定义明确的输入，产生定义明确的输出，以及给定相同的输入总是产生相同的输出。 特别是，该函数仅作用于给定的输入（它不考虑任何外部状态或数据，而仅依赖于被调用的参数），并且它唯一的作用就是返回一些输出（ 每次您输入相同的输入时，输入的内容都会相同）； 因此，它不会改变程序或系统自身之外的状态。 我将讨论不变性，即本质上是无法更改值的。起初这似乎是一个弊端，而不是收益，但是当在接下来的两章中将所有这些概念综合在一起时，您会发现不变性在函数式编程的灵活配方性质中起着关键作用，并且是其中之一。 这些因素使您可以轻松地推断出函数式代码。 Listing 2-3 backtrace.php 123456789101112131415161718192021222324&lt;?phpfunction prepare_text($text) &#123; return make_headline($text);&#125;function make_headline($text) &#123; return add_h_tags( upper_case($text) );&#125;function upper_case($text) &#123; return strtoupper($text);&#125;function add_h_tags($text) &#123; debug_print_backtrace(); return '&lt;h1&gt;'.$text.'&lt;/h1&gt;';&#125;$title = prepare_text('testing');echo $title; Listing 2-4 backtrace-output.txt 1234#0 add_h_tags(TESTING) called at [backtrace.php:12]#1 make_headline(testing) called at [backtrace.php:6]#2 prepare_text(testing) called at [backtrace.php:30]&lt;h1&gt;TESTING&lt;/h1&gt; 可变性和不变性如果某些东西是可变的，则意味着您可以更改它。 变量是可变的。 在函数式编程中，您希望值（由函数表示）是不可变的。 PHP对不变性的支持有限，主要表现为使用define（）函数或const关键字定义的“常量”形式。 在使用define（）和const时，如何以及如何声明常量的声明之间有一些区别，但是一旦声明，由这两种方法创建的常量都是相同的。 两者的共同点是只有标量或数组才能为常数。 清单2-7尝试从包含匿名函数的变量中创建一个常量。 清单2-8显示了输出。 Listing 2-7. constant-func.php 12345678910&lt;?php$double = function ($input) &#123; return $input * 2;&#125;;define('DOUBLE', $double);echo "Double 2 is " . $double(2) . "\n";echo "Double 2 is " . DOUBLE(2) . "\n"; Listing 2-8. constant-func-output.txt 12345678PHP Warning: Constants may only evaluate to scalar values or arrays in constant-func.php online 8Double 2 is 4PHP Fatal error: Uncaught Error: Call to undefined function DOUBLE() in constant-func.php:12Stack trace:#0 &#123;main&#125;thrown in constant-func.php on line 12 在这里，您可以看到在尝试使用在define（）中包含函数的变量时收到警告，并且当您尝试使用DOUBLE常量时，您将得到确认（通过致命错误），该确确实定义失败。 因此，在没有PHP太多帮助的情况下，您将需要在编码时通过纪律确保自己不变。帮助实现这一目标的关键方法之一是避免使用分配，而在阅读本书时，您将研究实现这一目标的方法。当您告诉他们您正在使用PHP进行函数式编程时，人们会指出PHP中缺乏对不变性的支持（与其他语言相比）。但是，它丝毫不会阻止您使用PHP编写功能程序。您只需要在编写代码时牢记它。 在观看自己的工作的同时，还需要留意PHP的工作。需要考虑的关键是PHP自身的函数如何对变量进行操作。例如，函数sort（）对传递的数组进行突变（即排序），而不是返回作为旧数组排序版本的新数组（并使旧数组保持不变）。但是，您可以很容易地使自己的sort（）的不可变版本（请参见清单2-9和清单2-10）。 Listing 2-9. sort.php 123456789101112131415161718192021&lt;?phpfunction immutable_sort($array) &#123; sort($array); return $array;&#125;$vegetables = ['Carrot', 'Beetroot', 'Asparagus'];# Sort using our immutable function$ordered = immutable_sort( $vegetables );print_r( $ordered );# Check that $vegetables remains unmutatedprint_r( $vegetables );# Do it the mutable waysort( $vegetables );# And see that the original array is mutatedprint_r( $vegetables ); Listing 2-10. sort-output.txt 123456789101112131415161718Array( [0] =&gt; Asparagus [1] =&gt; Beetroot [2] =&gt; Carrot)Array( [0] =&gt; Carrot [1] =&gt; Beetroot [2] =&gt; Asparagus)Array( [0] =&gt; Asparagus [1] =&gt; Beetroot [2] =&gt; Carrot) 之所以可行，是因为默认情况下，PHP函数参数是通过值而不是通过引用传递的。 这意味着在调用函数时，它会获取您作为参数提供的任何变量的副本，而不是对变量本身的引用。 该函数对该副本所做的任何操作均不会影响原始变量。PHP确实允许您通过引用传递参数（sort（）用来改变原始数组的引用），但这不是默认值。 传入对象或资源时，就是传入对象或资源变量，它是指向该对象或资源的指针。 该变量仍按值传递； 但是，变量的新副本仍指向原始对象或资源，因此它的行为与按值传递相似。 您将在第7章中深入探讨该问题。 在大多数情况下，显而易见的是，哪些函数会改变其参数。 他们通常不提供其输出作为返回值，但有些人则将按值和按引用参数混合使用，因此如果不确定，请务必查阅PHP手册。 什么是函数？我将从头开始介绍函数，因为必须了解PHP如何实现函数的基础知识以及处理函数的不同方法，才能理解如何在PHP中实现函数编程。 在本章的过程中，您将对函数的确切功能有了更好的了解。 但这是一个很好的开始定义： 函数是一组指令，封装在一个独立的，可重用的代码块中。 PHP使您可以使用几种不同的函数调用，接下来将依次介绍。 命名函数以下是命名函数的主要限制： 它们不能被销毁。 一旦定义，其功能（功能中的代码）就无法更改。 它们很难“传递”，因为它们无法分配给变量。 只能将函数名称分配给变量，而不是函数本身。 尽管可以通过动态方式处理已命名函数，但是call_user_func()函数确实提供了一种以这种方式工作的方法，如清单2-15和清单2-16所示，该方法的功能有限。 Listing 2-15. userfunc.php 1234567891011&lt;?phpfunction list_fruit($item) &#123;return ['apple','orange','mango'][$item];&#125;function list_meat($item) &#123;return ['pork','beef','human'][$item];&#125;$the_list = 'list_fruit';var_dump( call_user_func($the_list, 2) );$the_list = 'list_meat';var_dump( call_user_func($the_list, 1) ); Listing 2-16. userfunc-output.txt 12string(5) &quot;mango&quot;string(4) &quot;beef&quot; 如您所见，您可以将函数的名称（作为字符串）传递给call_user_func（）（加上要提供该函数的任何参数），并且call_user_func（）将从您自己调用的函数中返回返回值返回值。如您所见，您可以在$ the_list中更改该函数的名称（因为它是一个字符串变量），然后再次运行call_user_func（），这一次运行另一个函数。 这可以使您具有一点活力，但功能有限。一种类似的方法称为变量函数，您将在下一节中对其进行介绍。从PHP 7.0开始，您还可以使用PHP闭包对象的fromCallable静态方法将命名函数包装到称为闭包的对象中，稍后将进行介绍。 命名函数的范围也不直观。正如您将在本章后面的“范围”部分中看到的那样，当您在函数中创建变量时，默认情况下，该函数之外的代码将无法使用该变量。但是，在另一个函数中实例化一个命名函数时，会在全局范围内创建该函数，以便可以从任何地方调用它，因此还需要具有全局唯一名称。考虑清单2-17中嵌套函数的演示，该函数返回一个字符串来说明其嵌套（清单2-18显示了输出）。 123456789101112131415161718192021222324252627282930313233343536&lt;?phpfunction a() &#123; function b() &#123; return "a -&gt; b"; &#125; return "a";&#125;function c() &#123; function d() &#123; function e() &#123; return "c -&gt; d -&gt; e"; &#125; return "c -&gt; d"; &#125; return "c";&#125;var_dump( a() );var_dump( b() );var_dump( c() );var_dump( d() );var_dump( e() ); Listing 2-18. name-scope-output.txt 12345string(1) &quot;a&quot;string(6) &quot;a -&gt; b&quot;string(1) &quot;c&quot;string(6) &quot;c -&gt; d&quot;string(11) &quot;c -&gt; d -&gt; e&quot; Listing 2-19. name-scope2.php 12345678910111213141516171819202122232425262728&lt;?phpfunction a() &#123; function b() &#123; return "a -&gt; b"; &#125; return "a";&#125;function c() &#123; function d() &#123; function e() &#123; return "c -&gt; d -&gt; e"; &#125; return "c -&gt; d"; &#125; return "c";&#125;var_dump( a() );var_dump( b() );var_dump( d() );var_dump( c() );var_dump( e() ); Listing 2-20. name-scope2-output.txt 123456string(1) &quot;a&quot;string(6) &quot;a -&gt; b&quot;PHP Fatal error: Uncaught Error: Call to undefined function d() in name-scope2.php:38Stack trace:#0 &#123;main&#125;thrown in name-scope2.php on line 38 Listing 2-21. name-scope3.php 12345678910111213141516171819202122&lt;?phpfunction f() &#123; function g() &#123; return "1st g()"; &#125;; return "f()";&#125;function h() &#123; function g() &#123; return "2nd g()"; &#125;; return "h()";&#125;var_dump( f() );var_dump( g() );var_dump( h() ); Listing 2-22. name-scope3-output.txt 1234string(3) &quot;f()&quot;string(7) &quot;1st g()&quot;PHP Fatal error: Cannot redeclare g() (previously declared in name-scope3.php:7) in name-scope3.php on line 17 可变函数Listing 2-23. variable.php 1234567891011121314151617181920212223242526272829303132&lt;?phpfunction vehicles( $index ) &#123; $types = ["car", "motorbike", "tractor"]; return $types[$index];&#125;function animals( $index ) &#123; $types = ["cow", "pig", "chicken", "horse"]; return $types[$index];&#125;$get_thing = 'animals'; # string with the name of a functionvar_dump( $get_thing(2) ); # add ($index) to call it$get_thing = 'vehicles'; # change the functionvar_dump( $get_thing(2) ); #same "code", different function# Just to show that $get_thing is just a# standard string, and nothing special...$get_thing = strrev('selcihev'); # do string thingsvar_dump( $get_thing ); # it's a stringvar_dump( $get_thing(2) ); # call itvar_dump( $get_thing ); # afterwards, still just a stringunset( $get_thing ); # we can destroy it, because it's a stringvar_dump( $get_thing );var_dump( vehicles(2) ); # But the function still exists# However, it needs to be set to a function that exists$get_thing = 'people';var_dump( $get_thing(2) ); Listing 2-24. variable-output.txt 123456789101112string(7) &quot;chicken&quot;string(7) &quot;tractor&quot;string(8) &quot;vehicles&quot;string(7) &quot;tractor&quot;string(8) &quot;vehicles&quot;PHP Notice: Undefined variable: get_thing in variable.php on line 41NULLstring(7) &quot;tractor&quot;PHP Fatal error: Uncaught Error: Call to undefined function people() in variable.php:49Stack trace:#0 &#123;main&#125;thrown in variable.php on line 49 Listing 2-25. constructs.php 123&lt;?php$var_func = 'echo';$var_func('hello world!'); Listing 2-26. constructs-output.php 1234PHP Fatal error: Uncaught Error: Call to undefined function echo() in constructs.php:5Stack trace:#0 &#123;main&#125;thrown in constructs.php on line 5 Listing 2-27. constructs2.php 1234567&lt;?phpfunction my_echo($string) &#123; echo $string;&#125;$var_func = 'my_echo';$var_func('hello world!'); Listing 2-28. constructs2-output.php 1hello world! 返回值Listing 2-29. null-return.php 12345678910111213141516171819202122&lt;?phpfunction reverse($string) &#123; $string = strrev($string);&#125;function capitals($string) &#123; if ($string != 'banana') &#123; $string = strtoupper($string); return $string; &#125;&#125;# no return statementvar_dump( reverse('hello') );# returns a valuevar_dump( capitals('peaches') );# execution flow misses return statementvar_dump( capitals('banana') ); Listing 2-30. null-return-output.txt 123NULLstring(7) &quot;PEACHES&quot;NULL Listing 2-31. null-return2.php 12345678910111213141516&lt;?phpfunction fruits($type) &#123; if ($type == 'mango') &#123; return 'Yummy!'; &#125; else &#123; return; &#125;&#125;var_dump( fruits('kiwi') );var_dump( fruits('pomegranate') );var_dump( fruits('mango') ); Listing 2-32. null-return2-output.txt 123NULLNULLstring(6) &quot;Yummy!&quot; Listing 2-33. return.php 1234567891011&lt;?phpfunction my_funct() &#123; $a = 23; return $a; $a = 45; return $a;&#125;var_dump( my_funct() ); Listing 2-34. return-output.txt 1int(23)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[高级函数式技巧]]></title>
    <url>%2F2020%2F03%2F30%2F%E9%AB%98%E7%BA%A7%E5%87%BD%E6%95%B0%E5%BC%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 到目前为止，您已经对编程的功能风格和优点有了一定的了解它可以带来。您可以将这些技术从今天开始使用，而无需进一步阅读。理想情况下，不过，我激发了您的胃口，以进一步发展它，并了解更多可用于您的功能性技术程序员的工具箱。在本章中，您将了解函数式编程的一些更高级的方面，这些方面将使您以越来越实用的方式构建PHP代码。本章是您之前的“理论”的最后一部分在本书的下一部分中开始讲一些实际的例子。您将从查看curring开始，扩展了部分函数应用程序的概念，将其分解为可自动化的方式较低种族的版本。接下来，您将了解寓言中的monad，它们可帮助您进行程序流控制和让您处理在现实世界中工作时会遇到的讨厌的副作用。之后，您将了解蹦床，这是一种可控制递归的方法。最后，我会讲关于使用类型声明的严格类型与动态类型的讨论很少，尽管这不是严格的功能概念在某些方面可能有用（在其他方面则没有）。 柯里化函数柯里化(Currying)指的是将原来接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数。 实例首先我们定义一个函数:1def add(x:Int,y:Int)=x+y 那么我们应用的时候，应该是这样用：add(1,2) 现在我们把这个函数变一下形：1def add(x:Int)(y:Int) = x + y 那么我们应用的时候，应该是这样用：add(1)(2),最后结果都一样是3，这种方式（过程）就叫柯里化。 实现过程add(1)(2) 实际上是依次调用两个普通函数（非柯里化函数），第一次调用使用一个参数 x，返回一个函数类型的值，第二次使用参数y调用这个函数类型的值。 实质上最先演变成这样一个方法：1def add(x:Int)=(y:Int)=&gt;x+y 那么这个函数是什么意思呢？ 接收一个x为参数，返回一个匿名函数，该匿名函数的定义是：接收一个Int型参数y，函数体为x+y。现在我们来对这个方法进行调用。1val result = add(1) 返回一个result，那result的值应该是一个匿名函数：(y:Int)=&gt;1+y 所以为了得到结果，我们继续调用result。1val sum = result(2) 最后打印出来的结果就是3。 完整实例下面是一个完整实例：1234567891011object Test &#123; def main(args: Array[String]) &#123; val str1:String = "Hello, " val str2:String = "Scala!" println( "str1 + str2 = " + strcat(str1)(str2) ) &#125; def strcat(s1: String)(s2: String) = &#123; s1 + s2 &#125;&#125; 执行以上代码，输出结果为： $ scalac Test.scala$ scala Teststr1 + str2 = Hello, Scala! 名义上只接受部分参数，但其实底下偷偷补足其他参数 123456789101112131415var bind = function(fn, a)&#123; return function(b)&#123; return fn(a, b) &#125;&#125;var mult = function(a, b)&#123; return a*b&#125;// 绑定mult的第一个参数a，譬如指定该参数为2var time2 = bind(mult, 2)// 调用新函数time2time(1) // 得2time(3) // 得6 严谨一点来说，currying之后的函数只接受一个参数，这比一般的部分绑定函数形式上更加精炼。 柯里化通常也称部分求值，其含义是给函数分步传递参数，每次传递参数后部分应用参数，并返回一个更具体的函数接受剩下的参数，这中间可嵌套多层这样的接受部分参数函数，直至返回最后结果。因此柯里化的过程是逐步传参，逐步缩小函数的适用范围，逐步求解的过程。 柯里化一个求和函数按照分步求值，我们看一个简单的例子 var concat3Words = function (a, b, c) { return a+b+c;}; var concat3WordsCurrying = function(a) { return function (b) { return function (c) { return a+b+c; }; };};console.log(concat3Words(“foo “,”bar “,”baza”)); // foo bar bazaconsole.log(concat3WordsCurrying(“foo “)); // [Function]console.log(concat3WordsCurrying(“foo “)(“bar “)(“baza”)); // foo bar baza可以看到， concat3WordsCurrying(“foo “) 是一个 Function，每次调用都返回一个新的函数，该函数接受另一个调用，然后又返回一个新的函数，直至最后返回结果，分布求解，层层递进。（PS：这里利用了闭包的特点） 那么现在我们更进一步，如果要求可传递的参数不止3个，可以传任意多个参数，当不传参数时输出结果？ 首先来个普通的实现： var add = function(items){ return items.reduce(function(a,b){ return a+b });};console.log(add([1,2,3,4]));但如果要求把每个数乘以10之后再相加，那么：12345678var add = function (items,multi) &#123; return items.map(function (item) &#123; return item*multi; &#125;).reduce(function (a, b) &#123; return a + b &#125;);&#125;;console.log(add([1, 2, 3, 4],10)); 好在有 map 和 reduce 函数，假如按照这个模式，现在要把每项加1,再汇总，那么我们需要更换map中的函数。 下面看一下柯里化实现：1234567891011121314151617181920var adder = function () &#123; var _args = []; return function () &#123; if (arguments.length === 0) &#123; return _args.reduce(function (a, b) &#123; return a + b; &#125;); &#125; [].push.apply(_args, [].slice.call(arguments)); return arguments.callee; &#125;&#125;; var sum = adder();console.log(sum); // Functionsum(100,200)(300); // 调用形式灵活，一次调用可输入一个或者多个参数，并且支持链式调用sum(400);console.log(sum()); // 1000 （加总计算） ` 上面 adder是柯里化了的函数，它返回一个新的函数，新的函数接收可分批次接受新的参数，延迟到最后一次计算。 通用的柯里化函数更典型的柯里化会把最后一次的计算封装进一个函数中，再把这个函数作为参数传入柯里化函数，这样即清晰，又灵活。例如 每项乘以10, 我们可以把处理函数作为参数传入：123456789101112131415161718192021222324var currying = function (fn) &#123; var _args = []; return function () &#123; if (arguments.length === 0) &#123; return fn.apply(this, _args); &#125; Array.prototype.push.apply(_args, [].slice.call(arguments)); return arguments.callee; &#125;&#125;;var multi=function () &#123; var total = 0; for (var i = 0, c; c = arguments[i++];) &#123; total += c; &#125; return total;&#125;;var sum = currying(multi); sum(100,200)(300);sum(400);console.log(sum()); // 1000 （空白调用时才真正计算） 这样 sum = currying(multi)，调用非常清晰，使用效果也堪称绚丽，例如要累加多个值，可以把多个值作为做个参数 sum(1,2,3)，也可以支持链式的调用，sum(1)(2)(3) 柯里化的基础上面的代码其实是一个高阶函数（high-order function）, 高阶函数是指操作函数的函数，它接收一个或者多个函数作为参数，并返回一个新函数。此外，还依赖与闭包的特性，来保存中间过程中输入的参数。即： 函数可以作为参数传递函数能够作为函数的返回值闭包柯里化的作用延迟计算。上面的例子已经比较好低说明了。参数复用。当在多次调用同一个函数，并且传递的参数绝大多数是相同的，那么该函数可能是一个很好的柯里化候选。动态创建函数。这可以是在部分计算出结果后，在此基础上动态生成新的函数处理后面的业务，这样省略了重复计算。或者可以通过将要传入调用函数的参数子集，部分应用到函数中，从而动态创造出一个新函数，这个新函数保存了重复传入的参数（以后不必每次都传）。例如，事件浏览器添加事件的辅助方法： 1234567891011var addEvent = function(el, type, fn, capture) &#123; if (window.addEventListener) &#123; el.addEventListener(type, function(e) &#123; fn.call(el, e); &#125;, capture); &#125; else if (window.attachEvent) &#123; el.attachEvent("on" + type, function(e) &#123; fn.call(el, e); &#125;); &#125; &#125;; 每次添加事件处理都要执行一遍 if…else…，其实在一个浏览器中只要一次判定就可以了，把根据一次判定之后的结果动态生成新的函数，以后就不必重新计算。 123456789101112131415var addEvent = (function()&#123; if (window.addEventListener) &#123; return function(el, sType, fn, capture) &#123; el.addEventListener(sType, function(e) &#123; fn.call(el, e); &#125;, (capture)); &#125;; &#125; else if (window.attachEvent) &#123; return function(el, sType, fn, capture) &#123; el.attachEvent("on" + sType, function(e) &#123; fn.call(el, e); &#125;); &#125;; &#125;&#125;)(); 这个例子，第一次 if…else… 判断之后，完成了部分计算，动态创建新的函数来处理后面传入的参数，这是一个典型的柯里化。 您在上一章中了解了部分函数的优点，并且我提到了一种用于自动分解功能。分解是分解多arar函数的行为通过固定一个或多个参数的值，将其转换为具有较小签名的函数。方法您要查看的自动分解称为currying，并以Haskell Curry（一个男人其名称（字面上）是整个函数式编程！咖喱确实与部分功能的应用密切相关，乍看之下它是咖喱功能看起来很像您创建的部分函数生成器。但是，有一些微妙但重要的差异。就是说，部分功能应用程序只是一种currying（或者相反），取决于您与谁交谈），因此每种方法的好处是相似的。您选择使用哪个取决于什么根据您的情况为您工作。在部分函数生成器中，您获取了一个函数，以及一个绑定到第一个参数的值，然后返回了一个签名短了一个参数的函数。在currying中，您可以使其更加灵活通过获取一个函数和一个或多个参数的列表并将所有给定的参数绑定到新函数回到。到目前为止，咖喱相似（如果更笼统）。要获得功能的实际结果，您需要到达已绑定和/或传递函数所有参数的位置，函数将然后执行并返回一个值。 生成器和currying函数返回的部分函数（在两种情况下均为闭包）是把握两者之间差异的关键。使用您看过的简单的部分生成器，返回的函数是签名减少的函数（即，叫它）。如果您想进一步减少它来创建另一个局部函数，则可以调用局部函数在返回的闭包上再次生成函数。相反，闭包是由一个循环例程返回的是一项独立功能，可以自动自动进行进一步处理。例如，如果您有一个具有五个参数的函数，并且通过固定两个参数来进行咖喱处理，则将得到一个接受三个闭包参数。如果然后再用一个参数调用该闭包，则不要执行不完整的闭包参数集（如前面显示的部分函数所示），它将自动咖喱自身并返回另一个接受两个参数的闭包（如果使用，则再次具有进一步咖喱自己的能力另一个参数）。将此与生成器的部分功能进行对比；如果您提供一个接受三个部分函数的参数，它将尝试使用简化的参数集执行，通常会导致错误。 与往常一样，用一个例子可能会更清楚。编写适当形式的currying函数并非易事，您将使用Matteo Giachino编写的名为php-curry的库来帮助您。这是可用的在GitHub上的[https://github.com/matteosister/php-curry]上，可以通过Composer或如清单4-1和清单4-2所示，直接包含它。 Listing 4-1. currying.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;?phpinclude('Curry/Placeholder.php');include('Curry/functions.php');use Cypress\Curry as C;# Let's make a function place an order with our chef# for some delicious curry (the food, not the function)$make_a_curry = function($meat, $chili, $amount, $extras, $where) &#123;return ["Meat type"=&gt;$meat,"Chili hotness"=&gt;$chili,"Quantity to make"=&gt;$amount,"Extras"=&gt;$extras,"Eat in or take out"=&gt;$where];&#125;;# We think that everyone will want a mild Rogan Josh, so# let's curry the function with the first two parameters$rogan_josh = C\curry($make_a_curry, 'Lamb','mild');# $rogan_josh is now a closure that will continue to# curry with the arguments we give it$dishes = $rogan_josh("2 portions");# likewise $dishes is now a closure that will continue# to curry$meal = $dishes('Naan bread');# and so on for meal. However, we only have 1 parameter# which we've not used, $where, and so when we add# that, rather than returning another closure, $meal# will execute and return the result of $make_a_curry$order = $meal('Eat in');print_r( $order );# To show that our original function remains unmutated, when# we realize that actually people only want 1 portion of curry# at a time, with popadoms, and they want to eat it at home, we# can curry it again. This time, the parameters we want to bind# are at the end, so we use curry_right.$meal_type = C\curry_right($make_a_curry, 'Take out', 'Poppadoms', '1 portion');$madrass = $meal_type('hot', 'Chicken');print_r( $madrass );# We could curry the function with all of the parameters# provided, this creates a parameter-less closure but doesn't# execute it until we explicitly do so.$korma = C\curry($make_a_curry,'Chicken', 'Extra mild', 'Bucket full', 'Diet cola', 'Eat in');print_r($korma()); Listing 4-2. currying-output.txt 123456789101112131415161718192021222324Array( [Meat type] =&gt; Lamb [Chili hotness] =&gt; mild [Quantity to make] =&gt; 2 portions [Extras] =&gt; Naan bread [Eat in or take out] =&gt; Eat in)Array( [Meat type] =&gt; Chicken [Chili hotness] =&gt; hot [Quantity to make] =&gt; 1 portion [Extras] =&gt; Poppadoms [Eat in or take out] =&gt; Take out)Array( [Meat type] =&gt; Chicken [Chili hotness] =&gt; Extra mild [Quantity to make] =&gt; Bucket full [Extras] =&gt; Diet cola [Eat in or take out] =&gt; Eat in)]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数式编程入门]]></title>
    <url>%2F2020%2F03%2F29%2F%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么要使用诸如map，filter和reduce之类的函数代替foreach循环？ 一个函数调用多次，函数状态会在内存中新生成一个“副本”吗？ Map,Filter,Reduce Listing 3-1 map_filter_reduce.php 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677&lt;?php// 配料$ingredients = [ "cod", // 鳕鱼 "beef", "kiwi", // 奇异果 "egg", "vinegar" // 醋];// 菜式$dish_types = [ "pie", "smoothie", // 冰沙 "tart", // 果馅饼 "ice cream", "crumble" // 酥皮水果甜点 ];// 烘焙食品$baked = [ "pie", "tart", "crumble", "cake"];# 通过将一种配料与一道菜相结合来创建食谱$make_recipe = function ($ingredient, $dish) &#123; return $ingredient.' '.$dish;&#125;;# 通过查看其中是否包含$baked数组中的任何单词，来检查某个食谱是否包含烘焙食品$is_baked = function ($recipe) use ($baked) &#123; return array_filter($baked, function($item) use ($recipe) &#123; return strpos($recipe, $item) !== false; &#125; );&#125;;# 得到最长菜谱的函数$get_longest = function ($current_longest, $recipe) &#123; return strlen($recipe) &gt; strlen($current_longest) ? $recipe : $current_longest;&#125;;# PHP函数shuffle并非一成不变，它更改了给定的数组。# 因此，我们创建了自己的不可变的$reshuffle函数。# 请注意，shuffle还具有副作用（它使用外部熵源使数组随机化），因此不是参照透明的。但这现在就可以了。// shuffle 洗牌$reshuffle = function ($array) &#123; shuffle($array); return $array;&#125;;$all_recipes = array_map($make_recipe, $reshuffle($ingredients), $reshuffle($dish_types));print_r($all_recipes);$baking_recipes = array_filter($all_recipes, $is_baked);print_r($baking_recipes);$best_recipe = array_reduce($baking_recipes, $get_longest, '');print_r($best_recipe); Listing 3-2 map_filter_reduce-output.txt 123456789101112131415Array( [0] =&gt; vinegar ice cream [1] =&gt; kiwi tart [2] =&gt; cod crumble [3] =&gt; egg smoothie [4] =&gt; beef pie)Array( [1] =&gt; kiwi tart [2] =&gt; cod crumble [4] =&gt; beef pie)cod crumble 递归函数 Listing 3-3 shopping_list1.php 1234567891011121314151617&lt;?php$shopping = [ "fruits" =&gt; [ "apples" =&gt; 7, "pears" =&gt; 4, // 梨 "bananas" =&gt; 6 ], "bakery" =&gt; [ // 面包店 "bread" =&gt; 1, "apple pie" =&gt; 2 ], "meat" =&gt; [ "sausages" =&gt; 10, // 香肠 "steaks" =&gt; 3, "chorizo" =&gt; 1 // 乔里索香肠 ]]; Listing 3-4 foreach.php 1234567891011121314&lt;?phprequire('shopping_list1.php');$total = 0;foreach ($shopping as $group) &#123; foreach ($group as $food =&gt; $count) &#123; $total += $count; &#125;&#125;echo "Total items to purchase : $total\n"; Listing 3-5 foreach-output.txt 1Total items to purchase : 34 Listing 3-6 shopping_list2.php 1234567891011121314151617181920&lt;?php$shopping = [ "fruits" =&gt; [ "apples" =&gt; [ "red" =&gt; 3, "green" =&gt; 4 ], "pears" =&gt; 4, "bananas" =&gt; 6 ], "bakery" =&gt; [ "bread" =&gt; 1, "apple pie" =&gt; 2 ], "meat" =&gt; [ "sausages" =&gt; 10, "steaks" =&gt; 3, "chorizo" =&gt; 1 ]]; Listing 3-7 foreach2-output.txt 1234PHP Fatal error: Uncaught Error: Unsupported operand types in foreach.php:11Stack trace:#0 &#123;main&#125;thrown in foreach.php on line 11 Listing 3-8 recursive.php 1234567891011121314151617181920212223242526272829&lt;?phpfunction count_total($list) &#123; # 用一个变量来保存总数 $total = 0; # 遍历数组中的每个值 foreach ($list as $food =&gt; $value) &#123; # 对于数组中的每个值，该值是否实际上是另一个数组 if (is_array ($value)) &#123; # 在新的（子）数组上调用这个函数，并将结果添加到$total中。 这是递归的部分。 $total += count_total ($value); &#125; else &#123; $total += $value; &#125; &#125; return $total;&#125;require('shopping_list1.php');echo "List 1 : ".count_total($shopping)."\n";require('shopping_list2.php');echo "List 2 : ".count_total($shopping)."\n"; Listing 3-9 recursive-output.txt 123List 1 : 34List 2 : 34List 3 : 34 每次您调用一个函数（无论是从内部调用还是从外部调用），则在内存中创建函数状态的新“副本”。这意味着该函数的每次调用与其他相同函数的调用实际上是分开的。调用它们时，每个函数调用的状态被放置到内存中的调用堆栈中，查看调用堆栈可以帮助您可视化递归。 Listing 3-10 recursive_stack.php 12345678910111213141516&lt;?phpfunction sum($start) &#123; echo "---\n"; debug_print_backtrace(); if ($start &lt; 2) &#123; return 1; &#125; else &#123; return $start + sum($start-1); &#125;&#125;echo "The result is : ".sum(4); Listing 3-11 recursive_stack-output.txt 123456789101112131415---#0 sum(4) called at [recursive_stack.php:17]---#0 sum(3) called at [recursive_stack.php:13]#1 sum(4) called at [recursive_stack.php:17]---#0 sum(2) called at [recursive_stack.php:13]#1 sum(3) called at [recursive_stack.php:13]#2 sum(4) called at [recursive_stack.php:17]---#0 sum(1) called at [recursive_stack.php:13]#1 sum(2) called at [recursive_stack.php:13]#2 sum(3) called at [recursive_stack.php:13]#3 sum(4) called at [recursive_stack.php:17]The result is : 10 递归是好的，但是您必须小心以确保递归循环一定会终止于一点。 Listing 3-12 forever.php 123456789&lt;?phpini_set('memory_limit','1G');function forever() &#123; forever();&#125;forever(); Listing 3-13 forever-output.txt 1PHP Fatal error: Allowed memory size of 1073741824 bytes exhausted (tried to allocate 262144 bytes) in forever.php on line 6 每次调用函数时，都会在其中创建一个副本内存，在这种情况下，由于无法退出函数，每个内存消耗越来越多的内存调用，并且永远不会通过退出函数来释放。请注意，我为脚本显式设置了内存限制ini_set。与Web脚本不同，PHP CLI脚本默认情况下没有内存限制。没有限制，这脚本可能会消耗所有可用内存，从而使您的机器瘫痪。 调用函数时，在函数中使用的每个变量，每个调试语句以及分配的每个其他资源都占用宝贵的内存。调用一次，它的总和可能不多，但调用递归进行数百或数千次，可能很快成为一个问题。因此，您应始终尝试将递归函数中的每种状态形式保持在绝对最小值。 尾递归是递归的一种形式，其中递归调用是函数的最后一部分。在许多语言中，编译器可以优化尾部递归，因为它不需要“堆栈框架”即可让编译器将状态存储回去。不幸的是，PHP虚拟机没有提供这样的优化，因此，我不会详细介绍尾递归。 在下一章中，您将转而关注“蹦床”，通过自动将递归函数展平到循环中，您可以得到类似的优化。 实现递归函数 Listing 3-14 all_recipes.php 12345678910111213141516171819202122232425262728&lt;?php$ingredients = [ "cod", "beef", "kiwi", "egg", "vinegar"];$dish_types = [ "pie", "smoothie", "tart", "ice cream", "crumble"];$all_recipes = [];foreach ($ingredients as $ingredient) &#123; foreach ($dish_types as $dish) &#123; $all_recipes[] = $ingredient.' '.$dish; &#125;&#125;print_r($all_recipes); Listing 3-15 all_recipes-output.txt 12345678910111213141516171819202122232425262728Array( [0] =&gt; cod pie [1] =&gt; cod smoothie [2] =&gt; cod tart [3] =&gt; cod ice cream [4] =&gt; cod crumble [5] =&gt; beef pie [6] =&gt; beef smoothie [7] =&gt; beef tart [8] =&gt; beef ice cream [9] =&gt; beef crumble [10] =&gt; kiwi pie [11] =&gt; kiwi smoothie [12] =&gt; kiwi tart [13] =&gt; kiwi ice cream [14] =&gt; kiwi crumble [15] =&gt; egg pie [16] =&gt; egg smoothie [17] =&gt; egg tart [18] =&gt; egg ice cream [19] =&gt; egg crumble [20] =&gt; vinegar pie [21] =&gt; vinegar smoothie [22] =&gt; vinegar tart [23] =&gt; vinegar ice cream [24] =&gt; vinegar crumble) Listing 3-16 recipe_functions.php 12345678910111213141516171819202122232425262728&lt;?phpfunction combine($a,$b) &#123; $combinations = []; if (is_array($a)) &#123; foreach ($a as $i) &#123; $combinations = array_merge( $combinations, combine($i, $b) ); &#125; &#125; else &#123; foreach ($b as $i) &#123; $combinations[] = $a.' '.$i; &#125; &#125; return $combinations;&#125;function print_first($items, $count) &#123; for ($counter=0; $counter&lt;$count; $counter++) &#123; echo "$counter. $&#123;items[$counter]&#125; \n"; &#125;&#125; Listing 3-17 all_recipes_recursive.php 123456789101112131415161718192021&lt;?phprequire_once('recipe_functions.php');$ingredients = [ "cod", "beef", "kiwi", "egg", "vinegar"];$dish_types = [ "pie", "smoothie", "tart", "ice cream", "crumble"];$all_recipes = combine($ingredients, $dish_types);print_first($all_recipes, 5); Listing 3-18 all_recipes_recursive_output.txt 123456Showing 5 of 25 items:1. cod pie2. cod smoothie3. cod tart4. cod ice cream5. cod crumble Listing 3-19 new_ingredients.php 12345678910111213141516171819202122232425&lt;?phprequire_once('recipe_functions.php');$ingredients = [ [ "ham", "beef" ], [ "apple", "kumquat" ], "vinegar"];$dish_types = [ "pie", "smoothie", "tart", "ice cream", "crumble"];$all_recipes = combine($ingredients, $dish_types);print_first($all_recipes, 11); Listing 3-20 new_ingredients-output.txt 123456789101112Showing 11 of 25 items:1. ham pie2. ham smoothie3. ham tart4. ham ice cream5. ham crumble6. beef pie7. beef smoothie8. beef tart9. beef ice cream10. beef crumble11. apple pie 偏函数在第1章中，您研究了函数式编程如何体现OOP的SOLID原理。一在这些原则中，接口隔离原则（ISP）意味着仅对于完成当前任务应该是您需要传递给函数的任务。在上一节中，考虑recipe_functions.php中的print_first函数。需要两个参数，要打印的项目数组和要打印的项目数。通常这是合理的需要两个参数，因为通常它们对于给定任务都会有所不同。但是，如果您正在编写新的网站theTopFiveBestEverListsOfStuff.com，您将永远只想打印第一个列出的任何五个项目。当然，您可以在整个过程中重复输入print_first（$ list，5）脚本。但是，当排在前五名的名单的市场饱和时，您需要继续前进，有史以来十大最佳市场，您需要找到所有这些5并将其替换为10。如果您不小心输入了4而不是5或1而不是10，您在一下午的市场份额将损失一半。您当然可以用变量$ count替换5，然后在需要时设置$ count = 10。但在全局范围内执行此操作意味着要进行额外的工作，以确保其他功能范围内的调用都可以使用它，并且当另一个程序员在某处意外地将$ count用作循环计数器时，奇怪的错误将比比皆是。 偏函数可为您解决这些问题。偏函数是采用现有功能并通过将值绑定到一个（或多个）参数来减少其复杂性。 放另一个方式，部分功能通过修复一个或多个现有功能的一个或多个功能，可提供现有功能的更具体版本参数设置为特定值，从而减少了调用它所需的参数数量。让我们创建一个在前五名站点上打印列表的部分功能。 请参见清单3-21和清单3-22。 Listing 3-21 top_five.php 12345678910111213141516171819&lt;?phprequire_once('print_first.php');# Some data ...$best_names = ["Rob", "Robert", "Robbie", "Izzy", "Ellie", "Indy", "Parv", "Mia", "Joe", "Surinder", "Lesley"];# Calling the function in fullprint_first($best_names, 5);# Now let's define a partial function, print_top_list, which# binds the value 5 to the second parameter of print_firstfunction print_top_list($list) &#123; print_first($list, 5);&#125;;# Calling the new partial function will give the same# output as the full function call above.print_top_list($best_names); Listing 3-22 top_five-output.txt 123456789101112Showing 5 of 11 items:1. Rob2. Robert3. Robbie4. Izzy5. EllieShowing 5 of 11 items:1. Rob2. Robert3. Robbie4. Izzy5. Ellie 您现在可以在整个网站上愉快地使用print_top_list部分功能，在知道a）您可以随时在一个中央位置将数字5更改为10，b）您仍然可以受益于对基础print_first函数的任何更新或更改，并且c）您仍然可以调用在任何其他脚本中，print_first函数直接使用任何数字表示第二个参数中的第二个参数使用相同的功能，但需要不同的编号。尽管这展示了部分函数的好处，但是您手动创建它的过程有点笨拙并且不可重用。因此，让我们成为真正的函数式程序员，并创建一个函数来创建您的部分函数职能！我在第二章中谈到了高阶函数。提醒一下，这些功能可以其他功能作为输入和/或作为输出返回。您将定义一个名为partial的函数，该函数需要一个函数和一个或多个绑定到它的参数，并吐出一个现成的部分函数供您使用。参见清单3-23，清单3-24和清单3-25。 Listing 3-23 partial_generator.php 12345678910111213141516171819202122232425262728293031&lt;?php# Our function to create a partial function. $func is# a "callable", i.e. a closure or the name of a function, and# $args is one or more arguments to bind to the function.function partial($func, ...$args) &#123; # We return our partial function as a closure return function() use ($func, $args) &#123; # The partial function we return consists of # a call to the full function using "call_user_func_array" # with a list of arguments made up of our bound # argument(s) in $args plus any others supplied at # calltime (via func_get_args) return call_user_func_array($func, array_merge($args, func_get_args() ) ); &#125;;&#125;# The partial function generator above binds the given# n arguments to the *first* n arguments. In our case# we want to bind the *last* argument, so we'll create# another function that returns a function with the# arguments reversed.function reverse($func) &#123; return function() use ($func) &#123; return call_user_func_array($func, array_reverse(func_get_args()) ); &#125;;&#125; Listing 3-24 partial.php 12345678910&lt;?phprequire_once('print_first.php');require_once('partial_generator.php');$foods = ["mango", "apple pie", "cheese", "steak", "yoghurt", "chips"];$print_top_five = partial(reverse('print_first'), 5);$print_top_five($foods);$print_best = partial(reverse('print_first'), 1);$print_best($foods); Listing 3-25 partial-output.txt 12345678Showing 5 of 6 items:1. mango2. apple pie3. cheese4. steak5. yoghurtShowing 1 of 6 items:1. mango 尽管我说过有关named的内容，但本示例使用了一个命名函数而不是闭包功能更早。 这是为本书的范围而故意设计的； 您稍后将再次使用它，并且在您正在编写的简单程序，将其用作命名函数意味着您不需要在每个程序中您要从中调用的每个函数。 在程序中，您可能希望将其更改为闭包给您带来好处。如您所见，局部函数生成器允许您使用可重用的方式来创建多个局部函数您可以根据需要使用它们，并制作了两个不同的部分（$ print_top_five和$ print_best）。 您可以使用此功能来减少任何功能的数量。 考虑清单3-26中的函数，的Arity为4，您将减少2。 清单3-27显示了输出。 Listing 3-26 concatenate.php 12345678910&lt;?phprequire_once("partial_generator.php");$concatenate = function ($a, $b, $c, $d) &#123; return $a.$b.$c.$d;&#125;;echo $concatenate("what ", "is ", "your ", "name\n");$whatis = partial($concatenate, "what ", "is ");echo $whatis("happening ", "here\n"); Listing 3-27 concatenate-output.txt 12what is your namewhat is happening here 偏函数可帮助您将函数分解为单一用途，可重用和可维护的功能。 它们使您可以共享更广泛的“单片式”功能的核心功能几个不同的任务，同时仍然受益于功能的集中化。 他们还允许您（如果需要）使用纯数学函数来实现奇偶校验，该函数仅接受一个单论点。 在下一章中，您将研究curring，尽管我专注于食物，但它并不是功能化印度菜，而是一种将多种功能自动分解为一连串的单参数函数。 函数式表达式函数式编程倾向于使用“函数式表达式”进行程序控制，而不是使用传统的命令式控制结构，您已经间接查看了其中的一些示例。您可以使用已经探索的技术来组合一些更有用的表达方式。某些易于转换和理解的示例往往是数字函数。 毕竟，函数式编程源于数学。 在许多语言中，函数inc和dec存在用于递增和递减整数。 在PHP中，您习惯使用++和-运算符而是，但是没有理由不能使用称为的函数编写自己的函数表达式公司和十二月 您可能会很想创建清单3-28所示的这些函数来实现此目的（使用输出如清单3-29所示）。 Listing 3-28 inc_dec.php 123456789101112131415&lt;?phpfunction inc($number) &#123; $number++; return $number;&#125;function dec($number) &#123; $number--; return $number;&#125;var_dump( inc(3) );var_dump( dec(3) ); Listing 3-29 inc_dec-output.txt 12int(4)int(2) 完全正确，但是让我们考虑使用部分函数技术的不同方法您之前看过的。 参见清单3-30和清单3-31。 Listing 3-30 inc_dec_partial.php 123456789101112131415161718192021222324&lt;?phprequire_once('partial_generator.php');# First define a generic adding functionfunction add($a,$b) &#123; return $a + $b;&#125;# Then create our inc and dec as partial functions# of the add() function.$inc = partial('add', 1);$dec = partial('add', -1);var_dump( $inc(3) );var_dump( $dec(3) );# Creating variations is then a simple one-liner$inc_ten = partial('add', 10);var_dump( $inc_ten(20) );# and we still have our add function. We can start# to build more complex functional expressions$answer = add( $inc(3), $inc_ten(20) );var_dump ( $answer ); Listing 3-31 inc_dec_partial-output.txt 1234int(4)int(2)int(30)int(34) 请注意，您可以根据需要混合和匹配命名函数和匿名函数技术。 最初，您只需付出一点额外的努力，即可获得更大的灵活性，并轻松创建其他派生类职能。 另一个示例可能是根据用例创建功能版本的能力。例如，您和我可能会认为一打是12，但对面包师来说是13。请参见清单3-32和清单3-33。 Listing 3-32 dsl.php 12345678910111213141516&lt;?phprequire_once('partial_generator.php');# Define a multiply functionfunction multiply($a,$b) &#123; return $a * $b;&#125;# And then create two ways to count in# dozens, depending on your industry$programmers_dozens = partial('multiply', 12);$bakers_dozens = partial('multiply', 13);var_dump( $programmers_dozens(2) );var_dump( $bakers_dozens(2) ); Listing 3-33 dsl-output.txt 12int(24)int(26) 这种创建功能的功能描述了他们将要做什么，而不是详细说明如何去做，是使函数式编程非常适合创建领域特定语言的属性之一（DSL）。 DSL是为特定应用量身定制的语言或现有语言的改编“域”（例如，特定行业或软件类型）。 您已经讨论了一种通过减少现有功能的繁琐性来创建新功能的方法，但是如果您想要通过合并多个现有功能来制作新功能？您可以在其他带有中间变量的变量将输出从一个传递到下一个。或者，您可以连锁通过直接使用一个函数作为下一个函数的参数将它们组合在一起。这是一种功能形式组合，并且一如既往，有一种更好的“功能性”方法可以做到这一点。假设您有一个秘密的公式可以计算出使世界上最好的温度的最佳温度芒果雪糕。该公式计算您正在使用的芒果数量（例如6），将其加倍（12），取反（-12），再加上2（-10°C）。您需要将此公式作为函数嵌入到运行的PHP软件中您的冰淇淋机。但是，您会制作其他口味的冰淇淋，每种口味都有自己独特的配方。因此，您需要从一组可重用的基本数学函数开始并进行组合到专门用于芒果的配方中，同时仍留有空间轻松实现该配方待会儿再来吃草莓冰淇淋。一种方法是将几个函数一起组成一个mango_temp函数，如清单3-34和清单3-35所示。 Listing 3-34 sums1.php 1234567891011121314151617181920212223242526272829&lt;?phpfunction double($number) &#123; return $number * 2; &#125;;function negate($number) &#123; return -$number; &#125;;function add_two($number) &#123; return $number + 2; &#125;;function mango_temp ($num_mangos) &#123; return add_two( negate ( double ( $num_mangos ) ) );&#125;;echo mango_temp(6)."°C\n"; Listing 3-35 sums1-output.txt 1-10°C 可以，但是阅读起来不太直观。 由于每个函数都嵌套在前一个函数中，您必须有效地从右向后阅读它，以了解执行顺序。纯函数语言通常具有语法或函数，用于像这样将函数组合在一起，但是在一种更易于阅读的方式。 PHP没有，但不要担心，因为创建自己的PHP很容易（请参见清单3-36）。 Listing 3-36 compose.php 1234567891011121314151617181920212223242526272829303132&lt;?php# This is a special function which simply returns it's input,# and is called the "identity function" in functional programming.function identity ($value) &#123; return $value; &#125;;# This function takes a list of "callables" (function names, closures etc.)# and returns a function composed of all of them, using array_reduce to# reduce them into a single chain of nested functions.function compose(...$functions)&#123; return array_reduce( # This is the array of functions, that we are reducing to one. $functions, # This is the function that operates on each item in $functions and # returns a function with the chain of functions thus far wrapped in # the current one. function ($chain, $function) &#123; return function ($input) use ($chain, $function) &#123; return $function( $chain($input) ); &#125;; &#125;, # And this is the starting point for the reduction, which is where # we use our $identity function as it effectively does nothing 'identity' );&#125; Listing 3-37 sums2.php 123456789101112131415161718192021222324252627&lt;?phpinclude('compose.php');function double($number) &#123; return $number * 2; &#125;;function negate($number) &#123; return -$number; &#125;;function add_two($number) &#123; return $number + 2; &#125;;$mango_temp = compose( 'double', 'negate', 'add_two');echo $mango_temp(6)."°C\n\n ";print_r ($mango_temp); Listing 3-38 sums2-output.txt 1234567891011121314151617181920212223242526272829303132333435-10°CClosure Object( [static] =&gt; Array ( [chain] =&gt; Closure Object ( [static] =&gt; Array ( [chain] =&gt; Closure Object ( [static] =&gt; Array ( [chain] =&gt; identity [function] =&gt; double ) [parameter] =&gt; Array ( [$input] =&gt; &lt;required&gt; ) ) [function] =&gt; negate ) [parameter] =&gt; Array ( [$input] =&gt; &lt;required&gt; ) ) [function] =&gt; add_two ) [parameter] =&gt; Array ( [$input] =&gt; &lt;required&gt; )) 您可以在链的开头（此输出的中间）看到身份函数，每个后续功能依次作为每个“链”闭合的属性。在第1章中，您查看了功能类型代码的样本。 我不想介绍构图在那个阶段发挥作用，以免在早期使水变得浑浊。 但是，现在您知道了组成，您可以重写该示例，如清单3-39所示。 Listing 3-39 example2.php 123456789101112131415&lt;?phprequire_once('image_functions.php');require_once('stats_functions.php');require_once('data_functions.php');require_once('compose.php');$csv_data = file_get_contents('my_data.csv');$make_chart = compose( 'data_to_array', 'generate_stats', 'make_chart_image');file_put_contents('my_chart.png', $make_chart( $csv_data ) ); 这些示例中要注意的一件事是，您的compose函数仅适用于取一个参数。这是故意的，因为函数只能返回单个返回值。如果有功能接受两个参数，compose函数将如何知道从何处使用单个返回值上一个函数调用？您可以使用我已经介绍过的部分函数之类的技术来创建单个函数配合使用。当然，单个参数可以是数组或类似的数据结构，如果您需要在函数之间移动数据集。强制执行单个参数还有助于确保您的功能应保持简单并尽可能限制范围。但是，这通常很实用（有时如果您正在使用其他人的功能或代码，则可以使用此功能）具有多个参数的函数。函数式编程在这里也有介绍。你只是将函数包装在另一个返回函数的函数中！清单3-40和清单3-41显示了使用PHP的本机的str_repeat函数（带有两个参数：字符串和重复次数）应该使这一点更加清楚。 Listing 3-40 strrepeat.php 12345678910111213141516171819202122232425262728293031&lt;?phpinclude('compose.php');# A function to format a string for displayfunction display($string) &#123; echo "The string is : ".$string."\n";&#125;;# Our function to wrap str_repeat.# Note it takes one parameter, the $countfunction repeat_str($count) &#123; # This function returns another (closure) function, # which binds $count, and accepts a single parameter # $string. Note that *this* returned closure is the # actual function that gets used in compose(). return function ($string) use ($count) &#123; return str_repeat($string, $count); &#125;;&#125;;# Now let's compose those two functions together.$ten_chars = compose( repeat_str(10), 'display');# and run our composed functionecho $ten_chars('*'); Listing 3-41 strrepeat-output.txt 1The string is : ********** 理解您在此脚本中所做的工作的关键是要认识到，当您在脚本中使用repeat_str（10）compose语句，不是您要传入的函数。在函数名称后加上括号在此处执行它，然后将其自身替换为返回值。 因此，您正在调用中的repeat_str（10）编写语句定义，而repeat_str（10）返回的函数实际上是由组成为参数。 repeat_str（10）返回一个接受一个参数的闭包（这是您所需要的）（对于您的compose函数）为$ string，但通过使用（$ count）绑定了第二个参数（10）。当然，您不必这样做。 例如，您可以开始创建部分函数（例如repeat_ten_times（$ string）函数），但这是编写多arar函数的更实用的方法在许多情况下。 总结您现在就开始编写功能代码。 在本章中，您研究了各种结构化方式以“函数式”方式运行函数，并研究了诸如递归和部分函数之类的技术如何使您编写更灵活的功能。 您可以使用到目前为止所研究的技术来使其他通用程序控制结构，当您阅读本书的其余部分时，将对其进行研究。 下一个本章中，您将开始研究一些更高级的函数式编程主题。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Provider]]></title>
    <url>%2F2020%2F03%2F24%2FLaravel-Provider%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 简介服务提供者是Laravel应用启动的中心，你自己的应用以及所有Laravel的核心服务都是通过服务提供者启动。 但是，我们所谓的「启动」指的是什么？通常，这意味着注册服务，包括注册服务容器绑定、事件监听器、中间件甚至路由。服务提供者是应用配置的中心。 如果你打开Laravel自带的config/app.php文件，将会看到一个providers数组，这里就是应用所要加载的所有服务提供者类，当然，其中很多是延迟加载的，也就是说不是每次请求都会被加载，只有真的用到它们的时候才会加载。 通过本文档，你将会学习如何编写自己的服务提供者并在Laravel应用中注册它们。 编写服务提供者所有的服务提供者都继承自Illuminate\Support\ServiceProvider类。大部分服务提供者都包含两个方法：register和boot。在register方法中，你唯一要做的事情就是绑定服务到服务容器，不要尝试在该方法中注册事件监听器，路由或者任何其它功能。 通过Artisan命令make:provider即可生成一个新的提供者： 1php artisan make:provider RiakServiceProvider register方法正如前面所提到的，在register方法中只绑定服务到服务容器，而不要做其他事情，否则，一不小心就可能用到一个尚未被加载的服务提供者提供的服务。 现在让我们来看看一个基本的服务提供者长什么样，在任何服务提供者方法中，都可以通过$app属性来访问服务容器： 1234567891011121314151617181920&lt;?phpnamespace App\Providers;use Riak\Connection;use Illuminate\Support\ServiceProvider;class RiakServiceProvider extends ServiceProvider&#123; /** * 在容器中注册绑定. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton(Connection::class, function ($app) &#123; return new Connection(config('riak')); &#125;); &#125;&#125; 该服务提供者只定义了一个register方法，并使用该方法在服务容器中定义了一个Riak\Connection的实现。如果你不知道服务容器是如何工作的，请参考其文档。 bindings和singletons属性 如果你的服务提供者注册了很多简单的绑定，你可能希望使用bindings和singletons属性来替代手动注册每个容器绑定以简化代码。当服务提供者被框架加载后，会自动检查这些属性并注册相应绑定： 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\Providers;use App\Contracts\ServerProvider;use App\Contracts\DowntimeNotifier;use App\Services\ServerToolsProvider;use Illuminate\Support\ServiceProvider;use App\Services\PingdomDowntimeNotifier;use App\Services\DigitalOceanServerProvider;class AppServiceProvider extends ServiceProvider&#123; /** * All of the container bindings that should be registered. * * @var array */ public $bindings = [ ServerProvider::class =&gt; DigitalOceanServerProvider::class, ]; /** * All of the container singletons that should be registered. * * @var array */ public $singletons = [ DowntimeNotifier::class =&gt; PingdomDowntimeNotifier::class, ServerToolsProvider::class =&gt; ServerToolsProvider::class, ];&#125; boot方法如果我们想要在服务提供者中注册视图Composer该怎么做？这就要用到boot方法了。该方法在所有服务提供者被注册以后才会被调用，这就是说我们可以在其中访问框架已注册的所有其它服务： 12345678910111213141516171819&lt;?phpnamespace App\Providers;use Illuminate\Support\ServiceProvider;class ComposerServiceProvider extends ServiceProvider&#123; /** * Perform post-registration booting of services. * * @return void */ public function boot() &#123; view()-&gt;composer('view', function () &#123; // &#125;); &#125;&#125; boot方法的依赖注入 我们可以在boot方法中对依赖进行类型提示，服务容器会自动注入你所需要的依赖： 1234567use Illuminate\Contracts\Routing\ResponseFactory;public function boot(ResponseFactory $response)&#123; $response-&gt;macro('caps', function ($value) &#123; // &#125;);&#125; 注册服务提供者所有服务提供者都是通过配置文件config/app.php中进行注册，该文件包含了一个列出所有服务提供者名字的providers数组，默认情况下，其中列出了所有核心服务提供者，这些服务提供者启动 Laravel核心组件，比如邮件、队列、缓存等等。 要注册你自己的服务提供者，只需要将其追加到该数组中即可： 1234'providers' =&gt; [ // 其它服务提供者 App\Providers\ComposerServiceProvider::class,], 延迟加载服务提供者如果你的提供者仅仅只是在服务容器中注册绑定，你可以选择延迟加载该绑定直到注册绑定的服务真的需要时再加载，延迟加载这样的一个提供者将会提升应用的性能，因为它不会在每次请求时都从文件系统加载。 Laravel编译并保存所有延迟服务提供者提供的服务及服务提供者的类名。然后，只有当你尝试解析其中某个服务时Laravel才会加载其服务提供者。 想要延迟加载一个提供者，需要实现\Illuminate\Contracts\Support\DeferrableProvider接口并定义一个provides方法，provides方法会返回通过服务提供者注册的服务容器绑定： 1234567891011121314151617181920212223242526272829303132&lt;?phpnamespace App\Providers;use Riak\Connection;use Illuminate\Support\ServiceProvider;use Illuminate\Contracts\Support\DeferrableProvider;class RiakServiceProvider extends ServiceProvider implements DeferrableProvider&#123; /** * Register the service provider. * * @return void */ public function register() &#123; $this-&gt;app-&gt;singleton(Connection::class, function ($app) &#123; return new Connection($app['config']['riak']); &#125;); &#125; /** * Get the services provided by the provider. * * @return array */ public function provides() &#123; return [Connection::class]; &#125;&#125; 源码 Illuminate\Support\ServiceProvider.php 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306&lt;?phpnamespace Illuminate\Support;use Illuminate\Console\Application as Artisan;use Illuminate\Contracts\Support\DeferrableProvider;abstract class ServiceProvider&#123; /** * The application instance. * * @var \Illuminate\Contracts\Foundation\Application */ protected $app; /** * The paths that should be published. * * @var array */ public static $publishes = []; /** * The paths that should be published by group. * * @var array */ public static $publishGroups = []; /** * Create a new service provider instance. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public function __construct($app) &#123; $this-&gt;app = $app; &#125; /** * Register any application services. * * @return void */ public function register() &#123; // &#125; /** * Merge the given configuration with the existing configuration. * * @param string $path * @param string $key * @return void */ protected function mergeConfigFrom($path, $key) &#123; if (! $this-&gt;app-&gt;configurationIsCached()) &#123; $this-&gt;app['config']-&gt;set($key, array_merge( require $path, $this-&gt;app['config']-&gt;get($key, []) )); &#125; &#125; /** * Load the given routes file if routes are not already cached. * * @param string $path * @return void */ protected function loadRoutesFrom($path) &#123; if (! $this-&gt;app-&gt;routesAreCached()) &#123; require $path; &#125; &#125; /** * Register a view file namespace. * * @param string|array $path * @param string $namespace * @return void */ protected function loadViewsFrom($path, $namespace) &#123; if (is_array($this-&gt;app-&gt;config['view']['paths'])) &#123; foreach ($this-&gt;app-&gt;config['view']['paths'] as $viewPath) &#123; if (is_dir($appPath = $viewPath.'/vendor/'.$namespace)) &#123; $this-&gt;app['view']-&gt;addNamespace($namespace, $appPath); &#125; &#125; &#125; $this-&gt;app['view']-&gt;addNamespace($namespace, $path); &#125; /** * Register a translation file namespace. * * @param string $path * @param string $namespace * @return void */ protected function loadTranslationsFrom($path, $namespace) &#123; $this-&gt;app['translator']-&gt;addNamespace($namespace, $path); &#125; /** * Register a JSON translation file path. * * @param string $path * @return void */ protected function loadJsonTranslationsFrom($path) &#123; $this-&gt;app['translator']-&gt;addJsonPath($path); &#125; /** * Register a database migration path. * * @param array|string $paths * @return void */ protected function loadMigrationsFrom($paths) &#123; $this-&gt;app-&gt;afterResolving('migrator', function ($migrator) use ($paths) &#123; foreach ((array) $paths as $path) &#123; $migrator-&gt;path($path); &#125; &#125;); &#125; /** * Register paths to be published by the publish command. * * @param array $paths * @param mixed $groups * @return void */ protected function publishes(array $paths, $groups = null) &#123; $this-&gt;ensurePublishArrayInitialized($class = static::class); static::$publishes[$class] = array_merge(static::$publishes[$class], $paths); foreach ((array) $groups as $group) &#123; $this-&gt;addPublishGroup($group, $paths); &#125; &#125; /** * Ensure the publish array for the service provider is initialized. * * @param string $class * @return void */ protected function ensurePublishArrayInitialized($class) &#123; if (! array_key_exists($class, static::$publishes)) &#123; static::$publishes[$class] = []; &#125; &#125; /** * Add a publish group / tag to the service provider. * * @param string $group * @param array $paths * @return void */ protected function addPublishGroup($group, $paths) &#123; if (! array_key_exists($group, static::$publishGroups)) &#123; static::$publishGroups[$group] = []; &#125; static::$publishGroups[$group] = array_merge( static::$publishGroups[$group], $paths ); &#125; /** * Get the paths to publish. * * @param string $provider * @param string $group * @return array */ public static function pathsToPublish($provider = null, $group = null) &#123; if (! is_null($paths = static::pathsForProviderOrGroup($provider, $group))) &#123; return $paths; &#125; return collect(static::$publishes)-&gt;reduce(function ($paths, $p) &#123; return array_merge($paths, $p); &#125;, []); &#125; /** * Get the paths for the provider or group (or both). * * @param string|null $provider * @param string|null $group * @return array */ protected static function pathsForProviderOrGroup($provider, $group) &#123; if ($provider &amp;&amp; $group) &#123; return static::pathsForProviderAndGroup($provider, $group); &#125; elseif ($group &amp;&amp; array_key_exists($group, static::$publishGroups)) &#123; return static::$publishGroups[$group]; &#125; elseif ($provider &amp;&amp; array_key_exists($provider, static::$publishes)) &#123; return static::$publishes[$provider]; &#125; elseif ($group || $provider) &#123; return []; &#125; &#125; /** * Get the paths for the provider and group. * * @param string $provider * @param string $group * @return array */ protected static function pathsForProviderAndGroup($provider, $group) &#123; if (! empty(static::$publishes[$provider]) &amp;&amp; ! empty(static::$publishGroups[$group])) &#123; return array_intersect_key(static::$publishes[$provider], static::$publishGroups[$group]); &#125; return []; &#125; /** * Get the service providers available for publishing. * * @return array */ public static function publishableProviders() &#123; return array_keys(static::$publishes); &#125; /** * Get the groups available for publishing. * * @return array */ public static function publishableGroups() &#123; return array_keys(static::$publishGroups); &#125; /** * Register the package's custom Artisan commands. * * @param array|mixed $commands * @return void */ public function commands($commands) &#123; $commands = is_array($commands) ? $commands : func_get_args(); Artisan::starting(function ($artisan) use ($commands) &#123; $artisan-&gt;resolveCommands($commands); &#125;); &#125; /** * Get the services provided by the provider. * * @return array */ public function provides() &#123; return []; &#125; /** * Get the events that trigger this service provider to register. * * @return array */ public function when() &#123; return []; &#125; /** * Determine if the provider is deferred. * * @return bool */ public function isDeferred() &#123; return $this instanceof DeferrableProvider; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Container]]></title>
    <url>%2F2020%2F03%2F22%2FLaravel-Container%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： $a实例 = 服务容器（Container）::getInstance(‘A’);自动注入是这样用的。怎么理解？ bound是bind的过去式，是否被绑定。 简介深入理解Laravel服务容器对于构建功能强大的大型Laravel应用而言至关重要，对于贡献代码到Laravel核心也很有帮助。 Laravel服务容器是一个用于管理类依赖和执行依赖注入的强大工具。依赖注入其实质是通过构造函数或者某些情况下通过「setter」方法将类依赖注入到类中。 让我们看一个简单的例子：12345678910111213141516171819202122232425262728293031323334353637383940&lt;?phpnamespace App\Http\Controllers;use App\User;use App\Repositories\UserRepository;use App\Http\Controllers\Controller;class UserController extends Controller&#123; /** * The user repository implementation. * * @var UserRepository */ protected $users; /** * Create a new controller instance. * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) &#123; $this-&gt;users = $users; &#125; /** * Show the profile for the given user. * * @param int $id * @return Response */ public function show($id) &#123; $user = $this-&gt;users-&gt;find($id); return view('user.profile', ['user' =&gt; $user]); &#125;&#125; 在本例中，UserController需要从数据源获取用户，所以，我们注入了一个可以获取用户的服务UserRepository，其扮演的角色类似使用Eloquent从数据库获取用户信息。注入UserRepository后，我们可以在其基础上封装其他实现，也可以模拟或者创建一个假的UserRepository实现用于测试。 绑定绑定基础几乎所有的服务容器绑定都是在服务提供者中完成。因此本文档的演示例子用到的容器都是在服务提供者中绑定。 注：如果一个类没有基于任何接口那么就没有必要将其绑定到容器。容器并不需要被告知如何构建对象，因为它会使用PHP的反射服务自动解析出具体的对象。 简单的绑定 在一个服务提供者中，可以通过$this-&gt;app变量访问容器，然后使用bind方法注册一个绑定，该方法需要两个参数，第一个参数是我们想要注册的类名或接口名称，第二个参数是返回类的实例的闭包：1234// API类依赖HttpClient$this-&gt;app-&gt;bind('HelpSpot\API', function ($app) &#123; return new HelpSpot\API($app-&gt;make('HttpClient'));&#125;); 注意到我们将容器本身作为解析器的一个参数，然后我们可以使用该容器来解析我们正在构建的对象的子依赖。 绑定一个单例 singleton方法绑定一个只会解析一次的类或接口到容器，然后接下来对容器的调用将会返回同一个对象实例： 123$this-&gt;app-&gt;singleton('HelpSpot\API', function ($app) &#123; return new HelpSpot\API($app-&gt;make('HttpClient'));&#125;); 绑定实例 你还可以使用instance方法绑定一个已存在的对象实例到容器，随后调用容器将总是返回给定的实例： 123$api = new HelpSpot\API(new HttpClient);$this-&gt;app-&gt;instance('HelpSpot\API', $api); 绑定原始值 你可能有一个接收注入类的类，同时需要注入一个原生的数值比如整型，可以结合上下文轻松注入这个类需要的任何值： 123$this-&gt;app-&gt;when('App\Http\Controllers\UserController') -&gt;needs('$variableName') -&gt;give($value); 绑定接口到实现服务容器的一个非常强大的功能是其绑定接口到实现。我们假设有一个EventPusher接口及其实现类RedisEventPusher，编写完该接口的RedisEventPusher实现后，就可以将其注册到服务容器：1234$this-&gt;app-&gt;bind( 'App\Contracts\EventPusher', 'App\Services\RedisEventPusher'); 这段代码告诉容器当一个类需要EventPusher的实现时将会注入RedisEventPusher，现在我们可以在构造器或者任何其它通过服务容器注入依赖的地方进行EventPusher接口的依赖注入：123456789101112use App\Contracts\EventPusher;/** * 创建一个新的类实例 * * @param EventPusher $pusher * @return void */public function __construct(EventPusher $pusher)&#123; $this-&gt;pusher = $pusher;&#125; 上下文绑定有时侯我们可能有两个类使用同一个接口，但我们希望在每个类中注入不同实现，例如，两个控制器依赖Illuminate\Contracts\Filesystem\Filesystem契约的不同实现。Laravel为此定义了简单、平滑的接口：12345678910111213141516use Illuminate\Support\Facades\Storage;use App\Http\Controllers\VideoController;use App\Http\Controllers\PhotoControllers;use Illuminate\Contracts\Filesystem\Filesystem;$this-&gt;app-&gt;when(PhotoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return Storage::disk('local'); &#125;);$this-&gt;app-&gt;when(VideoController::class) -&gt;needs(Filesystem::class) -&gt;give(function () &#123; return Storage::disk('s3'); &#125;); 标签少数情况下，我们需要解析特定分类下的所有绑定，例如，你正在构建一个接收多个不同Report接口实现的报告聚合器，在注册完Report实现之后，可以通过tag方法给它们分配一个标签： 123456789$this-&gt;app-&gt;bind('SpeedReport', function () &#123; //&#125;);$this-&gt;app-&gt;bind('MemoryReport', function () &#123; //&#125;);$this-&gt;app-&gt;tag(['SpeedReport', 'MemoryReport'], 'reports'); 这些服务被打上标签后，可以通过tagged方法来轻松解析它们： 123$this-&gt;app-&gt;bind('ReportAggregator', function ($app) &#123; return new ReportAggregator($app-&gt;tagged('reports'));&#125;); 扩展绑定extend方法允许对解析服务进行修改。例如，当服务被解析后，可以运行额外代码装饰或配置该服务。extend方法接收一个闭包来返回修改后的服务： 123$this-&gt;app-&gt;extend(Service::class, function($service) &#123; return new DecoratedService($service);&#125;); 解析make方法 有很多方式可以从容器中解析对象，首先，你可以使用make方法，该方法接收你想要解析的类名或接口名作为参数：1$fooBar = $this-&gt;app-&gt;make('HelpSpot\API'); 如果你所在的代码位置访问不了$app变量，可以使用辅助函数resolve： 1$api = resolve('HelpSpot\API'); 某些类的依赖不能通过容器来解析，你可以通过关联数组方式将其传递传递到makeWith方法来注入： 1$api = $this-&gt;app-&gt;makeWith('HelpSpot\API', ['id' =&gt; 1]); 自动注入 最后，也是最常用的，你可以简单的通过在类的构造函数中对依赖进行类型提示来从容器中解析对象，控制器、事件监听器、中间件等都是通过这种方式。此外，你还可以在队列任务的handle方法中进行类型提示。在具体实践中，这是大多数对象从容器中解析的方式。 容器会自动为其解析类注入依赖，例如，你可以在控制器的构造函数中为应用定义的仓库进行类型提示，该仓库会自动解析并注入该类： 12345678910111213141516171819202122232425262728293031323334&lt;?phpnamespace App\Http\Controllers;use App\Users\Repository as UserRepository;class UserController extends Controller&#123; /** * 用户仓库实例 */ protected $users; /** * 创建一个控制器实例 * * @param UserRepository $users * @return void */ public function __construct(UserRepository $users) &#123; $this-&gt;users = $users; &#125; /** * 通过指定ID显示用户 * * @param int $id * @return Response */ public function show($id) &#123; // &#125;&#125; 容器事件服务容器在每一次解析对象时都会触发一个事件，可以使用resolving方法监听该事件： 1234567$this-&gt;app-&gt;resolving(function ($object, $app) &#123; // Called when container resolves object of any type...&#125;);$this-&gt;app-&gt;resolving(HelpSpot\API::class, function ($api, $app) &#123; // Called when container resolves objects of type "HelpSpot\API"...&#125;); 正如你所看到的，被解析的对象将会传递给回调函数，从而允许你在对象被传递给消费者之前为其设置额外属性。 PSR-11Laravel的服务容器实现了PSR-11接口。所以，你可以通过类型提示PSR-11容器接口来获取Laravel容器的实例： 1234567use Psr\Container\ContainerInterface;Route::get('/', function (ContainerInterface $container) &#123; $service = $container-&gt;get('Service'); //&#125;); 如果传入的标识不能被解析则会抛出异常。如果该标识未被绑定的话抛出的异常会是Psr\Container\NotFoundExceptionInterface接口实例；如果标识已绑定但未能成功解析则抛出的异常是Psr\Container\ContainerExceptionInterface接口实例。 源码Container.php不依赖任何类，只实现了接口，复制到别的框架或单独使用都是可以的。 ArrayAccess首先是ArrayAccess。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778&lt;?phpnamespace Illuminate\Container;use ArrayAccess;class Container implements ArrayAccess&#123; /** * Determine if a given offset exists. * * @param string $key * @return bool */ public function offsetExists($key) &#123; return $this-&gt;bound($key); &#125; /** * Get the value at a given offset. * * @param string $key * @return mixed */ public function offsetGet($key) &#123; return $this-&gt;make($key); &#125; /** * Set the value at a given offset. * * @param string $key * @param mixed $value * @return void */ public function offsetSet($key, $value) &#123; $this-&gt;bind($key, $value instanceof Closure ? $value : function () use ($value) &#123; return $value; &#125;); &#125; /** * Unset the value at a given offset. * * @param string $key * @return void */ public function offsetUnset($key) &#123; unset($this-&gt;bindings[$key], $this-&gt;instances[$key], $this-&gt;resolved[$key]); &#125; /** * Dynamically access container services. * * @param string $key * @return mixed */ public function __get($key) &#123; return $this[$key]; &#125; /** * Dynamically set container services. * * @param string $key * @param mixed $value * @return void */ public function __set($key, $value) &#123; $this[$key] = $value; &#125;&#125; 单例相关12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788&lt;?phpnamespace Illuminate\Container;use ArrayAccess;class Container implements ArrayAccess&#123; /** * The current globally available container (if any). * * 这是Container自身的实例 * * @var static */ protected static $instance; /** * Drop all of the stale instances and aliases. * * @param string $abstract * @return void */ protected function dropStaleInstances($abstract) &#123; unset($this-&gt;instances[$abstract], $this-&gt;aliases[$abstract]); &#125; /** * Remove a resolved instance from the instance cache. * * @param string $abstract * @return void */ public function forgetInstance($abstract) &#123; unset($this-&gt;instances[$abstract]); &#125; /** * Clear all of the instances from the container. * * @return void */ public function forgetInstances() &#123; $this-&gt;instances = []; &#125; /** * Flush the container of all bindings and resolved instances. * * @return void */ public function flush() &#123; $this-&gt;aliases = []; $this-&gt;resolved = []; $this-&gt;bindings = []; $this-&gt;instances = []; $this-&gt;abstractAliases = []; &#125; /** * Get the globally available instance of the container. * * @return static */ public static function getInstance() &#123; if (is_null(static::$instance)) &#123; static::$instance = new static; &#125; return static::$instance; &#125; /** * Set the shared instance of the container. * * @param \Illuminate\Contracts\Container\Container|null $container * @return \Illuminate\Contracts\Container\Container|static */ public static function setInstance(ContainerContract $container = null) &#123; return static::$instance = $container; &#125;&#125; 属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123&lt;?phpnamespace Illuminate\Container;use ArrayAccess;class Container implements ArrayAccess&#123; /** * An array of the types that have been resolved. * * @var bool[] */ protected $resolved = []; /** * The container's bindings. * * @var array[] */ protected $bindings = []; /** * The container's method bindings. * * @var \Closure[] */ protected $methodBindings = []; /** * The container's shared instances. * * 这是Container维护的实例 * * * @var object[] */ protected $instances = []; /** * The registered type aliases. * * @var string[] */ protected $aliases = []; /** * The registered aliases keyed by the abstract name. * * @var array[] */ protected $abstractAliases = []; /** * The extension closures for services. * * @var array[] */ protected $extenders = []; /** * All of the registered tags. * * @var array[] */ protected $tags = []; /** * The stack of concretions currently being built. * * @var array[] */ protected $buildStack = []; /** * The parameter override stack. * * @var array[] */ protected $with = []; /** * The contextual binding map. * * @var array[] */ public $contextual = []; /** * All of the registered rebound callbacks. * * @var array[] */ protected $reboundCallbacks = []; /** * All of the global resolving callbacks. * * @var \Closure[] */ protected $globalResolvingCallbacks = []; /** * All of the global after resolving callbacks. * * @var \Closure[] */ protected $globalAfterResolvingCallbacks = []; /** * All of the resolving callbacks by class type. * * @var array[] */ protected $resolvingCallbacks = []; /** * All of the after resolving callbacks by class type. * * @var array[] */ protected $afterResolvingCallbacks = [];&#125; 从下往上从build开始： build和其相关函数。只有build是public，其他都是protected。 有用到反射来创建实例和依赖的类的实例。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215/** * Instantiate a concrete instance of the given type. * * @param \Closure|string $concrete * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */public function build($concrete)&#123; // If the concrete type is actually a Closure, we will just execute it and // hand back the results of the functions, which allows functions to be // used as resolvers for more fine-tuned resolution of these objects. // 先忽略，看不是闭包的参数 if ($concrete instanceof Closure) &#123; return $concrete($this, $this-&gt;getLastParameterOverride()); &#125; try &#123; $reflector = new ReflectionClass($concrete); &#125; catch (ReflectionException $e) &#123; throw new BindingResolutionException("Target class [$concrete] does not exist.", 0, $e); &#125; // If the type is not instantiable, the developer is attempting to resolve // an abstract type such as an Interface or Abstract Class and there is // no binding registered for the abstractions so we need to bail out. if (! $reflector-&gt;isInstantiable()) &#123; // Instantiable able 形容词 可实例化的。判断类是否可以实例化 return $this-&gt;notInstantiable($concrete); // 这个函数专门用于抛出异常 &#125; $this-&gt;buildStack[] = $concrete; // buildStack是个包含string类型的数组 concrete是一个类路径 $constructor = $reflector-&gt;getConstructor(); // If there are no constructors, that means there are no dependencies then // we can just resolve the instances of the objects right away, without // resolving any other types or dependencies out of these containers. if (is_null($constructor)) &#123; array_pop($this-&gt;buildStack); // 删除数组中的最后一个元素 return new $concrete; &#125; $dependencies = $constructor-&gt;getParameters(); // Once we have all the constructor's parameters we can create each of the // dependency instances and then use the reflection instances to make a // new instance of this class, injecting the created dependencies in. try &#123; $instances = $this-&gt;resolveDependencies($dependencies); &#125; catch (BindingResolutionException $e) &#123; array_pop($this-&gt;buildStack); throw $e; &#125; array_pop($this-&gt;buildStack); return $reflector-&gt;newInstanceArgs($instances);&#125;/** * Resolve all of the dependencies from the ReflectionParameters. * * 构造函数的参数有可能是类，也有可能是数值，字符串等类型 * * @param \ReflectionParameter[] $dependencies * @return array * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolveDependencies(array $dependencies)&#123; $results = []; foreach ($dependencies as $dependency) &#123; // If the dependency has an override for this particular build we will use // that instead as the value. Otherwise, we will continue with this run // of resolutions and let reflection attempt to determine the result. if ($this-&gt;hasParameterOverride($dependency)) &#123; $results[] = $this-&gt;getParameterOverride($dependency); continue; &#125; // If the class is null, it means the dependency is a string or some other // primitive type which we can not resolve since it is not a class and // we will just bomb out with an error since we have no-where to go. $result = is_null(Util::getParameterClassName($dependency)) // 判断是类还是非类 ? $this-&gt;resolvePrimitive($dependency) // 非类类型 : $this-&gt;resolveClass($dependency); // 类 if ($dependency-&gt;isVariadic()) &#123; // Variadic 可变 检查是否是可变参数 // 可变参数 function demo( ...$parameter)&#123;&#125; $results = array_merge($results, $result); &#125; else &#123; $results[] = $result; &#125; &#125; return $results;&#125;/** * Resolve a non-class hinted primitive dependency. * * @param \ReflectionParameter $parameter * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolvePrimitive(ReflectionParameter $parameter)&#123; if (! is_null($concrete = $this-&gt;getContextualConcrete('$'.$parameter-&gt;getName()))) &#123; return $concrete instanceof Closure ? $concrete($this) : $concrete; &#125; if ($parameter-&gt;isDefaultValueAvailable()) &#123; return $parameter-&gt;getDefaultValue(); &#125; $this-&gt;unresolvablePrimitive($parameter);&#125;/** * Resolve a class based dependency from the container. * * @param \ReflectionParameter $parameter * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolveClass(ReflectionParameter $parameter)&#123; try &#123; return $parameter-&gt;isVariadic() ? $this-&gt;resolveVariadicClass($parameter) : $this-&gt;make(Util::getParameterClassName($parameter)); &#125; // If we can not resolve the class instance, we will check to see if the value // is optional, and if it is we will return the optional parameter value as // the value of the dependency, similarly to how we do this with scalars. catch (BindingResolutionException $e) &#123; if ($parameter-&gt;isDefaultValueAvailable()) &#123; return $parameter-&gt;getDefaultValue(); &#125; if ($parameter-&gt;isVariadic()) &#123; return []; &#125; throw $e; &#125;&#125;/** * Resolve a class based variadic dependency from the container. * * @param \ReflectionParameter $parameter * @return mixed */protected function resolveVariadicClass(ReflectionParameter $parameter)&#123; $className = Util::getParameterClassName($parameter); $abstract = $this-&gt;getAlias($className); if (! is_array($concrete = $this-&gt;getContextualConcrete($abstract))) &#123; return $this-&gt;make($className); &#125; return array_map(function ($abstract) &#123; return $this-&gt;resolve($abstract); &#125;, $concrete);&#125;/** * Throw an exception that the concrete is not instantiable. * * @param string $concrete * @return void * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function notInstantiable($concrete)&#123; if (! empty($this-&gt;buildStack)) &#123; $previous = implode(', ', $this-&gt;buildStack); $message = "Target [$concrete] is not instantiable while building [$previous]."; &#125; else &#123; $message = "Target [$concrete] is not instantiable."; &#125; throw new BindingResolutionException($message);&#125;/** * Throw an exception for an unresolvable primitive. * * @param \ReflectionParameter $parameter * @return void * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function unresolvablePrimitive(ReflectionParameter $parameter)&#123; $message = "Unresolvable dependency resolving [$parameter] in class &#123;$parameter-&gt;getDeclaringClass()-&gt;getName()&#125;"; throw new BindingResolutionException($message);&#125; 然后是Resolve 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667/** * Resolve the given type from the container. * * @param string $abstract * @param array $parameters * @param bool $raiseEvents * @return mixed * * @throws \Illuminate\Contracts\Container\BindingResolutionException */protected function resolve($abstract, $parameters = [], $raiseEvents = true)&#123; $abstract = $this-&gt;getAlias($abstract); $concrete = $this-&gt;getContextualConcrete($abstract); $needsContextualBuild = ! empty($parameters) || ! is_null($concrete); // If an instance of the type is currently being managed as a singleton we'll // just return an existing instance instead of instantiating new instances // so the developer can keep using the same objects instance every time. if (isset($this-&gt;instances[$abstract]) &amp;&amp; ! $needsContextualBuild) &#123; return $this-&gt;instances[$abstract]; &#125; $this-&gt;with[] = $parameters; if (is_null($concrete)) &#123; $concrete = $this-&gt;getConcrete($abstract); &#125; // We're ready to instantiate an instance of the concrete type registered for // the binding. This will instantiate the types, as well as resolve any of // its "nested" dependencies recursively until all have gotten resolved. if ($this-&gt;isBuildable($concrete, $abstract)) &#123; $object = $this-&gt;build($concrete); &#125; else &#123; $object = $this-&gt;make($concrete); &#125; // If we defined any extenders for this type, we'll need to spin through them // and apply them to the object being built. This allows for the extension // of services, such as changing configuration or decorating the object. foreach ($this-&gt;getExtenders($abstract) as $extender) &#123; $object = $extender($object, $this); &#125; // If the requested type is registered as a singleton we'll want to cache off // the instances in "memory" so we can return it later without creating an // entirely new instance of an object on each subsequent request for it. if ($this-&gt;isShared($abstract) &amp;&amp; ! $needsContextualBuild) &#123; $this-&gt;instances[$abstract] = $object; &#125; if ($raiseEvents) &#123; $this-&gt;fireResolvingCallbacks($abstract, $object); &#125; // Before returning, we will also set the resolved flag to "true" and pop off // the parameter overrides for this build. After those two things are done // we will be ready to return back the fully constructed class instance. $this-&gt;resolved[$abstract] = true; array_pop($this-&gt;with); return $object;&#125; with属性： 123456789101112131415161718192021222324252627282930313233/** * Determine if the given dependency has a parameter override. * * @param \ReflectionParameter $dependency * @return bool */protected function hasParameterOverride($dependency)&#123; return array_key_exists( $dependency-&gt;name, $this-&gt;getLastParameterOverride() );&#125;/** * Get a parameter override for a dependency. * * @param \ReflectionParameter $dependency * @return mixed */protected function getParameterOverride($dependency)&#123; return $this-&gt;getLastParameterOverride()[$dependency-&gt;name];&#125;/** * Get the last parameter override. * * @return array */protected function getLastParameterOverride()&#123; return count($this-&gt;with) ? end($this-&gt;with) : [];&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中的闭包]]></title>
    <url>%2F2020%2F03%2F12%2FPHP%E4%B8%AD%E7%9A%84%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 闭包是个Closure类吗？ 闭包在创建时就会为传入的参数、use中的变量创建新的内存，相当于clone一份。怎么理解？ Closure的bind方法是什么意思？ 可以在匿名函数中使用$this关键字吗？ 在PHP中闭包与匿名函数是一个概念：123$sayHello = function($name)&#123; echo("Hello $name");&#125;; 在PHP中闭包是像函数的对象，是个Closure类，只是能够像函数一样调用：1$sayHello("world"); 输出：1Hello world 1var_dump($sayHello instanceof Closure); 输出：1boolean(true) 闭包在创建时就会为传入的参数、use中的变量创建新的内存，相当于clone一份，因此与函数外部的变量变化无关；1234567891011$name = 'world'; $sayHello = function() use($name)&#123; echo("Hello $name");&#125;; // 这里不要忘记结束的;号 $sayHello(); // 必须函数方式调用，即用(), 输出Hello world $name = 'zj'; $sayHello();// 输出Hello world 如果想使闭包内和外部的变量同步，则use中传入引用即可，就是加个&amp;：1234567891011$name = 'world'; $sayHello = function() use(&amp;$name)&#123; // 传入了引用 echo("Hello $name");&#125;;//这里不要忘记结束的;号 $sayHello(); // 必须函数方式调用，即用(), 输出Hello world $name = 'zj'; $sayHello();// 输出Hello zj Closure类有两个方法：bind()和bindTo() Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。 Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。 通过这两个方法可以给类扩展复杂功能，类似策略模式，将实际操作与类定义解耦。比如通过bing为用户类增加行为：1234567891011121314151617181920Class User&#123; public $name = 'Tom'; public $age = 10; private $action = []; //...&#125;$sayHello = function()&#123; echo("Hello &#123;$this-&gt;name&#125;\n");&#125;; $swimming = function()&#123; echo("&#123;$this-&gt;name&#125; is swimming\n");&#125;; $bindSayHello = Closure::bind($sayHello, new User());$bindSwimming = Closure::bind($swimming, new User());$bindSayHello();$bindSwimming(); 输出：12Hello Tom Tom is swimming 可以把类写的更优雅点：123456789101112131415161718192021222324252627282930313233343536Class user&#123; public $name = 'Tom'; public $age = 10; private $action = []; public function addAction($actionName, $actionFunction)&#123; $this-&gt;action[$actionName] = Closure::bind($actionFunction, $this); &#125; public function doAction()&#123; foreach ($this-&gt;action as $actionFunction) &#123; $actionFunction($this-&gt;name); &#125; &#125;&#125; $sayHello = function()&#123; echo("Hello &#123;$this-&gt;name&#125;\n");&#125;; $swimming = function()&#123; echo("&#123;$this-&gt;name&#125; is swimming\n");&#125;; $bindSayHello = Closure::bind($sayHello, new user());$bindSayHello(); $user = new user(); $user-&gt;addAction('sayHello', $sayHello);$user-&gt;addAction('swimming', $swimming);$user-&gt;doAction();// 输出：// Hello Tom // Hello Tom // Tom is swimming bindTo方法与bind类似，只是通过闭包调用的，将自身绑定到对象或类上。 bind及bindTo方法都有第三个参数，确定绑定的作用域。 发现一个闭包实现中间件的例子，搬来作为补充学习： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;?php// 框架核心应用层$application = function($name) &#123; echo "this is a &#123;$name&#125; application\n";&#125;; // 前置校验中间件$auth = function($handler) &#123; return function($name) use ($handler) &#123; echo "&#123;$name&#125; need a auth middleware\n"; return $handler($name); &#125;;&#125;; // 前置过滤中间件$filter = function($handler) &#123; return function($name) use ($handler) &#123; echo "&#123;$name&#125; need a filter middleware\n"; return $handler($name); &#125;;&#125;; // 后置日志中间件$log = function($handler) &#123; return function($name) use ($handler) &#123; $return = $handler($name); echo "&#123;$name&#125; need a log middleware\n"; return $return; &#125;;&#125;; // 中间件栈$stack = []; // 打包function pack_middleware($handler, $stack)&#123; foreach (array_reverse($stack) as $key =&gt; $middleware) &#123; $handler = $middleware($handler); &#125; return $handler;&#125; // 注册中间件// 这里用的都是全局中间件，实际应用时还可以为指定路由注册局部中间件$stack['log'] = $log;$stack['filter'] = $filter;$stack['auth'] = $auth; $run = pack_middleware($application, $stack); 输出：1234Laravle need a filter middlewareLaravle need a auth middlewarethis is a Laravle applicationLaravle need a log middleware 打包程序 中间件的执行顺序是由打包函数(pack_middleware)决定，这里返回的闭包实际上相当于:12$run = $log($filter($auth($application)));$run('Laravle'); 编写规范中间件要要满足一定的规范：总是返回一个闭包，闭包中总是传入相同的参数（由主要逻辑决定）， 闭包总是返回句柄(handler)的执行结果； 如果中间件的逻辑在返回句柄return $handler($name)前完成，就是前置中间件，否则为后置中间件。 一、什么是闭包 理论上讲，闭包和匿名函数是不同的概念，不过，php将其视作相同的概念。 闭包和匿名函数其实是伪装成函数的对象，如果审查php闭包和匿名函数，会发现他们是Closure类的实例，闭包和字符串或整数一样，也是一等值类型。 二、创建一个闭包12345$closure = function ($name) &#123; return sprintf('Hello %s', $name);&#125;; echo $closure('Yee Jason'); 输出 Hello Yee Jason. 之所以能调用$closure变量，是因为这个变量的值是一个闭包，而且闭包对象实现了__invoke()魔术方法，只要变量名后面有()，php就会查并调用__invoke() 方法。 我通常把闭包当做函数和方法的回调使用，很多php函数都会用到回调函数，例如array_map和preg_replace_callback()是使用匿名函数的绝佳时机，记住，闭包和其他值一样，可以作为参数传入其他php函数。12345$numberPlusOne = array_map(function($number) &#123; return $number + 1;&#125;, [1, 2, 3]); print_r($numberPlusOne); 在PHP闭包之前, php开发者无法选择，只能单独创建具名函数，然后引用那个函数，这么做，代码执行的稍微慢一点， 而且把回调的实现和使用场所隔离开了，传统的php代码：1234567function incrementNumber($number)&#123; return $number + 1;&#125; $numberPlusOne = array_map('incrementNumber', [1, 2, 3]);print_r($numberPlusOne); 以上两个例子输出：1Array ( [0] =&gt; 2 [1] =&gt; 3 [2] =&gt; 4 ) 三、附加状态 前面演示了如何把匿名函数当成回调使用，下面探讨如何为php闭包附加并封装状态，javascript开发者可能对php的闭包感到奇怪，因为php闭包不会像真正的javascript闭包那样自动封装应用的状态，在php中，必须手动调用闭包对象的bindTo()方法或者使用use关键字，把状态附加到php闭包上。 使用use关键字附加闭包状态常见的多，因此我们先看这种方式，使用use关键字把变量附加到闭包上时，附加的变量会记住附件时付给他的值。12345678910function enclosePerson($name)&#123; return function ($doCommand) use ($name) &#123; return sprintf('%s, %s', $name, $doCommand); &#125;;&#125; $clay = enclosePerson('Clay'); echo $clay('get me sweet tea!'); 以上代码输出：Clay get me sweet tea 使用use关键字，把多个参数传入闭包时，需要还是用，号分隔开。 具名函数enclosePerson()有个名为$name的参数，这个函数返回一个闭包对象，而且这个闭包对象封装了 $name参数， 即便 返回的闭包对象跳出了enclosePerson()函数的作用域，它也会记住$name参数的值，因为$name变量仍在闭包中。 使用bindTo方法附加闭包的状态 别忘了php 闭包是对象，与任何其他的php对象类似，每个闭包实例都可以使用$this关键字获取闭包的内部状态。闭包对象的默认状态没什么用，不过有一个 __invoke()魔术方法和bindTo()方法，仅此而已。但是bindTo() 方法为闭包增加了一些有趣的潜力，我们可以使用这个方法把Closure对象的内部状态绑定到其他的对象上，bindTo() 方法的第二个参数很重要，其作用是指定绑定闭包的那个对象所属的php类，因此闭包可以访问绑定闭包的对象中受保护和私有的成员变量。 你会发现，php框架经常使用bindTo()方法把路由URL映射到匿名回调函数上，框架会把匿名函数绑定到应用对象上，这么做可以在这个匿名函数中使用$this关键字引用重要的对象。 例子：123456789101112131415161718192021222324252627class APP&#123; protected $routes = array(); protected $responseStatus = '200 ok'; protected $responseContentType = 'text/html'; protected $responseBody = 'hello world'; public function addRoute($routePath, $routeCallback) &#123; $this-&gt;routes[$routePath] = $routeCallback-&gt;bindTo($this, __CLASS__); &#125; public function dispath($currentPath) &#123; foreach ($this-&gt;routes as $routePath =&gt; $callback) &#123; if ($routePath == $currentPath) &#123; $callback(); &#125; &#125; header('HTTP/1.1'. $this-&gt;responseStatus); header('Content-type' . $this-&gt;responseContentType); header('Content-length' . $this-&gt;responseBody); echo $this-&gt;responseBody; &#125;&#125; 我们要特别注意addRoute方法，这个方法的参数分别是一个路由路径和路由回调，dispatch() 方法的参数是当前的HTTP请 求的 路径，它会调用匹配的路由回调，我们把路由绑定到当前的App实例上，这么做就能再回调函数中处理App实例的状态 。123456$app = new App();$app-&gt;addRoute('/users/josh', function () &#123; $this-&gt;responseContentType = 'application/json; charset=utf8'; $this-&gt;responseBody = '&#123;"name" : "yee Jason"&#125;';&#125;);$app-&gt;dispatch('/users/josh'); 匿名函数提到闭包就不得不想起匿名函数，也叫闭包函数（closures），貌似PHP闭包实现主要就是靠它。声明一个匿名函数是这样：123$func = function() &#123; &#125;; //带结束符 可以看到，匿名函数因为没有名字，如果要使用它，需要将其返回给一个变量。匿名函数也像普通函数一样可以声明参数，调用方法也相同：123456$func = function( $param ) &#123; echo $param;&#125;;$func( 'some string' );//输出：//some string 顺便提一下，PHP在引入闭包之前，也有一个可以创建匿名函数的函数：create function，但是代码逻辑只能写成字符串，这样看起来很晦涩并且不好维护，所以很少有人用。 实现闭包将匿名函数在普通函数中当做参数传入，也可以被返回。这就实现了一个简单的闭包。 下边有三个例子 12345678910111213141516171819202122232425262728293031323334//例一//在函数里定义一个匿名函数，并且调用它function printStr() &#123; $func = function( $str ) &#123; echo $str; &#125;; $func( 'some string' );&#125;printStr();//例二//在函数中把匿名函数返回，并且调用它function getPrintStrFunc() &#123; $func = function( $str ) &#123; echo $str; &#125;; return $func;&#125;$printStrFunc = getPrintStrFunc();$printStrFunc( 'some string' );//例三//把匿名函数当做参数传递，并且调用它function callFunc( $func ) &#123; $func( 'some string' );&#125;$printStrFunc = function( $str ) &#123; echo $str;&#125;;callFunc( $printStrFunc );//也可以直接将匿名函数进行传递。如果你了解js，这种写法可能会很熟悉callFunc( function( $str ) &#123; echo $str;&#125;); 连接闭包和外界变量的关键字：USE12345678910111213function getMoney() &#123; $rmb = 1; $dollar = 6; $func = function() use ( $rmb ) &#123; echo $rmb; echo $dollar; &#125;; $func();&#125;getMoney();//输出：//1//报错，找不到dorllar变量 闭包可以保存所在代码块上下文的一些变量和值。PHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用use关键字。 换一个例子看看： 可以看到，dollar没有在use关键字中声明，在这个匿名函数里也就不能获取到它，所以开发中要注意这个问题。 有人可能会想到，是否可以在匿名函数中改变上下文的变量，但我发现是不可以的： 1234567891011121314function getMoney() &#123; $rmb = 1; $func = function() use ( $rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; $func(); echo $rmb;&#125;getMoney();//输出：//1//1 啊，原来use所引用的也只不过是变量的一个副本而已。但是我想要完全引用变量，而不是复制。 要达到这种效果，其实在变量前加一个 &amp; 符号就可以了： 1234567891011121314function getMoney() &#123; $rmb = 1; $func = function() use ( &amp;$rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; $func(); echo $rmb;&#125;getMoney();//输出：//1//2 好，这样匿名函数就可以引用上下文的变量了。如果将匿名函数返回给外界，匿名函数会保存use所引用的变量，而外界则不能得到这些变量，这样形成‘闭包’这个概念可能会更清晰一些。 12345678910111213141516function getMoneyFunc() &#123; $rmb = 1; $func = function() use ( &amp;$rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; return $func;&#125;$getMoney = getMoneyFunc();$getMoney();$getMoney();$getMoney();//输出：//1//2//3 总结PHP闭包的特性并没有太大惊喜，其实用CLASS就可以实现类似甚至强大得多的功能，更不能和js的闭包相提并论，只能期待PHP以后对闭包支持的改进。不过匿名函数还是挺有用的，比如在使用preg_replace_callback等之类的函数可以不用在外部声明回调函数了。 一、闭包总结把一个闭包转换为某个类的方法(只是这个方法不需要通过对象调用), 这样闭包中的$this、static、self就转换成了对应的对象或类 把闭包当成对象的成员方法或者静态成员方法.12Closure::bind($cl1, null, 'A'); //就相当于在类里面加了个静态成员方法Closure::bind($cl2, new A(), 'A'); //相当于在类里面加了个成员方法 成员方法中使用$this访问对象, 静态成员方法直接使用类名::成员的方法.但是因为是匿名函数, 没有函数名, 所以返回一个已经绑定$this对象和类作用域的闭包给你使用. 二、闭包基本用法闭包（Closure）又叫做匿名函数，也就是没有定义名字的函数。比如下面的例子：12345678910111213141516171819202122232425262728// 定义一个闭包，并把它赋给变量 $f$f = function () &#123; return 7;&#125;// 使用闭包也很简单$f(); //这样就调用了闭包，输出 7// 当然更多的时候是把闭包作为参数(回调函数)传递给函数function testClosure (Closure $callback) &#123; return $callback();&#125;// $f 作为参数传递给函数 testClosure，如果是普遍函数是没有办法作为testClosure的参数的testClosure($f);// 也可以直接将定义的闭包作为参数传递，而不用提前赋给变量testClosure (function () &#123; return 7;&#125;);// 闭包不止可以做函数的参数，也可以作为函数的返回值function getClosure () &#123; return function () &#123; return 7; &#125;;&#125;$c = getClosure(); // 函数返回的闭包就复制给 $c 了$c(); // 调用闭包，返回 7 三、闭包类（Closure）定义一个闭包函数，其实是产生了一个闭包类（Closure）的对象，Closure 类摘要如下1234Closure &#123; public static Closure bind (Closure $closure , object $newthis [, mixed $newscope = 'static' ]) public Closure bindTo (object $newthis [, mixed $newscope = 'static' ]) &#125; 方法说明：Closure::bind： 复制一个闭包，绑定指定的 $this 对象和类作用域。Closure::bindTo： 复制当前闭包对象，绑定指定的 $this 对象和类作用域。下面将介绍Closure::bind和Closure::bindTo参数和返回值说明：closure：表示需要绑定的闭包对象。newthis：表示需要绑定到闭包对象的对象，或者 NULL 创建未绑定的闭包。newscope：表示想要绑定给闭包的类作用域，可以传入类名或类的示例，默认值是’static’， 表示不改变。该方法成功时返回一个新的 Closure 对象，失败时返回 FALSE。123456789101112131415161718192021222324252627282930313233343536class Animal &#123; private static $cat = "cat"; private $dog = "dog"; public $pig = "pig"; &#125; /* * 获取Animal类静态私有成员属性 */ $cat = static function() &#123; return Animal::$cat; &#125;; /* * 获取Animal实例私有成员属性 */ $dog = function() &#123; return $this-&gt;dog; &#125;; /* * 获取Animal实例公有成员属性 */ $pig = function() &#123; return $this-&gt;pig; &#125;; $bindCat = Closure::bind($cat, null, new Animal());// 给闭包绑定了Animal实例的作用域，但未给闭包绑定$this对象 $bindDog = Closure::bind($dog, new Animal(), 'Animal');// 给闭包绑定了Animal类的作用域，同时将Animal实例对象作为$this对象绑定给闭包 $bindPig = Closure::bind($pig, new Animal());// 将Animal实例对象作为$this对象绑定给闭包,保留闭包原有作用域 echo $bindCat(),'&lt;br&gt;';// 根据绑定规则，允许闭包通过作用域限定操作符获取Animal类静态私有成员属性 echo $bindDog(),'&lt;br&gt;';// 根据绑定规则，允许闭包通过绑定的$this对象(Animal实例对象)获取Animal实例私有成员属性 echo $bindPig(),'&lt;br&gt;';// 根据绑定规则，允许闭包通过绑定的$this对象获取Animal实例公有成员属性// bindTo与bind类似，是面向对象的调用方式，这里只举一个，其他类比就可以$bindCat = $cat-&gt;bindTo(null, 'Animal'); 以上示例输出：123catdogpig 四、连接闭包和外界变量的关键字：USE 闭包可以保存所在代码块上下文的一些变量和值。PHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用 use 关键字。12345678910111213function getMoney() &#123; $rmb = 1; $dollar = 6; $func = function() use ( $rmb ) &#123; echo $rmb; echo $dollar; &#125;; $func();&#125;getMoney();//输出：//1//报错，找不到dorllar变量 可以看到，dollar没有在use关键字中声明，在这个匿名函数里也就不能获取到它，所以开发中要注意这个问题。 有人可能会想到，是否可以在匿名函数中改变上下文的变量，但我发现是不可以的：1234567891011121314function getMoney() &#123; $rmb = 1; $func = function() use ( $rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; $func(); echo $rmb;&#125;getMoney();//输出：//1//1 原来use所引用的也只不过是变量的一个副本而已。但是我想要完全引用变量，而不是复制。要达到这种效果，其实在变量前加一个 &amp; 符号就可以了：1234567891011121314151617function getMoneyFunc() &#123; $rmb = 1; $func = function() use ( &amp;$rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; return $func;&#125;$getMoney = getMoneyFunc();$getMoney();$getMoney();$getMoney();//输出：//1//2//3 匿名函数实现一个简单的匿名函数： 上面就是一个简单的匿名函数，定义一个函数体，将函数体赋值给一个变量（php5.3之后支持该写法）。 实现闭包1、当做参数传递： 2、将匿名函数返回： 捕获外界变量闭包： 闭包是词法作用于的体现，一个持有外部环境自由变量的函数就是闭包。闭包体现的是在程序运行过程中，由 “不确定”变为“ 确定” 的过程。 捕获外部变量：在PHP中对捕获这一动作有了更清晰的表现，使用use关键字。如上面例2。 在上面的例2中，匿名函数$func通过use关键字捕获了外部的自由变量$param，在调用时通过传入cFunc()函数的参数123（$param此时会变为“确定”状态），进而调用匿名函数时输出“params:456 123”。 use引入的是自由变量的副本。 golang闭包： 在golang中同样通过匿名函数实现了闭包，和PHP不同的是，golang中的闭包是默认会引入上下文的自由变量，且引入的地址，即在闭包函数内部修改变量会在函数外部生效。 PHP Closure类用于代表匿名函数类。在PHP中定义一个闭包函数其实就是一个Closure类的实例。 类摘要123456789Closure &#123;/* 方法 */__construct ( void )public static bind ( Closure $closure , object $newthis [, mixed $newscope = 'static' ] ) : Closurepublic bindTo ( object $newthis [, mixed $newscope = 'static' ] ) : Closure Closure::__construct — 用于禁止实例化的构造函数 Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。Closure::bind复制一个闭包，绑定指定的$this对象和类作用域，返回一个新的匿名函数 参数说明：closure： 需要绑定的匿名函数。newthis： 需要绑定到匿名函数的对象，或者 NULL 创建未绑定的闭包。（ 理解：可以选择是否将匿名函数绑定到一个类对象，若绑定到了一个类对象，则可以在匿名函数内使用 $this ，否则不可使用。 ）newscope： 想要绑定给闭包的类作用域，或者 ‘static’ 表示不改变。如果传入一个对象，则使用这个对象的类型名。类作用域用来决定在闭包中 $this 对象的 私有、保护方法 的可见性。（ 理解：如果传入一个类，则可以访问类的static、private、protected属性，否则只能访问public属性。 ）简单理解：可以简单理解为将该匿名函数绑定到一个类或实例。根据参数的不同，可以访问不同的类的属性。 输出：1234567891011bind catstring(3) &quot;cat&quot;bind dogstring(3) &quot;dog&quot;bind dog2Fatal error: Using $this when not in object context Closure::bindToClosure::bind()的非静态形式。 小结PHP通过匿名函数实现闭包。可以通过将匿名函数作为参数或返回值实现闭包。可以通过use关键字引入外部变量，且引入的变量副本。匿名函数均实现了Closure类，且可以通过Closure::bind()方法将匿名函数绑定到某个类。以上是文章全部内容，有需要学习交流的友人请加入Swoole交流群的咱们一起，有问题一起交流，一起进步！前提是你是学技术的。感谢阅读！ 面向对象变成语言代码的复用主要采用继承来实现，而函数的复用，就是通过闭包来实现。这就是闭包的设计初衷。 注：PHP里面闭包函数是为了复用函数而设计的语言特性，如果在闭包函数里面访问指定域的变量，使用use关键字来实现。 PHP具有面向函数的编程特性，但是也是面向对象编程语言，PHP 会自动把闭包函数转换成内置类 Closure 的对象实例，依赖Closure 的对象实例又给闭包函数添加了更多的能力。 闭包不能被实例(私有构造函数)，也不能被继承(finally 类)。可以通过反射来判断闭包实例是否能被实例，继承。 匿名函数 提到闭包就不得不想起匿名函数，也叫闭包函数（closures），貌似PHP闭包实现主要就是靠它。声明一个匿名函数是这样： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185$func = function() &#123; &#125;; //带结束符``` 可以看到，匿名函数因为没有名字，如果要使用它，需要将其返回给一个变量。匿名函数也像普通函数一样可以声明参数，调用方法也相同：```php$func = function( $param ) &#123; echo $param;&#125;;$func( 'some string' ); //输出：//some string``` 顺便提一下，PHP在引入闭包之前，也有一个可以创建匿名函数的函数：create function，但是代码逻辑只能写成字符串，这样看起来很晦涩并且不好维护，所以很少有人用。 实现闭包将匿名函数在普通函数中当做参数传入，也可以被返回。这就实现了一个简单的闭包。 连接闭包和外界变量的关键字：USEPHP在默认情况下，匿名函数不能调用所在代码块的上下文变量，而需要通过使用use关键字。```phpfunction getMoney() &#123; $rmb = 1; $func = function() use ( $rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; $func(); echo $rmb; //闭包内的变量改变了，但是闭包外没有改变。&#125;getMoney(); //输出：//1//1``` 注：use所引用的是变量的复制(副本而），并不是完全引用变量。如果要达到引用的效果，就需要使用 &amp; 符号，进行引用传递参数。```phpfunction getMoney() &#123; $rmb = 1; $func = function() use ( &amp;$rmb ) &#123; echo $rmb; //把$rmb的值加1 $rmb++; &#125;; $func(); echo $rmb;&#125;getMoney(); //输出：//1//2``` 总结： 闭包函数不能直接访问闭包外的变量，而是通过use 关键字来调用上下文变量(闭包外的变量)，也就是说通过use来引用上下文的变量；闭包内所引用的变量不能被外部所访问(即，内部对变量的修改，外部不受影响)，若想要在闭包内对变量的改变从而影响到上下文变量的值，需要使用&amp;的引用传参。PHP Closure 类是用于代表匿名函数的类，匿名函数（在 PHP 5.3 中被引入）会产生这个类型的对象，Closure类摘要如下：```phpClosure &#123; __construct ( void ) public static Closure bind (Closure $closure , object $newthis [, mixed $newscope = 'static' ]) public Closure bindTo (object $newthis [, mixed $newscope = 'static' ])&#125;``` 方法说明：Closure::\_\_construct — 用于禁止实例化的构造函数Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。 除了此处列出的方法，还有一个 \_\_invoke 方法。这是为了与其他实现了 \_\_invoke()魔术方法 的对象保持一致性，但调用闭包对象的过程与它无关。 参数说明：closure表示需要绑定的闭包对象。newthis表示需要绑定到闭包对象的对象，或者NULL创建未绑定的闭包。newscope表示想要绑定给闭包的类作用域，可以传入类名或类的示例，默认值是 'static'， 表示不改变。 返回值：成功时返回一个新的 Closure 对象，失败时返回FALSE。 Closure::bind是Closure::bindTo的静态版本 例子：```phpclass Animal &#123; public $cat = 'cat'; public static $dog = 'dog'; private $pig = 'pig'; private static $duck = 'duck';&#125; //不能通过 $this 访问静态变量//不同通过 类名::私有静态变量，只能通过self,或者static,在类里面访问私有静态变量 $cat = function() &#123; return $this-&gt;cat;&#125;; $dog = static function () &#123; return Animal::$dog;&#125;; $pig = function() &#123; return $this-&gt;pig;&#125;; $duck = static function() &#123; //return Animal::$duck; 这样写，会报错，提示不能通过类名访问私有静态变量 return self::$duck; // return static::$duck&#125;; $bindCat = Closure::bind($cat, new Animal(), 'Animal');$bindCat2 = Closure::bind($cat, new Animal(), new Animal());echo $bindCat() . PHP_EOL;echo $bindCat2() . PHP_EOL; $bindDog = Closure::bind($dog, null, 'Animal');$bindDog2 = Closure::bind($dog, null, new Animal());echo $bindDog() . PHP_EOL;echo $bindDog2() . PHP_EOL; $bindPig = Closure::bind($pig, new Animal(), 'Animal');$bindPig2 = Closure::bind($pig, new Animal(), new Animal());echo $bindPig() . PHP_EOL;echo $bindPig2() . PHP_EOL; $bindDuck = Closure::bind($duck, null, 'Animal');$bindDuck2 = Closure::bind($duck, null, new Animal());echo $bindDuck() . PHP_EOL;echo $bindDuck2() . PHP_EOL;``` 通过上面的例子，可以看出函数复用得，可以把函数挂在不同的类上，或者对象上。 总结：1. 闭包内如果用 $this, 则 $this 只能调用非静态的属性，这和实际类中调用原则是一致的，且 Closure::bind() 方法的第2个参数不能为null，必须是一个实例 (因为$this,必须在实例中使用)，第三个参数可以是实例，可以是类字符串，或 static；2. 闭包内调用静态属性时，闭包必须声明为 static,同时Closure::bind()方法的第2个参数需要为null,因为 静态属性不需要实例，第3个参数可以是类字符串，实例，staic.php的闭包（Closure）也就是匿名函数。是PHP5.3引入的。闭包的语法很简单，需要注意的关键字就只有use，use意思是连接闭包和外界变量。```php$a = function() use($b) &#123; &#125; 闭包的几个作用：1 减少foreach的循环的代码比如手册http://php.net/manual/en/functions.anonymous.php 中的例子Cart1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?php// 一个基本的购物车，包括一些已经添加的商品和每种商品的数量。// 其中有一个方法用来计算购物车中所有商品的总价格。该方法使用了一个closure作为回调函数。class Cart&#123; const PRICE_BUTTER = 1.00; const PRICE_MILK = 3.00; const PRICE_EGGS = 6.95; protected $products = array(); public function add($product, $quantity) &#123; $this-&gt;products[$product] = $quantity; &#125; public function getQuantity($product) &#123; return isset($this-&gt;products[$product]) ? $this-&gt;products[$product] : FALSE; &#125; public function getTotal($tax) &#123; $total = 0.00; $callback = function ($quantity, $product) use ($tax, &amp;$total) &#123; $pricePerItem = constant(__CLASS__ . "::PRICE_" . strtoupper($product)); $total += ($pricePerItem * $quantity) * ($tax + 1.0); &#125;; array_walk($this-&gt;products, $callback); return round($total, 2);; &#125;&#125; $my_cart = new Cart; // 往购物车里添加条目$my_cart-&gt;add('butter', 1);$my_cart-&gt;add('milk', 3);$my_cart-&gt;add('eggs', 6); // 打出出总价格，其中有 5% 的销售税.print $my_cart-&gt;getTotal(0.05) . "\n";// The result is 54.29?&gt;``` 这里如果我们改造getTotal函数必然要使用到foreach 2 减少函数的参数```phpfunction html ($code , $id="", $class="")&#123; if ($id !== "") $id = " id = \"$id\"" ; $class = ($class !== "")? " class =\"$class\"":"&gt;"; $open = "&lt;$code$id$class"; $close = "&lt;/$code&gt;"; return function ($inner = "") use ($open, $close)&#123; return "$open$inner$close";&#125;; &#125; 如果是使用平时的方法，我们会把inner放到html函数参数中，这样不管是代码阅读还是使用都不如使用闭包 3 解除递归函数123456789101112131415161718192021&lt;?php $fib = function($n) use(&amp;$fib) &#123; if($n == 0 || $n == 1) return 1; return $fib($n - 1) + $fib($n - 2); &#125;; echo $fib(2) . "\n"; // 2 $lie = $fib; $fib = function()&#123;die('error');&#125;;//rewrite $fib variable echo $lie(5); // error because $fib is referenced by closure``` 注意上题中的use使用了&amp;，这里不使用&amp;会出现错误fib(n-1)是找不到function的（前面没有定义fib的类型）所以想使用闭包解除循环函数的时候就需要使用```php&lt;?php$recursive = function () use (&amp;$recursive)&#123;// The function is now available as $recursive&#125; 这样的形式 4 关于延迟绑定如果你需要延迟绑定use里面的变量，你就需要使用引用，否则在定义的时候就会做一份拷贝放到use中1234567891011121314151617&lt;?php$result = 0; $one = function()&#123; var_dump($result); &#125;; $two = function() use ($result)&#123; var_dump($result); &#125;; $three = function() use (&amp;$result)&#123; var_dump($result); &#125;; $result++; $one(); // outputs NULL: $result is not in scope$two(); // outputs int(0): $result was copied$three(); // outputs int(1) 使用引用和不使用引用就代表了是调用时赋值，还是申明时候赋值 PHP Closure类是用于代表匿名函数的类，匿名函数（在PHP5.3中被引入）会产生这个类型的对象，Closure类摘要如下：12345Closure &#123; __construct ( void ) public static Closure bind (Closure $closure , object $newthis [, mixed $newscope = 'static' ]) public Closure bindTo (object $newthis [, mixed $newscope = 'static' ])&#125; 方法说明： Closure::__construct — 用于禁止实例化的构造函数 Closure::bind — 复制一个闭包，绑定指定的$this对象和类作用域。 Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域。 除了此处列出的方法，还有一个__invoke 方法。这是为了与其他实现了__invoke()魔术方法 的对象保持一致性，但调用闭包对象的过程与它无关。 下面将介绍Closure::bind和Closure::bindTo。 Closure::bind是Closure::bindTo的静态版本，其说明如下：1public static Closure bind (Closure $closure , object $newthis [, mixed $newscope = 'static' ]) closure表示需要绑定的闭包对象。 newthis表示需要绑定到闭包对象的对象，或者NULL创建未绑定的闭包。 newscope表示想要绑定给闭包的类作用域，可以传入类名或类的示例，默认值是 ‘static’， 表示不改变。 该方法成功时返回一个新的Closure对象，失败时返回FALSE。 例子说明：12345678910111213141516171819202122232425262728293031323334353637383940&lt;?php/** * 复制一个闭包，绑定指定的$this对象和类作用域。 * * @author 疯狂老司机 */class Animal &#123; private static $cat = "cat"; private $dog = "dog"; public $pig = "pig";&#125; /* * 获取Animal类静态私有成员属性 */$cat = static function() &#123; return Animal::$cat;&#125;; /* * 获取Animal实例私有成员属性 */$dog = function() &#123; return $this-&gt;dog;&#125;; /* * 获取Animal实例公有成员属性 */$pig = function() &#123; return $this-&gt;pig;&#125;; $bindCat = Closure::bind($cat, null, new Animal());// 给闭包绑定了Animal实例的作用域，但未给闭包绑定$this对象$bindDog = Closure::bind($dog, new Animal(), 'Animal');// 给闭包绑定了Animal类的作用域，同时将Animal实例对象作为$this对象绑定给闭包$bindPig = Closure::bind($pig, new Animal());// 将Animal实例对象作为$this对象绑定给闭包,保留闭包原有作用域echo $bindCat(),'&lt;br&gt;';// 根据绑定规则，允许闭包通过作用域限定操作符获取Animal类静态私有成员属性echo $bindDog(),'&lt;br&gt;';// 根据绑定规则，允许闭包通过绑定的$this对象(Animal实例对象)获取Animal实例私有成员属性echo $bindPig(),'&lt;br&gt;';// 根据绑定规则，允许闭包通过绑定的$this对象获取Animal实例公有成员属性?&gt; 输出：123catdogpig Closure::bindTo — 复制当前闭包对象，绑定指定的$this对象和类作用域，其说明如下：1public Closure Closure::bindTo (object $newthis [, mixed $newscope = 'static' ]) newthis表示绑定给闭包对象的一个对象，或者NULL来取消绑定。newscope表示关联到闭包对象的类作用域，可以传入类名或类的示例，默认值是 ‘static’， 表示不改变。该方法创建并返回一个闭包对象，它与当前对象绑定了同样变量，但可以绑定不同的对象，也可以绑定新的类作用域。绑定的对象决定了返回的闭包对象中的$this的取值，类作用域决定返回的闭包对象能够调用哪些方法，也就是说，此时$this可以调用的方法，与newscope类作用域相同。 例子1：12345678&lt;?phpfunction __autoload($class) &#123; require_once "$class.php";&#125; $template = new Template;$template-&gt;render(new Article, 'tpl.php');?&gt; Template.php 模板类12345678910111213141516171819202122232425&lt;?php/** * 模板类，用于渲染输出 * * @author 疯狂老司机 */class Template&#123; /** * 渲染方法 * * @access public * @param obj 信息类 * @param string 模板文件名 */ public function render($context, $tpl)&#123; $closure = function($tpl)&#123; ob_start(); include $tpl; return ob_end_flush(); &#125;; $closure = $closure-&gt;bindTo($context, $context); $closure($tpl); &#125; &#125; Article.php 信息类12345678910&lt;?php/** * 文章信息类 * * @author 疯狂老司机 */class Article&#123; private $title = "这是文章标题"; private $content = "这是文章内容";&#125; tpl.php 模板文件12345678910&lt;!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"&gt;&lt;html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en"&gt; &lt;head&gt; &lt;meta http-equiv="Content-Type" content="text/html;charset=UTF-8"&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;?php echo $this-&gt;title;?&gt;&lt;/h1&gt; &lt;p&gt;&lt;?php echo $this-&gt;content;?&gt;&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 运行时确保以上文件位于同级目录。输出：12这是文章标题这是文章内容 例子2：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&lt;?php/** * 给类动态添加新方法 * * @author 疯狂老司机 */trait DynamicTrait &#123; /** * 自动调用类中存在的方法 */ public function __call($name, $args) &#123; if(is_callable($this-&gt;$name))&#123; return call_user_func($this-&gt;$name, $args); &#125;else&#123; throw new \RuntimeException("Method &#123;$name&#125; does not exist"); &#125; &#125; /** * 添加方法 */ public function __set($name, $value) &#123; $this-&gt;$name = is_callable($value)? $value-&gt;bindTo($this, $this): $value; &#125;&#125; /** * 只带属性不带方法动物类 * * @author 疯狂老司机 */class Animal &#123; use DynamicTrait; private $dog = 'dog';&#125; $animal = new Animal; // 往动物类实例中添加一个方法获取实例的私有属性$dog$animal-&gt;getdog = function() &#123; return $this-&gt;dog;&#125;; echo $animal-&gt;getdog(); ?&gt; 输出：1dog 例子3：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465&lt;?php/** * 一个基本的购物车，包括一些已经添加的商品和每种商品的数量 * * @author 疯狂老司机 */class Cart &#123; // 定义商品价格 const PRICE_BUTTER = 1.00; const PRICE_MILK = 3.33; const PRICE_EGGS = 8.88; protected $products = array(); /** * 添加商品和数量 * * @access public * @param string 商品名称 * @param string 商品数量 */ public function add($item, $quantity) &#123; $this-&gt;products[$item] = $quantity; &#125; /** * 获取单项商品数量 * * @access public * @param string 商品名称 */ public function getQuantity($item) &#123; return isset($this-&gt;products[$item]) ? $this-&gt;products[$item] : FALSE; &#125; /** * 获取总价 * * @access public * @param string 税率 */ public function getTotal($tax) &#123; $total = 0.00; $callback = function ($quantity, $item) use ($tax, &amp;$total) &#123; $pricePerItem = constant(__CLASS__ . "::PRICE_" . strtoupper($item)); $total += ($pricePerItem * $quantity) * ($tax + 1.0); &#125;; array_walk($this-&gt;products, $callback); return round($total, 2);; &#125;&#125; $my_cart = new Cart; // 往购物车里添加商品及对应数量$my_cart-&gt;add('butter', 10);$my_cart-&gt;add('milk', 3);$my_cart-&gt;add('eggs', 12); // 打出出总价格，其中有 5% 的销售税.echo $my_cart-&gt;getTotal(0.05); ?&gt; 输出：1132.88 补充说明：闭包可以使用USE关键连接外部变量。 总结：合理使用闭包能使代码更加简洁和精炼。 PHP核心特性-匿名函数提出在匿名函数出现之前，所有的函数都需要先命名才能使用：123456function increment($value)&#123; return $value + 1;&#125;array_map('increment', [1, 2, 3]); 有的时候函数可能只需要使用一次，这时候使用匿名函数会使得代码更加简洁直观，同时也避免了函数在其他地方被使用：123array_map(function($value)&#123; return $value + 1;&#125;, [1, 2, 3]); 定义和使用PHP将闭包和匿名函数视为同等概念（本文统称为匿名函数），本质上都是伪装成函数的对象。 匿名函数的本质是对象，因此跟对象一样可将匿名函数赋值给某一变量：12345$greet = function(string $name)&#123; echo "hello &#123;$name&#125;";&#125;$greet("jack") // hello jack 所有的匿名函数都是Closure对象的实例：1$greet instanceof Closure // true 对象并没有什么父作用域可言，所以需要使用use来手动声明使用的变量：1234567$num = 1;$func = function() use($num)&#123; $num = $num + 1; echo $num;&#125;$func(); // 2echo $num; // 还是 1 如果要让匿名函数中的变量生效，需要使用引用传值：1234567$num = 1;$func = function() use(&amp;$num)&#123; $num = $num + 1; echo $num;&#125;$func(); // 2echo $num; // 2 从PHP5.4开始，在类里面使用匿名函数时，匿名函数的$this将自动绑定到当前类：123456789101112class Foo &#123; public function bar() &#123; return function() &#123; return $this; &#125;; &#125;&#125;$foo = new Foo();$obj = $foo-&gt;bar(); // Closure()$obj(); // Foo 如果不想让自动绑定生效，可使用静态匿名函数：1234567891011class Foo &#123; public function bar() &#123; return static function() &#123; return $this; &#125;; &#125;&#125;$foo = new Foo();$obj = $foo-&gt;bar(); // Closure()$obj(); // Using $this when not in object context 匿名函数的本质匿名函数的本质是Closure对象，包括了以下五个方法1234567Closure &#123; private __construct ( void ) public static bind ( Closure $closure , object $newthis [, mixed $newscope = "static" ] ) : Closure public bindTo ( object $newthis [, mixed $newscope = "static" ] ) : Closure public call ( object $newthis [, mixed $... ] ) : mixed public static fromCallable ( callable $callable ) : Closure&#125; __construct - 防止匿名函数被实例化12$closure = new \Closure();// PHP Error: Instantiation of 'Closure' is not allowed Closure::bindTo - 复制当前匿名函数对象，绑定指定的 $this 对象和类作用域。通俗的说，就是手动将匿名函数与指定对象绑定，利用这点，可以扩展对象的功能。123456789101112131415161718192021222324// 定义商品类class Good &#123; private $price; public function __construct(float $price) &#123; $this-&gt;price = $price; &#125;&#125;// 定义一个匿名函数，计算商品的促销价$addDiscount = function(float $discount = 0.8)&#123; return $this-&gt;price * $discount;&#125;$good = new Good(100);// 将匿名函数绑定到 $good 实例，同时指定作用域为 Good$count = $addDiscount-&gt;bindTo($good, Good::class); $count(); // 80// 将匿名函数绑定到 $good 实例，但是不指定作用域，将无法访问 $good 的私有属性$count = $addDiscount-&gt;bindTo($good); $count(); // 报错 Closure::bind - bindTo 方法的静态版本，有两种用法： 用法一：实现与bindTo方法同样的效果1$count = \Closure::bind($addDiscount, $good, Good::class); 用法二：将匿名函数与类（而不是对象）绑定，记得要将第二个参数设置为 null123456789101112131415// 商品库存为 10class Good &#123; static $num = 10;&#125;// 每次销售后返回当前库存$sell = static function() &#123; return"当前库存为". --static::$num ;&#125;;// 将静态匿名函数绑定到 Good 类中$sold = \Closure::bind($sell, null, Good::class);$sold(); // 当前库存为 9$sold(); // 当前库存为 8 call - PHP7新增的call方法可以实现绑定并调用匿名函数，除了语法更加简洁外，性能也更高123456// call 版本$addDiscount-&gt;call($good, 0.5); // 绑定并传入参数 0.5，结果为 50// bindTo 版本$count = $addDiscount-&gt;bindTo($good, Good::class); $count(0.5); // 50 fromCallable - 将给定的 callable 函数转化成匿名函数123456789101112131415161718class Good &#123; private $price; public function __construct(float $price) &#123; $this-&gt;price = $price; &#125;&#125;function addDiscount(float $discount = 0.8)&#123; return $this-&gt;price * $discount;&#125;$closure = \Closure::fromCallable('addDiscount');$good = new Good(100);$count = $closure-&gt;bindTo($good); $count = $closure-&gt;bindTo($good, Good::class); // 报错，不能重复绑定作用域$count(); // 报错，无法访问私有属性 fromCallable 等价于12$reflexion = new ReflectionFunction('addDiscount');$closure = $reflexion-&gt;getClosure(); 这里有一点需要特别注意的是，无论是fromCallable转化成的闭包，还是使用反射得到的闭包，在使用 bindTo 时，如果第二个参数指定绑定类，会报错1Cannot rebind scope of closure created by ReflectionFunctionAbstract::getClosure()]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>函数式编程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Laravel-Facade]]></title>
    <url>%2F2020%2F03%2F10%2FLaravel-Facade%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 简介门面为应用服务容器中的绑定类提供了一个「静态」接口。Laravel内置了很多门面，你可能在不知道的情况下正在使用它们。Laravel的门面作为服务容器中底层类的「静态代理」，相比于传统静态方法，在维护时能够提供更加易于测试、更加灵活、简明优雅的语法。 Laravel的所有门面都定义在Illuminate\Support\Facades命名空间下，所以我们可以轻松访问到门面：12345use Illuminate\Support\Facades\Cache;Route::get('/cache', function () &#123; return Cache::get('key');&#125;); 在整个Laravel文档中，很多例子使用了门面来演示框架的各种功能特性。 何时使用门面门面有诸多优点，其提供了简单、易记的语法，让我们无需记住长长的类名即可使用Laravel提供的功能特性，此外，由于他们对PHP动态方法的独到用法，使得它们很容易测试。 但是，使用门面也有需要注意的地方，一个最主要的危险就是类范围蠕变。由于门面如此好用并且不需要注入，在单个类中使用过多门面，会让类很容易变得越来越大。使用依赖注入则会让此类问题缓解，因为一个巨大的构造函数会让我们很容易判断出类在变大。因此，使用门面的时候要尤其注意类的大小，以便控制其有限职责。 注：构建与Laravel交互的第三方扩展包时，最好注入Laravel契约而不是使用门面，因为扩展包在Laravel之外构建，你将不能访问Laravel的门面测试辅助函数。 门面 vs. 依赖注入依赖注入的最大优点是可以替换注入类的实现，这在测试时很有用，因为你可以注入一个模拟或存根并且在存根上断言不同的方法。 但是在静态类方法上进行模拟或存根却行不通，不过，由于门面使用了动态方法对服务容器中解析出来的对象方法调用进行了代理，我们也可以像测试注入类实例那样测试门面。例如，给定以下路由： 12345use Illuminate\Support\Facades\Cache;Route::get('/cache', function () &#123; return Cache::get('key');&#125;); 我们可以这样编写测试来验证 Cache::get 方法以我们期望的方式被调用： 12345678910111213141516use Illuminate\Support\Facades\Cache;/** * A basic functional test example. * * @return void */public function testBasicExample()&#123; Cache::shouldReceive('get') -&gt;with('key') -&gt;andReturn('value'); $this-&gt;visit('/cache') -&gt;see('value');&#125; 门面 vs. 辅助函数除了门面之外，Laravel还内置了许多辅助函数用于执行通用任务，比如生成视图、触发事件、分配任务，以及发送 HTTP 响应等。很多辅助函数提供了和相应门面一样的功能，例如，下面这个门面调用和辅助函数调用是等价的：12return View::make('profile');return view('profile'); 门面和辅助函数之间并不存在实质性差别，使用辅助函数的时候，可以像测试相应门面那样测试它们。例如，给定以下路由：123Route::get('/cache', function () &#123; return cache('key');&#125;); 在调用底层，cache方法会去调用Cache门面上的get方法，因此，尽管我们使用这个辅助函数，我们还是可以编写如下测试来验证这个方法以我们期望的方式和参数被调用：12345678910111213141516use Illuminate\Support\Facades\Cache;/** * A basic functional test example. * * @return void */public function testBasicExample()&#123; Cache::shouldReceive('get') -&gt;with('key') -&gt;andReturn('value'); $this-&gt;visit('/cache') -&gt;see('value');&#125; 门面工作原理在Laravel应用中，门面就是一个为容器中对象提供访问方式的类。该机制原理由Facade类实现。Laravel自带的门面，以及我们创建的自定义门面，都会继承自Illuminate\Support\Facades\Facade基类。 门面类只需要实现一个方法：getFacadeAccessor。正是getFacadeAccessor方法定义了从容器中解析什么，然后Facade基类使用魔术方法__callStatic()从你的门面中调用解析对象。 下面的例子中，我们将会调用Laravel的缓存系统，浏览代码后，也许你会觉得我们调用了Cache 的静态方法get：123456789101112131415161718192021&lt;?phpnamespace App\Http\Controllers;use Cache;use App\Http\Controllers\Controller;class UserController extends Controller&#123; /** * 为指定用户显示属性 * * @param int $id * @return Response */ public function showProfile($id) &#123; $user = Cache::get('user:'.$id); return view('profile', ['user' =&gt; $user]); &#125;&#125; 注意我们在顶部位置引入了Cache门面。该门面作为代理访问底层Illuminate\Contracts\Cache\Factory接口的实现。我们对门面的所有调用都会被传递给Laravel缓存服务的底层实例。 如果我们查看Illuminate\Support\Facades\Cache类的源码，将会发现其中并没有静态方法get：1234567891011class Cache extends Facade&#123; /** * 获取组件注册名称 * * @return string */ protected static function getFacadeAccessor() &#123; return 'cache'; &#125;&#125; Cache门面继承Facade基类并定义了getFacadeAccessor方法，该方法的工作就是返回服务容器绑定类的别名，当用户引用Cache类的任何静态方法时，Laravel从服务容器中解析cache绑定，然后在解析出的对象上调用所有请求方法（本例中是 get）。 实时门面使用实时门面，可以将应用中的任意类当做门面来使用。为了说明如何使用这个功能，我们先看一个替代方案。例如我们假设Podcast模型有一个publish方法，尽管如此，为了发布博客，我们需要注入Publisher实例： 12345678910111213141516171819202122&lt;?phpnamespace App;use App\Contracts\Publisher;use Illuminate\Database\Eloquent\Model;class Podcast extends Model&#123; /** * Publish the podcast. * * @param Publisher $publisher * @return void */ public function publish(Publisher $publisher) &#123; $this-&gt;update(['publishing' =&gt; now()]); $publisher-&gt;publish($this); &#125;&#125; 因为可以模拟注入的发布服务，所以注入发布实现到该方法后允许我们轻松在隔离状态下测试该方法。不过，这要求我们每次调用 publish 方法都要传递一个发布服务实例，使用实时门面，我们可以在维持这种易于测试的前提下不必显式传递Publisher实例。要生成一个实时门面，在导入类前面加上Facades命名空间前缀即可：123456789101112131415161718192021&lt;?phpnamespace App;use Facades\App\Contracts\Publisher;use Illuminate\Database\Eloquent\Model;class Podcast extends Model&#123; /** * Publish the podcast. * * @return void */ public function publish() &#123; $this-&gt;update(['publishing' =&gt; now()]); Publisher::publish($this); &#125;&#125; 使用实时门面后，发布服务实现将会通过使用Facades前缀后的接口或类名在服务容器中解析。在测试的时候，我们可以使用Laravel自带的门面测试辅助函数来模拟这个方法调用： 123456789101112131415161718192021222324252627&lt;?phpnamespace Tests\Feature;use App\Podcast;use Tests\TestCase;use Facades\App\Contracts\Publisher;use Illuminate\Foundation\Testing\RefreshDatabase;class PodcastTest extends TestCase&#123; use RefreshDatabase; /** * A test example. * * @return void */ public function test_podcast_can_be_published() &#123; $podcast = factory(Podcast::class)-&gt;create(); Publisher::shouldReceive('publish')-&gt;once()-&gt;with($podcast); $podcast-&gt;publish(); &#125;&#125; Facade123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137namespace Illuminate\Support\Facades;use Closure;use Mockery;use Mockery\MockInterface;use RuntimeException;abstract class Facade&#123; /** * The application instance being facaded. * * @var \Illuminate\Contracts\Foundation\Application */ protected static $app; // 两个函数有这个有关 /** * The resolved object instances. * * @var array */ protected static $resolvedInstance; // 重点在维护这个数组，有两个清除函数 public static function resolved(Closure $callback) &#123; $accessor = static::getFacadeAccessor(); if (static::$app-&gt;resolved($accessor) === true) &#123; $callback(static::getFacadeRoot()); &#125; &#125; /** * Get the registered name of the component. * * @return string * * @throws \RuntimeException */ protected static function getFacadeAccessor() &#123; throw new RuntimeException('Facade does not implement getFacadeAccessor method.'); &#125; /** * Get the root object behind the facade. * * @return mixed */ public static function getFacadeRoot() &#123; return static::resolveFacadeInstance(static::getFacadeAccessor()); &#125; /** * Resolve the facade root instance from the container. * * @param object|string $name * @return mixed */ protected static function resolveFacadeInstance($name) &#123; if (is_object($name)) &#123; return $name; &#125; if (isset(static::$resolvedInstance[$name])) &#123; return static::$resolvedInstance[$name]; &#125; if (static::$app) &#123; return static::$resolvedInstance[$name] = static::$app[$name]; &#125; &#125; /** * Clear a resolved facade instance. * * @param string $name * @return void */ public static function clearResolvedInstance($name) &#123; unset(static::$resolvedInstance[$name]); &#125; /** * Clear all of the resolved instances. * * @return void */ public static function clearResolvedInstances() &#123; static::$resolvedInstance = []; &#125; /** * Get the application instance behind the facade. * * @return \Illuminate\Contracts\Foundation\Application */ public static function getFacadeApplication() &#123; return static::$app; &#125; /** * Set the application instance. * * @param \Illuminate\Contracts\Foundation\Application $app * @return void */ public static function setFacadeApplication($app) &#123; static::$app = $app; &#125; /** * Handle dynamic, static calls to the object. * * @param string $method * @param array $args * @return mixed * * @throws \RuntimeException */ public static function __callStatic($method, $args) &#123; $instance = static::getFacadeRoot(); if (! $instance) &#123; throw new RuntimeException('A facade root has not been set.'); &#125; return $instance-&gt;$method(...$args); &#125;&#125; Event12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;?phpnamespace Illuminate\Support\Facades;use Illuminate\Database\Eloquent\Model;use Illuminate\Support\Testing\Fakes\EventFake;/** * @method static void listen(string|array $events, \Closure|string $listener) * @method static bool hasListeners(string $eventName) * @method static void push(string $event, array $payload = []) * @method static void flush(string $event) * @method static void subscribe(object|string $subscriber) * @method static array|null until(string|object $event, mixed $payload = []) * @method static array|null dispatch(string|object $event, mixed $payload = [], bool $halt = false) * @method static array getListeners(string $eventName) * @method static \Closure makeListener(\Closure|string $listener, bool $wildcard = false) * @method static \Closure createClassListener(string $listener, bool $wildcard = false) * @method static void forget(string $event) * @method static void forgetPushed() * @method static \Illuminate\Events\Dispatcher setQueueResolver(callable $resolver) * @method static void assertDispatched(string $event, callable|int $callback = null) * @method static void assertDispatchedTimes(string $event, int $times = 1) * @method static void assertNotDispatched(string $event, callable|int $callback = null) * * @see \Illuminate\Events\Dispatcher */class Event extends Facade&#123; /** * Replace the bound instance with a fake. * * @param array|string $eventsToFake * @return \Illuminate\Support\Testing\Fakes\EventFake */ public static function fake($eventsToFake = []) &#123; static::swap($fake = new EventFake(static::getFacadeRoot(), $eventsToFake)); Model::setEventDispatcher($fake); Cache::refreshEventDispatcher(); return $fake; &#125; /** * Replace the bound instance with a fake during the given callable's execution. * * @param callable $callable * @param array $eventsToFake * @return callable */ public static function fakeFor(callable $callable, array $eventsToFake = []) &#123; $originalDispatcher = static::getFacadeRoot(); static::fake($eventsToFake); return tap($callable(), function () use ($originalDispatcher) &#123; static::swap($originalDispatcher); Model::setEventDispatcher($originalDispatcher); Cache::refreshEventDispatcher(); &#125;); &#125; /** * Get the registered name of the component. * * @return string */ protected static function getFacadeAccessor() &#123; return 'events'; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Laravel</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP中钩子函数的实现与认识]]></title>
    <url>%2F2020%2F03%2F06%2FPHP%E4%B8%AD%E9%92%A9%E5%AD%90%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9E%E7%8E%B0%E4%B8%8E%E8%AE%A4%E8%AF%86%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 假如有这么一段程序：12345function fun()&#123; fun1(); fun2();&#125; 首先程序执行完fun1()之后执行fun2()然后fun()结束。 但是，假如我们想对函数做一些变化。比如说，fun是一个解析函数，我们希望后期可以提供丰富的解析函数，而究竟用哪个函数解析，我们希望在配置文件中配置。这个时候就可以发挥钩子的力量了。 我们可以在function fun(){}中加入一个挂钩点H，然后在执行H这个函数之前，将钩子函数配置好，那么就可以根据需要来解析了。 例如:1234567// 从配置文件中获得相应的配置信息$h = config_item("parser_fun");function fun($data)&#123; global $h; return $h();&#125; 除此以外，PHP还可以根据字符串提供自己的类，然后调用类的一个方法，传递某些参数，这些就为PHP程序的编写，以及后期的维护扩展奠定了相当坚实的基础。 123$c=get_class_name(); //获得类的名字$m=get_method_name(); //获得方法的名字$k=$c-&gt;$m(); //执行类的某一个方法 1、钩子函数是预设并在特定的条件下触发的。2、钩子函数接管程序后可以影响到程序的走向。 钩子的完整实现应该叫事件驱动。事件驱动分为两个阶段，第一个阶段是注册事件，目的是给未来可能发生的“事件”起一个名字，简单的实现方法 是用单例模式产生一个持久的对象或者注册一个全局变量，然后将事件名称，以及该事件对应的类与方法插入全局变量即可。也就是挂载一个钩子。 第二个阶段是触发事件，本质上就是在事件的全局变量中查询要触发的事件名称，然后找到注册好的类与方法，实例化并运行。这样子就可以摆脱传统方式中程序必须按顺序的规则，进一步实现解除耦合的目的。 钩子函数可以截获并处理其他应用程序的消息。每当特定的消息发出，在没有到达目的窗口前，钩子程序就先捕获该消息，亦即钩子函数先得到控制权。这时钩子函数即可以加工处理（改变）该消息，也可以不作处理而继续传递该消息，还可以强制结束消息的传递。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用php数组函数进行函数式编程]]></title>
    <url>%2F2020%2F03%2F05%2F%E5%88%A9%E7%94%A8php%E6%95%B0%E7%BB%84%E5%87%BD%E6%95%B0%E8%BF%9B%E8%A1%8C%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 函数式编程是什么样子的代码？ 绝大多数的for、foreach和while都可以用数组函数代替吗？ foreach有代码副作用怎么理解？array_walk有吗？ 数组内的值互相比较，累加的时候用array_reduce。怎么理解？ 旧代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647for ($index = 0; $index &lt; count($scope) -1; $index++) &#123; $total = 0; $online = []; $tmp_k = []; foreach ($rs as $k =&gt; $v) &#123; if ($max == 0) &#123; $max = $v['online']; $data['max']['value'] = $v['online']; $data['max']['time'] = $v['time']; &#125; else &#123; if ($max &lt;= $v['online']) &#123; $data['max']['value'] = $v['online']; $data['max']['time'] = $v['time']; $max = $v['online']; &#125; &#125; $stamp = $v['stamp']; if ($stamp &gt; $scope[$index] &amp;&amp; $stamp &lt; $scope[$index + 1]) &#123; array_push($online, $v['online']); array_push($tmp_k, $k); &#125; else &#123; break; &#125; &#125; foreach ($tmp_k as $key) &#123; unset($rs[$key]); &#125; if(count($online)) &#123; array_push($data['info'], max($online)); &#125; else &#123; array_push($data['info'], 'null'); &#125;&#125; 这段代码实现了两个功能。 第一个是在一个从数据库中读取的列表数组中找出某个值是最大的一条记录， 并且把这个最大的值和跟这个值相关的时间给取出来。 第二个比较复杂，是将这个列表数组中的值映射到另外一个列表数组中，可以把这个过程看作是SQL中的JOIN操作，只是JOIN的条件异常复杂 ，在这里我也不详述了，阅读的同学也不必去深入探究。 重构123456789101112131415161718192021$maxInfo = array_reduce($rs, function($result, $item)&#123; if ($result['value'] &lt; $item['online']) &#123; $result['value'] = $item['online']; $result['time'] = $item['time']; &#125; return $result;&#125;, ['value' =&gt; 0]);$onlineInfo = array_map(function($item) use ($rs, $interval)&#123; $result = array_reduce($rs, function($value, $onlineItem) use ($item)&#123; $0 = abs($item - $onlineItem['stamp']); if($diff &lt;= $value['diff']) &#123; $value['diff'] = $diff; $value['val'] = $onlineItem['online']; &#125; return $value; &#125;, ['diff' =&gt; $interval, 'val' =&gt; 'null']); return $result['val'];&#125;, $scope); 从代码结构上来看， 重构后的代码的确清晰了不少。 我将原本拥挤在一起的两个功能进行了拆分，上面部份是求最大值，下面部份是对两个数组进行映射。这里我用到了两个PHP中数组的函数array_map和array_reduce，这篇文章想表达的思想就是利用此类函数来提高PHP代码的可读性。这类函数主要包括以下4个函数： array_filter array_map array_walk array_reduce 这4个函数威力巨大， 在处理列表数组方面可以完全替换掉for、foreach、while这些循环控制语句，这也是函数式编程方式在PHP的一部份体现。 数组函数array_filter1234567891011121314151617181920$data = [ ['id' =&gt; 1, 'name' =&gt; '张三', '性别' =&gt; '男', 'age' =&gt; 20], ['id' =&gt; 2, 'name' =&gt; '李四', '性别' =&gt; '男', 'age' =&gt; 21], ['id' =&gt; 3, 'name' =&gt; '王五', '性别' =&gt; '男', 'age' =&gt; 22], ['id' =&gt; 4, 'name' =&gt; '甲', '性别' =&gt; '女', 'age' =&gt; 20], ['id' =&gt; 5, 'name' =&gt; '乙', '性别' =&gt; '女', 'age' =&gt; 27], ['id' =&gt; 6, 'name' =&gt; '丙', '性别' =&gt; '女', 'age' =&gt; 19], ['id' =&gt; 7, 'name' =&gt; '丁', '性别' =&gt; '女', 'age' =&gt; 18],];$result = [];foreach ($data as $item) &#123; if ($item['性别'] == '女') &#123; array_push($result, $item); &#125;&#125; 这段代码将数组中性别字段为女的数据项提取出来。这是原汁原味的命令式程序代码。 如果data变量中的数据并非存放于php数组中，而是存在于关系数库的表之中，那如何取得性别为女的数据结果呢？ 对于程序员来说这貌似是一个更加简单的问题，一句SQL语句就搞定了。1select * from data where 性别='女'; 显然， 利用SQL查询数据更加方便，意途也更加清晰，毕竟一个SQL表达式就将所有的程序逻辑都给表达了现来。这句SQL只表达了：“我需要性别为女的数据，至于怎么拿，我不管”，除了结果，其它的它一概不知。 我们不妨把这种思路引入到PHP程序设计之中，不也意味着我们的PHP程序的逻辑表达也更加清晰，代码的可读性也更高。所幸， 这种利用表达式编程的方法在PHP中也完全可以实现。123$result = array_filter($data, function($item)&#123; return $item['性别'] == '女';&#125;); 利用array_filter函数，可以轻松的完成这个任务， 仔细观察一下， 是不是原来的程序逻辑都不见了，包括定义数组、循环、条件判断这些都不见了，逻辑方面是只剩下了一个性别比较语句，这对于代码所实现的功能一目了然。 和上面的SQL比较一下，这里的性别判断语句就是SQL中where子句后面的条件判断，而array_filter函数其实就是SQL中的where子句。 这就是SQL语句面向结果编程的逻辑原封不变的在PHP中的体现，也就是时下最流行的“声明性编程”或者也称为“表达式编程”。 此外，代码中性别判断语句所在的位置称之为lambda表达式， 更通俗一些的叫法是匿名函数。不难看出，在SQL的where条件中编写条件判断远不如在匿名函数中写PHP代码来的灵活，在where条件中只能执行or和and逻辑，而在php匿名函数中可以随便怎么写，只要函数的返回值是个布尔值就可以了，这也是php声明性编程优于SQL声明性编程的地方。 array_map12345678$result = [];foreach ($data as $item) &#123; $item['gender'] = $item['性别'] == '男' ? 'male' : 'female'; unset($item['性别']); array_push($result, $item); &#125; 数据中的性别字段是中文的，值也是中文的，现在想把字段名和字段值都改为英文的，就可以用上面这段代码实现。 下面是利用SQL的实现方式： 1select id, name case 性别 when '男' then 'male' else 'female' end as gender from data; SQL中case when语句好像不太好看， 但是不影响整体逻辑的表达。将这段SQL转换成PHP的方式实现。1234567$result = array_map(function($item)&#123; return [ 'id' =&gt; $item['id'], 'name' =&gt; $item['name'], 'gender' =&gt; $item['性别'] == '男' ? 'male' : 'female' ]&#125;, $data); 相比之前的PHP实现， 是不是简洁明了了许多。 在这里使用到了array_map函数。在SQL语句中以select语句最为常用，select的字面意思是“选择”，而select语句也被称之为选择查询，事实上从关系数据库的角度来说，select被称之为“投影”，并不是查询什么的。换言之，select语句只是将SQL的查询结果以一定的方式（选字段、计算值等等）提取出来了。php中的array_map表达的也是这层意思，“映射”与“投影”完全是一种意思的不同表达。 很多情况下，迭代的数据一般为一个二维关联数组，但array_map本身在回调函数的函数体内无法获取到关联数组的下标的。 目的：在回调体内获取迭代关联数组的下标值。 解决：可以把关联数组的下标通过array_map()的第三个形参把下标传进去。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081&lt;?php$arr = [ 'goods' =&gt; '辣条', 'spec' =&gt; [ 'attr' =&gt; [ '颜色', '口感', '副作用'], 'value' =&gt; [ '红色', '辣', 'The `菊花` is hot' ] ]];print_r($arr);/*Array( [goods] =&gt; 辣条 [spec] =&gt; Array ( [attr] =&gt; Array ( [0] =&gt; 颜色 [1] =&gt; 口感 [2] =&gt; 副作用 ) [value] =&gt; Array ( [0] =&gt; 红色 [1] =&gt; 辣 [2] =&gt; The `菊花` is hot ) ))*/$arr['spec'] = array_map(function($item, $key)&#123; return [ 'attr' =&gt; $key, 'value' =&gt; $item, ]; &#125;, $arr['spec']['value'], $arr['spec']['attr']);print_r($arr);/*Array( [goods] =&gt; 辣条 [spec] =&gt; Array ( [0] =&gt; Array ( [attr] =&gt; 颜色 [value] =&gt; 红色 ) [1] =&gt; Array ( [attr] =&gt; 口感 [value] =&gt; 辣 ) [2] =&gt; Array ( [attr] =&gt; 副作用 [value] =&gt; The `菊花` is hot ) ))*/ array_walkarray_walk函数没有像array_map和array_filter那样深刻的意义，但是它在设计可读性良好的代码时也是不可或缺的。 array_walk是for或foreach语句的替代函数。12345678foreach ($data as $item) &#123; echo $item['id'];&#125;array_walk($data, funcname($item)&#123; echo $item['id'];&#125;) 以上代码分别是foreach和array_walk对于遍历数组的实现方式。看起来，好像array_walk的实现方式更加复杂，但是在更深层次的语义方面foreach表达的是循环遍历，但是在这个循环的过程中，要做什么样的处理，是没有任何约束的， 删除被遍历的数组的某一项，或者修改一个十万八千里以外的变量的值，这便是所谓的“代码副作用”，俗话说“白蚁虽小，危害无穷”，当这些看似微不足道的副作用发展壮大时，便会给程序员维护程序代码带来的障碍是致命的。 而array_walk函数缺省情况下所有执行代码的作用域都在匿名函数内，如果要依赖或操作函数之外的数据，必须通过匿名函数的use关键字导入。通俗一点的请，array_walk函数的权限不如foreach来的大，因此，使用array_walk函数后，虽然无法让你随心所欲的编程，但是大限度的减少了你代码的副作用，两相权衡array_walk所带来的好处还是有值得使用它的理由的。 首先，大多数时候写代码根本不需要太大的“权限”，其次，把代码所影响的范围控制到最小好处不言而喻。微信张小龙讲过，微信做的最好的一点便是“克制”，我们写代码又何尝不是。这一点array_filter和array_map中也有体现，宽泛的讲，所有使用匿名函数的地方都能享受到这个好处。 array_walk所表达的语义就是“假如你需要用到我，那么你除了遍历以外，其它的事情最好都别干，否则你还是去用原生的foreach吧”。 第3个参数 1array_walk(array, myfunction, parameter...) 第3个参数规定用户自定义函数的参数，可以为函数设置一个或多个参数。 123456789$color = [ "a" =&gt; "red", "b" =&gt; "green", "c" =&gt; "blue"];array_walk($color, function($value, $key, $p)&#123; echo "$key $p $value&lt;br&gt;";&#125;, "has the value"); 输出结果：123a has the value redb has the value greenc has the value blue 向二维数组中追加元素 12345678910111213141516171819202122$addDataArr = [ [ 'order_id' =&gt; 6, 'add_time' =&gt; "2020-03-05 19:50:05", 'add_time_sync' =&gt; "0000-00-00 00:00:00", 'status' =&gt; 0, 'item_id' =&gt; 24353454 ], [ 'order_id' =&gt; 7, 'add_time' =&gt; "2020-03-05 19:55:12", 'add_time_sync' =&gt; "0000-00-00 00:00:00", 'status' =&gt; 0, 'item_id' =&gt; 12454758 ]];$appendArr = ['add_time_sync' =&gt; date('Y-m-d H:i:s')];array_walk($addDataArr, function(&amp;$val, $k, $appendArr)&#123; $val = array_merge($val, $appendArr);&#125;, $appendArr); 输出结果：1234567891011121314151617181920Array( [0] =&gt; Array ( [order_id] =&gt; 6 [add_time] =&gt; 2020-03-05 19:50:05 [add_time_sync] =&gt; 2020-03-05 19:54:17 [status] =&gt; 0 [item_id] =&gt; 24353454 ) [1] =&gt; Array ( [order_id] =&gt; 7 [add_time] =&gt; 2020-03-05 19:52:12 [add_time_sync] =&gt; 2020-03-05 19:54:17 [status] =&gt; 0 [item_id] =&gt; 12454758 )) array_reducearray_reduce是上面所讲的三个函数的集大成者，这三个函数的底层完全可以由array_reduce实现。 先看一下下面的php代码。12345678910111213141516171819202122// 求最大年龄$maxAge = 0;$result = null;foreach ($data as $item) &#123; if($item['age'] &gt; $maxAge) &#123; $maxAge = $item['age']; $result = $item; &#125;&#125;// 计算平均年龄$total = 0;foreach ($data as $item) &#123; $total += $item['age'];&#125;$avg = $total / count($data); 常规的PHP写法，代码分别用于计算数组记录中平均年龄和最大年龄，代码需要循环数组，并把计算结果存入一个标量（单个值，区分于列表变量）。 假如要以表达式编程的方式完成编写这两个功能，利用array_filter、array_walk、array_map三个函数是很难一步到位实现的。 于是，就到了array_reduce大显身手的时候了。1234567$result = array_reduce($data, function($curr, $item)&#123; return $curr['age'] &lt; $item['age'] ? $item : $curr;&#125;, ['age' =&gt; 0]);$avg = array_reduce($data, function($curr, $item)&#123; return $curr + $item['age'];&#125;, 0) / count($data); 上面的代码是求平均年龄和最大年龄的表达式编程的实现，如果对array_reduce函数的工作机制不了解，看上面两段代码会觉得在看天书。12345678function array_reduce($data, $callback, $initial)&#123; foreach ($data as $index =&gt; $val) &#123; $initial = $callback($initial, $val); &#125; return $initial;&#125; 这是array_reduce函数的实现代码，函数有3个参数，3个参数的作用分别是： 第一个参数$data，就要是处理的数据源。 第二个参数$callback，循环遍历时会被调用的函数，函数返回的结果在下一次循环调用时会被再次当成参数传入。 第三个参数$initial，作为$callback函数被初次调用时的参数传递。 再来一个递归版本的array_reduce实现，帮助更好的理解这个函数的使用意义。12345678910function array_reduce($data, $callback, $initial)&#123; if(count($data) == 0) &#123; return $initial; &#125; $item = array_shift($data); $initial = $callback($initial, $item); return array_reduce($data, $callback, $initial);&#125; 善用array_reduce函数几乎可以替换掉绝大多数需要使用foreach、for、while语句的代码。 123456789$arr = [ ["id" =&gt; 1, 'name' =&gt; "a"], ["id" =&gt; 2, "name" =&gt; "c"], ["id" =&gt; 3, "name" =&gt; "d"]];echo ltrim(array_reduce($arr , function($result , $v)&#123; return $result.','.$v['id'];&#125;), ','); 在标准的函数式编程语言中，是没有循环控制语句的，假如要进行循环计算，都是使用此类函数来实现的，如果某些极端的情况下这些函数无法满足需求，那么就以手动写递归来实现循环，以达到表达式编程的目的。 array_walk与array_map区别1、array_map里面的函数可以是自定义函数，也可以是php自带的函数，比如trim去除空格等。而array_walk里面的函数只能是自定义的函数。 2、array_map必须要有返回值，因为要填充数组。而array_walk可以没有返回值，输出的话要在调用的函数中通过echo来输出。 3、map主要是为了得到你的回调函数处理后的新数组，要的是结果。walk主要是对每个参数都使用一次你的回调函数，要的是处理的过程。 总结1.通过函数本身的意义就能表达出代码实现了什么样的功能，而不用去琢磨代码具体细节来理解代码的作用。 2.表达式编程相对于命令式编程能极大的简化功能的实现过程， 提升编码效率。 3.表达式编程对于代码的可读性、可维护性具有非凡的意义。 4.利用匿名函数控制代码的副作用。 5.由传统的面向过程式程序设计向现代化的函数式编程靠拢。 通过前面示例的讲解，利用这4个函数实现的代码相对于传统的实现方式并没有不可思议的变化，然而，当需要解决的问题复杂到一定程度时，合理利用这4个函数会使代码的复杂性大规模下降。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hyperf-AOP面向切面编程]]></title>
    <url>%2F2020%2F03%2F05%2FHyperf-AOP%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 适合和一起查看。 概念AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过动态代理等技术实现程序功能的统一维护的一种技术。AOP 是 OOP 的延续，也是 Hyperf 中的一个重要内容，是函数式编程的一种衍生范型。利用 AOP 可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 用通俗的话来讲，就是在Hyperf里可以通过切面(Aspect) 介入到由hyperf/di管理的任意类的任意方法的执行流程中去，从而改变或加强原方法的功能，这就是 AOP。 使用 AOP 功能必须使用 hyperf/di 来作为依赖注入容器 介绍相对于其它框架实现的 AOP 功能的使用方式，我们进一步简化了该功能的使用不做过细的划分，仅存在 环绕(Around) 一种通用的形式： 切面(Aspect) 为对流程织入的定义类，包括要介入的目标，以及实现对原方法的修改加强处理代理类(ProxyClass) ，每个被介入的目标类最终都会生成一个代理类，来达到执行 切面(Aspect) 方法的目的，而非通过原类定义切面(Aspect)每个切面(Aspect) 必须实现 Hyperf\Di\Aop\AroundInterface 接口，并提供public的$classes和$annotations 属性，为了方便使用，我们可以通过继承 Hyperf\Di\Aop\AbstractAspect 来简化定义过程，我们通过代码来描述一下。 123456789101112131415161718192021222324252627282930313233343536&lt;?phpnamespace App\Aspect;use App\Service\SomeClass;use App\Annotation\SomeAnnotation;use Hyperf\Di\Annotation\Aspect;use Hyperf\Di\Aop\AbstractAspect;use Hyperf\Di\Aop\ProceedingJoinPoint;/** * @Aspect */class FooAspect extends AbstractAspect&#123; // 要切入的类，可以多个，亦可通过 :: 标识到具体的某个方法，通过 * 可以模糊匹配 public $classes = [ SomeClass::class, 'App\Service\SomeClass::someMethod', 'App\Service\SomeClass::*Method', ]; // 要切入的注解，具体切入的还是使用了这些注解的类，仅可切入类注解和类方法注解 public $annotations = [ SomeAnnotation::class, ]; public function process(ProceedingJoinPoint $proceedingJoinPoint) &#123; // 切面切入后，执行对应的方法会由此来负责 // $proceedingJoinPoint 为连接点，通过该类的 process() 方法调用原方法并获得结果 // 在调用前进行某些处理 $result = $proceedingJoinPoint-&gt;process(); // 在调用后进行某些处理 return $result; &#125;&#125; 每个 切面(Aspect) 必须定义 @Aspect 注解或在 config/autoload/aspects.php 内配置均可发挥作用。 使用 @Aspect 注解时需 use Hyperf\Di\Annotation\Aspect; 命名空间； 代理类缓存所有被 AOP 影响的类，都会在./runtime/container/proxy/文件夹内生成对应的代理类缓存，服务启动时，如果类所对应的代理类缓存存在，则不会重新生成直接使用缓存，即使Aspect的切入范围发生了改变。不存在时，则会自动重新生成新的代理类缓存。 在部署生产环境时，我们可能会希望 Hyperf 提前将所有代理类提前生成，而不是使用时动态的生成，可以通过 php bin/hyperf.php di:init-proxy 命令来生成所有代理类，该命令会忽视现有的代理类缓存，全部重新生成。 基于以上，我们可以将生成代理类的命令和启动服务的命令结合起来，vendor/bin/init-proxy.sh &amp;&amp; php bin/hyperf.php start 来达到自动重新生成所有代理类缓存然后启动服务的目的。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Hyperf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hyperf-注解]]></title>
    <url>%2F2020%2F03%2F05%2FHyperf-%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： PHP为什么要专门引入注解？和C#的特性有什么区别？ 体会不同语言使用注解此类功能的异曲同工之妙。 注解是Hyperf非常强大的一项功能，可以通过注解的形式减少很多的配置，以及实现很多非常方便的功能。 概念什么是注解什么是注释？ 注释：给程序员看，帮助理解代码，对代码起到解释、说明的作用。 注解：给应用程序看，用于元数据的定义，单独使用时没有任何作用，需配合应用程序对其元数据进行利用才有作用。 注解解析如何实现？Hyperf使用了doctrine/annotations包来对代码内的注解进行解析，注解必须写在下面示例的标准注释块才能被正确解析，其它格式均不能被正确解析。 注释块示例：123/** * @AnnotationClass() */ 在标准注释块内通过书写@AnnotationClass()这样的语法即表明对当前注释块所在位置的对象（类、类方法、类属性）进行了注解的定义，AnnotationClass对应的是一个注解类的类名，可写全类的命名空间，亦可只写类名，但需要在当前类 use 该注解类以确保能够根据命名空间找到正确的注解类。 注解是如何发挥作用的？我们有说到注解只是元数据的定义，需配合应用程序才能发挥作用，在Hyperf里，注解内的数据会被收集到Hyperf\Di\Annotation\AnnotationCollector类供应用程序使用，当然根据您的实际情况，也可以收集到您自定义的类去，随后在这些注解本身希望发挥作用的地方对已收集的注解元数据进行读取和利用，以达到期望的功能实现。 使用注解注解一共有3种应用对象，分别是类、类方法和类属性。 使用类注解类注解定义是在 class 关键词上方的注释块内，比如常用的 @Controller 和 @AutoController 就是类注解的使用典范，下面的代码示例则为一个正确使用类注解的示例，表明 @ClassAnnotation 注解应用于 Foo 类。1234/** * @ClassAnnotation() */class Foo &#123;&#125; 使用类方法注解类方法注解定义是在方法上方的注释块内，比如常用的 @RequestMapping 就是类方法注解的使用典范，下面的代码示例则为一个正确使用类方法注解的示例，表明 @MethodAnnotation 注解应用于 Foo::bar() 方法。12345678910class Foo&#123; /** * @MethodAnnotation() */ public function bar() &#123; // some code &#125;&#125; 使用类属性注解类属性注解定义是在属性上方的注释块内，比如常用的 @Value 和 @Inject 就是类属性注解的使用典范，下面的代码示例则为一个正确使用类属性注解的示例，表明 @PropertyAnnotation 注解应用于 Foo 类的 $bar 属性。1234567class Foo&#123; /** * @PropertyAnnotation() */ private $bar;&#125; 注解参数传递传递主要的单个参数 @DemoAnnotation(“value”)传递字符串参数 @DemoAnnotation(key1=”value1”, key2=”value2”)传递数组参数 @DemoAnnotation(key={“value1”, “value2”}) 自定义注解创建一个注解类在任意地方创建注解类，如下代码示例：123456789101112131415161718192021namespace App\Annotation;use Hyperf\Di\Annotation\AbstractAnnotation;/** * @Annotation * @Target(&#123;"METHOD","PROPERTY"&#125;) */class Bar extends AbstractAnnotation&#123; // some code&#125;/** * @Annotation * @Target("CLASS") */class Foo extends AbstractAnnotation&#123; // some code&#125; 注意注解类的 @Annotation 和 @Target 注解为全局注解，无需 use 其中 @Target 有如下参数： METHOD 注解允许定义在类方法上PROPERTY 注解允许定义在类属性上CLASS 注解允许定义在类上ALL 注解允许定义在任何地方我们注意一下在上面的示例代码中，注解类都继承了 Hyperf\Di\Annotation\AbstractAnnotation 抽象类，对于注解类来说，这个不是必须的，但对于 Hyperf 的注解类来说，继承 Hyperf\Di\Annotation\AnnotationInterface 接口类是必须的，那么抽象类在这里的作用是提供极简的定义方式，该抽象类已经为您实现了注解参数自动分配到类属性、根据注解使用位置自动按照规则收集到 AnnotationCollector 这样非常便捷的功能。 自定义注解收集器注解的收集时具体的执行流程也是在注解类内实现的，相关的方法由 Hyperf\Di\Annotation\AnnotationInterface 约束着，该接口类要求了下面 3 个方法的实现，您可以根据自己的需求实现对应的逻辑： public function collectClass(string $className): void; 当注解定义在类时被扫描时会触发该方法public function collectMethod(string $className, ?string $target): void; 当注解定义在类方法时被扫描时会触发该方法public function collectProperty(string $className, ?string $target): void 当注解定义在类属性时被扫描时会触发该方法 利用注解数据在没有自定义注解收集方法时，默认会将注解的元数据统一收集在Hyperf\Di\Annotation\AnnotationCollector 类内，通过该类的静态方法可以方便的获取对应的元数据用于逻辑判断或实现。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Hyperf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP的函数式编程]]></title>
    <url>%2F2020%2F03%2F05%2FPHP%E7%9A%84%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： function a() { return (function(){}); }返回什么类型？ 第一等公民是什么意思？ 只用“表达式”，不用“语句”是什么意思？ 闭包和函数式编程密切相关，可以说函数式编程就是闭包。怎么理解？ 只要函数里有相同代码就可以使用闭包，尤其是if else里面有相同的代码。怎么理解？ 处理一个数组。 12345678&lt;?phpdeclare(strict_types=1);for ($i=0; $i &lt; 101; $i++) &#123; $results[] = $i;&#125; 最终都是返回Generator生成器。 常见写法12345678910111213141516171819202122232425262728/** * 返回闭包对象 * */function handleArrYield1(array $data)&#123; return (function ($data) &#123; foreach ($data as $value) &#123; yield $value; &#125; &#125;);&#125;$yield1 = handleArrYield1($results);print_r($yield1); // Closure Object ( [parameter] =&gt; Array ( [$data] =&gt; ) )print_r($yield1($results)); // Generator Object ( )echo '&lt;br/&gt;';foreach ($yield1($results) as $key =&gt; $value) &#123; echo $value; echo "&lt;br/&gt;";&#125; 常规函数 12345678910111213$data = function ($results)&#123; foreach ($results as $v) &#123; yield $v; &#125;&#125;;foreach ($data($results) as $key =&gt; $value) &#123; echo $value; echo "&lt;br/&gt;";&#125; 闭包 12345678910111213$data = function () use ($results)&#123; foreach ($results as $v) &#123; yield $v; &#125;&#125;;foreach ($data() as $key =&gt; $value) &#123; echo $value; echo "&lt;br/&gt;";&#125; 抽象写法1234567891011121314151617181920212223242526/** * 返回生成器对象 * */function handleArrYield2(array $data)&#123; return (function ($data) &#123; foreach ($data as $value) &#123; yield $value; &#125; &#125;)($data);&#125;$yield2 = handleArrYield2($results);print_r($yield2); // Generator Object ( )echo "&lt;br/&gt;";foreach ($yield2 as $key =&gt; $value) &#123; echo $value; echo "&lt;br/&gt;";&#125; 函数式编程闭包closure是函数式编程。 闭包可以理解成“定义在一个函数内部的函数”。在本质上，闭包是将函数内部和函数外部连接起来的桥梁。 实现同样的功能函数式编程所需要的代码比面向对象编程要少很多，代码更加简洁明晰。 函数式编程的特点：函数可以赋给变量，所以，可作为参数传递，可作为返回值返回。PHP返回闭包。 array_walk、array_map等都是函数式编程。 什么是函数式编程与面向对象编程（Object-oriented programming）和过程式编程（Procedural programming）并列的编程范式。 最主要的特征是，函数是第一等公民。 强调将计算过程分解成可复用的函数，典型例子就是map方法和reduce方法组合而成的MapReduce算法。 只有纯的、没有副作用的函数，才是合格的函数。 PHP中的函数例子：1234567891011121314151617$grade = [ [ 'id' =&gt; 1, 'subject' =&gt; 'chinese', 'score' =&gt; 82 ], [ 'id' =&gt; 2, 'subject' =&gt; 'math', 'score' =&gt; 98 ], [ 'id' =&gt; 3, 'subject' =&gt; 'english', 'score' =&gt; 78 ],]; array_filter — 用回调函数过滤数组中的单元 1234// 获取成绩大于80分的学科$arrayFilter = array_filter($grade, function($item)&#123; return $item['score'] &gt; 80 ;&#125;); array_map() - 为数组的每个元素应用回调函数 123456789// 不影响原数组，返回一个新数组$arrayMap = array_map(function($item)&#123; return [ 'id' =&gt; $item['id'], 'subject' =&gt; $item['subject'], 'score' =&gt; $item['score'], 'grade' =&gt; $item['score'] &gt;= 60 ? '合格' : '不合格', ];&#125;, $grade); array_reduce() - 用回调函数迭代地将数组简化为单一的值 123456789// 求分数最高的科目,返回最大科目信息$maxScore = array_reduce($grade, function($init, $val)&#123; return $init['score'] &gt; $val['score'] ? $init : $val;&#125;, ['score' =&gt; 0]); // 求平均成绩$avgScore = array_reduce($grade, function($init, $item)&#123; return $init + $item['score'];&#125;, 0) / count($grade); array_walk() - 使用用户自定义函数对数组中的每个元素做回调处理 1234// 修改原数组array_walk($grade, function(&amp;$item, $index)&#123; $item['grade'] = $item['score'] &gt;= 60 ? '合格' : '不合格';&#125;); 定义简单说，“函数式编程”是一种“编程范式”（programming paradigm），也就是如何编写程序的方法论。它属于“结构化编程”的一种，主要思想是把运算过程尽量写成一系列嵌套的函数调用。 函数编程式是一种编程风格，它将关注点从执行命令转移到表达式计算。这些表达式是使用函数构成的，结合这些函数可以得到我们要查找的结果。 闭包通常出现在允许将函数处理为第一类值（First-class value）的语言中，这意味着函数可以动态创建并作为参数传递给其他语言。 函数式编程的特点函数是“第一等公民” 所谓“第一等公民”（first class），指的是函数与其他数据类型一样，处于平等地位，可以赋值给其他变量，也可以作为参数，传入另一个函数，或者作为别的函数的返回值。 只用“表达式”，不用“语句” “表达式”（expression）是一个单纯的运算过程，总是有返回值；“语句”（statement）是执行某种操作，没有返回值。函数式编程要求，只使用表达式，不使用语句。也就是说，每一步都是单纯的运算，而且都有返回值。 原因是函数式编程的开发动机，一开始就是为了处理运算（computation），不考虑系统的读写（I/O）。“语句”属于对系统的读写操作，所以就被排斥在外。 当然，实际应用中，不做I/O是不可能的。因此，编程过程中，函数式编程只要求把I/O限制到最小，不要有不必要的读写行为，保持计算过程的单纯性。 函数式编程不依赖、也不会改变外界的状态，只要给定输入参数，返回的结果必定相同。因此，每一个函数都可以被看做独立单元，很有利于进行单元测试（unit testing）和除错（debugging），以及模块化组合。 副作用 所谓“副作用”，指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。在纯函数式语言中，函数只能读取其参数提供给它的内容，并且它对世界产生影响的唯一方式就是通过它返回的值。 递归和迭代 对于函数式而言，循环体有一个无法避免的副作用，就是它会修改某些对象的状态，通常这些对象又是和其他部分共享的。而且也因为变量值是不可变的，纯函数编程语言也无法实现循环。 所以纯函数编程语言通常不包含像while和for这样的迭代构造器，而是采用的无需修改的递归。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP语法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP算法学习之分治法]]></title>
    <url>%2F2020%2F03%2F05%2FPHP%E7%AE%97%E6%B3%95%E5%AD%A6%E4%B9%A0%E4%B9%8B%E5%88%86%E6%B2%BB%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 简介分治法，顾名思义就是分而治之，即把问题拆解为性质相同的小问题再处理。 分治法除了分治，名字里还少了一步，那就是合，也就是怎样通过小问题的答案得到拆分之前大问题的答案。 分治法的时间复杂度：分治法并没有像二分法一样每次丢掉一半无用的解，它只是做了分离，而分离的两部分都是需要处理的，所以分治法的时间复杂度是O(n)。特例情况是当分离的两部分继续分治处理出现重复计算的情况时，就会比O(n)大了！所以请确保你的分治尽量不要出现重叠计算的情况。 那么什么问题适合用分治的思想解决呢？ 二叉树！ 二叉树这种左右子树的结构天生就非常适合分治，所以它的大部分问题都能用分治解决，碰到一个问题你只需要问问左子树你怎么处理，右子树你怎么办，得到左右子树的答案后，你再想想最后的答案是个啥。 除了二叉树，快速排序归并排序这两个著名的排序算法也是分治的思想。下面就举几个解题的例子来加深一下对分治法的学习。 1、前序遍历二叉树 12345678910111213141516171819202122232425262728293031323334class TreeNode&#123; public $val; public $left; public $right; function __construct($val, $left = null, $right = null) &#123; $this-&gt;val = intval($val); $this-&gt;left = $left; $this-&gt;right = $right; &#125;&#125;function preorder(TreeNode $root = null)&#123; $result = []; // 治：当节点不存在时，返回空数组 if ($root == null) &#123; return $result; &#125; // 分：分别求出当前节点左右子树的前序遍历结果 $left = preorder($root-&gt;left); $right = preorder($root-&gt;right); // 合：因为是前序遍历，所以先添加当前节点的val，然后是左子树右子树 $result[] = $root-&gt;val; $result = array_merge($result, $left, $right); return $result;&#125; 2、求二叉树的最大路径和 给一棵二叉树，找出从根节点出发的路径中，和最大的一条。 这条路径可以在任何二叉树中的节点结束，但是必须包含至少一个点。 12345678910111213141516171819202122function maxPathSum(TreeNode $root = null)&#123; // 治：当节点不存在时，返回0 if ($root == null) &#123; return 0; &#125; // 分：分别求出当前节点左右子树的最大路径和 $left = maxPathSum($root-&gt;left); $right = maxPathSum($root-&gt;right); // 合：此处有坑，注意左右子树和都为负数的情况 if ($left &lt; 0 &amp;&amp; $right &lt; 0) &#123; return $root-&gt;val; &#125; else &#123; return $root-&gt;val + max($left, $right); &#125;&#125; 3、求最近公共祖先 给定一棵二叉树，找到两个节点的最近公共父节点(LCA)，给出的两个节点都在树中存在。 123456789101112131415161718192021222324252627function lca(TreeNode $root = null, TreeNode $A, TreeNode $B)&#123; if ($root == null || $root == $A || $root == $B) &#123; return $root; &#125; $left = lca($root-&gt;left, $A, $B); $right = lca($root-&gt;right, $A, $B); if ($left &amp;&amp; $right) &#123; return $root; &#125; elseif($left) &#123; return $left; &#125; elseif($right) &#123; return $right; &#125; else &#123; return null; &#125;&#125; 4、快速排序 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?php $arr = [25,133,452,364,5876,293,607,365,8745,534,18,33]; function quick_sort($arr)&#123; // 判断是否需要继续 if (count($arr) &lt;= 1) &#123; return $arr; &#125; $middle = $arr[0]; // 中间值 $left = array(); // 小于中间值 $right = array();// 大于中间值 // 循环比较 for ($i=1; $i &lt; count($arr); $i++) &#123; if ($middle &lt; $arr[$i]) &#123; // 大于中间值 $right[] = $arr[$i]; &#125; else &#123; // 小于中间值 $left[] = $arr[$i]; &#125; &#125; // 递归排序两边 $left = quick_sort($left); $right = quick_sort($right); // 合并排序后的数据，别忘了合并中间值 return array_merge($left, array($middle), $right);&#125; var_dump($arr);var_dump(quick_sort($arr));]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>数据结构与算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP反射机制实现自动依赖注入]]></title>
    <url>%2F2020%2F03%2F04%2FPHP%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 依赖注入为什么又叫控制反转？ 只要知道类的名字就能实例化该类。依赖注入就是传类名做参数，然后保证有这个类就好了。怎么理解？ 手动和自动依赖注入的区别是什么？ PHP支持可变长度参数吗？ 使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class A&#123; protected $bObj; /** * 构造函数依赖注入 * 用于测试多级依赖注入 A依赖B，B依赖C * * @param B $b [使用依赖注入B] */ public function __construct(B $b) &#123; $this-&gt;bObj = $b; &#125; /** * 方法调用依赖注入 * * @param C $c [依赖注入C] * @param string $param [这个是自己手动填写的参数] * @return void */ public function aa(C $c, $param) &#123; $c-&gt;cc(); echo "&lt;br/&gt;"; echo 'params:' . $param; &#125; /** * 验证依赖注入是否成功 * @return void */ public function aaa() &#123; $this-&gt;bObj-&gt;bbc(); &#125;&#125;class B&#123; protected $cObj; /** * 构造函数依赖注入 * * @param C $c [使用依赖注入C] */ public function __construct(C $c) &#123; $this-&gt;cObj = $c; &#125; public function bb() &#123; echo 'this is B-&gt;bb()'; &#125; public function bbc() &#123; $this-&gt;cObj-&gt;cc(); &#125;&#125;class C&#123; public function cc() &#123; echo 'this is C-&gt;cc()'; &#125;&#125; 测试构造函数的依赖注入 12345678910111213141516171819// 使用IOC来创建A类的实例，A的构造函数依赖B类，B的构造函数依赖C类。$aObj = IOC::getInstance('A');$aObj-&gt;aaa(); // 输出：this is C-&gt;cc() ， 说明依赖注入成功。// 打印$aObjprint_r($aObj);// 打印结果，可以看出A中有B实例，B中有C实例，说明依赖注入成功。/*A Object( [bObj:protected] =&gt; B Object ( [cObj:protected] =&gt; C Object ( ) ))*/ 测试方法依赖注入 123456789$methodResult = IOC::make('A', 'aa', ['this is param a']);print_r($methodResult);// 输出结果，可以看出依赖注入成功。/*this is C-&gt;cc()params:this is param a*/ 从上面两个例子可以看出我们创建对象或者调用方法时，根本就不用知道该类或该方法依赖了哪个类。使用反射机制可以轻松的为我们自动注入所需要的类。 源码使用php的反射函数，创建一个容器类，使用该类来实现其他类的依赖注入功能。依赖注入分为两种，一种是构造函数的依赖注入，一种是方法的依赖注入。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135/** * 工具类，使用该类来实现自动依赖注入。 * */class IOC&#123; /* * 获得类的对象实例 * * @param string $className [类名] * @return object 实例对象 */ public static function getInstance($className) &#123; $paramArr = self::getMethodParams($className); return (new ReflectionClass($className))-&gt;newInstanceArgs($paramArr); /* A Object ( [bObj:protected] =&gt; B Object ( [cObj:protected] =&gt; C Object ( ) ) ) */ &#125; /** * 执行类的方法 * * @param string $className [类名] * @param string $methodName [方法名称] * @param array $params [额外的参数] * @return */ public static function make($className, $methodName, $params = []) &#123; // 获取类的实例 $instance = self::getInstance($className); // 获取该方法所需要依赖注入的参数 $paramArr = self::getMethodParams($className, $methodName); return $instance-&gt;&#123;$methodName&#125;(...array_merge($paramArr, $params)); &#125; /** * 获得类的方法参数，只获得有类型的参数 * * @param string $className [类名] * @param string $methodsName [构造函数] * @return array [参数数组] */ protected static function getMethodParams($className, $methodsName = '__construct') &#123; // 获得该类的反射类 $class = new ReflectionClass($className); // ReflectionClass Object ( [name] =&gt; A ) $paramArr = []; // 记录参数，和参数类型 // 判断该类是否有构造函数 if ($class-&gt;hasMethod($methodsName)) &#123; // 获得构造函数 $construct = $class-&gt;getMethod($methodsName); // ReflectionMethod Object ( [name] =&gt; __construct [class] =&gt; A ) // 判断构造函数是否有参数 $params = $construct-&gt;getParameters(); // Array ( [0] =&gt; ReflectionParameter Object ( [name] =&gt; b ) ) if (count($params) &gt; 0) &#123; // 判断参数类型 foreach ($params as $key =&gt; $param) &#123; if ($paramClass = $param-&gt;getClass()) // ReflectionClass Object ( [name] =&gt; B ) &#123; // 获得参数类型名称 $paramClassName = $paramClass-&gt;getName(); // B // 获得参数类型 // 递归 $args = self::getMethodParams($paramClassName); // print_r($args); /* Array ( ) Array ( [0] =&gt; C Object ( ) ) */ $paramArr[] = (new ReflectionClass($paramClass-&gt;getName()))-&gt;newInstanceArgs($args); // $args这个参数以array形式传递到类的构造函数。 &#125; &#125; &#125; &#125; // print_r($paramArr); /* Array ( ) Array ( [0] =&gt; C Object ( ) ) Array ( [0] =&gt; B Object ( [cObj:protected] =&gt; C Object ( ) ) ) */ return $paramArr; &#125;&#125; laravel中利用反射实现依赖注入在一个类中经常会依赖于其他的对象，先看一下经典的写法。 12345678910class Foo &#123; public $bar; public function __construct() &#123; $this-&gt;bar = new Bar(); &#125;&#125;$foo = new Foo(); 当类的依赖发生改变时，比如Bar这个类需要实例化参数时，而依赖于它的类有很多，总不能一个一个地去修改吧。 再看一下使用依赖注入怎么做、 123456789101112class Foo &#123; public $bar; public function __construct($bar) &#123; $this-&gt;bar = $bar; &#125;&#125;$bar = new Bar();$foo = new Foo($bar); 将Bar类在外部实例化好后，作为一个参数传入进Foo类，从而实现了控制反转，假如现在Bar类需要参数了，外部修改就好了，不必一个个地去修改依赖于它的类。 在laravel中，经常写出下面这种代码： 1234567class SomeController &#123; public function index(Request $request) &#123; dd($request-&gt;all()); &#125;&#125; 只要在方法参数中申明Request $request，就可以直接使用$request对象了，非常地方便。 其实laravel在背后利用PHP的反射机制为我们做了$request = new Request这一步。反射是一种类的反省能力，可以导出类的详细信息包括属性、方法、甚至注释等等。 实现，看代码：1234567891011$method = new ReflectionMethod('SomeController', 'index');$args = [];foreach($method-&gt;getParameters() as $parameter) &#123; if ($class = $parameter-&gt;getClass()) &#123; $args[] = new $class-&gt;name; //$request = new Request &#125;&#125;$method-&gt;invokeArgs(new SomeController, $args); 通过ReflectionMethod获取类方法的参数，如果参数是其他的类，就实例化后作为参数使用ReflectionMethod::invokeArgs 传入到类方法中，原理就是这么简单。 通常使用new ReflectionClass(‘className’) 来反射类，ReflectionMethod来反射类方法。 总结只要熟悉php的反射机制，依赖注入并不难实现，上面的代码为了方便理解，所以写的简单粗暴，在实际的项目中肯定不会这么简单，比如：会对注入的类和参数进行配置，比如会缓存实例化过的类，下次需要该类的实例时，可以直接使用，而不用在重新初始化，等等。不过相信原理了解了，其他的可以随着项目的需求自己去完善。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hyperf-依赖注入]]></title>
    <url>%2F2020%2F03%2F03%2FHyperf-%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 依赖注入的思想，无论什么语言都是相通的。怎么理解？ 类的关系及注入是无需显性定义的。怎么理解？ 简介Hyperf默认采用hyperf/di作为框架的依赖注入管理容器，hyperf/di是一个强大的用于管理类的依赖关系并完成自动注入的组件，与传统依赖注入容器的区别在于更符合长生命周期的应用使用、提供了注解及注解注入的支持、提供了无比强大的AOP面向切面编程能力。 绑定对象关系简单对象注入通常来说，类的关系及注入是无需显性定义的，这一切Hyperf都会默默的为您完成，我们通过一些代码示例来说明一下相关的用法。 假设我们需要在IndexController内调用UserService类的getInfoById(int $id)方法。12345678910namespace App\Service;class UserService&#123; public function getInfoById(int $id) &#123; // 我们假设存在一个Info实体 return (new Info())-&gt;fill($id); &#125;&#125; 通过构造方法注入123456789101112131415161718192021222324namespace App\Controller;use App\Service\UserService;class IndexController&#123; /** * @var UserService */ private $userService; // 通过在构造函数的参数上声明参数类型完成自动注入 public function __construct(UserService $userService) &#123; $this-&gt;userService = $userService; &#125; public function index() &#123; $id = 1; // 直接使用 return $this-&gt;userService-&gt;getInfoById($id); &#125;&#125; 注意调用方也就是IndexController必须是由DI创建的对象才能完成自动注入，而Controller默认是由DI创建的，所以可以直接使用构造函数注入，直接new该对象不会生效。 当您希望定义一个可选的依赖项时，可以通过给参数定义为nullable或将参数的默认值定义为null，即表示该参数如果在DI容器中没有找到或无法创建对应的对象时，不抛出异常而是直接使用null来注入。12345678910111213141516171819202122232425262728&lt;?phpnamespace App\Controller;use App\Service\UserService;class IndexController&#123; /** * @var null|UserService */ private $userService; // 通过设置参数为 nullable，表明该参数为一个可选参数 public function __construct(?UserService $userService) &#123; $this-&gt;userService = $userService; &#125; public function index() &#123; $id = 1; if ($this-&gt;userService instanceof UserService) &#123; // 仅值存在时 $userService 可用 return $this-&gt;userService-&gt;getInfoById($id); &#125; return null; &#125;&#125; 通过@Inject注解注入1234567891011121314151617181920212223&lt;?phpnamespace App\Controller;use App\Service\UserService;use Hyperf\Di\Annotation\Inject;class IndexController&#123; /** * 通过 `@Inject` 注解注入由 `@var` 注解声明的属性类型对象 * * @Inject * @var UserService */ private $userService; public function index() &#123; $id = 1; // 直接使用 return $this-&gt;userService-&gt;getInfoById($id); &#125;&#125; 使用@Inject注解时需use Hyperf\Di\Annotation\Inject;命名空间； Required参数 Required参数仅可在1.1.0版本或更高版本使用。 @Inject注解存在一个required参数，默认值为true，当将该参数定义为false时，则表明该成员属性为一个可选依赖，当对应@var的对象不存在于DI容器或不可创建时，将不会抛出异常而是注入一个null，如下： 123456789101112131415161718192021222324252627&lt;?phpnamespace App\Controller;use App\Service\UserService;use Hyperf\Di\Annotation\Inject;class IndexController&#123; /** * 通过 `@Inject` 注解注入由 `@var` 注解声明的属性类型对象 * 当 UserService 不存在于 DI 容器内或不可创建时，则注入 null * * @Inject(required=false) * @var UserService */ private $userService; public function index() &#123; $id = 1; if ($this-&gt;userService instanceof UserService) &#123; // 仅值存在时 $userService 可用 return $this-&gt;userService-&gt;getInfoById($id); &#125; return null; &#125;&#125; 抽象对象注入基于上面的例子，从合理的角度上来说，Controller面向的不应该直接是一个UserService类，可能更多的是一个UserServiceInterface的接口类，此时我们可以通过config/autoload/dependencies.php来绑定对象关系达到目的。 定义一个接口类：1234567&lt;?phpnamespace App\Service;interface UserServiceInterface&#123; public function getInfoById(int $id);&#125; UserService实现接口类：1234567891011&lt;?phpnamespace App\Service;class UserService implements UserServiceInterface&#123; public function getInfoById(int $id) &#123; // 我们假设存在一个 Info 实体 return (new Info())-&gt;fill($id); &#125;&#125; 在config/autoload/dependencies.php内完成关系配置：1234&lt;?phpreturn [ \App\Service\UserServiceInterface::class =&gt; \App\Service\UserService::class]; 这样配置后就可以直接通过UserServiceInterface来注入UserService对象了，我们仅通过注解注入的方式来举例，构造函数注入也是一样的：123456789101112131415161718192021&lt;?phpnamespace App\Controller;use App\Service\UserServiceInterface;use Hyperf\Di\Annotation\Inject;class IndexController&#123; /** * @Inject * @var UserServiceInterface */ private $userService; public function index() &#123; $id = 1; // 直接使用 return $this-&gt;userService-&gt;getInfoById($id); &#125;&#125; 工厂对象注入我们假设UserService的实现会更加复杂一些，在创建UserService对象时构造函数还需要传递进来一些非直接注入型的参数，假设我们需要从配置中取得一个值，然后UserService需要根据这个值来决定是否开启缓存模式。 我们需要创建一个工厂来生成UserService对象：123456789101112131415161718&lt;?php namespace App\Service;use Hyperf\Contract\ConfigInterface;use Psr\Container\ContainerInterface;class UserServiceFactory&#123; // 实现一个 __invoke() 方法来完成对象的生产，方法参数会自动注入一个当前的容器实例 public function __invoke(ContainerInterface $container) &#123; $config = $container-&gt;get(ConfigInterface::class); // 我们假设对应的配置的 key 为 cache.enable $enableCache = $config-&gt;get('cache.enable', false); // make(string $name, array $parameters = []) 方法等同于 new ，使用 make() 方法是为了允许 AOP 的介入，而直接 new 会导致 AOP 无法正常介入流程 return make(UserService::class, compact('enableCache')); &#125;&#125; UserService 也可以在构造函数提供一个参数接收对应的值：12345678910111213141516171819202122&lt;?phpnamespace App\Service;class UserService implements UserServiceInterface&#123; /** * @var bool */ private $enableCache; public function __construct(bool $enableCache) &#123; // 接收值并储存于类属性中 $this-&gt;enableCache = $enableCache; &#125; public function getInfoById(int $id) &#123; return (new Info())-&gt;fill($id); &#125;&#125; 在 config/autoload/dependencies.php 调整绑定关系：1234&lt;?phpreturn [ \App\Service\UserServiceInterface::class =&gt; \App\Service\UserServiceFactory::class]; 这样在注入 UserServiceInterface 的时候容器就会交由 UserServiceFactory 来创建对象了。 当然在该场景中可以通过 @Value 注解来更便捷的注入配置而无需构建工厂类，此仅为举例 懒加载Hyperf 的长生命周期依赖注入在项目启动时完成。这意味着长生命周期的类需要注意： 构造函数时还不是协程环境，如果注入了可能会触发协程切换的类，就会导致框架启动失败。 构造函数中要避免循环依赖（比较典型的例子为 Listener 和 EventDispatcherInterface），不然也会启动失败。 目前解决方案是：只在实例中注入 Psr\Container\ContainerInterface ，而其他的组件在非构造函数执行时通过 container 获取。但 PSR-11 中指出: 「用户不应该将容器作为参数传入对象然后在对象中通过容器获得对象的依赖。这样是把容器当作服务定位器来使用，而服务定位器是一种反模式」 也就是说这样的做法虽然有效，但是从设计模式角度来说并不推荐。 另一个方案是使用 PHP 中常用的惰性代理模式，注入一个代理对象，在使用时再实例化目标对象。Hyperf DI 组件设计了懒加载注入功能。 添加 Hyperf\Di\Listener\LazyLoaderBootApplicationListener 到 config/autoload/listeners.php 中。 监听器会监听 BootApplication 事件，自动读取 lazy_loader 配置，并通过 spl_autoload_register 注册懒加载模式。12345678910111213141516171819&lt;?phpdeclare(strict_types=1);return [ Hyperf\Di\Listener\LazyLoaderBootApplicationListener::class,];Copy to clipboardErrorCopied添加 config/autoload/lazy_loader.php 文件并绑定懒加载关系：&lt;?phpreturn [ /** * 格式为：代理类名 =&gt; 原类名 * 代理类此时是不存在的，Hyperf会在runtime文件夹下自动生成该类。 * 代理类类名和命名空间可以自由定义。 */ 'App\Service\LazyUserService' =&gt; \App\Service\UserServiceInterface::class]; 这样在注入 App\Service\LazyUserService 的时候容器就会创建一个 懒加载代理类 注入到目标对象中了。12345678use App\Service\LazyUserService;class Foo&#123; public $service; public function __construct(LazyUserService $sevice)&#123; $this-&gt;service = $service; &#125;&#125; 您还可以通过注解 @Inject(lazy=true) 注入懒加载代理。通过注解实现懒加载不用创建配置文件。12345678910use Hyperf\Di\Annotation\Inject;use App\Service\UserServiceInterface;class Foo&#123; /** * @Inject(lazy=true) * @var UserServiceInterface */ public $service;&#125; 注意：当该代理对象执行下列操作时，被代理对象才会从容器中真正实例化。 1234567891011121314// 方法调用$proxy-&gt;someMethod();// 读取属性echo $proxy-&gt;someProperty;// 写入属性$proxy-&gt;someProperty = 'foo';// 检查属性是否存在isset($proxy-&gt;someProperty);// 删除属性unset($proxy-&gt;someProperty); 注意事项容器仅管理长生命周期的对象换种方式理解就是容器内管理的对象都是单例，这样的设计对于长生命周期的应用来说会更加的高效，减少了大量无意义的对象创建和销毁，这样的设计也就意味着所有需要交由 DI 容器管理的对象均不能包含 状态 值。状态 可直接理解为会随着请求而变化的值，事实上在 协程 编程中，这些状态值也是应该存放于 协程上下文 中的，即 Hyperf\Utils\Context。 短生命周期对象通过 new 关键词创建的对象毫无疑问的短生命周期的，那么如果希望创建一个短生命周期的对象但又希望通过依赖注入容器注入相关的依赖呢？这是我们可以通过 make(string $name, array $parameters = []) 函数来创建 $name 对应的的实例，代码示例如下： $userService = make(UserService::class, [‘enableCache’ =&gt; true]);Copy to clipboardErrorCopied注意仅 $name 对应的对象为短生命周期对象，该对象的所有依赖都是通过 get() 方法获取的，即为长生命周期的对象 获取容器对象有些时候我们可能希望去实现一些更动态的需求时，会希望可以直接获取到 容器(Container) 对象，在绝大部分情况下，框架的入口类（比如命令类、控制器、RPC 服务提供者等）都是由 容器(Container) 创建并维护的，也就意味着您所写的绝大部分业务代码都是在 容器(Container) 的管理作用之下的，也就意味着在绝大部分情况下您都可以通过在 构造函数(Constructor) 声明或通过 @Inject 注解注入 Psr\Container\ContainerInterface 接口类都能够获得 Hyperf\Di\Container 容器对象，我们通过代码来演示一下： 12345678910111213141516171819&lt;?phpnamespace App\Controller;use Hyperf\HttpServer\Annotation\AutoController;use Psr\Container\ContainerInterface;class IndexController&#123; /** * @var ContainerInterface */ private $container; // 通过在构造函数的参数上声明参数类型完成自动注入 public function __construct(ContainerInterface $container) &#123; $this-&gt;container = $container; &#125;&#125; 在某些更极端动态的情况下，或者非 容器(Container) 的管理作用之下时，想要获取到 容器(Container) 对象还可以通过 \Hyperf\Utils\ApplicationContext::getContaienr() 方法来获得 容器(Container) 对象。1$container = \Hyperf\Utils\ApplicationContext::getContainer(); 源码12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?phpdeclare(strict_types=1);/** * This file is part of Hyperf. * * @link https://www.hyperf.io * @document https://doc.hyperf.io * @contact group@hyperf.io * @license https://github.com/hyperf/hyperf/blob/master/LICENSE */namespace Hyperf\Di;interface MetadataCollectorInterface&#123; /** * Retrieve the metadata via key. * @param null|mixed $default */ public static function get(string $key, $default = null); /** * Set the metadata to holder. * @param mixed $value */ public static function set(string $key, $value): void; /** * Serialize the all metadata to a string. */ public static function serialize(): string; /** * Deserialize the serialized metadata and set the metadata to holder. */ public static function deserialize(string $metadata): bool; /** * Return all metadata array. */ public static function list(): array;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475&lt;?phpdeclare(strict_types=1);/** * This file is part of Hyperf. * * @link https://www.hyperf.io * @document https://doc.hyperf.io * @contact group@hyperf.io * @license https://github.com/hyperf/hyperf/blob/master/LICENSE */namespace Hyperf\Di;use Hyperf\Utils\Arr;abstract class MetadataCollector implements MetadataCollectorInterface&#123; /** * Subclass MUST override this property. * * @var array */ protected static $container = []; /** * Retrieve the metadata via key. * @param null|mixed $default */ public static function get(string $key, $default = null) &#123; return Arr::get(static::$container, $key) ?? $default; &#125; /** * Set the metadata to holder. * @param mixed $value */ public static function set(string $key, $value): void &#123; Arr::set(static::$container, $key, $value); &#125; /** * Determine if the metadata exist. * If exist will return true, otherwise return false. */ public static function has(string $key): bool &#123; return Arr::has(static::$container, $key); &#125; /** * Serialize the all metadata to a string. */ public static function serialize(): string &#123; return serialize(static::$container); &#125; /** * Deserialize the serialized metadata and set the metadata to holder. */ public static function deserialize(string $metadata): bool &#123; $data = unserialize($metadata); static::$container = $data; return true; &#125; public static function list(): array &#123; return static::$container; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;?phpdeclare(strict_types=1);/** * This file is part of Hyperf. * * @link https://www.hyperf.io * @document https://doc.hyperf.io * @contact group@hyperf.io * @license https://github.com/hyperf/hyperf/blob/master/LICENSE */namespace Hyperf\Di;use InvalidArgumentException;use ReflectionClass;use ReflectionMethod;use ReflectionProperty;class ReflectionManager extends MetadataCollector&#123; /** * @var array */ protected static $container = []; public static function reflectClass(string $className): ReflectionClass &#123; if (! isset(static::$container['class'][$className])) &#123; if (! class_exists($className) &amp;&amp; ! interface_exists($className)) &#123; throw new InvalidArgumentException("Class &#123;$className&#125; not exist"); &#125; static::$container['class'][$className] = new ReflectionClass($className); &#125; return static::$container['class'][$className]; &#125; public static function reflectMethod(string $className, string $method): ReflectionMethod &#123; $key = $className . '::' . $method; if (! isset(static::$container['method'][$key])) &#123; // TODO check interface_exist if (! class_exists($className)) &#123; throw new InvalidArgumentException("Class &#123;$className&#125; not exist"); &#125; static::$container['method'][$key] = static::reflectClass($className)-&gt;getMethod($method); &#125; return static::$container['method'][$key]; &#125; public static function reflectProperty(string $className, string $property): ReflectionProperty &#123; $key = $className . '::' . $property; if (! isset(static::$container['property'][$key])) &#123; if (! class_exists($className)) &#123; throw new InvalidArgumentException("Class &#123;$className&#125; not exist"); &#125; static::$container['property'][$key] = static::reflectClass($className)-&gt;getProperty($property); &#125; return static::$container['property'][$key]; &#125; public static function clear(): void &#123; static::$container = []; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Hyperf</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章：树]]></title>
    <url>%2F2020%2F01%2F18%2F%E7%AC%AC6%E7%AB%A0%EF%BC%9A%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 层数是对节点而言的，高度是对树而言的。怎么理解？ 前序遍历、中序遍历和后序遍历分别是什么样的？ 本章知识点 理解树这种数据结构及其用法。 了解如何用树实现映射。 用类和引用实现树。 将树实现为递归数据结构。 用堆实现优先级队列。 术语及定义 图1 用树表示一些常见动物的分类 树的属性 第一个属性是层次性，即树是按层级构建的，越笼统就越靠近顶部，越具体则越靠近底部。树的层次性衍生出另一个重要属性，即可以将树的某个部分（称作子树）整体移到另一个位置，而不影响下面的层。 树的第二个属性是，一个节点的所有子节点都与另一个节点的所有子节点无关。 第三个属性是，叶子节点都是独一无二的。 节点 节点是树的基础部分。它可以有自己的名字，我们称作“键”。节点也可以带有附加信息，我们称作“有效载荷”。有效载荷信息对于很多树算法来说不是重点，但它常常在使用树的应用中很重要。 边 边是树的另一个基础部分。两个节点通过一条边相连，表示它们之间存在关系。除了根节点以外，其他每个节点都仅有一条入边，出边则可能有多条。 根节点 根节点是树中唯一没有入边的节点。 路径 路径是由边连接的有序节点列表。 子节点 一个节点通过出边与子节点相连。 父节点 一个节点是其所有子节点的父节点。 兄弟节点 具有同一父节点的节点互称为兄弟节点。 子树 一个父节点及其所有后代的节点和边构成一棵子树。 叶子节点 叶子节点没有子节点。 层数 节点n的层数是从根节点到n的唯一路径长度。在图1中，猫属的层数是5。由定义可知，根节点的层数是 0。 高度 树的高度是其中节点层数的最大值。图1中的树高度为7。 树有两种定义，其中一种涉及节点和边，另一种涉及递归。你在后面会看到，递归定义很有用。 定义一：树由节点及连接节点的边构成。树有以下属性： 有一个根节点； 除根节点外，其他每个节点都与其唯一的父节点相连； 从根节点到其他每个节点都有且仅有一条路径； 如果每个节点最多有两个子节点，我们就称这样的树为二叉树。 图2展示了一棵符合定义一的树。边的箭头表示连接方向。 图2 由节点和边构成的树 定义二：一棵树要么为空，要么由一个根节点和零棵或多棵子树构成，子树本身也是一棵树。每棵子树的根节点通过一条边连到父树的根节点。图3展示了树的递归定义。 图3 树的递归定义 从树的递归定义可知，图中的树至少有4个节点，因为三角形代表的子树必定有一个根节点。这棵树或许有更多的节点，但必须更深入地查看子树后才能确定。 实现根据上节给出的定义，可以使用以下函数创建并操作二叉树。 BinaryTree() 创建一个二叉树实例。 getLeftChild() 返回当前节点的左子节点所对应的二叉树。 getRightChild() 返回当前节点的右子节点所对应的二叉树。 setRootVal(val) 在当前节点中存储参数val中的对象。 getRootVal() 返回当前节点存储的对象。 insertLeft(val) 新建一棵二叉树，并将其作为当前节点的左子节点。 insertRight(val) 新建一棵二叉树，并将其作为当前节点的右子节点。 我们将定义一个类，其中有根节点和左右子树的属性。 图3 “节点与引用”表示法的简单示例 首先定义一个简单的类，如代码清单1所示。“节点与引用”表示法的要点是，属性left和right会指向BinaryTree类的其他实例。举例来说，在向树中插入新的左子树时，我们会创建另一个BinaryTree实例，并将根节点的self.leftChild改为指向新树。 代码清单1 BinaryTree类 12345class BinaryTree: def __init__(self, rootObj): self.key = rootObj self.leftChild = None self.rightChild = None 在代码清单1中，构造方法接受一个对象，并将其存储到根节点中。正如能在列表中存储任何对象，根节点对象也可以成为任何对象的引用。就之前的例子而言，我们将节点名作为根的值存储。采用“节点与引用”法表示图3中的树，将创建6个BinaryTree实例。 下面看看基于根节点构建树所需要的函数。为了给树添加左子树，我们新建一个二叉树对象，将根节点的left属性指向新对象。代码清单2给出了insertLeft函数的代码。 代码清单2 插入左子节点 1234567def insertLeft(self, newNode): if self.leftChild == None: self.leftChild = BinaryTree(newNode) else: t = BinaryTree(newNode) t.left = self.leftChild self.leftChild = t 在插入左子树时，必须考虑两种情况。第一种情况是原本没有左子节点。此时，只需往树中添加一个节点即可。第二种情况是已经存在左子节点。此时，插入一个节点，并将已有的左子节点降一层。代码清单2中的else语句处理的就是第二种情况。 insertRight函数也要考虑相应的两种情况：要么原本没有右子节点，要么必须在根节点和已有的右子节点之间插入一个节点。代码清单3给出了insertRight函数的代码。 代码清单3 插入右子节点 1234567def insertRight(self, newNode): if self.rightChild == None: self.rightChild = BinaryTree(newNode) else: t = BinaryTree(newNode) t.right = self.rightChild self.rightChild = t 为了完成对二叉树数据结构的定义，我们来编写一些访问左右子节点与根节点的函数，如代码清单4所示。 代码清单4 二叉树的访问函数 1234567891011def getRightChild(self): return self.rightChilddef getLeftChild(self): return self.leftChilddef setRootVal(self, obj): self.key = objdef getRootVal(self): return self.key 有了创建与操作二叉树的所有代码，现在用它们来进一步了解结构。我们创建一棵简单的树，并为根节点a添加子节点b和c。下面的Python会话创建了这棵树，并查看key、left和right中存储的值。注意，根节点的左右子节点本身都是BinaryTree类的实例。正如递归定义所言，二叉树的所有子树也都是二叉树。1234567891011121314151617181920&gt;&gt;&gt; from pythonds.trees import BinaryTree&gt;&gt;&gt; r = BinaryTree('a')&gt;&gt;&gt; r.getRootVal()'a'&gt;&gt;&gt; print(r.getLeftChild())None&gt;&gt;&gt; r.insertLeft('b')&gt;&gt;&gt; print(r.getLeftChild())&lt;__main__.BinaryTree instance at 0x6b238&gt;&gt;&gt;&gt; print(r.getLeftChild().getRootVal())b&gt;&gt;&gt; r.insertRight('c')&gt;&gt;&gt; print(r.getRightChild())&lt;__main__.BinaryTree instance at 0x6b9e0&gt;&gt;&gt;&gt; print(r.getRightChild().getRootVal())c&gt;&gt;&gt; r.getRightChild().setRootVal('hello')&gt;&gt;&gt; print(r.getRightChild().getRootVal())hello&gt;&gt;&gt; 二叉树的应用解析树树的实现已经齐全了，现在来看看如何用树解决一些实际问题。本节介绍解析树，可以用它来表示现实世界中像句子（如图4所示）或数学表达式这样的构造。 图4 一个简单句子的解析树 图4展示了一个简单句子的层次结构。用树状结构表示句子让我们可以使用子树处理句子的独立部分。 我们也可以将((7 + 3) * (5 - 2))这样的数学表达式表示成解析树，如图5所示。 图5 ((7 + 3) * (5 - 2))的解析树 这是完全括号表达式，乘法的优先级高于加法和减法，但因为有括号，所以在做乘法前必须先做括号内的加法和减法。树的层次性有助于理解整个表达式的计算次序。在计算顶层的乘法前，必须先计算子树中的加法和减法。加法（左子树）的结果是10，减法（右子树）的结果是3。利用树的层次结构，在计算完子树的表达式后，只需用一个节点代替整棵子树即可。应用这个替换过程后，便得到如图6所示的简化树。 图6 ((7 + 3) * (5 - 2))的简化解析树 本节的剩余部分将仔细考察解析树，重点如下： 如何根据完全括号表达式构建解析树； 如何计算解析树中的表达式； 如何将解析树还原成最初的数学表达式。 构建解析树的第一步是将表达式字符串拆分成标记列表。需要考虑4种标记：左括号、右括号、运算符和操作数。我们知道，左括号代表新表达式的起点，所以应该创建一棵对应该表达式的新树。反之，遇到右括号则意味着到达该表达式的终点。我们也知道，操作数既是叶子节点，也是其运算符的子节点。此外，每个运算符都有左右子节点。 有了上述信息，便可以定义以下4条规则： (1) 如果当前标记是(，就为当前节点添加一个左子节点，并下沉至该子节点； (2) 如果当前标记在列表[‘+’, ‘-‘, ‘/‘, ‘*‘]中，就将当前节点的值设为当前标记对应的运算符；为当前节点添加一个右子节点，并下沉至该子节点； (3) 如果当前标记是数字，就将当前节点的值设为这个数并返回至父节点； (4) 如果当前标记是)，就跳到当前节点的父节点。 编写Python代码前，我们先通过一个例子来理解上述规则。将表达式(3 + (4 * 5))拆分成标记列表[‘(‘, ‘3’, ‘+’, ‘(‘, ‘4’, ‘*‘, ‘5’, ‘)’, ‘)’]。起初，解析树只有一个空的根节点，随着对每个标记的处理，解析树的结构和内容逐渐充实，如图7所示。 图7 一步步地构建解析树 以图7为例，我们来一步步地构建解析树。 (a) 创建一棵空树。 (b) 读入第一个标记(。根据规则1，为根节点添加一个左子节点。 (c) 读入下一个标记3。根据规则3，将当前节点的值设为3，并回到父节点。 (d) 读入下一个标记+。根据规则2，将当前节点的值设为+，并添加一个右子节点。新节点成为当前节点。 (e) 读入下一个标记(。根据规则1，为当前节点添加一个左子节点，并将其作为当前节点。 (f) 读入下一个标记4。根据规则3，将当前节点的值设为4，并回到父节点。 (g) 读入下一个标记*。根据规则2，将当前节点的值设为*，并添加一个右子节点。新节点成为当前节点。 (h) 读入下一个标记5。根据规则3，将当前节点的值设为5，并回到父节点。 (i) 读入下一个标记)。根据规则4，将*的父节点作为当前节点。 (j) 读入下一个标记)。根据规则4，将+的父节点作为当前节点。因为+没有父节点，所以工作完成。 本例表明，在构建解析树的过程中，需要追踪当前节点及其父节点。可以通过getLeftChild与getRightChild获取子节点，但如何追踪父节点呢？一个简单的办法就是在遍历这棵树时使用栈记录父节点。每当要下沉至当前节点的子节点时，先将当前节点压到栈中。当要返回到当前节点的父节点时，就将父节点从栈中弹出来。 利用前面描述的规则以及Stack和BinaryTree，就可以编写创建解析树的Python函数。代码清单5给出了解析树构建器的代码。 代码清单5 解析树构建器 1234567891011121314151617181920212223242526272829from pythonds.basic import Stackfrom pythonds.trees import BinaryTreedef buildParseTree(fpexp): fplist = fpexp.split() pStack = Stack() eTree = BinaryTree('') pStack.push(eTree) currentTree = eTree for i in fplist: if i == '(': currentTree.insertLeft('') pStack.push(currentTree) currentTree = currentTree.getLeftChild() elif i not in '+-*/)': currentTree.setRootVal(eval(i)) parent = pStack.pop() currentTree = parent elif i in '+-*/': currentTree.setRootVal(i) currentTree.insertRight('') pStack.push(currentTree) currentTree = currentTree.getRightChild() elif i == ')': currentTree = pStack.pop() else: raise ValueError("Unknown Operator: " + i) return eTree 在代码清单5中，第11、15、19和24行的if语句体现了构建解析树的4条规则，其中每条语句都通过调用BinaryTree和Stack的方法实现了前面描述的规则。这个函数中唯一的错误检查在else从句中，如果遇到一个不能识别的标记，就抛出一个ValueError异常。 有了一棵解析树之后，我们能对它做些什么呢？作为第一个例子，我们可以写一个函数计算解析树，并返回计算结果。要写这个函数，我们将利用树的层次性。针对图7中的解析树，可以用图8中的简化解析树替换。由此可见，可以写一个算法，通过递归计算每棵子树得到整棵解析树的结果。 和之前编写递归函数一样，设计递归计算函数要从确定基本情况开始。就针对树进行操作的递归算法而言，一个很自然的基本情况就是检查叶子节点。解析树的叶子节点必定是操作数。由于像整数和浮点数这样的数值对象不需要进一步翻译，因此evaluate函数可以直接返回叶子节点的值。为了向基本情况靠近，算法将执行递归步骤，即对当前节点的左右子节点调用evaluate函数。递归调用可以有效地沿着各条边往叶子节点靠近。 若要结合两个递归调用的结果，只需将父节点中存储的运算符应用于子节点的计算结果即可。从图8中可知，根节点的两个子节点的计算结果就是它们自身，即10和3。应用乘号，得到最后的结果30。 递归函数evaluate的实现如代码清单10所示。首先，获取指向当前节点的左右子节点的引用。如果左右子节点的值都是None，就说明当前节点确实是叶子节点。第7行执行这项检查。如果当前节点不是叶子节点，则查看当前节点中存储的运算符，并将其应用于左右子节点的递归计算结果。 代码清单6 计算二叉解析树的递归函数 1234567891011def evaluate(parseTree): opers = &#123;'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv&#125; leftC = parseTree.getLeftChild() rightC = parseTree.getRightChild() if leftC and rightC: fn = opers[parseTree.getRootVal()] return fn(evaluate(leftC), evaluate(rightC)) else: return parseTree.getRootVal() 我们使用具有键+、-、*和/的字典实现。字典中存储的值是operator模块的函数。该模块给我们提供了常用运算符的函数版本。在字典中查询运算符时，对应的函数对象被取出。既然取出的对象是函数，就可以用普通的方式function(param1, param2)调用。因此，opers[\\’+\\’](2, 2)等价于operator.add(2, 2)。 最后，让我们通过图9中的解析树构建过程来理解evaluate函数。第一次调用evaluate函数时，将整棵树的根节点作为参数parseTree传入。然后，获取指向左右子节点的引用，检查它们是否存在。第9行进行递归调用。从查询根节点的运算符开始，该运算符是+，对应operator.add函数，要传入两个参数。和普通的Python函数调用一样，Python做的第一件事是计算入参的值。本例中，两个入参都是对evaluate函数的递归调用。由于入参的计算顺序是从左到右，因此第一次递归调用是在左边。对左子树递归调用evaluate函数，发现节点没有左右子节点，所以这是一个叶子节点。处于叶子节点时，只需返回叶子节点的值作为计算结果即可。本例中，返回整数3。 至此，我们已经为顶层的operator.add调用计算出一个参数的值了，但还没完。继续从左到右的参数计算过程，现在进行一个递归调用，计算根节点的右子节点。我们发现，该节点不仅有左子节点，还有右子节点，所以检查节点存储的运算符——是*，将左右子节点作为参数调用函数。这时可以看到，两个调用都已到达叶子节点，计算结果分别是4和5。算出参数之后，返回operator.mul(4, 5)的结果。至此，我们已经算出了顶层运算符（+）的操作数，剩下的工作就是完成对operator.add(3, 20)的调用。因此，表达式(3 + (4 * 5))的计算结果就是23。 树的遍历我们将对所有节点的访问称为“遍历”，共有3种遍历方式，分别为前序遍历、中序遍历和后序遍历。接下来，我们先仔细地定义这3种遍历方式，然后通过一些例子看看它们的用法。 前序遍历 在前序遍历中，先访问根节点，然后递归地前序遍历左子树，最后递归地前序遍历右子树。 中序遍历 在中序遍历中，先递归地中序遍历左子树，然后访问根节点，最后递归地中序遍历右子树。 后序遍历 在后序遍历中，先递归地后序遍历右子树，然后递归地后序遍历左子树，最后访问根节点。 首先看看前序遍历。我们将一本书的内容结构表示为一棵树，整本书是根节点，每一章是根节点的子节点，每一章中的每一节是这章的子节点，每小节又是这节的子节点，依此类推。图10展示了一本书的树状结构，它包含两章。 图10 一本书的树状结构 假设我们从前往后阅读这本书，那么阅读顺序就符合前序遍历的次序。从根节点“书”开始，遵循前序遍历指令，对左子节点“第1章”递归调用preorder函数。然后，对“第1章”的左子节点递归调用preorder函数，得到节点“1.1节”。由于该节点没有子节点，因此不必再进行递归调用。沿着树回到节点“第1章”，接下来访问它的右子节点，即“1.2节”。和前面一样，先访问左子节点“1.2.1节”，然后访问右子节点“1.2.2节”。访问完“1.2节”之后，回到“第1章”。接下来，回到根节点，以同样的方式访问节点“第2章”。 遍历树的代码格外简洁，这主要是因为遍历是递归的。 你可能会想，前序遍历算法的最佳实现方式是什么呢？是一个将树用作数据结构的函数，还是树本身的一个方法？代码清单11给出了前序遍历算法的外部函数版本，该函数将二叉树作为参数，其代码尤为简洁，这是因为算法的基本情况仅仅是检查树是否存在。如果参数tree是None，函数直接返回。 代码清单11 将前序遍历算法实现为外部函数 12345def preorder(tree): if tree: print(tree.getRootVal()) preorder(tree.getLeftChild()) preorder(tree.getRightChild()) 我们也可以将preorder实现为BinaryTree类的方法，如代码清单12所示。请留意将代码从外部移到内部后有何变化。通常来说，不仅需要用self代替tree，还需要修改基本情况。内部方法必须在递归调用preorder前，检查左右子节点是否存在。 代码清单12 将前序遍历算法实现为BinaryTree类的方法 123456def preorder(self): print(self.key) if self.leftChild: self.left.preorder() if self.rightChild: self.right.preorder() 哪种实现方式更好呢？在本例中，将preorder实现为外部函数可能是更好的选择。原因在于，很少会仅执行遍历操作，在大多数情况下，还要通过基本的遍历模式实现别的目标。在下一个例子中，我们就会通过后序遍历来计算解析树。所以，我们在此采用外部函数版本。 在代码清单13中，后序遍历函数postorder与前序遍历函数preorder几乎相同，只不过对print的调用被移到了函数的末尾。 代码清单13 后序遍历函数 12345def postorder(tree): if tree != None: postorder(tree.getLeftChild()) postorder(tree.getRightChild()) print(tree.getRootVal()) 我们已经见识过后序遍历的一个常见用途，那就是计算解析树。回顾代码清单10，我们所做的就是先计算左子树，再计算右子树，最后通过根节点运算符的函数调用将两个结果结合起来。假设二叉树只存储一个表达式的数据。让我们来重写计算函数，使之更接近于代码清单13中的后序遍历函数。 代码清单14 后序求值函数 123456789101112def postordereval(tree): opers = &#123;'+':operator.add, '-':operator.sub, '*':operator.mul, '/':operator.truediv&#125; res1 = None res2 = None if tree: res1 = postordereval(tree.getLeftChild()) res2 = postordereval(tree.getRightChild()) if res1 and res2: return opers[tree.getRootVal()](res1, res2) else: return tree.getRootVal() 注意，代码清单14与代码清单13在形式上很相似，只不过求值函数最后不是打印节点，而是返回节点。这样一来，就可以保存从第7行和第8行的递归调用返回的值，然后在第10行使用这些值和运算符进行计算。 最后来了解中序遍历。中序遍历的访问顺序是左子树、根节点、右子树。代码清单15给出了中序遍历函数的代码。注意，3个遍历函数的区别仅在于print语句与递归调用语句的相对位置。 代码清单15 中序遍历函数 12345def inorder(tree): if tree != None: inorder(tree.getLeftChild()) print(tree.getRootVal()) inorder(tree.getRightChild()) 通过中序遍历解析树，可以还原不带括号的表达式。接下来修改中序遍历算法，以得到完全括号表达式。唯一要做的修改是：在递归调用左子树前打印一个左括号，在递归调用右子树后打印一个右括号。代码清单16是修改后的函数。 代码清单16 修改后的中序遍历函数，它能还原完全括号表达式 1234567def printexp(tree): sVal = "" if tree: sVal = '(' + printexp(tree.getLeftChild()) sVal = sVal + str(tree.getRootVal()) sVal = sVal + printexp(tree.getRightChild()) + ')' return sVal 以下Python会话展示了printexp和postordereval的用法。1234567891011121314&gt;&gt;&gt; from pythonds.trees import BinaryTree&gt;&gt;&gt; x = BinaryTree('*')&gt;&gt;&gt; x.insertLeft('+')&gt;&gt;&gt; l = x.getLeftChild()&gt;&gt;&gt; l.insertLeft(4)&gt;&gt;&gt; l.insertRight(5)&gt;&gt;&gt; x.insertRight(7)&gt;&gt;&gt;&gt;&gt;&gt; print(printexp(x))(((4) + (5)) * (7))&gt;&gt;&gt;&gt;&gt;&gt; print(postordereval(x))63&gt;&gt;&gt; 注意，printexp函数给每个数字都加上了括号。尽管不能算错误，但这些括号显然是多余的。在章末的练习中，请修改printexp函数，移除这些括号。 利用二叉堆实现优先级队列第3章介绍过队列这一先进先出的数据结构。队列有一个重要的变体，叫作优先级队列。和队列一样，优先级队列从头部移除元素，不过元素的逻辑顺序是由优先级决定的。优先级最高的元素在最前，优先级最低的元素在最后。因此，当一个元素入队时，它可能直接被移到优先级队列的头部。你在第7章会看到，对于一些图算法来说，优先级队列是一个有用的数据结构。 你或许可以想到一些使用排序函数和列表实现优先级队列的简单方法。但是，就时间复杂度而言，列表的插入操作是O(n)，排序操作是O(n log n)。其实，效率可以更高。实现优先级队列的经典方法是使用叫作二叉堆的数据结构。二叉堆的入队操作和出队操作均可达到O(log n)。 二叉堆学起来很有意思，它画出来很像一棵树，但实现时只用一个列表作为内部表示。二叉堆有两个常见的变体：最小堆（最小的元素一直在队首）与最大堆（最大的元素一直在队首）。 本节将实现最小堆，并将最大堆的实现留作练习。 二叉堆的操作我们将实现以下基本的二叉堆方法。 BinaryHeap()新建一个空的二叉堆。 insert(k)往堆中加入一个新元素。 findMin()返回最小的元素，元素留在堆中。 delMin()返回最小的元素，并将该元素从堆中移除。 isEmpty()在堆为空时返回True，否则返回False。 size()返回堆中元素的个数。 buildHeap(list)根据一个列表创建堆。 以下 Python会话展示了一些二叉堆方法的用法。12345678910111213&gt;&gt;&gt; from pythonds.trees import BinaryHeap&gt;&gt;&gt; bh = BinaryHeap()&gt;&gt;&gt; bh.insert(5)&gt;&gt;&gt; bh.insert(7)&gt;&gt;&gt; bh.insert(3)&gt;&gt;&gt; bh.insert(11)&gt;&gt;&gt; print(bh.delMin())3&gt;&gt;&gt; print(bh.delMin())5&gt;&gt;&gt; print(bh.delMin())7&gt;&gt;&gt; print(bh.delMin()) 二叉堆的实现1.结构属性 为了使二叉堆能高效地工作，我们利用树的对数性质来表示它。你会在6.7.3节学到，为了保证对数性能，必须维持树的平衡。平衡的二叉树是指，其根节点的左右子树含有数量大致相等的节点。在实现二叉堆时，我们通过创建一棵完全二叉树来维持树的平衡。在完全二叉树中，除了最底层，其他每一层的节点都是满的。在最底层，我们从左往右填充节点。图11展示了完全二叉树的一个例子。 图11 完全二叉树 完全二叉树的另一个有趣之处在于，可以用一个列表来表示它，而不需要采用“列表之列表”或“节点与引用”表示法。由于树是完全的，因此对于在列表中处于位置p的节点来说，它的左子节点正好处于位置2p；同理，右子节点处于位置2p+1。若要找到树中任意节点的父节点，只需使用Python的整数除法即可。给定列表中位置 n处的节点，其父节点的位置就是 n/2。图6-15展示了一棵完全二叉树，并给出了列表表示。树的列表表示——加上这个“完全”的结构性质——让我们得以通过一些简单的数学运算遍历完全二叉树。我们会看到，这也有助于高效地实现二叉堆。 图12 一棵完全二叉树及其列表表示 2.堆的有序性 我们用来存储堆元素的方法依赖于堆的有序性。堆的有序性是指：对于堆中任意元素x及其父元素p，p都不大于x。图12也展示出完全二叉树具备堆的有序性。 3.堆操作 首先实现二叉堆的构造方法。既然用一个列表就可以表示整个二叉堆，那么构造方法要做的就是初始化这个列表与属性currentSize，用于记录堆的当前大小。代码清单17给出了构造方法的Python代码。列表heapList的第一个元素是0，它的唯一用途是为了使后续的方法可以使用整数除法。 代码清单17 新建二叉堆 123def __init__(self): self.heapList = [0] self.currentSize = 0 接下来实现insert方法。将元素加入列表的最简单、最高效的方法就是将元素追加到列表的末尾。追加操作的优点在于，它能保证完全树的性质，但缺点是很可能会破坏堆的结构性质。 不过可以写一个方法，通过比较新元素与其父元素来重新获得堆的结构性质。如果新元素小于其父元素，就将二者交换。图16展示了将新元素放到正确位置上所需的一系列交换操作。 图13 将新元素往上移到正确位置 注意，将元素往上移时，其实是在新元素及其父元素之间重建堆的结构性质。此外，也保留了兄弟元素之间的堆性质。当然，如果新元素很小，需要继续往上一层交换。代码清单18给出了percUp方法的代码，该方法将元素一直沿着树向上移动，直到重获堆的结构性质。此时，heapList中的元素0正好能发挥重要作用。我们使用整数除法计算任意节点的父节点。就当前节点而言，父节点的下标就是当前节点的下标除以2。 代码清单18 percUp方法 1234567def percUp(self, i): while i // 2 &gt; 0: if self.heapList[i] &lt; self.heapList[i // 2]: tmp = self.heapList[i // 2] self.heapList[i // 2] = self.heapList[i] self.heapList[i] = tmp i = i // 2 现在准备好编写insert方法了。代码清单19给出了该方法的Python代码。其实，insert方法的大部分工作是由percUp方法完成的。当元素被追加到树中之后，percUp方法将其移到正确的位置。 代码清单19 向二叉堆中新加元素 1234def insert(self, k): self.heapList.append(k) self.currentSize = self.currentSize + 1 self.percUp(self.currentSize) 正确定义insert方法后，就可以编写delMin方法。既然堆的结构性质要求根节点是树的最小元素，那么查找最小值就很简单。delMin方法的难点在于，如何在移除根节点之后重获堆的结构性质和有序性。可以分两步重建堆。第一步，取出列表中的最后一个元素，将其移到根节点的位置。移动最后一个元素保证了堆的结构性质，但可能会破坏二叉堆的有序性。第二步，将新的根节点沿着树推到正确的位置，以重获堆的有序性。图6-17展示了将新的根节点移动到正确位置所需的一系列交换操作。 图14 将根节点往下移到正确位置 为了维持堆的有序性，只需交换根节点与它的最小子节点即可。重复节点与子节点的交换过程，直到节点比其两个子节点都小。代码清单20给出了percDown方法和minChild方法的Python代码。 代码清单20 percDown方法和minChild方法 1234567891011121314151617def percDown(self, i): while (i * 2) &lt;= self.currentSize: mc = self.minChild(i) if self.heapList[i] &gt; self.heapList[mc]: tmp = self.heapList[i] self.heapList[i] = self.heapList[mc] self.heapList[mc] = tmp i = mcdef minChild(self, i): if i * 2 + 1 &gt; self.currentSize: return i * 2 else: if self.heapList[i*2] &lt; self.heapList[i*2+1]: return i * 2 else: return i * 2 + 1 delMin方法如代码清单21所示。同样，主要工作也由辅助函数完成。本例中的辅助函数是percDown。 代码清单21 从二叉堆中删除最小的元素 1234567def delMin(self): retval = self.heapList[1] self.heapList[1] = self.heapList[self.currentSize] self.currentSize = self.currentSize - 1 self.heapList.pop() self.percDown(1) return retval 关于二叉堆，还有最后一点需要讨论。我们来看看根据元素列表构建整个堆的方法。你首先想到的方法或许是这样的：给定元素列表，每次插入一个元素，构建一个堆。由于是从列表只有一个元素的情况开始，并且列表是有序的，因此可以采用二分搜索算法找到下一个元素的正确插入位置，时间复杂度约为O(log n)。但是，为了在列表的中部插入元素，可能需要移动其他元素，以为新元素腾出空间，这种操作的时间复杂度为O(n)。因此，将n个元素插入堆中的操作为O(n log n)。然而，如果从完整的列表开始，构建整个堆只需O(n)。代码清单22给出了构建整个堆的代码。 代码清单22 根据元素列表构建堆 1234567def buildHeap(self, alist): i = len(alist) // 2 self.currentSize = len(alist) self.heapList = [0] + alist[:] while (i &gt; 0): self.percDown(i) i = i – 1 图15 根据列表[9, 6, 5, 2, 3]构建堆 图15展示了buildHeap方法进行的交换过程，它将各节点从最初状态移到各自的正确位置上。尽管从树的中间开始，向根的方向操作，但是percDown方法保证了最大的节点总是沿着树向下移动。在这棵完全二叉树中，超过中点的节点都是叶子节点，没有任何子节点。当i=1时，从树的根节点往下移，可能需要经过多次交换。如你所见，9先被移出根节点，然后percDown会沿着树检查子节点，以确保尽量将它往下移。在本例中，9的第2次交换对象是3。这样一来，9就移到了树的底层，不需要再做交换了。比较一系列交换操作后的列表表示将有助于理解，如图16所示。 图16 根据列表[9, 6, 5, 2, 3]构建堆 前面说过，构建堆的时间复杂度是O(n)，这乍一听可能很难理解，证明过程超出了本书范畴。不过，要点在于，因子log n是由树的高度决定的。在buildHeap的大部分工作中，树的高度不足log n。 利用建堆的时间复杂度为O(n)这一点，可以构造一个使用堆为列表排序的算法，使它的时间复杂度为O(n log n)。这个算法留作练习。 二叉搜索树我们已经学习了两种从集合中获取键–值对的方法。回想一下，我们讨论过映射抽象数据类型的两种实现，它们分别是列表二分搜索和散列表。本节将探讨二叉搜索树，它是映射的另一种实现。我们感兴趣的不是元素在树中的确切位置，而是如何利用二叉树结构提供高效的搜索。 搜索树的操作在实现搜索树之前，我们来复习一下映射抽象数据类型提供的接口。你会发现，这个接口类似于Python字典。 Map()新建一个空的映射。 put(key, val)往映射中加入一个新的键–值对。如果键已经存在，就用新值替换旧值。 get(key)返回key对应的值。如果key不存在，则返回None。 del通过del map[key]这样的语句从映射中删除键–值对。 len()返回映射中存储的键–值对的数目。 in通过key in map这样的语句，在键存在时返回True，否则返回False 。 搜索树的实现二叉搜索树依赖于这样一个性质：小于父节点的键都在左子树中，大于父节点的键则都在右子树中。我们称这个性质为二叉搜索性，它会引导我们实现上述映射接口。图6-20描绘了二叉搜索树的这个性质，图中只展示了键，没有展示对应的值。注意，每一对父节点和子节点都具有这个性质。左子树的所有键都小于根节点的键，右子树的所有键则都大于根节点的键。 图6-20 简单的二叉搜索树 接下来看看如何构造二叉搜索树。图6-20中的节点是按如下顺序插入键之后形成的：70、31、93、94、14、23、73。因为70是第一个插入的键，所以是根节点。31小于70，所以成为70的左子节点。93大于70，所以成为70的右子节点。现在树的两层已经满了，所以下一个键会成为31或93的子节点。94比70和93都要大，所以它成了93的右子节点。同理，14比70和31都要小，所以它成了31的左子节点。23也小于31，所以它必定在31的左子树中。而它又大于14，所以成了14的右子节点。 我们将采用“节点与引用”表示法实现二叉搜索树，它类似于我们在实现链表和表达式树时采用的方法。不过，由于必须创建并处理一棵空的二叉搜索树，因此我们将使用两个类。一个称作BinarySearchTree，另一个称作TreeNode。BinarySearchTree类有一个引用，指向作为二叉搜索树根节点的TreeNode类。大多数情况下，外面这个类的方法只是检查树是否为空。如果树中有节点，请求就被发往BinarySearchTree类的私有方法，这个方法以根节点作为参数。当树为空，或者想删除根节点的键时，需要采取特殊措施。代码清单23是BinarySearchTree类的构造方法及一些其他的方法。 代码清单23 BinarySearchTree类 1234567891011121314class BinarySearchTree: def __init__(self): self.root = None self.size = 0 def length(self): return self.size def __len__(self): return self.size def __iter__(self): return self.root.__iter__() TreeNode类提供了很多辅助函数，这大大地简化了BinarySearchTree类的工作。代码清单24是TreeNode类的构造方法以及辅助函数。可以看到，很多辅助函数有助于根据子节点的位置（是左还是右）以及自己的子节点类型来给节点归类。 代码清单24 TreeNode类 12345678910111213141516171819202122232425262728293031323334353637383940414243class TreeNode: def __init__(self, key, val, left=None, right=None, parent=None): self.key = key self.payload = val self.leftChild = left self.rightChild = right self.parent = parent def hasLeftChild(self): return self.leftChild def hasRightChild(self): return self.rightChild def isLeftChild(self): return self.parent and \ self.parent.leftChild == self def isRightChild(self): return self.parent and \ self.parent.rightChild == self def isRoot(self): return not self.parent def isLeaf(self): return not (self.rightChild or self.leftChild) def hasAnyChildren(self): return self.rightChild or self.leftChild def hasBothChildren(self): return self.rightChild and self.leftChild def replaceNodeData(self, key, value, lc, rc): self.key = key self.payload = value self.leftChild = lc self.rightChild = rc if self.hasLeftChild(): self.leftChild.parent = self if self.hasRightChild(): self.rightChild.parent = self TreeNode类与6.4.2节中的BinaryTree类有一个很大的区别，那就是显式地将每个节点的父节点记录为它的一个属性。在讨论del操作的实现时，你会看到这一点为何重要。 在TreeNode类的实现中，另一个有趣之处是使用Python的可选参数。可选参数使得在多种环境下创建TreeNode更方便。有时，我们想构造一个已有parent和child的TreeNode。可以将父节点和子节点作为参数传入。其他时候，只通过键–值对创建TreeNode，而不传入parent和child。在这种情况下，可选参数使用默认值。 现在有了BinarySearchTree和TreeNode，是时候写一个帮我们构建二叉搜索树的put方法了。put是BinarySearchTree类的一个方法。它检查树是否已经有根节点，若没有，就创建一个TreeNode，并将其作为树的根节点；若有，就调用私有的递归辅助函数_put，并根据以下算法在树中搜索。 从根节点开始搜索二叉树，比较新键与当前节点的键。如果新键更小，搜索左子树。如果新键更大，搜索右子树。 当没有可供搜索的左（右）子节点时，就说明找到了新键的插入位置。 向树中插入一个节点，做法是创建一个TreeNode对象，并将其插入到前一步发现的位置上。 向树中插入新节点的方法如代码清单25所示。按照上述步骤，我们将_put写成递归函数。注意，在向树中插入新的子节点时，currentNode被作为父节点传入新树。 代码清单25 为二叉搜索树插入新节点 123456789101112131415161718def put(self, key, val): if self.root: self._put(key, val, self.root) else: self.root = TreeNode(key, val) self.size = self.size + 1def _put(self, key, val, currentNode): if key &lt; currentNode.key: if currentNode.hasLeftChild(): self._put(key, val, currentNode.leftChild) else: currentNode.leftChild = TreeNode(key, val, parent=currentNode) else: if currentNode.hasRightChild(): self._put(key, val, currentNode.rightChild) else: currentNode.rightChild = TreeNode(key, val, parent=currentNode) 插入方法有个重要的问题：不能正确地处理重复的键。遇到重复的键时，它会在已有节点的右子树中创建一个具有同样键的节点。这样做的结果就是搜索时永远发现不了较新的键。要处理重复键插入，更好的做法是用关联的新值替换旧值。这个修复工作留作练习。 定义put方法后，就可以方便地通过让__setitem__方法调用put方法来重载[]运算符。如此一来，就可以写出像myZipTree[‘Plymouth’] = 55446这样的Python语句，就如同访问Python字典一样。__setitem__方法如代码清单26所示。 代码清单26 __setitem__方法 12def __setitem__(self, k, v): self.put(k, v) 图6-21展示了向二叉搜索树中插入新节点的过程。浅灰色节点表示在插入过程中被访问过的节点。 构造出树后，下一个任务就是实现为给定的键取值。get方法比put方法还要简单，因为它只是递归地搜索二叉树，直到访问到叶子节点或者找到匹配的键。在后一种情况下，它会返回节点中存储的值。 图6-21 插入键为19的新节点 get、_get和__getitem__的实现如代码清单27所示。_get方法中的搜索代码和_put方法中选择左右子节点的逻辑相同。注意，_get方法返回一个TreeNode给get。这样一来，对于其他BinarySearchTree方法来说，如果需要使用TreeNode有效载荷之外的数据，_get可以作为灵活的辅助函数使用。 通过实现__getitem__方法，可以写出类似于访问字典的Python语句——而实际上使用的是二叉搜索树——比如z = myZipTree[‘Fargo’]。从代码清单27可以看出，__getitem__方法要做的就是调用get方法。 代码清单27 查找键对应的值 12345678910111213141516171819202122def get(self, key): if self.root: res = self._get(key, self.root) if res: return res.payload else: return None else: return Nonedef _get(self, key, currentNode): if not currentNode: return None elif currentNode.key == key: return currentNode elif key &lt; currentNode.key: return self._get(key, currentNode.leftChild) else: return self._get(key, currentNode.rightChild)def __getitem__(self, key): return self.get(key) 利用get方法，可以通过为BinarySearchTree编写__contains方法来实现in操作。\contains方法只需调用get方法，并在get方法返回一个值时返回True，或在get方法返回None时返回False。代码清单28实现了\contains__方法。 代码清单28 检查树中是否有某个键 12345def __contains__(self, key): if self._get(key, self.root): return True else: return False 你应该记得，__contains__方法重载了in运算符，因此我们可以写出这样的语句：12if 'Northfield' in myZipTree: print("oom ya ya") 最后，我们将注意力转向二叉搜索树中最有挑战性的方法——删除一个键。第一个任务是在树中搜索并找到要删除的节点。如果树中不止一个节点，使用_get方法搜索，找到要移除的TreeNode。如果树中只有一个节点，则意味着要移除的是根节点，不过仍要确保根节点的键就是要删除的键。无论哪种情况，如果找不到要删除的键，delete方法都会抛出一个异常，如代码清单29所示。 代码清单29 delete方法 12345678910111213141516def delete(self, key): if self.size &gt; 1: nodeToRemove = self._get(key, self.root) if nodeToRemove: self.remove(nodeToRemove) self.size = self.size – 1 else: raise KeyError('Error, key not in tree') elif self.size == 1 and self.root.key == key: self.root = None self.size = self.size – 1 else: raise KeyError('Error, key not in tree')def __delitem__(self, key): self.delete(key) 一旦找到待删除键对应的节点，就必须考虑3种情况。 (1)待删除节点没有子节点（如图22所示）。 图6-22 待删除节点16没有子节点 (2)待删除节点只有一个子节点（如图23所示）。 图6-23 待删除节点25有一个子节点 (3)待删除节点有两个子节点（如图24所示）。 图6-24 待删除节点5有两个子节点 情况1很简单。如果当前节点没有子节点，要做的就是删除这个节点，并移除父节点对这个节点的引用，如代码清单30所示。 代码清单30 情况1：待删除节点没有子节点 12345if currentNode.isLeaf(): if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = None else: currentNode.parent.rightChild = None 情况2稍微复杂些。如果待删除节点只有一个子节点，那么可以用子节点取代待删除节点，如代码清单31所示。查看这段代码后会发现，它考虑了6种情况。由于左右子节点的情况是对称的，因此只需要讨论当前节点有左子节点的情况。 (1)如果当前节点是一个左子节点，只需将当前节点的左子节点对父节点的引用改为指向当前节点的父节点，然后将父节点对当前节点的引用改为指向当前节点的左子节点。 (2)如果当前节点是一个右子节点，只需将当前节点的右子节点对父节点的引用改为指向当前节点的父节点，然后将父节点对当前节点的引用改为指向当前节点的右子节点。 (3)如果当前节点没有父节点，那它肯定是根节点。调用replaceNodeData方法，替换根节点的key、payload、leftChild和rightChild数据。 代码清单31 情况2：待删除节点只有一个子节点 12345678910111213141516171819202122232425else: # 只有一个子节点 if currentNode.hasLeftChild(): if currentNode.isLeftChild(): currentNode.leftChild.parent = currentNode.parent currentNode.parent.leftChild = currentNode.leftChild elif currentNode.isRightChild(): currentNode.leftChild.parent = currentNode.parent currentNode.parent.rightChild = currentNode.leftChild else: currentNode.replaceNodeData(currentNode.leftChild.key, currentNode.leftChild.payload, currentNode.leftChild.leftChild, currentNode.leftChild.rightChild) else: if currentNode.isLeftChild(): currentNode.rightChild.parent = currentNode.parent currentNode.parent.leftChild = currentNode.rightChild elif currentNode.isRightChild(): currentNode.rightChild.parent = currentNode.parent currentNode.parent.rightChild = currentNode.rightChild else: currentNode.replaceNodeData(currentNode.rightChild.key, currentNode.rightChild.payload, currentNode.rightChild.leftChild, currentNode.rightChild.rightChild) 情况3最难处理。如果一个节点有两个子节点，那就不太可能仅靠用其中一个子节点取代它来解决问题。不过，可以搜索整棵树，找到可以替换待删除节点的节点。候选节点要能为左右子树都保持二叉搜索树的关系，也就是树中具有次大键的节点。我们将这个节点称为后继节点，有一种方法能快速找到它。后继节点的子节点必定不会多于一个，所以我们知道如何按照已实现的两种删除方法来移除它。移除后继节点后，只需直接将它放到树中待删除节点的位置上即可。 处理情况3的代码如代码清单32所示。注意，我们用辅助函数findSuccessor和findMin来寻找后继节点，并用spliceOut方法移除它（如代码清单34所示）。之所以用spliceOut方法，是因为它可以直接访问待拼接的节点，并进行正确的修改。虽然也可以递归调用delete，但那样做会浪费时间重复搜索键的节点。 代码清单32 情况3：待删除节点有两个子节点 12345elif currentNode.hasBothChildren(): # 内部 succ = currentNode.findSuccessor() succ.spliceOut() currentNode.key = succ.key currentNode.payload = succ.payload 寻找后继节点的代码如代码清单33所示。可以看出，这是TreeNode类的一个方法。它利用的二叉搜索树属性，也是从小到大打印出树节点的中序遍历所利用的。在查找后继节点时，要考虑以下3种情况。 (1)如果节点有右子节点，那么后继节点就是右子树中最小的节点。 (2)如果节点没有右子节点，并且其本身是父节点的左子节点，那么后继节点就是父节点。 (3)如果节点是父节点的右子节点，并且其本身没有右子节点，那么后继节点就是除其本身外父节点的后继节点。 在试图从一棵二叉搜索树中删除节点时，上述第一个条件是唯一重要的。但是，findSuccessor方法还有其他用途，本章末会进行探索。 findMin方法用来查找子树中最小的键。可以确定，在任意二叉搜索树中，最小的键就是最左边的子节点。鉴于此，findMin方法只需沿着子树中每个节点的leftChild引用走，直到遇到一个没有左子节点的节点。代码清单35给出了完整的remove方法。 代码清单33 寻找后继节点 12345678910111213141516171819def findSuccessor(self): succ = None if self.hasRightChild(): succ = self.rightChild.findMin() else: if self.parent: if self.isLeftChild(): succ = self.parent else: self.parent.rightChild = None succ = self.parent.findSuccessor() self.parent.rightChild = self return succdef findMin(self): current = self while current.hasLeftChild(): current = current.leftChild return current 代码清单34 spliceOut方法 12345678910111213141516171819def spliceOut(self): if self.isLeaf(): if self.isLeftChild(): self.parent.leftChild = None else: self.parent.rightChild = None elif self.hasAnyChildren(): if self.hasLeftChild(): if self.isLeftChild(): self.parent.leftChild = self.leftChild else: self.parent.rightChild = self.leftChild self.leftChild.parent = self.parent else: if self.isLeftChild(): self.parent.leftChild = self.rightChild else: self.parent.rightChild = self.rightChild self.rightChild.parent = self.parent 代码清单35 remove方法 1234567891011121314151617181920212223242526272829303132333435363738def remove(self, currentNode):if currentNode.isLeaf(): # 叶子节点 if currentNode == currentNode.parent.leftChild: currentNode.parent.leftChild = Noneelse: currentNode.parent.rightChild = Noneelif currentNode.hasBothChildren(): # 内部succ = currentNode.findSuccessor()succ.spliceOut()currentNode.key = succ.keycurrentNode.payload = succ.payloadelse: # 只有一个子节点if currentNode.hasLeftChild(): if currentNode.isLeftChild(): currentNode.leftChild.parent = currentNode.parentcurrentNode.parent.leftChild = currentNode.leftChildelif currentNode.isRightChild():currentNode.leftChild.parent = currentNode.parentcurrentNode.parent.rightChild = currentNode.leftChildelse: currentNode.replaceNodeData(currentNode.leftChild.key, currentNode.leftChild.payload,currentNode.leftChild.leftChild,currentNode.leftChild.rightChild) else:if currentNode.isLeftChild(): currentNode.rightChild.parent = currentNode.parentcurrentNode.parent.leftChild = currentNode.rightChildelif currentNode.isRightChild():currentNode.rightChild.parent = currentNode.parentcurrentNode.parent.rightChild = currentNode.rightChildelse: currentNode.replaceNodeData(currentNode.rightChild.key, currentNode.rightChild.payload,currentNode.rightChild.leftChild,currentNode.rightChild.rightChild) 现在来看看最后一个二叉搜索树接口方法。假设我们想按顺序遍历树中的键。我们在字典中就是这么做的，为什么不在树中试试呢？我们已经知道如何按顺序遍历二叉树——使用中序遍历算法。不过，为了创建迭代器，还需要做更多工作，因为迭代器每次调用只返回一个节点。 Python为创建迭代器提供了一个很强大的函数，即yield。与return类似，yield每次向调用方返回一个值。除此之外，yield还会冻结函数的状态，因此下次调用函数时，会从这次离开之处继续。创建可迭代对象的函数被称作生成器。 二叉搜索树迭代器的代码如代码清单36所示。请仔细看看这份代码。乍看之下，你可能会认为它不是递归的。但是，因为 __iter__ 重载了循环的for x in操作，所以它真的是递归的！由于在TreeNode实例上递归，因此__iter__方法被定义在TreeNode类中。 代码清单 6-36 二叉搜索树迭代器 123456789def __iter__(self):if self:if self.hasLeftChild(): for elem in self.leftChild: yield elemyield self.key if self.hasRightChild():for elem in self.rightChild:yield elem 搜索树的分析至此，我们已经完整地实现了二叉搜索树，接下来简单地分析它的各个方法。先分析put方法，限制其性能的因素是二叉树的高度。6.3节曾说过，树的高度是其中节点层数的最大值。高度之所以是限制因素，是因为在搜索合适的插入位置时，每一层最多需要做一次比较。 那么，二叉树的高度是多少呢？答案取决于键的插入方式。如果键的插入顺序是随机的，那么树的高度约为log2n，其中n为树的节点数。这是因为，若键是随机分布的，那么小于和大于根节点的键大约各占一半。二叉树的顶层有1个根节点，第1层有2个节点，第2层有4个节点，依此类推。在完全平衡的二叉树中，节点总数是2h+1-1，其中h代表树的高度。 在完全平衡的二叉树中，左右子树的节点数相同。最坏情况下，put的时间复杂度是O(log2n)，其中n是树的节点数。注意，这是上一段所述运算的逆运算。所以，log2n是树的高度，代表put在搜索合适的插入位置时所需的最大比较次数。 不幸的是，按顺序插入键可以构造出一棵高度为n的搜索树！图6-25就是一个例子，这时put方法的时间复杂度为O(n)。 图25 偏斜的二叉搜索树 既然理解了为何说put的性能由树的高度决定，你应该可以猜到，get、in和del也都如此。get在树中查找键，最坏情况就是沿着树一直搜到底也没找到。乍看之下，del可能更复杂，因为在删除节点前可能还得找到后继节点。但是查找后继节点的最坏情况也受限于树的高度，也就是把工作量加一倍。所以，对于不平衡的树来说，最坏情况下的时间复杂度仍是O(n)。 平衡二叉搜索树在 6.7节中，我们了解了二叉搜索树的构建过程。我们已经知道，当二叉搜索树不平衡时，get 和 put 等操作的性能可能降到 ( ) O n 。本节将介绍一种特殊的二叉搜索树，它能自动维持平衡。这种树叫作 AVL 树，以其发明者 G. M. Adelson-Velskii和 E. M. Landis的姓氏命名。 AVL树实现映射抽象数据类型的方式与普通的二叉搜索树一样，唯一的差别就是性能。实现AVL树时，要记录每个节点的平衡因子。我们通过查看每个节点左右子树的高度来实现这一点。更正式地说，我们将平衡因子定义为左右子树的高度之差。 ( ) ( ) balanceFactor height left SubTree height rightSubTree  根据上述定义，如果平衡因子大于零，我们称之为左倾；如果平衡因子小于零，就是右倾；如果平衡因子等于零，那么树就是完全平衡的。为了实现AVL树并利用平衡树的优势，我们将平衡因子为–1、0和 1的树都定义为平衡树。一旦某个节点的平衡因子超出这个范围，我们就需要通过一个过程让树恢复平衡。图26展示了一棵右倾树及其中每个节点的平衡因子。 图26 带平衡因子的右倾树 AVL 树的性能我们先看看限定平衡因子带来的结果。我们认为，保证树的平衡因子为–1、0或1，可以使关键操作获得更好的大O性能。首先考虑平衡因子如何改善最坏情况。有左倾与右倾这两种可能性。如果考虑高度为0、1、2和 3的树，图27展示了应用新规则后最不平衡的左倾树。 图27 左倾 AVL 树的最坏情况 查看树中的节点数之后可知，高度为 0时有 1个节点，高度为 1时有 2个节点（1 + 1 = 2），高度为 2时有 4个节点（1 + 1 + 2 = 4），高度为 3时有 7个节点（1 + 2 + 4 = 7）。也就是说，当高度为 h时，节点数hN 是：   你或许觉得这个公式很眼熟，因为它与斐波那契数列很相似。可以根据它推导出由AVL树的节点数计算高度的公式。在斐波那契数列中，第 i个数是： 一个重要的事实是，随着斐波那契数列的增长， F F 逐渐逼近黄金分割比例  ， = 。如果你好奇这个等式的推导过程，可以找一本数学书看看。我们在此直接使用这个等式，将iF 近似为 / 5iiF   。由此，可以将hN 的等式重写为：N h = F h+2 1, h≥1用黄金分割近似替换，得到：  移项，两边以 2为底取对数，求 h，得到：  在任何时间，AVL树的高度都等于节点数取对数再乘以一个常数（1.44）。对于搜索AVL树来说，这是一件好事，因为时间复杂度被限制为 (log ) O N 。 AVL 树的实现我们已经证明，保持 AVL 树的平衡会带来很大的性能优势，现在看看如何往树中插入一个键。所有新键都是以叶子节点插入的，因为新叶子节点的平衡因子是零，所以新插节点没有什么限制条件。但插入新节点后，必须更新父节点的平衡因子。新的叶子节点对其父节点平衡因子的影响取决于它是左子节点还是右子节点。如果是右子节点，父节点的平衡因子减一。如果是左子节点，则父节点的平衡因子加一。这个关系可以递归地应用到每个祖先，直到根节点。既然更新平衡因子是递归过程，就来检查以下两种基本情况： 递归调用抵达根节点； 父节点的平衡因子调整为零；可以确信，如果子树的平衡因子为零，那么祖先节点的平衡因子将不会有变化。 我们将 AVL 树实现为 BinarySearchTree 的子类。首先重载_put方法，然后新写updateBalance辅助方法，如代码清单 6-37 所示。可以看到，除了在第 8 行和第 15 行调用updateBalance 以外， _put 方法的定义和代码清单 6-25中的几乎一模一样。 代码清单 6-37 更新平衡因子 12345678910111213141516171819202122232425262728def _put(self, key, val, currentNode):if key &lt; currentNode.key:if currentNode.hasLeftChild():self._put(key, val, currentNode.leftChild) else:currentNode.leftChild = TreeNode(key, val,parent=currentNode) self.updateBalance(currentNode.leftChild) else: if currentNode.hasRightChild(): self._put(key, val, currentNode.rightChild) else: currentNode.rightChild = TreeNode(key, val, parent=currentNode) self.updateBalance(currentNode.rightChild) def updateBalance(self, node): if node.balanceFactor &gt; 1 or node.balanceFactor &lt; -1: self.rebalance(node) return if node.parent != None: if node.isLeftChild(): node.parent.balanceFactor += 1 elif node.isRightChild(): node.parent.balanceFactor -= 1 if node.parent.balanceFactor != 0: self.updateBalance(node.parent) 新方法updateBalance做了大部分工作，它实现了前面描述的递归过程。updateBalance方法先检查当前节点是否需要再平衡（第 18行）。如果符合判断条件，就进行再平衡，不需要更新父节点；如果当前节点不需要再平衡，就调整父节点的平衡因子。如果父节点的平衡因子非零，那么沿着树往根节点的方向递归调用updateBalance 方法。 如果需要进行再平衡，该怎么做呢？高效的再平衡是让AVL树发挥作用同时不损性能的关键。为了让AVL树恢复平衡，需要在树上进行一次或多次旋转。 要理解什么是旋转，来看一个简单的例子。考虑图6-28中左边的树。这棵树失衡了，平衡因子是–2。要让它恢复平衡，我们围绕以节点 A为根节点的子树做一次左旋。 图28 通过左旋让失衡的树恢复平衡 本质上，左旋包括以下步骤。 将右子节点（节点 B）提升为子树的根节点。 将旧根节点（节点 A）作为新根节点的左子节点。 如果新根节点（节点B）已经有一个左子节点，将其作为新左子节点（节点A）的右子节点。注意，因为节点 B之前是节点 A的右子节点，所以此时节点 A必然没有右子节点。 因此，可以为它添加新的右子节点，而无须过多考虑。 左旋过程在概念上很简单，但代码细节有点复杂，因为需要将节点挪来挪去，以保证二叉搜索树的性质。另外，还要保证正确地更新父指针。我们来看一棵稍微复杂一点的树，并理解右旋过程。图29 左边的是一棵左倾的树，根节点的平衡因子是 2。右旋步骤如下。 将左子节点（节点 C）提升为子树的根节点。 将旧根节点（节点 E）作为新根节点的右子节点。 如果新根节点（节点 C）已经有一个右子节点（节点 D），将其作为新右子节点（节点 E）的左子节点。注意，因为节点 C 之前是节点 E 的左子节点，所以此时节点 E 必然没有左子节点。因此，可以为它添加新的左子节点，而无须过多考虑。 图29通过右旋让失衡的树恢复平衡了解旋转的基本原理之后，来看看代码。代码清单38给出了左旋的代码。第2行创建一个临时变量，用于记录子树的新根节点。如前所述，新根节点是旧根节点的右子节点。既然临时变量存储了指向右子节点的引用，便可以将旧根节点的右子节点替换为新根节点的左子节点。 下一步是调整这两个节点的父指针。如果新根节点有左子节点，那么这个左子节点的新父节点就是旧根节点。将新根节点的父指针指向旧根节点的父节点。如果旧根节点是整棵树的根节点，那么必须将树的根节点设为新根节点；如果不是，则当旧根节点是左子节点时，将左子节点的父指针指向新根节点；当旧根节点是右子节点时，将右子节点的父指针指向新根节点（第 10~13行）。 最后，将旧根节点的父节点设为新根节点。这一系列描述很复杂，所以建议你根据图6-28的例子运行一遍函数。 rotateRight 与 rotateLeft 对称，所以留作练习。 代码清单 6-38 左旋 12345678910111213141516171819def rotateLeft(self, rotRoot): newRoot = rotRoot.rightChild rotRoot.rightChild = newRoot.leftChild if newRoot.leftChild != None: newRoot.leftChild.parent = rotRoot newRoot.parent = rotRoot.parent if rotRoot.isRoot(): self.root = newRoot else: if rotRoot.isLeftChild(): rotRoot.parent.leftChild = newRoot else: rotRoot.parent.rightChild = newRoot newRoot.leftChild = rotRoot rotRoot.parent = newRoot rotRoot.balanceFactor = rotRoot.balanceFactor + 1 \ - min(newRoot.balanceFactor, 0) newRoot.balanceFactor = newRoot.balanceFactor + 1 \ + max(rotRoot.balanceFactor, 0) 第16~19行需要特别解释一下。这几行更新了旧根节点和新根节点的平衡因子。由于其他移动操作都是针对整棵子树，因此旋转后其他节点的平衡因子都不受影响。但在没有完整地重新计算新子树高度的情况下，怎么能更新平衡因子呢？下面的推导过程能证明，这些代码是对的。 图30 左旋 图30 展示了左旋结果。B 和 D 是关键节点，A、C、E 是它们的子树。针对根节点为 x 的子树，将其高度记为xh 。由定义可知：( )( )A CA DnewBal B h holdBal B h h  D 的旧高度也可以定义为 1 max( , )C Eh h  ，即 D 的高度等于两棵子树的高度的大值加一。因为Ch 与Eh 不变，所以代入第 2 个等式，得到 ( ) (1 max( , ))A C EoldBal B h h h    。然后，将两个等式相减，并运用代数知识简化 ( ) newBal B 的等式。( ) ( ) ( (1 max( , )))( ) ( ) (1 max( , ))( ) ( ) 1 max( , )( ) ( ) 1 max( , )A C A C EA C A C EA A C E CC E CnewBal B oldBal B h h h h hnewBal B oldBal B h h h h hnewBal B oldBal B h h h h hnewBal B oldBal B h h h                  下面将 ( ) oldBal B 移到等式右边，并利用性质 max( , ) max( , ) a b c a c b c     得到：( ) ( ) 1 max( , )C C E CnewBal B oldBal B h h h h     由于E Ch h  就等于 ( ) oldBal D  ，因此可以利用另一个性质 max( , ) min( , ) a b a b     。最后几步推导如下：( ) ( ) 1 max(0, ( ))( ) ( ) 1 min(0, ( ))newBal B oldbal B oldBal DnewBal B oldBal B oldBal D    至此，我们已经做好所有准备了。如果还记得B是rotRoot而D是newRoot，那么就能看到以上等式对应于代码清单6-38中的第16行： 12rotRoot.balanceFactor = rotRoot.balanceFactor + 1 \- min(newRoot.balanceFactor, 0) 通过类似的推导，可以得到节点D的等式，以及右旋后的平衡因子。这个推导过程留作练习。 现在你可能认为大功告成了。我们已经知道如何左旋和右旋，也知道应该在什么时候旋转，但请看看图31。节点A的平衡因子为–2，应该做一次左旋。但是，围绕节点A左旋后会怎样呢？ 图31 更难平衡的树 左旋后得到另一棵失衡的树，如图32所示。如果在此基础上做一次右旋，就回到了图31的状态。 图32 左旋后，树朝另一个方向失衡 要解决这种问题，必须遵循以下规则。 如果子树需要左旋，首先检查右子树的平衡因子。如果右子树左倾，就对右子树做一次右旋，再围绕原节点做一次左旋。 如果子树需要右旋，首先检查左子树的平衡因子。如果左子树右倾，就对左子树做一次左旋，再围绕原节点做一次右旋。 图33展示了如何通过以上规则解决图31和图32中的困境。围绕节点C做一次右旋，再围绕节点A做一次左旋，就能让子树恢复平衡。 图33 先右旋，再左旋 rebalance方法实现了上述规则，如代码清单6-39所示。第2行的if语句实现了规则1，第8行的elif语句实现了规则2。 在6.11节中，你将尝试通过先左旋再右旋的方式恢复一棵树的平衡，还会试着为一些更复杂的树恢复平衡。 代码清单6-39 实现再平衡 12345678910111213def rebalance(self, node): if node.balanceFactor &lt; 0: if node.rightChild.balanceFactor &gt; 0: self.rotateRight(node.rightChild) self.rotateLeft(node) else: self.rotateLeft(node) elif node.balanceFactor &gt; 0: if node.leftChild.balanceFactor &lt; 0: self.rotateLeft(node.leftChild) self.rotateRight(node) else: self.rotateRight(node) 通过维持树的平衡，可以保证get方法的时间复杂度为$O(\log_2n)$。但这会给put操作的性能带来多大影响呢？我们来看看put操作。因为新节点作为叶子节点插入，所以更新所有父节点的平衡因子最多需要$\log_2n$次操作——每一层一次。如果树失衡了，恢复平衡最多需要旋转两次。每次旋转的时间复杂度是$O(1)$，所以put操作的时间复杂度仍然是$O(\log_2n)$。 至此，我们已经实现了一棵可用的AVL树，不过还没有实现删除节点的功能。我们将删除节点及后续的更新和再平衡的实现留作练习。 映射实现总结本章和第5章介绍了可以用来实现映射这一抽象数据类型的多种数据结构，包括有序列表、散列表、二叉搜索树以及AVL树。表6-1总结了每个数据结构的性能。 表6-1 映射的不同实现间的性能对比 有序列表 散列表 二叉搜索树 AVL树 put $O(n)$ $O(1)$ $O(n)$ $O(\log_2n)$ get $O(\log_2n)$ $O(1)$ $O(n)$ $O(\log_2n)$ in $O(\log_2n)$ $O(1)$ $O(n)$ $O(\log_2n)$ del $O(n)$ $O(1)$ $O(n)$ $O(\log_2n)$ 小结本章介绍了树这一数据结构。有了树，我们可以写出很多有趣的算法。我们用树做了以下这些事。 用二叉树解析并计算表达式。 用二叉树实现映射。 用平衡二叉树（AVL树）实现映射。 用二叉树实现最小堆。 用最小堆实现优先级队列。 关键术语AVL树 边 层数 堆的有序性二叉堆 二叉树 二叉搜索树 父节点高度 根节点 后继节点 后序遍历节点 路径 前序遍历 树完全二叉树 兄弟节点 旋转 叶子节点映射 优先级队列 中序遍历 子节点子树 最小堆/最大堆 讨论题1.画出下列函数调用后的树结构。123456789101112&gt;&gt;&gt; r = BinaryTree(3)&gt;&gt;&gt; insertLeft(r, 4)[3, [4, [], []], []]&gt;&gt;&gt; insertLeft(r, 5)[3, [5, [4, [], []], []], []]&gt;&gt;&gt; insertRight(r, 6)[3, [5, [4, [], []], []], [6, [], []]]&gt;&gt;&gt; insertRight(r, 7)[3, [5, [4, [], []], []], [7, [], [6, [], []]]]&gt;&gt;&gt; setRootVal(r, 9)&gt;&gt;&gt; insertLeft(r, 11)[9, [11, [5, [4, [], []], []], []], [7, [], [6, [], []]]] 2.为表达式 (4 * 8) / 6 - 3 创建对应的表达式树。3.针对整数列表 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ，给出插入列表中整数得到的二叉搜索树。4.针对整数列表 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] ，给出插入列表中整数得到的二叉搜索树。5.生成一个随机整数列表。给出插入列表中整数得到的二叉堆。6.将前一道题得到的列表作为 buildHeap 方法的参数，给出得到的二叉堆。以树和列表两种形式展示。7.画出按次序插入这些键之后的二叉搜索树：68、88、61、89、94、50、4、76、66、82。8.生成一个随机整数列表。画出插入列表中整数得到的二叉搜索树。9.针对整数列表 [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] ，给出插入列表中整数得到的二叉堆。10.针对整数列表 [10, 9, 8, 7, 6, 5, 4, 3, 2, 1] ，给出插入列表中整数得到的二叉堆。11.考虑本章实现二叉树的两种方式。在实现为方法时，为什么必须在调用preorder前检查，而在实现为函数时，可以在调用内部检查？12.给出构建下面这棵二叉树所需的函数调用。13.对下面这棵树，实施恢复平衡所需的旋转操作。14.以图30作为出发点，推导出节点 D在更新后的平衡因子等式。 编程练习 1.扩展buildParseTree方法，使其能处理字符间没有空格的数学表达式。 2.修改buildParseTree和evaluate，使它们支持逻辑运算符（and、or、not）。注意，not是一元运算符，这会让代码有点复杂。 3.使用findSuccessor方法，写一个非递归的二叉搜索树中序遍历方法。 4.修改二叉搜索树的实现代码，从而实现线索二叉搜索树。为线索二叉搜索树写一个非递归的中序遍历方法。线索二叉搜索树为其中的每个节点都维护着指向后继节点的引用。 5.修改二叉搜索树的实现代码，以正确处理重复的键。也就是说，如果键已在树中，就替换有效载荷，而不是用同一个键插入一个新节点。 6.创建限定大小的二叉堆。也就是说，堆只保持n个最重要的元素。如果堆的大小超过了n，就会舍弃最不重要的元素。 7.整理printexp函数，去掉数字周围多余的括号。 8.使用buildHeap方法，针对列表写一个时间复杂度为$O(n\log n)$的排序函数。 9.写一个函数，以数学表达式解析树为参数，计算各变量的导数。 10.将二叉堆实现为最大堆。 11.使用BinaryHeap类，实现一个叫作PriorityQueue的新类。为PriorityQueue类实现构造方法，以及enqueue方法和dequeue方法。 12.实现AVL树的delete方法。]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Python数据结构与算法分析（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章：算法分析]]></title>
    <url>%2F2020%2F01%2F16%2F%E7%AC%AC2%E7%AB%A0%EF%BC%9A%E7%AE%97%E6%B3%95%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章目标 理解算法分析的重要性。 能够使用大O符号描述执行时间。 针对Python列表和字典的常见操作，理解用大O符号表示的执行时间。 理解Python数据的实现如何影响算法分析。 理解如何对简单的Python程序进行基准测试。 何谓算法分析刚接触计算机科学的同学常常拿自己的程序和别人的做比较。你可能已经注意到了，计算机程序看起来很相似，尤其是简单的程序。这就产生了一个有趣的问题：当两个看上去不同的程序解决同一个问题时，会有优劣之分么？ 要回答这个问题，需要记住，程序和它所代表的算法是不同的。第1章说过，算法是为逐步解决问题而设计的一系列通用指令。给定某个输入，算法能得到对应的结果——算法就是解决问题的方法。程序则是用某种编程语言对算法编码。同一个算法可以对应许多程序，这取决于程序员和编程语言。 为了进一步说明算法和程序的区别，来看看代码清单2-1中的函数。该函数解决了一个常见的问题，即计算前n个整数之和。算法的思路是使用一个初始值为0的累加器变量，然后遍历n个整数，并将值加到累加器上。 代码清单2-1 计算前n个整数之和 123456def sumOfN(n): theSum = 0 for i in range(1, n+1): theSum = theSum + i return theSum 下面看看代码清单2-2。乍看会觉得有些奇怪，但是仔细观察后，你会发现这个函数所做的工作在本质上和前一个相同。之所以不能一眼看出来，是因为代码写得太差。没有用好的变量名提高可读性，而且在累加时还使用了一条多余的赋值语句。 代码清单2-2 计算前n个整数之和的另一种写法 1234567def foo(tom): fred = 0 for bill in range(1, tom+1): barney = bill fred = fred + barney return fred 前面提出过一个问题：程序是否有优劣之分？答案取决于你的标准。如果你关心的是可读性，那么sumOfN当然比foo更好。实际上，你可能已经在编程入门课上看过很多例子，毕竟入门课的一个目标就是帮你写出易读的程序。不过，除了可读性，本书还对描述算法感兴趣。（我们当然希望你继续向着写出易读代码的目标努力。） 算法分析关心的是基于所使用的计算资源比较算法。我们说甲算法比乙算法好，依据是甲算法有更高的资源利用率或使用更少的资源。从这个角度来看，上面两个函数其实差不多，它们本质上都利用同一个算法解决累加问题。 计算资源究竟指什么？思考这个问题很重要。有两种思考方式。一是考虑算法在解决问题时要占用的空间或内存。解决方案所需的空间总量一般由问题实例本身决定，但算法往往也会有特定的空间需求，后文会详细介绍。 另一种思考方式是根据算法执行所需的时间进行分析和比较。这个指标有时称作算法的执行时间或运行时间。要衡量sumOfN函数的执行时间，一个方法就是做基准分析。也就是说，我们会记录程序计算出结果所消耗的实际时间。在Python中，我们记录下函数就所处系统而言的开始时间和结束时间。time模块中有一个time函数，它会以秒为单位返回自指定时间点起到当前的系统时钟时间。在首尾各调用一次这个函数，计算差值，就可以得到以秒为单位的执行时间（多数情况下非常短）。 在代码清单2-3中，sumOfN函数在累加前后调用time。函数返回一个元组，由结果与计算时间（单位为秒）构成。如果调用5次，每次计算前10 000个整数之和，会得到如下结果。 12345678&gt;&gt;&gt; for i in range(5): print("Sum is %d required %10.7f seconds" % sumOfN(10000))Sum is 50005000 required 0.0018950 secondsSum is 50005000 required 0.0018620 secondsSum is 50005000 required 0.0019171 secondsSum is 50005000 required 0.0019162 secondsSum is 50005000 required 0.0019360 seconds&gt;&gt;&gt; 代码清单2-3 计算执行时间 123456789101112import timedef sumOfN2(n): start = time.time() theSum = 0 for i in range(1, n+1): theSum = theSum + i end = time.time() return theSum, end-start 可以看出，执行时间基本上是一致的，平均约为0.0019秒。如果计算前100 000个整数之和，又会如何呢？12345678&gt;&gt;&gt; for i in range(5): print("Sum is %d required %10.7f seconds" % sumOfN(100000))Sum is 5000050000 required 0.0199420 secondsSum is 5000050000 required 0.0180972 secondsSum is 5000050000 required 0.0194821 secondsSum is 5000050000 required 0.0178988 secondsSum is 5000050000 required 0.0188949 seconds&gt;&gt;&gt; 执行时间都变长了，但还是很一致，差不多都是之前的10倍。如果n取1 000 000，结果如下。12345678&gt;&gt;&gt; for i in range(5): print("Sum is %d required %10.7f seconds" % sumOfN(1000000))Sum is 500000500000 required 0.1948988 secondsSum is 500000500000 required 0.1850290 secondsSum is 500000500000 required 0.1809771 secondsSum is 500000500000 required 0.1729250 secondsSum is 500000500000 required 0.1646299 seconds&gt;&gt;&gt; 这次的平均执行时间差不多是前一个例子的10倍。 现在来看看代码清单2-4，其中给出了解决累加问题的新方法。函数sumOfN3使用以下公式计算前n个整数之和，不必使用循环。 \sum^n_{i=1}i=\frac{(n)(n+1)}{2} 代码清单2-4 不使用循环来计算前n个整数之和 12def sumOfN3(n): return (n*(n+1))/2 对sumOfN3做同样的基准测试，n取5个值（10 000、100 000、1 000 000、10 000 000和100 000 000），会得到以下结果。12345Sum is 50005000 required 0.00000095 secondsSum is 5000050000 required 0.00000191 secondsSum is 500000500000 required 0.00000095 secondsSum is 50000005000000 required 0.00000095 secondsSum is 5000000050000000 required 0.00000119 seconds 关于这个结果，有两点要注意。首先，记录的耗时比之前的例子都要短。其次，不管n取什么值，耗时都很稳定。看起来sumOfN3不太受整数数目的影响。 不过，以上基准测试结果的意义到底是什么呢？直觉上，循环方案看上去工作量更大，因为有些步骤重复。这好像是耗时更久的原因。而且，循环方案的耗时会随着n一起增长。然而，这里有个问题。如果在另一台计算机上运行这个函数，或用另一种编程语言来实现，很可能会得到不同的结果。如果计算机再旧些，sumOfN3的执行时间甚至更长。 所以，我们需要更好的方式来描述算法的执行时间。基准测试计算的是执行算法的实际时间。这不是一个有用的指标，因为它依赖于特定的计算机、程序、时间、编译器与编程语言。我们希望找到一个独立于程序或计算机的指标。这样的指标在评价算法方面会更有用，可以用来比较不同实现下的算法。 大O记法试图摆脱程序或计算机的影响而描述算法的效率时，量化算法的操作或步骤很重要。如果将每一步看成基本计算单位，那么可以将算法的执行时间描述成解决问题所需的步骤数。确定合适的基本计算单位很复杂，也依赖于算法的实现。 对于累加算法，计算总和所用的赋值语句的数目就是一个很好的基本计算单位。在sumOfN函数中，赋值语句数是1（theSum = 0）加上n（theSum = theSum + i的运行次数）。可以将其定义成函数$T$，令$T(n)=1+n$。参数n常被称作问题规模，可以将函数解读为“当问题规模为n时，解决问题所需的时间是$T(n)$，即需要$1+n$步”。 在前面给出的累加函数中，用累加次数定义问题规模是合理的。这样一来，就可以说处理前100 000个整数的问题规模比处理前1000个整数的大。鉴于此，前者花的时间要比后者长。接下来的目标就是揭示算法的执行时间如何随问题规模而变化。 计算机科学家将分析向前推进了一步。精确的步骤数并没有$T(n)$函数中起决定性作用的部分重要。也就是说，随着问题规模的增长，$T(n)$函数的某一部分会比其余部分增长得更快。最后比较的其实就是这一起决定性作用的部分。数量级函数描述的就是，当n增长时，$T(n)$增长最快的部分。数量级（order of magnitude）常被称作大$\boldsymbol{O}$记法（O指order），记作$O(f(n))$。它提供了步骤数的一个有用的近似方法。$f(n)$函数为$T(n)$函数中起决定性作用的部分提供了简单的表示。 对于$T(n)=1+n$，随着n越来越大，常数1对最终结果的影响越来越小。如果要给出$T(n)$的近似值，可以舍去1，直接说执行时间是$O(n)$。注意，1对于$T(n)$来说是重要的。但是随着n的增长，没有1也不会太影响近似值。 再举个例子，假设某算法的步骤数是$T(n)=5n^2+27n+1005$。当n很小时，比如说1或2，常数1005看起来是这个函数中起决定性作用的部分。然而，随n着增长，$n^2$变得更重要。实际上，当n很大时，另两项的作用对于最终结果来说就不显著了，因此可以忽略这两项，只关注$5n^2$。另外，当n变大时，系数5的作用也不显著了。因此可以说，函数$T(n)$的数量级是$f(n)=n^2$，或者直接说是$O(n^2)$。 累加的例子没有体现的一点是，算法的性能有时不仅依赖于问题规模，还依赖于数据值。对于这种算法，要用最坏情况、最好情况和普通情况来描述性能。最坏情况指的是某一个数据集会让算法的性能极差；另一个数据集可能会让同一个算法的性能极好（最好情况）。大部分情况下，算法的性能介于两个极端之间（普通情况）。计算机科学家要理解这些区别，以免被某个特例误导。 在学习算法的路上，常见的函数会反复出现，如表2-1所示。要判断哪一个才是$T(n)$的决定性部分，必须了解它们在n变大时彼此有多大差别。图2-1展示了表2-1中的各个函数。注意，当n较小时，这些函数之间的界限不是很明确，很难看出哪个起主导作用。随着n的增长，它们之间的差别就很明显了。 表2-1 常见的大$\boldsymbol{O}$函数 $\boldsymbol{f(n)}$ 名称 $1$ 常数 $\log n$ 对数 $n$ 线性 $n\log n$ 对数线性 $n^2$ 平方 $n^3$ 立方 $2^n$ 指数 图2-1 常见的大O函数 最后来看一个例子，假设有如代码清单2-5所示的一段Python代码。尽管这个程序没有做什么实际工作，但它对分析性能有一定的指导意义。 代码清单2-5 Python代码示例 123456789101112a = 5b = 6c = 10for i in range(n): for j in range(n): x = i * i y = j * j z = i * jfor k in range(n): w = a * k + 45 v = b * bd = 33 赋值操作的数量是4项之和：$T(n)=3+3n^2+2n+1$。第1项是常数3，对应起始部分的3条赋值语句。第2项是$3n^2$，因为有3条语句要在嵌套循环中重复$n^2$次。第3项是$2n$，因为两条语句要循环n遍。第4项是常数1，代表最后那条赋值语句。 T(n)=3+3n^2+2n+1=3n^2+2n+4很容易看出来，$n^2$起主导作用，所以这段代码的时间复杂度是$O(n^2)$。当n变大时，其他项以及主导项的系数都可以忽略。 图2-2展示了一部分常见的大O函数与前面讨论的$T(n)$函数的对比情况。注意，$T(n)$一开始比立方函数大。然而，随着n的增长，立方函数很快就超越了$T(n)$。 图2-2 对比$T(n)$函数与常见的大O函数 异序词检测示例要展示不同数量级的算法，一个好例子就是经典的异序词检测问题。如果一个字符串只是重排了另一个字符串的字符，那么这个字符串就是另一个的异序词，比如heart与earth，以及python与typhon。为了简化问题，假设要检查的两个字符串长度相同，并且都是由26个英文字母的小写形式组成的。我们的目标是编写一个布尔函数，它接受两个字符串，并能判断它们是否为异序词。 方案1：清点法 清点第1个字符串的每个字符，看看它们是否都出现在第2个字符串中。如果是，那么两个字符串必然是异序词。清点是通过用Python中的特殊值None取代字符来实现的。但是，因为Python中的字符串是不可修改的，所以先要将第2个字符串转换成列表。在字符列表中检查第1个字符串中的每个字符，如果找到了，就替换掉。代码清单2-6给出了这个函数。 代码清单2-6 实现清点方案 1234567891011121314151617181920212223def anagramSolution1(s1, s2): alist = list(s2) pos1 = 0 stillOK = True while pos1 &lt; len(s1) and stillOK: pos2 = 0 found = False while pos2 &lt; len(alist) and not found: if s1[pos1] == alist[pos2]: found = True else: pos2 = pos2 + 1 if found: alist[pos2] = None else: stillOK = False pos1 = pos1 + 1 return stillOK 来分析这个算法。注意，对于s1中的n个字符，检查每一个时都要遍历s2中的n个字符。要匹配s1中的一个字符，列表中的n个位置都要被访问一次。因此，访问次数就成了从1到n的整数之和。这可以用以下公式来表示。 \sum^n_{i=1}i=\frac{n(n+1)}{2}=\frac{1}{2}n^2+\frac{1}{2}n当n变大时，起决定性作用的是$n^2$，而$\frac{1}{2}$可以忽略。所以，这个方案的时间复杂度是$O(n^2)$。 方案2：排序法 尽管s1与s2是不同的字符串，但只要由相同的字符构成，它们就是异序词。基于这一点，可以采用另一个方案。如果按照字母表顺序给字符排序，异序词得到的结果将是同一个字符串。代码清单2-7给出了这个方案的实现代码。在Python中，可以先将字符串转换为列表，然后使用内建的sort方法对列表排序。 代码清单2-7 实现排序方案 1234567891011121314151617def anagramSolution2(s1, s2): alist1 = list(s1) alist2 = list(s2) alist1.sort() alist2.sort() pos = 0 matches = True while pos &lt; len(s1) and matches: if alist1[pos] == alist2[pos]: pos = pos + 1 else: matches = False return matches 乍看之下，你可能会认为这个算法的时间复杂度是$O(n)$，因为在排序之后只需要遍历一次就可以比较$n$个字符。但是，调用两次sort方法不是没有代价。我们在后面会看到，排序的时间复杂度基本上是$O(n^2)$或$O(n\log n)$，所以排序操作起主导作用。也就是说，该算法和排序过程的数量级相同。 方案3：蛮力法 用蛮力解决问题的方法基本上就是穷尽所有的可能。就异序词检测问题而言，可以用s1中的字符生成所有可能的字符串，看看s2是否在其中。但这个方法有个难处。用s1中的字符生成所有可能的字符串时，第1个字符有n种可能，第2个字符有$n-1$种可能，第3个字符有$n-2$种可能，依此类推。字符串的总数是$n*(n-1)*(n-2)*\cdots*3*2*1$，即$n!$。也许有些字符串会重复，但程序无法预见，所以肯定会生成$n!$个字符串 n当较大时，$n!$增长得比$2^n$还要快。实际上，如果s1有20个字符，那么字符串的个数就是$20!=2~432~902~008~176~640~000$。假设每秒处理一个，处理完整个列表要花77 146 816 596年。这可不是个好方案。 方案4：计数法 最后一个方案基于这样一个事实：两个异序词有同样数目的a、同样数目的b、同样数目的c，等等。要判断两个字符串是否为异序词，先数一下每个字符出现的次数。因为字符可能有26种，所以使用26个计数器，对应每个字符。每遇到一个字符，就将对应的计数器加1。最后，如果两个计数器列表相同，那么两个字符串肯定是异序词。代码清单2-8给出了这个方案的实现代码。 代码清单2-8 实现计数方案 123456789101112131415161718192021def anagramSolution4(s1, s2): c1 = [0] * 26 c2 = [0] * 26 for i in range(len(s1)): pos = ord(s1[i]) - ord('a') c1[pos] = c1[pos] + 1 for i in range(len(s2)): pos = ord(s2[i]) - ord('a') c2[pos] = c2[pos] + 1 j = 0 stillOK = True while j &lt; 26 and stillOK: if c1[j] == c2[j]: j = j + 1 else: stillOK = False return stillOK 这个方案也有循环。但不同于方案1，这个方案的循环没有嵌套。前两个计数循环都是n阶的。第3个循环比较两个列表，由于可能有26种字符，因此会循环26次。全部加起来，得到总步骤数$T(n)=2n+26$，即$O(n)$。我们找到了解决异序词检测问题的线性阶算法。 结束这个例子的讲解之前，需要聊聊空间需求。尽管方案4的执行时间是线性的，它还是要用额外的空间来存储计数器。也就是说，这个算法用空间换来了时间。 这种情形很常见。很多时候，都需要在时间和空间之间进行权衡。本例中，额外使用的空间并不大。不过，如果有数以百万计的字符，那就有问题了。面对多种算法和具体的问题，计算机科学家需要决定如何利用好计算资源。 Python数据结构的性能你对大O记法及其不同函数的差别已经有了大致的了解。本节的目标是针对Python的列表和字典介绍如何用大O记法描述操作的性能。我们会做一些实验，展示在每个数据结构上做某些操作时的损耗与收益。理解这些Python数据结构的效率很重要，因为它们是本书用来实现其他数据结构的基石。本节不会解释性能优劣的原因。在后续章节中，你会看到列表和字典的一些可能的实现，以及为何性能取决于实现。 列表在实现列表数据结构时，Python的设计师有许多选择，每一个选择都会影响操作的性能。为了做出正确的选择，他们考虑了列表最常见的用法，并据此优化列表的实现，以使最常用的操作非常快。当然，他们也尽力使不常用的操作也很快，但在需要权衡时，往往会牺牲低频操作的性能。 两个常见操作是索引和给某个位置赋值。无论列表多长，这两个操作所花的时间应该恒定。像这种与列表长度无关的操作就是常数阶的。 另一个常见的操作是加长列表。有两种方式：要么采用追加方法，要么执行连接操作。追加方法是常数阶的。如果待连接列表的长度为k，那么连接操作的时间复杂度就是$O(k)$。知道这一点很重要，因为它能帮你选择正确的工具，使程序更高效。 假设要从0开始生成含有n个数的列表，来看看4种生成方式。首先，用for循环通过连接操作创建列表；其次，采用追加方法；再次，使用列表解析式；最后，用列表构造器调用range函数（这可能是最容易想到的方式）。代码清单2-9给出了4种方式的代码。假设代码保存在文件listfuns.py中。 代码清单2-9 生成列表的4种方式 123456789101112131415def test1(): l = [] for i in range(1000): l = l + [i]def test2(): l = [] for i in range(1000): l.append(i)def test3(): l = [i for i in range(1000)]def test4(): l = list(range(1000)) 要得到每个函数的执行时间，需要用到Python的timeit模块。该模块使Python开发人员能够在一致的环境下运行函数，并且在多种操作系统下使用尽可能相似的机制，以实现跨平台计时。 要使用timeit模块，首先创建一个Timer对象，其参数是两条Python语句。第1个参数是要为之计时的Python语句；第2个参数是建立测试的语句。timeit模块会统计多次执行语句要用多久。默认情况下，timeit会执行100万次语句，并在完成后返回一个浮点数格式的秒数。不过，既然这是执行100万次所用的秒数，就可以把结果视作执行1次所用的微秒数。此外，可以给timeit传入参数number，以指定语句的执行次数。下面的例子展示了测试函数各运行1000次所花的时间。 12345678910111213141516t1 = Timer("test1()", "from __main__ import test1")print("concat ", t1.timeit(number=1000), "milliseconds")t2 = Timer("test2()", "from __main__ import test2")print("append ", t2.timeit(number=1000), "milliseconds")t3 = Timer("test3()", "from __main__ import test3")print("comprehension ", t3.timeit(number=1000), "milliseconds")t4 = Timer("test4()", "from __main__ import test4")print("list range ", t4.timeit(number=1000), "milliseconds")# concat 6.54352807999 milliseconds# append 0.306292057037 milliseconds# comprehension 0.147661924362 milliseconds# list range 0.0655000209808 milliseconds 在本例中，计时的语句是对test1()、test2()等的函数调用。你也许会觉得建立测试的语句有些奇怪，所以我们仔细研究一下。你可能已经熟悉from和import，但它们通常在Python程序文件的开头使用。本例中，from __main__ import test1将test1函数从__main__命名空间导入到timeit设置计时的命名空间。timeit模块这么做，是为了在一个干净的环境中运行计时测试，以免某些变量以某种意外的方式干扰函数的性能。 实验结果清楚地表明，0.30毫秒的追加操作远快于6.54毫秒的连接操作。实验也测试了另两种列表创建操作：使用列表解析式，以及使用列表构造器调用range。有趣的是，与用for循环进行追加操作相比，使用列表解析式几乎快一倍。 关于这个小实验要说明的最后一点是，执行时间其实包含了调用测试函数的额外开销，但可以假设4种情形的函数调用开销相同，所以对比操作还是有意义的。鉴于此，说连接操作花了6.54毫秒不太准确，应该说用于连接操作的测试函数花了6.54毫秒。可以做个练习，测一下调用空函数的时间，然后从之前得到的数字中减去。 知道如何衡量性能之后，可以对照表2-2，看看基本列表操作的大O效率。仔细考虑之后，你可能会对pop的两种效率有疑问。在列表末尾调用pop时，操作是常数阶的，在列表头一个元素或中间某处调用pop时，则是阶的。原因在于Python对列表的实现方式。在Python中，从列表头拿走一个元素，其他元素都要向列表头挪一位。你可能觉得这个做法有点傻，但再看看表2-2，你会明白这种实现保证了索引操作为常数阶。Python的实现者认为这是不错的取舍决策。 表2-2 Python列表操作的大$\boldsymbol{O}$效率 操作 大$\boldsymbol{O}$效率 索引 $O(1)$ 索引赋值 $O(1)$ 追加 $O(1)$ pop() $O(1)$ pop(i) $O(n)$ insert(i, item) $O(n)$ 删除 $O(n)$ 遍历 $O(n)$ 包含 $O(n)$ 切片 $O(k)$ 删除切片 $O(n)$ 设置切片 $O(n+k)$ 反转 $O(n)$ 连接 $O(k)$ 排序 $O(n\log n)$ 乘法 $O(nk)$ 为了展示pop()和pop(i)的性能差异，我们使用timeit模块做另一个实验。实验目标是针对一个长度已知的列表，分别从列表头和列表尾弹出一个元素。我们也想衡量不同长度下的执行时间。预期结果是，从列表尾弹出元素的时间是恒定的，而从列表头弹出元素的时间会随着列表变长而增加。 代码清单2-10是实验代码。可以看到，从列表尾弹出元素花了0.0003毫秒，从列表头弹出花了4.8214毫秒。对于含有200万个元素的列表来说，后者是前者的16 000倍。 有两点需要说明。首先是from __main__ import x语句。尽管没有定义一个函数，但是我们仍然希望能在测试中使用列表对象x。这个办法允许我们只对pop语句计时，从而准确地获得这一个操作的耗时。其次，因为计时重复了1000次，所以列表每次循环都少一个元素。不过，由于列表的初始长度是200万，因此对于整体长度来说，只减少了0.05%。 代码清单2-10 pop的性能分析 12345678910popzero = timeit.Timer("x.pop(0)", "from __main__ import x")popend = timeit.Timer("x.pop()", "from __main__ import x")x = list(range(2000000))popzero.timeit(number=1000)# 4.8213560581207275x = list(range(2000000))popend.timeit(number=1000)# 0.0003161430358886719 虽然测试结果说明pop(0)确实比pop()慢，但是并没有证明pop(0)的时间复杂度是$O(n)$，也没有证明pop()的是$O(1)$。要证明这一点，需要看看两个操作在各个列表长度下的性能。代码清单2-11实现了这个测试。 代码清单2-11 比较pop(0)和pop()在不同列表长度下的性能 123456789popzero = Timer("x.pop(0)", "from __main__ import x")popend = Timer("x.pop()", "from __main__ import x")print("pop(0) pop()")for i in range(1000000, 100000001, 1000000): x = list(range(i)) pt = popend.timeit(number=1000) x = list(range(i)) pz = popzero.timeit(number=1000) print("%15.5f, %15.5f" % (pz, pt)) 图2-3展示了实验结果。可以看出，列表越长，pop(0)的耗时也随之变长，而pop()的耗时很稳定。这刚好符合$O(n)$和$O(1)$的特征。 图2-3 对比pop(0)和pop()的性能 实验会有一些误差。因为用来测量的计算机运行着其他进程，所以可能拖慢代码的速度。因此，尽管我们尽力减少计算机所做的其他工作，测出的时间仍然会有些许变化。这也是测试1000遍的原因，从统计角度来说，收集足够多的信息有助于得到可靠的结果。 字典Python的第二大数据结构就是字典。你可能还记得，字典不同于列表的地方在于，可以通过键——而不是位置——访问元素。你会在后文中发现，实现字典有许多方法。现在最重要的是，知道字典的取值操作和赋值操作都是常数阶。另一个重要的字典操作就是包含（检查某个键是否在字典中），它也是常数阶。表2-3总结了所有字典操作的大O效率。要注意，表中给出的效率针对的是普通情况。在某些特殊情况下，包含、取值、赋值等操作的时间复杂度可能变成$O(n)$。后文在讨论不同的字典实现方式时会详细说明。 表2-3 Python字典操作的大$\boldsymbol{O}$效率 操作 大$\boldsymbol{O}$效率 复制 $O(n)$ 取值 $O(1)$ 赋值 $O(1)$ 删除 $O(1)$ 包含 $O(1)$ 遍历 $O(n)$ 最后一个性能实验会比较列表和字典的包含操作，并验证列表的包含操作是$O(n)$，而字典的是$O(1)$。实验很简单，首先创建一个包含一些数的列表，然后随机取一些数，看看它们是否在列表中。如果表2-2给出的效率是正确的，那么随着列表变长，判断一个数是否在列表中所花的时间也就越长。 对于以数字为键的字典，重复上述实验。我们会看到，判断数字是否在字典中的操作，不仅快得多，而且当字典变大时，耗时基本不变。 代码清单2-12实现了这个对比实验。注意，我们进行的是完全相同的操作。不同点在于，第7行的x是列表，第9行的x则是字典。 代码清单2-12 比较列表和字典的包含操作 12345678910import timeitimport randomfor i in range(10000, 1000001, 20000): t = timeit.Timer("random.randrange(%d) in x" % i, "from __main__ import random, x") x = list(range(i)) lst_time = t.timeit(number=1000) x = &#123;j:None for j in range(i)&#125; d_time = t.timeit(number=1000) print("%d, %10.3f, %10.3f" % (i, lst_time, d_time)) 图2-4展示了运行结果。可以看出，字典一直更快。对于元素最少的情况（10 000），字典的速度是列表的89.4倍。对于元素最多的情况（990 000），字典的速度是列表的11 603倍！还可以看出，随着规模增加，列表的包含操作在耗时上的增长是线性的，这符合$O(n)$。对于字典来说，即使规模增加，包含操作的耗时也是恒定的。实际上，当字典有10 000个元素时，包含操作的耗时是0.004毫秒，当有990 000个元素时，耗时还是0.004毫秒。 图2-4 比较列表和字典的包含操作 小结 算法分析是一种独立于实现的算法度量方法。 大O记法使得算法可以根据随问题规模增长而起主导作用的部分进行归类。 关键术语大记法 对数 对数线性蛮力法 平方 普通情况清点法 时间复杂度 数量级线性 指数 最坏情况 讨论题给出以下代码的大O性能。123for i in range(n): for j in range(n): k = 2 + 2 给出以下代码的大O性能。12for i in range(n): k = 2 + 2 给出以下代码的大O性能。1234i = nwhile i &gt; 0: k = 2 + 2 i = i // 2 给出以下代码的大O性能。1234for i in range(n): for j in range(n): for k in range(n): k = 2 + 2 给出以下代码的大O性能。1234i = nwhile i &gt; 0: k = 2 + 2 i = i // 2 给出以下代码的大O性能。123456for i in range(n): k = 2 + 2for j in range(n): k = 2 + 2for k in range(n): k = 2 + 2 编程练习 1.设计一个实验，证明列表的索引操作为常数阶。 2.设计一个实验，证明字典的取值操作和赋值操作为常数阶。 3.设计一个实验，针对列表和字典比较del操作的性能。 4.给定一个数字列表，其中的数字随机排列，编写一个线性阶算法，找出第k小的元素，并解释为何该算法的阶是线性的。 5.针对前一个练习，能将算法的时间复杂度优化到$O(n\log n)$吗？]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
      <tags>
        <tag>Python数据结构与算法分析（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[结合Laravel Facade看外观模式怎么用？]]></title>
    <url>%2F2020%2F01%2F14%2F%E7%BB%93%E5%90%88Laravel-Facade%E7%9C%8B%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E6%80%8E%E4%B9%88%E7%94%A8%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是外观模式？ 当独立子系统的开发完成后，如果两个系统是客户—供应商关系，也就是说其中一个子系统（客户）需要使用另一个子系统（供应商）提供的服务时，我们可以通过外观模式来对客户子系统隐藏调用供应商系统的复杂性，客户端只需通过facade调用相应的服务而无需涉及供应商具体的服务调用方法。下面通过laravel中的facade来说明: 在laravel中，我们经常通过facade来实现全局调用某个方法而不需要实例化一个对象。通过查看源码可以知道，所有的Facade都是继承自同一个抽象父类Illuminate\Support\Facades\Facade。 当我们调用Auth::guard(‘customer’)来返回一个guard实例的时候，只需要在调用这个方法的所在脚本写上use Illuminate\Support\Facades\Auth;就可以了，而当我们去查看Illuminate\Support\Facades\Auth的具体定义的时候，我们就会发现，这种调用都是基于php的魔术方法——__callstatic()。 \vendor\laravel\framework\src\Illuminate\Support\Facades.php 12345678910public static function __callStatic($method, $args)&#123; $instance = static::getFacadeRoot(); if (! $instance) &#123; throw new RuntimeException('A facade root has not been set.'); &#125; return $instance-&gt;$method(...$args);&#125; 从代码中可以看出，最关键的一句就是$instance=static::getFacadeRoot();因为调用的方法和参数我们都能通过__callstatic获取，关键是我们如何获取到一个能执行这个方法的正确的对象，让我们继续往下扒。 1234public static function getFacadeRoot()&#123; return static::resolveFacadeInstance(static::getFacadeAccessor());&#125; 原来底层是你，resolveFacadeInstance(static::getFacadeAccessor())不管，继续扒。1234protected static function getFacadeAccessor()&#123; throw new RuntimeException('Facade does not implement getFacadeAccessor method.');&#125; static::getFacadeAccessor()为什么直接抛出错误，搞错了？不对，刚才好像在哪见过？？没错，每个Facade都会对这个方法进行重写，如果没有重写就会抛出错误，例如在Illuminate\Support\Facades\Auth中的实现是：1234protected static function getFacadeAccessor()&#123; return 'auth';&#125; 好了，看来接下来这个才是最核心的resolveFacadeInstance($name)123456789101112131415 protected static function resolveFacadeInstance($name)&#123; // 判断传入参数是否是对象，是则直接返回，我猜laravel框架告诉我们在定义自己的facade的时候可以直接在getFacadeAccessor返回一个对象 if (is_object($name)) &#123; return $name; &#125; // 不是对象的话,判断是否已经实例化过这个对象，是的话就把之前实例化后保存的对象拿去使 if (isset(static::$resolvedInstance[$name])) &#123; return static::$resolvedInstance[$name]; &#125; // 没有?!那只能返回新的对象并保存到$resolvedInstance中方便下次用了 return static::$resolvedInstance[$name] = static::$app[$name];&#125; 这里是$app是laravel的ioc容器。 通过上面的例子可以看出，laravel通过外观模式对外提供auth服务，向客户端隐藏了具体的操作，实际底层是调用了某个具体的执行者来提供该项服务，这样客户端就无需知道相关细节，就可以使用开箱即用的服务。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP性能优化利器：生成器yield理解]]></title>
    <url>%2F2020%2F01%2F14%2FPHP%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E5%88%A9%E5%99%A8%EF%BC%9A%E7%94%9F%E6%88%90%E5%99%A8yield%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 使用yield还需要再循环一次，怎么理解？ yield和两个foreach在一起。怎么理解？ 如果是做Python或者C#的小伙伴，对于生成器应该不陌生。但很多PHP开发者或许都不知道生成器这个功能，可能是因为生成器是PHP5.5.0才引入的功能，也可以是生成器作用不是很明显。但是，生成器功能的确非常有用。 优点 生成器会对PHP应用的性能有非常大的影响。 PHP代码运行时节省大量的内存。 比较适合计算大量的数据。 那么，这些神奇的功能究竟是如何做到的？我们先来举个例子。 概念引入首先，放下生成器概念的包袱，来看一个简单的PHP函数： 1234567891011function createRange($number)&#123; $data = []; for($i = 0; $i &lt; $number; $i++) &#123; $data[] = time(); &#125; return $data;&#125; 这是一个非常常见的PHP函数，我们在处理一些数组的时候经常会使用。这里的代码也非常简单： 1.我们创建一个函数。 2.函数内包含一个for循环，我们循环的把当前时间放到$data里面。 3.for循环执行完毕，把$data返回出去。 再写一个函数，把这个函数的返回值循环打印出来： 1234567$result = createRange(10); // 这里调用上面我们创建的函数foreach($result as $value)&#123; sleep(1); // 这里停顿1秒，我们后续有用 echo $value.'&lt;br/&gt;';&#125; 我们在浏览器里面看一下运行结果： 这里非常完美，没有任何问题。（当然sleep(1)效果你们看不出来） 生成器我们注意到，在调用函数createRange的时候给$number的传值是10，一个很小的数字。假设，现在传递一个值10000000（1000万）。 那么，在函数createRange里面，for循环就需要执行1000万次。且有1000万个值被放到$data里面，而$data数组在是被放在内存内。所以，在调用函数时候会占用大量内存。 这里，生成器就可以大显身手了。 创建生成器我们直接修改代码，你们注意观察： 1234567function createRange($number)&#123; for($i = 0; $i &lt; $number; $i++) &#123; yield time(); &#125;&#125; 看下这段和刚刚很像的代码，我们删除了数组$data，而且也没有返回任何内容，而是在time()之前使用了一个关键字yield。 使用生成器我们再运行一下第二段代码： 1234567$result = createRange(10); // 这里调用上面我们创建的函数foreach($result as $value)&#123; sleep(1); echo $value.'&lt;br /&gt;';&#125; 我们奇迹般的发现了，输出的值和第一次没有使用生成器的不一样。这里的值（时间戳）中间间隔了1秒。 这里的间隔一秒其实就是sleep(1)造成的后果。但是为什么第一次没有间隔？那是因为： 未使用生成器时：createRange函数内的for循环结果被很快放到$data中，并且立即返回。所以，foreach循环的是一个固定的数组。 使用生成器时：createRange的值不是一次性快速生成，而是依赖于foreach循环。foreach循环一次，for执行一次。 到这里，你应该对生成器有点儿头绪。 深入理解生成器代码剖析 下面我们来对于刚刚的代码进行剖析。 123456789101112131415function createRange($number)&#123; for($i = 0; $i &lt; $number; $i++) &#123; yield time(); &#125;&#125;$result = createRange(10); // 这里调用上面我们创建的函数foreach($result as $value)&#123; sleep(1); echo $value.'&lt;br /&gt;';&#125; 我们来还原一下代码执行过程。 1.首先调用createRange函数，传入参数10，但是for值执行了一次然后停止了，并且告诉foreach第一次循环可以用的值。 2.foreach开始对$result循环，进来首先sleep(1)，然后开始使用for给的一个值执行输出。 3.foreach准备第二次循环，开始第二次循环之前，它向for循环又请求了一次。 4.for循环于是又执行了一次，将生成的时间戳告诉foreach. 5.foreach拿到第二个值，并且输出。由于foreach中sleep(1)，所以，for循环延迟了1秒生成当前时间。 所以，整个代码执行中，始终只有一个记录值参与循环，内存中也只有一条信息。 无论开始传入的$number有多大，由于并不会立即生成所有结果集，所以内存始终是一条循环的值。 概念理解 到这里，你应该已经大概理解什么是生成器了。下面我们来说下生成器原理。 首先明确一个概念：生成器yield关键字不是返回值，他的专业术语叫产出值，只是生成一个值 那么代码中foreach循环的是什么？其实是PHP在使用生成器的时候，会返回一个Generator类的对象。foreach可以对该对象进行迭代，每一次迭代，PHP会通过Generator 实例计算出下一次需要迭代的值。这样foreach就知道下一次需要迭代的值了。 而且，在运行中for循环执行后，会立即停止。等待foreach下次循环时候再次和for索要下次的值的时候，循环才会再执行一次，然后立即再次停止。直到不满足条件不执行结束。 实际开发应用很多PHP开发者不了解生成器，其实主要是不了解应用领域。那么，生成器在实际开发中有哪些应用？ 读取超大文件PHP开发很多时候都要读取大文件，比如csv文件、text文件，或者一些日志文件。这些文件如果很大，比如5个G。这时，直接一次性把所有的内容读取到内存中计算不太现实。 这里生成器就可以派上用场啦。简单看个例子：读取text文件。 我们创建一个text文本文档，并在其中输入几行文字，示范读取。 12345678910111213141516171819&lt;?phpheader("content-type:text/html;charset=utf-8");function readTxt()&#123; # code... $handle = fopen("./test.txt", 'rb'); while (feof($handle)===false) &#123; # code... yield fgets($handle); &#125; fclose($handle);&#125;foreach (readTxt() as $key =&gt; $value) &#123; # code... echo $value.'&lt;br /&gt;';&#125; 通过上图的输出结果我们可以看出代码完全正常。 但是，背后的代码执行规则却一点儿也不一样。使用生成器读取文件，第一次读取了第一行，第二次读取了第二行，以此类推，每次被加载到内存中的文字只有一行，大大的减小了内存的使用。 这样，即使读取上G的文本也不用担心，完全可以像读取很小文件一样编写代码。 百万级别的访问量yield生成器是php5.5之后出现的，yield提供了一种更容易的方法来实现简单的迭代对象，相比较定义类实现Iterator接口的方式，性能开销和复杂性大大降低。 yield生成器允许你在foreach代码块中写代码来迭代一组数据而不需要在内存中创建一个数组。 使用示例：123456789101112131415161718192021222324252627/** * 计算平方数列 * @param $start * @param $stop * @return Generator */ function squares($start, $stop) &#123; if ($start &lt; $stop) &#123; for ($i = $start; $i &lt;= $stop; $i++) &#123; yield $i =&gt; $i * $i; &#125; &#125; else &#123; for ($i = $start; $i &gt;= $stop; $i--) &#123; yield $i =&gt; $i * $i; //迭代生成数组： 键=》值 &#125; &#125; &#125; foreach (squares(3, 15) as $n =&gt; $square) &#123; echo $n . ‘squared is‘ . $square . ‘&lt;br&gt;‘; &#125; 输出：12343 squared is 9 4 squared is 16 5 squared is 25 ... 示例2： 1234567891011121314151617181920212223242526272829303132333435363738394041//对某一数组进行加权处理 $numbers = array(‘nike‘ =&gt; 200, ‘jordan‘ =&gt; 500, ‘adiads‘ =&gt; 800); //通常方法，如果是百万级别的访问量，这种方法会占用极大内存 function rand_weight($numbers) &#123; $total = 0; foreach ($numbers as $number =&gt; $weight) &#123; $total += $weight; $distribution[$number] = $total; &#125; $rand = mt_rand(0, $total-1); foreach ($distribution as $num =&gt; $weight) &#123; if ($rand &lt; $weight) return $num; &#125; &#125; //改用yield生成器 function mt_rand_weight($numbers) &#123; $total = 0; foreach ($numbers as $number =&gt; $weight) &#123; $total += $weight; yield $number =&gt; $total; &#125; &#125; function mt_rand_generator($numbers) &#123; $total = array_sum($numbers); $rand = mt_rand(0, $total -1); foreach (mt_rand_weight($numbers) as $num =&gt; $weight) &#123; if ($rand &lt; $weight) return $num; &#125; &#125; Laravel + ElasticSearch123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127/** * 迁移用户数据到es * @param $container * @param $logger * @param $type */public static function syncUsersToEs($container, $logger, $type)&#123; list($builder, $currentTime) = [ $container-&gt;get(ClientBuilderFactory::class)-&gt;create(), time(), ]; $client = $builder-&gt;setHosts([env('ES_HOSTS', '')])-&gt;build(); $esFun = function ($data, $client) use ($type) &#123; $list = []; foreach ($data as $k =&gt; $va) &#123; if (count($list) &gt;= 500) &#123; $client-&gt;bulk([ 'index' =&gt; Users::ES_INDEX_NAME, 'type' =&gt; 'users', 'body' =&gt; $list ]); $list = []; &#125; else &#123; switch ($type) &#123; // 更新基础数据字段的值 case 'update': array_push( $list, [ 'update' =&gt; [ '_id' =&gt; (int)$va['id'], '_index' =&gt; Users::ES_INDEX_NAME, '_type' =&gt; '_doc', ] ], ['doc' =&gt; $va] ); break; // 把对应的新增用户注入es case 'create': array_push( $list, [ 'create' =&gt; [ '_id' =&gt; (int)$va['id'], '_index' =&gt; Users::ES_INDEX_NAME, '_type' =&gt; '_doc', ] ], $va ); break; &#125; &#125; &#125; if (!empty($list)) &#123; $res = $client-&gt;bulk(['index' =&gt; Videos::ES_INDEX_NAME, 'type' =&gt; 'sv_videos', 'body' =&gt; $list]); &#125; unset($list); &#125;; switch ($type) &#123; // 添加新用户到es中 case 'create': Users::query() -&gt;select(['id', 'name', 'avatar', 'gender', 'mobile']) -&gt;where([ ['created_at', '&gt;=', date('Y-m-d H:i:s', $currentTime - 3600)] ]) -&gt;chunkById(1000, function ($results) use ($client, $esFun) &#123; // 迭代器数据 $data = function () use ($results) &#123; foreach ($results-&gt;toArray() as $v) &#123; yield [ 'id' =&gt; (int)$v['id'], 'name' =&gt; (string)$v['name'], 'avatar' =&gt; (string)$v['avatar'], 'gender' =&gt; (int)$v['gender'], 'mobile' =&gt; (string)$v['mobile'], ]; &#125; &#125;; $esFun($data(), $client); &#125;); break; // 去更新用户搜索的基础数据 case 'update': Users::query() -&gt;select(['id', 'name', 'avatar', 'gender', 'mobile']) -&gt;where([ ['updated_at', '&gt;=', date('Y-m-d H:i:s', $currentTime - 3600)] ]) -&gt;chunkById(1000, function ($results) use ($client, $esFun) &#123; // 迭代器数据 $data = function () use ($results) &#123; foreach ($results-&gt;toArray() as $v) &#123; yield [ 'id' =&gt; (int)$v['id'], 'name' =&gt; (string)$v['name'], 'avatar' =&gt; (string)$v['avatar'], 'gender' =&gt; (int)$v['gender'], 'mobile' =&gt; (string)$v['mobile'], ]; &#125; &#125;; $esFun($data(), $client); &#125;); break; &#125;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章 树]]></title>
    <url>%2F2020%2F01%2F08%2F%E7%AC%AC6%E7%AB%A0-%E6%A0%91%2F</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[数据库分片（Database Sharding）详解]]></title>
    <url>%2F2020%2F01%2F06%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%86%E7%89%87%EF%BC%88Database-Sharding%EF%BC%89%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 导言任何看到显著增长的应用程序或网站，最终都需要进行扩展，以适应流量的增加。以确保数据安全性和完整性的方式进行扩展，对于数据驱动的应用程序和网站来说十分重要。人们可能很难预测某个网站或应用程序的流行程度，也很难预测这种流行程度会持续多久，这就是为什么有些机构选择“可动态扩展的”数据库架构的原因。 在这篇概念性文章中，我们将讨论一种“可动态扩展的”数据库架构：分片数据库。近年来，分片（Sharding）一直受到很多关注，但许多人并没有清楚地了解它是什么，或者对数据库进行分片可能有意义的场景。我们将讨论分片是什么，它的一些主要优点和缺点，以及一些常见的分片方法。 什么是分片？分片（Sharding）是一种与水平切分（horizontal partitioning）相关的数据库架构模式——将一个表里面的行，分成多个不同的表的做法（称为分区）。每个区都具有相同的模式和列，但每个表有完全不同的行。同样，每个分区中保存的数据都是唯一的，并且与其他分区中保存的数据无关。 从水平切分（horizontal partitioning）与垂直切分（vertical partitioning）的关系，可能会有所帮助。在垂直切分表中，所有的列被分离出来，并放入新的不同的表中。每个垂直切分内的数据，独立于所有其他分区中的数据，并且每个分区都包含不同的行和列。下图说明了如何在水平和垂直方向上对表进行分区： 分片（Sharding）将一个数据分成两个或多个较小的块，称为逻辑分片（logical shards）。然后，逻辑分片（logical shards）分布在单独的数据库节点上，称为物理分片（physical shards）。物理分片（physical shards）可以容纳多个逻辑分片（logical shards）。尽管如此，所有分片中保存的数据，共同代表整个逻辑数据集。 数据库分片（Database shards）是无共享架构的一个例子。这意味着分片是自治的：分片间不共享任何相同的数据或服务器资源。但是在某些情况下，将某些表复制到每个分片中作为参考表是有意义的。例如，假设某个应用程序的数据库依赖于重量测量的固定转换率。通过将包含必要转换率数据的表复制到每个分片中，有助于确保查询所需的所有数据都保存在每个分片中。 通常，分片（Sharding）在应用程序级别进行实现。这意味着应用程序包含“要向哪个分片发送读和写”的代码。但是，某些数据库管理系统内置了分片功能，允许您直接在数据库级别实现分片。 以上是分片（Sharding）的概述，接下来让我们来看一下，这种数据库架构的优点和缺点。 分片的好处数据库分片的主要吸引力在于，它可以帮助促进水平扩展（horizontal scaling），也称为向外扩展（scaling out）。水平扩展是将更多的机器添加到现有堆栈中，以分散负载，允许更多的流量和更快的处理。这通常与垂直扩展（vertical scaling）形成对比，垂直扩展也称为向上扩展（scaling up），是指升级现有服务器的硬件，通常是添加更多内存或CPU。 让一个关系数据库在单个机器上运行，并按需升级其服务器资源进行向上扩展是相对简单的。但最终，任何非分布式数据库在存储和计算能力方面都会受到限制，因此可以自由地水平扩展数据库，会使您的架构更加灵活且适应性强。 选择分片数据库架构的另一个原因，是为了加速查询响应的时间。当您对尚未分片的数据库提交查询时，必须先搜索您查询的表中的每一行，然后才能找到您要查找的结果集。对于具有大型单片数据库的应用程序，查询可能变得极其缓慢。但是，通过将一个表分成多个，查询过程会遍历更少的行，并且返回结果集的速度要快得多。 分片还可以通过减少宕机（outage）的影响，使应用程序更稳定可靠。如果您的应用程序或网站依赖于未分片的数据库，则宕机可能会导致整个应用程序不可用。但是，对于分片数据库，宕机可能只会影响单个分片。即使这可能使某些用户无法使用应用程序或网站部分功能，但仍会低于整个数据库崩溃带来的影响。 分片的缺点虽然对数据库进行分片可以使扩展更容易并提高性能，但它也可能会带来某些限制。在这里，我们将讨论其中的一些限制，以及为什么这些限制会让我们避免对数据库全部分片。 正确实现分片数据库架构，是十分复杂的，所以这是分片遇到的第一个困难。如果操作不正确，则分片过程可能会导致数据丢失或表损坏，这是一个很大的风险。但是，即使正确地进行了分片，也可能对团队的工作流程产生重大影响。与从单个入口点访问和管理数据不同，用户必须跨多个分片位置管理数据，这可能会让某些团队存在工作混乱。 在对数据库进行分片后，用户有时会遇到的一个问题是分片最终会变得不平衡。举例来说，假设您有一个数据库，其中有两个单独的分片，一个用于姓氏以字母A到M开头的客户，另一个用于名字以字母N到Z开头的客户。但是，您的应用程序为姓氏以字母G开头的人提供了过多的服务。因此，A-M分片逐渐累积的数据比N-Z分片要多，这会导致应用程序速度变慢，并对很大一部分用户造成影响。A-M分片已成为所谓的数据热点。在这种情况下，数据库分片的任何好处都被慢速和崩溃抵消了。数据库可能需要修复和重新分片，才能实现更均匀的数据分布。 另一个主要缺点是，一旦对数据库进行了分片，就很难将其恢复到未分片的架构。分片前数据库的备份数据，都无法与分片后写入的数据合并。因此，重建原始的非分片架构，需要将新的分区数据与旧备份合并，或者将分区的数据库转换回单个数据库，这两种方法都是昂贵且耗时的。 要考虑的最后一个缺点是，并不是每个数据库引擎本身都支持分片。例如，尽管可以手动分片PostgreSQL数据库，但PostgreSQL本身并不包括自动分片功能。有许多Postgres分支包括自动分片功能，但这些分支通常落后于最新的PostgreSQL版本，并且缺乏某些其他的功能特性。一些专业的数据库技术——如MySQL Cluster或某些数据库即服务产品（如MongoDB Atlas）确实包含自动分片功能，但这些数据库管理系统的普通版本却并不包含。因此，分片通常需要“自己动手”的方法。这意味着通常很难找到有关分片或故障排除技巧的文档。 现在我们已经介绍了一些分片的缺点和好处，我们将讨论一些分片数据库的不同架构。 一旦你决定对数据库进行分片，接下来你需要弄清楚的是如何进行分片。在运行查询或将传入的数据分发到分片表或数据库时，关键是要将其分配到正确的分片。否则，它可能导致数据丢失或查询速度缓慢。在本节中，我们将介绍一些常见的分片架构，每个架构使用稍微不同的流程来跨分片分发数据。 基于键的分片 为了确保数据记录以正确的方式被放置在正确的分片中，哈希函数中输入的值都应该来自同一列。此列称为分片键。简单来说，分片键与主键类似，因为它们都是列，用于为各个行建立唯一标识符。一般来说，分片键应该是静态的，这意味着它不应包含可能随时间变化的值。否则，它会增加更新操作的工作量，并可能降低性能。 虽然基于键的分片是一种相当常见的分片架构，但在尝试动态添加或删除数据库中的其他服务器时，它会使事情变得棘手。在添加服务器时，每个服务器都需要一个相应的哈希值，并且许多现有条目（如果不是全部）都需要重新映射到新的正确哈希值，然后迁移到相应的服务器。当您开始重新平衡数据时，新旧哈希函数都不会有效。因此，在迁移期间，您的服务器将无法编写任何新数据，您的应用程序可能会停机。 这种策略的主要吸引力在于，它可以用于均匀分布数据，从而防止热点。此外，由于它以算法方式分配数据，因此无需维护所有数据所在位置的映射，而其他策略（如范围或基于目录的分片）必须维护数据位置的映射。 基于范围的分片基于范围的分片（Range based sharding），基于给定值的范围进行数据分片。为了说明，假设您有一个数据库，用于存储零售商目录中所有产品的信息。您可以创建一些不同的分片，并根据每个产品的价格范围分配每个产品的信息，如下所示： 基于范围的分片的主要好处是，它实现起来相对简单。每个分片都包含一组不同的数据，但它们都具有相同的模式，以及原始数据库。应用程序代码只读取数据所属的范围，并将其写入相应的分片。 另一方面，基于范围的分片并不能预防数据不均匀分布的现象，而有可能会出现前面提到的数据热点现象。查看示例图，即使每个分片拥有相同数量的数据，特定产品比其他产品获得更多关注的可能性也会很大。相应的，各个的分片将接收不成比例的读取操作。 基于目录的分片要实现基于目录的分片，必须创建并维护一个查找表，该查找表使用分片键来跟踪哪个分片包含哪些数据。简而言之，查找表是一个表，其中包含有关可以找到特定数据的静态信息集。下图显示了基于目录的分片的简单示例： 此处，Delivery Zone列被定义为分片键。将来自分片键的数据，连同每一行应该写入的分片写入查找表。这与基于范围的分片类似，但不是确定分片键的数据落入哪个范围，而是将每个键绑定到其自己的特定分片。如果分片键的基数很低，并且分片键存储键的范围没有意义，那么基于目录的分片比基于范围的分片要更好。请注意，它也不同于基于密钥的分片，因为它不通过散列函数处理分片键; 它只是根据查找表检查键值，以查看数据需要写入的位置。 基于目录的分片的主要吸引力在于其灵活性。基于范围的分片架构只能指定键值范围，而基于键的分片架构只能使用固定的哈希函数，如前所述，在以后更改该函数非常困难。另一方面，基于目录的分片允许您使用任何系统或算法将数据项分配给分片，使用这种方法动态添加分片也相对容易。 虽然基于目录的分片是这里讨论的最灵活的分片方法，但是在每次查询或写入之前连接到查找表，可能会对应用程序的性能产生不利影响。此外，查找表可能出现单点故障：如果查询表损坏或出现其他故障，它可能会影响数据库写入新数据或访问现有数据的能力。 我应该分片吗？是否应该实现分片数据库架构，几乎总是一个争论的问题。有些人认为分片对于达到一定规模的数据库来说，是不可避免的结果。而另一些人则认为这是一个令人头疼的问题，除非绝对必要，否则应该避免，因为分片增加了操作的复杂性。 由于这种增加的复杂性，通常仅在处理非常大量的数据时才执行分片。以下是一些常见方案，可能对数据库分片的操作有所帮助： 应用程序数据量增长到超过单个数据库节点的存储容量。 对数据库的读写量，超过单个节点或其只读副本可以处理的量，从而导致响应时间增加或超时。 应用程序所需的网络带宽，超过单个数据库节点和任何只读副本可用的带宽，从而导致响应时间增加或超时。 在分片之前，您应该用尽所有其他选项来优化数据库。您可能需要考虑的一些优化包括： 设置远程数据库。如果您使用的是一个整体应用程序，其中所有组件都位于同一个服务器上，那么可以通过将数据库移到它自己的机器上来提高数据库的性能。由于数据库的表保持不变，因此这不会增加分片的复杂性。但是，它仍然允许您垂直伸缩数据库，使其与基础结构的其他部分分离。 实现缓存。如果您的应用程序的读取性能导致您遇到麻烦，那么缓存是一种可以帮助改进它的策略。缓存涉及临时存储已在内存中请求的数据，以便您以后更快地访问它。 创建一个或多个只读副本。另一种有助于提高读取性能的策略，包括将数据从一个数据库服务器（主服务器）复制到一个或多个从服务器。在此之后，每次新的写操作在复制到从服务器之前都要先到主服务器，而读操作只对从服务器进行。像这样分发读写可以防止任何一台机器承担过多的负载，从而有助于防止速度下降和崩溃。请注意，创建读副本需要更多的服务器资源，因此花费更多的钱，这对一些人来说可能是一个很大的限制。 升级到更大的服务器。在大多数情况下，将一个数据库服务器扩展到具有更多资源的计算机比分片需要更少的工作量。与创建只读副本一样，具有更多资源的服务器升级可能会花费更多的钱。因此，只有当它确实是您的最佳选择时，您才应该进行服务器扩容。 请记住，如果您的应用程序或网站增长超过某个点，这些策略本身都不足以提高性能。在这种情况下，分片可能确实是您的最佳选择。 结语对于那些希望横向扩展数据库的人来说，分片是一个很好的解决方案。但是，它还会增加很多复杂性，并为您的应用程序创建更多潜在的故障点。分片对于某些人来说可能是必要的，但是创建和维护分片架构所需的时间和资源可能会超过对其他人的好处。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2019%2F09%2F26%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么代理人和被代理人要有一个公共的接口？是为了减少客户端的修改，只是更换成代理类而不需要改方法的名字。怎么理解？ schoolGirl类和代理模式一点关系都没有。为什么？ 抽象类比接口的强制性高。怎么理解？ 它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。怎么理解？ 没有代理的代码 结构图 追求者类 1234567891011121314151617181920212223// 追求者class Pursuit&#123; SchoolGirl mm; public Pursuit(SchoolGirl mm) &#123; this.mm = mm; &#125; public void GiveDolls() &#123; Console.WriteLine(mm.Name + " 送你洋娃娃"); &#125; public void GiveFlowers() &#123; Console.WriteLine(mm.Name + " 送你鲜花"); &#125; public void GiveChocolate() &#123; Console.WriteLine(mm.Name + " 送你巧克力"); &#125;&#125; 被追求者类 12345678910//被追求者class SchoolGirl&#123; private string name; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125;&#125; 客户端调用代码如下 1234567891011121314151617class Program&#123; static void Main(string[] args) &#123; SchoolGirl jiaojiao = new SchoolGirl(); jiaojiao.Name = "李娇娇"; Pursuit zhuojiayi = new Pursuit(jiaojiao); zhuojiayi.GiveDolls(); zhuojiayi.GiveFlowers(); zhuojiayi.GiveChocolate(); Console.Read(); &#125;&#125; 娇娇并不认识卓贾易，这样写等于他们之间互相认识，并且是卓贾易亲自送东西给娇娇了，戴励就是代理。 只有代理的代码 结构图 客户端代码 1234567891011121314151617class Program&#123; static void Main(string[] args) &#123; SchoolGirl jiaojiao = new SchoolGirl(); jiaojiao.Name = "李娇娇"; Proxy daili = new Proxy(jiaojiao); daili.GiveDolls(); daili.GiveFlowers(); daili.GiveChocolate(); Console.Read(); &#125;&#125; 把‘Pursuit（追求者）’换成了‘Proxy（代理）’，这样写把‘Pursuit（追求者）’给忽略了，事实上应该是‘Pursuit（追求者）’通过‘Proxy（代理）’送给‘SchoolGirl（被追求者）’礼物，这才是合理的。‘Pursuit（追求者）’和‘Proxy（代理）’都有送礼物的三个方法，只不过‘Proxy（代理）’送的礼物是‘Pursuit（追求者）’买的，实质是‘Pursuit（追求者）’送的。他们都实现了同样的接口。 符合实际的代码 结构图 代理接口如下 1234567//送礼物interface GiveGift&#123; void GiveDolls(); void GiveFlowers(); void GiveChocolate();&#125; 追求者类如下 12345678910111213141516171819202122class Pursuit : GiveGift&#123; SchoolGirl mm; public Pursuit(SchoolGirl mm) &#123; this.mm = mm; &#125; public void GiveDolls() &#123; Console.WriteLine(mm.Name + " 送你洋娃娃"); &#125; public void GiveFlowers() &#123; Console.WriteLine(mm.Name + " 送你鲜花"); &#125; public void GiveChocolate() &#123; Console.WriteLine(mm.Name + " 送你巧克力"); &#125;&#125; 代理类如下 123456789101112131415161718192021222324class Proxy : GiveGift&#123; Pursuit gg; public Proxy(SchoolGirl mm) &#123; gg = new Pursuit(mm); &#125; public void GiveDolls() &#123; gg.GiveDolls(); &#125; public void GiveFlowers() &#123; gg.GiveFlowers(); &#125; public void GiveChocolate() &#123; gg.GiveChocolate(); &#125;&#125; 客户端如下 1234567891011121314151617class Program&#123; static void Main(string[] args) &#123; SchoolGirl jiaojiao = new SchoolGirl(); jiaojiao.Name = "李娇娇"; Proxy daili = new Proxy(jiaojiao); daili.GiveDolls(); daili.GiveFlowers(); daili.GiveChocolate(); Console.Read(); &#125;&#125; 代理模式12 代理模式（Proxy）结构图 Subject类，定义了RealSubject和Proxy的共用接口，这样就在任何使用RealSubject的地方都可以使用Proxy。 1234abstract class Subject&#123; public abstract void Request();&#125; RealSubject类，定义Proxy所代表的真实实体。 1234567class RealSubject : Subject&#123; public override void Request() &#123; Console.WriteLine("真实的请求"); &#125;&#125; Proxy类，保存一个引用使得代理可以访问实体，并提供一个与Subject的接口相同的接口，这样代理就可以用来替代实体。 12345678910111213class Proxy : Subject&#123; RealSubject realSubject; public override void Request() &#123; if (realSubject == null) &#123; realSubject = new RealSubject(); &#125; realSubject.Request(); &#125;&#125; 客户端代码 12345678910class Program&#123; static void Main(string[] args) &#123; Proxy proxy = new Proxy(); proxy.Request(); Console.Read(); &#125;&#125; 代理模式应用代理模式有以下几种使用场合： 第一，远程代理，也就是为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。 第二种应用是虚拟代理，是根据需要创建开销很大的对象。通过它来存放实例化需要很长时间的真实对象。这样就可以达到性能的最优化，比如说你打开一个很大的HTML网页时，里面可能有很多的文字和图片，但你还是可以很快打开它，此时你所看到的是所有的文字，但图片却是一张一张地下载后才能看到。那些未打开的图片框，就是通过虚拟代理来替代了真实的图片，此时代理存储了真实图片的路径和尺寸。浏览器是用代理模式来优化下载的。 第三种应用是安全代理，用来控制真实对象访问时的权限。一般用于对象应该有不同的访问权限的时候。第四种是智能指引，是指当调用真实的对象时，代理处理另外一些事。如计算真实对象的引用次数，这样当该对象没有引用时，可以自动释放它；或当第一次引用一个持久对象时，将它装入内存；或在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。它们都是通过代理在访问一个对象时附加一些内务处理。 代理模式其实就是在访问对象时引入一定程度的间接性，因为这种间接性，可以附加多种用途。说白了，代理就是真实对象的代表。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>大话设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[迭代器模式]]></title>
    <url>%2F2019%2F09%2F25%2F%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章导学 迭代器模式是一种使用频率非常高的设计模式，迭代器用于对一个聚合对象进行遍历。通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成，简化了聚合对象的设计，更符合单一职责原则的要求。 本章将学习迭代器模式的定义与结构，结合实例学习迭代器模式的实现和应用，并学习如何使用.NET Framework内置的迭代器。 本章知识点 迭代器模式的定义 迭代器模式的结构 迭代器模式的实现 迭代器模式的应用 迭代器模式的优缺点 迭代器模式的适用环境 使用内部类实现迭代器 .NET内置迭代器 迭代器模式概述在现实生活中，人们有两种方式来操作一台电视机实现开机、关机、换台、改变音量等功能，一种方式是直接通过电视机控制面板上的按键来实现，另一种方式是通过电视机遥控器来间接实现。遥控器为操作电视机带来很大的方便，用户并不需要知道电视频道到底怎样存储在电视机中。在此，可以将电视机看成一个存储电视频道的集合对象，通过遥控器可以对电视机中的电视频道集合进行操作，例如返回上一个频道、跳转到下一个频道或者跳转到指定的频道。电视机遥控器和电视机示意图如图1所示。 图1 电视机遥控器与电视机示意图 在软件开发中，也存在着大量类似电视机一样的类，它们可以存储多个成员对象（元素），这些类通常称为聚合类（Aggregate Classes），对应的对象称为聚合对象。为了更加方便地操作这些聚合对象，同时可以很灵活地为聚合对象增加不同的遍历方法，也需要类似电视机遥控器一样的角色，可以访问一个聚合对象中的元素但又不需要暴露它的内部结构。本章所要学习的迭代器模式将为聚合对象提供一个“遥控器”，通过引入迭代器，客户端无须了解聚合对象的内部结构即可实现对聚合对象中成员的遍历，还可以根据需要很方便地增加新的遍历方式。 在软件系统中，聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在迭代器对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合单一职责原则的要求。 迭代器模式的定义如下：1提供一种方法顺序访问一个聚合对象中的各个元素，且不用暴露该对象的内部表示。 迭代器模式又称为游标（Cursor）模式，它是一种对象行为型模式。 迭代器模式的结构与实现迭代器模式的结构在迭代器模式结构中包含聚合和迭代器两个层次结构，考虑到系统的灵活性和可扩展性，在迭代器模式中应用了工厂方法模式，其模式结构如图2所示。 图2 迭代器模式结构图 由图2可知，迭代器模式包含以下4个角色。 (1)Iterator（抽象迭代器）：它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法。例如，用于获取第一个元素的First()方法，用于访问下一个元素的Next()方法，用于判断是否还有下一个元素的HasNext()方法，用于获取当前元素的CurrentItem()方法等，在具体迭代器中将实现这些方法。 (2)ConcreteIterator（具体迭代器）：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。 (3)Aggregate（抽象聚合类）：它用于存储和管理元素对象，声明一个CreateIterator()方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。 (4)ConcreteAggregate（具体聚合类）：它是抽象聚合类的子类，实现了在抽象聚合类中声明的CreateIterator()方法，该方法返回一个与该具体聚合类对应的具体迭代器Concretelterator实例。 迭代器模式的实现在迭代器模式中，提供了一个外部的迭代器对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有。迭代器的引入，将使对一个复杂聚合对象的操作变得简单。 下面结合代码对迭代器模式的实现作进一步分析。在迭代器模式中应用了工厂方法模式，抽象迭代器对应于抽象产品角色，具体迭代器对应于具体产品角色，抽象聚合类对应于抽象工厂角色，具体聚合类对应于具体工厂角色。 在抽象迭代器中声明了用于遍历聚合对象中所存储元素的方法，其典型代码如下：1234567interface Iterator&#123; void First(); // 将游标指向第一个元素 void Next(); // 将游标指向下一个元素 bool HasNext(); // 判断是否存在下一个元素 object CurrentItem(); // 获取游标指向的当前元素&#125; 在具体迭代器中将实现抽象迭代器声明的遍历数据的方法，其典型代码如下：1234567891011121314151617181920212223242526272829303132class ConcreteIterator : Iterator &#123; private ConcreteAggregate objects; // 维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据 private int cursor; // 定义一个游标，用于记录当前访问位置 public ConcreteIterator(ConcreteAggregate objects) &#123; this.objects = objects; &#125; public void First() &#123; // 实现代码 &#125; public void Next() &#123; // 实现代码 &#125; public bool HasNext() &#123; // 实现代码 return false; &#125; public object CurrentItem() &#123; // 实现代码 return null; &#125;&#125; 需要注意的是，抽象迭代器接口的设计非常重要，一方面需要充分满足各种遍历操作的要求，尽量为各种遍历方法提供声明；另一方面又不能包含太多方法，如果接口中的方法太多将给子类的实现带来麻烦。因此，可以考虑使用抽象类来设计抽象迭代器，在抽象类中为每一个方法提供一个空的默认实现。如果需要在具体迭代器中为聚合对象增加全新的遍历操作，则必须修改抽象迭代器和具体迭代器的源代码，这将违反开闭原则，因此在设计时要考虑全面，避免之后修改接口。 聚合类用于存储数据并负责创建迭代器对象，最简单的抽象聚合类代码如下：1234interface Aggregate&#123; Iterator CreateIterator();&#125; 具体聚合类作为抽象聚合类的子类，一方面负责存储数据，另一方面实现了在抽象聚合类中声明的工厂方法CreateIterator()，用于返回一个与该具体聚合类对应的具体迭代器对象。其典型代码如下：123456789class ConcreteAggregate : Aggregate &#123; //...... public Iterator CreateIterator() &#123; return new ConcreteIterator(this); &#125; //......&#125; 迭代器模式的应用实例下面通过一个应用实例来进一步学习和理解迭代器模式。 1.实例说明 某软件公司为某商场开发了一套销售管理系统，在对该系统进行分析和设计时，开发人员发现经常需要对系统中的商品数据、客户数据等进行遍历，为了复用这些遍历代码，开发人员设计了一个抽象的数据集合类AbstractObjectList，将存储商品和客户等数据的类作为其子类，AbstractObjectList类结构如图3所示。 图3 AbstractObjectList类结构图 在图3中，List类型的对象objects用于存储数据，其方法与说明如表1所示。 表1 AbstractObjectList类的方法与说明 方法名 方法说明 AbstractObjectList() 构造方法，用于给objects对象赋值 AddObject() 增加元素 RemoveObject() 删除元素 GetObjects() 获取所有元素 Next() 移至下一个元素 IsLast() 判断当前元素是否是最后一个元素 Previous() 移至上一个元素 IsFirst() 判断当前元素是否是第一个元素 GetNextItem() 获取下一个元素 GetPreviousItem() 获取上一个元素 AbstractObjectList类的子类ProductList和CustomerList分别用于存储商品数据和客户数据。通过分析，发现AbstractObjectList类的职责非常重，它既负责存储和管理数据，又负责遍历数据，违背了单一职责原则，实现代码将非常复杂。因此，开发人员决定使用迭代器模式对AbstractObjectList类进行重构，将负责遍历数据的方法提取出来，封装到专门的类中，实现数据存储和数据遍历分离，还可以给不同的具体数据集合类提供不同的遍历方式。现给出使用迭代器模式重构后的解决方案。 2.实例类图 通过分析，本实例的结构如图4所示。 图4 销售管理系统数据遍历结构图 为了简化类图和代码，图4只提供了一个具体聚合类和一个具体迭代器类，AbstractObjectList充当抽象聚合类，ProductList充当具体聚合类，Abstractlterator充当抽象迭代器，Productlterator充当具体迭代器。 3.实例代码 (1)AbstractObjectList：抽象聚合类。 1234567891011121314151617181920212223242526272829303132using System.Collections.Generic;namespace IteratorSample&#123; abstract class AbstractObjectList &#123; protected List&lt;object&gt; objects = new List&lt;object&gt;(); public AbstractObjectList(List&lt;object&gt; objects) &#123; this.objects = objects; &#125; public void AddObject(object obj) &#123; this.objects.Add(obj); &#125; public void RemoveObject(object obj) &#123; this.objects.Remove(obj); &#125; public List&lt;object&gt; GetObjects() &#123; return this.objects; &#125; // 声明创建迭代器对象的抽象工厂方法 public abstract AbstractIterator CreateIterator(); &#125;&#125; (2)ProductList：商品数据类，充当具体聚合类。 1234567891011121314151617using System.Collections.Generic;namespace IteratorSample&#123; class ProductList : AbstractObjectList &#123; public ProductList(List&lt;object&gt; products) : base(products) &#123; &#125; // 实现创建迭代器对象的具体工厂方法 public override AbstractIterator CreateIterator() &#123; return new ProductIterator(this); &#125; &#125;&#125; (3)AbstractIterator：抽象迭代器。 123456789101112namespace IteratorSample&#123; interface AbstractIterator &#123; void Next(); // 移至下一个元素 bool IsLast(); // 判断是否为最后一个元素 void Previous(); // 移至上一个元素 bool IsFirst(); // 判断是否为第一个元素 object GetNextItem(); // 获取下一个元素 object GetPreviousItem(); // 获取上一个元素 &#125;&#125; (4)ProductIterator：商品迭代器，充当具体迭代器。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556using System.Collections.Generic;namespace IteratorSample&#123; class ProductIterator : AbstractIterator &#123; private ProductList productList; private List&lt;object&gt; products; private int cursor1; // 定义一个游标，用于记录正向遍历的位置 private int cursor2; // 定义一个游标，用于记录逆向遍历的位置 public ProductIterator(ProductList list) &#123; this.productList = list; this.products = list.GetObjects(); // 获取集合对象 cursor1 = 0; // 设置正向遍历游标的初始值 cursor2 = products.Count - 1; // 设置逆向遍历游标的初始值 &#125; public void Next() &#123; if (cursor1 &lt; products.Count) &#123; cursor1++; &#125; &#125; public bool IsLast() &#123; return (cursor1 == products.Count); &#125; public void Previous() &#123; if (cursor2 &gt; -1) &#123; cursor2--; &#125; &#125; public bool IsFirst() &#123; return (cursor2 == -1); &#125; public object GetNextItem() &#123; return products[cursor1]; &#125; public object GetPreviousItem() &#123; return products[cursor2]; &#125; &#125;&#125; (5)Program：客户端测试类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections;using System.Collections.Generic;namespace IteratorSample&#123; class Program &#123; static void Main(string[] args) &#123; List&lt;object&gt; products = new List&lt;object&gt;(); products.Add("倚天剑"); products.Add("屠龙刀"); products.Add("断肠草"); products.Add("葵花宝典"); products.Add("四十二章经"); AbstractObjectList list; AbstractIterator iterator; list = new ProductList(products); // 创建聚合对象 iterator = list.CreateIterator(); // 创建迭代器对象 Console.WriteLine("正向遍历："); while(!iterator.IsLast()) &#123; Console.Write(iterator.GetNextItem() + "，"); iterator.Next(); &#125; Console.WriteLine(); Console.WriteLine("-----------------------------"); Console.WriteLine("逆向遍历："); while(!iterator.IsFirst()) &#123; Console.Write(iterator.GetPreviousItem() + "，"); iterator.Previous(); &#125; Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12345正向遍历： 倚天剑，屠龙刀，断肠草，葵花宝典，四十二章经，-----------------------------逆向遍历： 四十二章经，葵花宝典，断肠草，屠龙刀，倚天剑， 如果需要增加一个新的具体聚合类，例如客户数据集合类，并且需要为客户数据集合类提供不同于商品数据集合类的正向遍历和逆向遍历操作，只需增加一个新的聚合子类和一个新的具体迭代器类即可，原有类库代码无须修改，符合开闭原则；如果需要为ProductList类更换一个迭代器，只需增加一个新的具体迭代器类作为抽象迭代器类的子类，重新实现遍历方法即可，原有迭代器代码无须修改，也符合开闭原则；如果要在迭代器中增加新的方法，则需要修改抽象迭代器的源代码，这将违背开闭原则。 使用内部类实现迭代器在图2所示的迭代器模式结构图中，可以看到具体迭代器类和具体聚合类之间存在着双重关系，其中一个关系为关联关系，在具体迭代器中需要维持一个对具体聚合对象的引用，该关联关系的目的是访问存储在聚合对象中的数据，以便迭代器能够对这些数据进行遍历操作。 除了使用关联关系外，为了能够让迭代器可以访问到聚合对象中的数据，还可以将迭代器类设计为聚合类的内部类。例如可以对19.3节中的ProductList类进行修改，将Productlterator类作为ProductList类的内部类，代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465using System.Collections.Generic;namespace IteratorSample&#123; class ProductListNew : AbstractObjectList &#123; public ProductListNew(List&lt;object&gt; products) : base(products) &#123; &#125; public override AbstractIterator CreateIterator() &#123; return new ProductIterator(); &#125; // 商品迭代器：具体迭代器，内部类实现 private class ProductIterator : AbstractIterator &#123; private int cursor1; private int cursor2; public ProductIterator() &#123; cursor1 = 0; cursor2 = objects.Count - 1; &#125; public void Next() &#123; if(cursor1 &lt; objects.Count) &#123; cursor1++; &#125; &#125; public bool IsLast() &#123; return (cursor1 == objects.Count); &#125; public void Previous() &#123; if(cursor2 &gt; -1) &#123; cursor2--; &#125; &#125; public bool IsFirst() &#123; return (cursor2 == -1); &#125; public object GetNextItem() &#123; return objects[cursor1]; &#125; public object GetPreviousItem() &#123; return objects[cursor2]; &#125; &#125; &#125;&#125; 需要注意的是，根据C#语言的语法规定，内部类只能访问到外部类中定义的静态（static）成员变量，因此需要将AbstractObjectList中的objects声明为静态变量，代码如下：123...protected static List&lt;object&gt; objects = new List&lt;object&gt;();... 同时还需要将引用该变量的方法中的this关键字去掉。 无论使用哪种实现机制，客户端代码都是一样的，也就是说客户端无须关心具体迭代器对象的创建细节，只需通过调用工厂方法Createlterator()即可得到一个可用的迭代器对象，这也是使用工厂方法模式的好处，通过工厂来封装对象的创建过程，简化了客户端的调用。 .NET内置迭代器在.NET Framework中内置了对迭代器模式的支持，提供了抽象的迭代器接口System.Collections.IEnumerator和枚举接口System.Collections.IEnumerable，C#语言中的foreach循环就是利用IEnumerable提供的IEnumerator来实现的。 在.Net中，IEnumerable接口的定义如下：1234public interface IEnumerable&#123; IEnumerator GetEnumerator(); // 工厂方法，获取迭代器对象&#125; IEnumerator接口的定义如下：123456789public interface IEnumerator&#123; object Current&#123; // 返回当前集合中的元素 get; &#125; bool MoveNext(); // 遍历集合，移至下一个元素 void Reset(); // 恢复初始位置&#125; 通过扩展IEnumerable接口和IEnumerator接口可以定义自己的聚合类和迭代器类，实现了IEnumerable的子类都可以对应定义一个迭代器，用于对其中的元素进行遍历。在NET中，ICollection继承自IEnumerable，IList继承自ICollection，而ArrayList是IList的子类，实现了GetEnumerator()方法，并返回一个ArrayListEnumeratorSimple类型的对象。 ArrayList类的代码片段如下：123456789public class ArrayList : IList, ICloneable&#123; ... public virtual IEnumerator GetEnumerator() &#123; return new ArrayListEnumeratorSimple(this); &#125; ...&#125; ArrayList中，GetEnumerator()方法是一个虚方法，表示可以自定义一个集合类型继承ArrayList，然后重写这个方法，创建不同的IEnumerator对象，从而实现不同的遍历方式。 在.NET中，ArrayListEnumeratorSimple类的代码片段如下：1234567891011121314151617181920212223[Serializable]private class ArrayListEnumeratorSimple : IEnumerator, ICloneable&#123; // Methods internal ArrayListEnumeratorSimple(ArrayList list) &#123; this.list = list; this.index = -1; this.version = list._version; this.currentElement = list; &#125; public object Clone()&#123;&#125;; public virtual bool MoveNext()&#123;&#125;; public virtual void Reset()&#123;&#125;; public virtual bool Current()&#123;&#125;; // Fields private object currentElement; private int index; private ArrayList list; private int version;&#125; ArrayListEnumeratorSimple实现了IEnumerator接口，且实现了MoveNext()、Reset()、Current等方法和属性，该类是一个私有类，其构造函数被internal修饰符限制，在构造函数中，传入的参数类型是ArrayList，MoveNext()、Current、Reset()等操作通过构造函数所传递的ArrayList对象实现。 在此，IEnumerable是抽象聚合类，IEnumerator是抽象迭代器，ArrayList是具体聚合类，ArrayListEnumeratorSimple是具体迭代器。 在实际的C#应用开发中通常很少自定义迭代器，一般使用.NET Framework内置的迭代器即可，下面的代码演示了如何使用.NET Framework内置迭代器。12345678910111213141516171819202122232425262728293031323334using System;using System.Collections;using System.Collections.Generic;namespace IteratorSample&#123; class Program &#123; static void Process(IEnumerable e) &#123; IEnumerator i = e.GetEnumerator(); // 创建迭代器对象 while (i.MoveNext()) &#123; Console.WriteLine(i.Current.ToString()); &#125; &#125; static void Main(string[] args) &#123; IList persons; persons = new ArrayList(); // 创建一个ArrayList类型的聚合对象 persons.Add("张无忌"); persons.Add("小龙女"); persons.Add("令狐冲"); persons.Add("韦小宝"); persons.Add("袁紫衣"); persons.Add("小龙女"); Process(persons); Console.Read(); &#125; &#125;&#125; 如上加粗代码所示，在静态方法Process()中使用迭代器1Enumerator对IEnumerable对象进行处理。该代码的运行结果如下：123456张无忌 小龙女 令狐冲 韦小宝 袁紫衣 小龙女 迭代器模式的优缺点与适用环境迭代器模式是一种使用频率非常高的设计模式，通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。由于很多编程语言的类库都已经实现了迭代器模式，因此在实际开发中，直接使用C#、Java等语言已经定义好的迭代器即可，迭代器已经成为操作聚合对象的基本工具之一。 迭代器模式的优点迭代器模式是一种使用频率非常高的设计模式，通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。由于很多编程语言的类库都已经实现了迭代器模式，因此在实际开发中，直接使用C#，Java等语言已经定义好的迭代器即可，迭代器已经成为操作聚合对象的基本工具之一。 迭代器模式的优点迭代器模式的主要优点如下： (1)迭代器模式支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中，只需用一个不同的迭代器来替换原有迭代器即可改变遍历算法，也可以自己定义迭代器的子类以支持新的遍历方式。 (2)迭代器模式简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。 (3)在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，符合开闭原则。 迭代器模式的缺点迭代器模式的主要缺点如下： (1)由于迭代器模式将存储数据和遍历数据的职责分离，在增加新的聚合类时需要对应地增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。 (2)抽象迭代器的设计难度较大，需要充分考虑系统将来的扩展。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是一件很容易的事情。 迭代器模式的适用环境在以下情况下可以考虑使用迭代器模式： (1)访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。 (2)需要为一个聚合对象提供多种遍历方式。 (3)为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。 本章小结(1)迭代器模式提供了一种方法顺序访问一个聚合对象中的各个元素，且不用暴露该对象的内部表示。迭代器模式是一种对象行为型模式。 (2)迭代器模式包含抽象迭代器、具体迭代器、抽象聚合类和具体聚合类4个角色。其中，抽象迭代器定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法；具体迭代器实现了抽象迭代器接口，完成对聚合对象的遍历；抽象聚合类用于存储和管理元素对象；具体聚合类是抽象聚合类的子类，实现了在抽象聚合类中声明的方法。 (3)迭代器模式的主要优点包括支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式；简化了聚合类；增加新的聚合类和迭代器类都很方便，无须修改原有代码，符合开闭原则。其主要缺点是在增加新的聚合类时需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性；抽象迭代器的设计难度较大，需要充分考虑系统将来的扩展。 (4)迭代器模式适用的环境:访问一个聚合对象的内容而无须暴露它的内部表示；需要为一个聚合对象提供多种遍历方式；为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。 (5)除了使用关联关系外，为了能够让迭代器可以访问到聚合对象中的数据，还可以将迭代器类设计为聚合类的内部类。 (6)在.NET Framework中内置了对迭代器模式的支持，提供了抽象的迭代器接口IEnumerator和枚举接口IEnumerable，通过使用.NET Framework内置的迭代器可以很方便地实现对常用集合对象的遍历操作。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解释器模式]]></title>
    <url>%2F2019%2F09%2F25%2F%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章导学 解释器模式用于描述如何构成一个简单的语言解释器，主要应用于使用面向对象语言开发的解释器的设计。当需要开发一个新的语言时，开发人员可以考虑使用解释器模式。在实际应用中，用户也许很少碰到去构造一个语言的情况，虽然很少使用，但是对它进行学习能够加深对面向对象思想的理解，并且掌握编程语言中语法规则解释的原理和过程。 本章将学习解释器模式的定义和结构，并结合实例学习如何使用解释器模式构造一个新的语言，以及如何通过终结符表达式和非终结符表达式在类中封装语言的文法规则。 本章知识点 解释器模式的定义 解释器模式的结构 解释器模式的实现 解释器模式的应用 文法规则和抽象语法树 解释器模式的优缺点 解释器模式的适用环境 解释器模式概述虽然目前计算机编程语言有几百种，但有时人们还是希望能用一些简单的语言来实现一些特定的操作，用户只要向计算机输入一个句子或文件，它就能够按照预先定义的文法规则对句子或文件进行解释，从而实现相应的功能。例如提供一个简单的加法/减法解释器，只要输入一个加法/减法表达式，它就能够计算出表达式结果，如图1所示，当输入字符串表达式为“1+2+3-4+1”时，将输出计算结果“3”。 图1 加法/减法解释器示意图 众所周知，像C#、C+和Java等语言无法直接解释类似“1+2+3-4+1”这样的字符串（如果直接作为数学表达式则可以解释），必须定义一套文法规则来实现对这些语句的解释，即设计一个自定义语言。在实际开发中，这些简单的自定义语言可以基于现有的编程语言来设计，如果所基于的编程语言是面向对象语言，则可以使用解释器模式来实现自定义语言。 解释器模式是一种使用频率相对较低但学习难度相对较大的设计模式，用于描述如何使用面向对象语言构成一个简单的语言解释器。在某些情况下，为了更好地描述某一些特定类型的问题，可以创建一种新的语言，这种语言拥有自己的表达式和结构，即文法规则，这些问题的实例将对应该语言中的句子。此时，用户可以使用解释器模式来设计这种新的语言。另外，对解释器模式进行学习能够加深用户对面向对象思想的理解，并且理解编程语言中文法规则的解释过程。 解释器模式的定义如下:1给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 在解释器模式的定义中所指的“语言”是使用规定格式和语法的代码，解释器模式是一种类行为型模式。 文法规则和抽象语法树解释器模式描述了如何为简单的语言定义一个文法，如何在该语言中表示一个句子，以及如何解释这些句子。在正式分析解释器模式结构之前，先来学习如何表示一个语言的文法规则以及如何构造一棵抽象语法树。 在前面所提到的加法/减法解释器中，每一个输入表达式，例如“1+2+3-4+1”，都包含了3个语言单位，可以使用以下文法规则来定义：123expression ::= value | operationoperation ::= expression &apos;+&apos; expression | expression &apos;-&apos; expressionvalue ::= an integer //一个整数值 该文法规则包含3条语句，第一条表示表达式的组成方式，其中，value和operation是后面两个语言单位的定义，每一条语句所定义的字符串（如operation和value）称为语言构造成分或语言单位，符号“::=”是“定义为”的意思，其左边的语言单位通过右边进行说明和定义，语言单位对应终结符表达式和非终结符表达式。例如本规则中的operation是非终结符表达式，它的组成元素仍然可以是表达式，还可以进一步分解，而value是终结符表达式，它的组成元素是最基本的语言单位，不能再进行分解。 在文法规则定义中可以使用一些符号表示不同的含义，例如使用“|”表示“或”，使用“{”和“}”表示“组合”，使用“*”表示出现“0次或多次”等。其中，使用频率最高的符号是表示“或”关系的“|”，例如文法规则“boolValue::=0|1”表示终结符表达式boolValue的取值可以为0或者1。 除了使用文法规则来定义一个语言外，在解释器模式中还可以通过一种被称为抽象语法树（Abstract Syntax Tree，AST）的图形方式来直观地表示语言的构成，每一棵抽象语法树对应一个语言实例，例如加法/减法解释器中的表达式“1+2+3-4+1”可以通过如图2所示的抽象语法树来表示。 图2 抽象语法树示意图 在该抽象语法树中，可以通过终结符表达式value和非终结符表达式operation组成复杂的语句，每个文法规则的语言实例都可以表示为一棵抽象语法树，即每一条具体的语句都可以用类似图2所示的抽象语法树来表示。在该图中，终结符表达式类的实例作为树的叶子结点，而非终结符表达式类的实例作为非叶子结点，它们可以将终结符表达式类的实例以及包含终结符和非终结符实例的子表达式作为其子结点。抽象语法树描述了如何构成一个复杂的句子，通过对抽象语法树的分析，可以识别出语言中的终结符类和非终结符类。 解释器模式的结构与实现解释器模式的结构由于表达式可以分为终结符表达式和非终结符表达式，所以解释器模式的结构与组合模式的结构有些类似，但在解释器模式中包含更多的组成元素，它的结构如图3所示。 图3 解释器模式结构图 由图3可知，解释器模式包含以下4个角色。 (1)AbstractExpression（抽象表达式）：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。 (2)TerminalExpression（终结符表达式）：终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常，在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。 (3)NonterminalExpression（非终结符表达式）：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。 (4)Context（环境类）：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常临时存储了需要解释的语句。 解释器模式的实现在解释器模式中，每一种终结符和非终结符都有一个具体类与之对应，正因为使用类来表示每一条文法规则，所以系统具有较好的灵活性和可扩展性。 对于所有的终结符和非终结符，首先需要抽象出一个公共父类，即抽象表达式类。其典型代码如下：1234abstract class AbstractExpression&#123; public abstract void Interpret(Context ctx);&#125; 终结符表达式类和非终结符表达式类都是抽象表达式类的子类，对于终结符表达式类，其代码很简单，主要是对终结符元素进行处理。其典型代码如下：1234567class TerminalExpression : AbstractExpression &#123; public override void Interpret(Context ctx) &#123; //终结符表达式的解释操作 &#125;&#125; 对于非终结符表达式，其代码相对比较复杂，因为可以通过非终结符将表达式组合成更加复杂的结构，对于包含两个操作元素的非终结符表达式类，其典型代码如下：1234567891011121314151617class NonterminalExpression : AbstractExpression &#123; private AbstractExpression left; private AbstractExpression right; public NonterminalExpression(AbstractExpression left,AbstractExpression right) &#123; this.left=left; this.right=right; &#125; public override void Interpret(Context ctx) &#123; //递归调用每一个组成部分的interpret()方法 //在递归调用时指定组成部分的连接方式，即非终结符的功能 &#125; &#125; 除了用于表示表达式的类以外，通常在解释器模式中还提供了一个环境类Context，用于存储一些全局信息，在环境类中一般包含了一个Hashtable或List等类型的集合对象（也可以直接由Hashtable等集合类充当环境类），存储一系列公共信息，例如变量名与值的映射关系（key/value等），用于在执行具体的解释操作时从中获取相关信息。其典型代码片段如下：12345678910111213141516class Context&#123; private Hashtable ht = new Hashtable(); //往环境类中设值 public void Assign(string key, string value) &#123; ht.Add(key,value); &#125; //获取存储在环境类中的值 public string Lookup(string key) &#123; return (string)ht[key]; &#125;&#125; 环境类Context的对象通常作为参数被传递到所有表达式的解释方法Interpret()中，可以在环境类对象中存储和访问表达式解释器的状态，向表达式解释器提供一些全局的、公共的数据，此外，还可以在环境类中增加一些所有表达式解释器都共有的功能，以减轻解释器的职责。当系统无须提供全局公共信息时可以省略环境类，根据实际情况决定是否需要环境类。 解释器模式的应用实例下面通过一个应用实例来进一步学习和理解解释器模式。 1.实例说明 某软件公司要开发一套机器人控制程序，在该机器人控制程序中包含一些简单的英文控制指令，每一个指令对应一个表达式（expression），该表达式可以是简单表达式也可以是复合表达式。每一个简单表达式由移动方向（direction）、移动方式（action）和移动距离（distance）三部分组成，其中，移动方向包括向上（up）、向下（down）、向左（left）、向右（right）；移动方式包括移动（move）和快速移动（run）；移动距离为一个正整数。两个表达式之间可以通过与（and）连接，形成复合（composite）表达式。用户通过对图形化的设置界面进行操作可以创建一个机器人控制指令，机器人在收到指令后将按照指令的设置进行移动，例如输入控制指令“up move 5”将“向上移动5个单位”；输入控制指令“down run 10 and left move 20”将“向下快速移动10个单位再向左移动20个单位”。现使用解释器模式来设计该程序并模拟实现。 2.实例类图 根据上述需求描述，用形式化语言来表示该简单语言的文法规则如下：12345expression ::= direction action distance | composite //表达式composite ::= expression &apos;and&apos; expression //复合表达式direction ::= &apos;up&apos; | &apos;down&apos; | &apos;left&apos; | &apos;right&apos; //移动方向action ::= &apos;move&apos; | &apos;run&apos; //移动方式distance ::= an integer //移动距离 该语言一共定义了5条文法规则，对应5个语言单位，这些语言单位可以分为两类，一类为终结符（也称为终结符表达式），例如direction，action和distance，它们是语言的最小组成单位，不能再进行拆分；另一类为非终结符（也称为非终结符表达式），例如expression和composite，它们都是一个完整的句子，包含一系列终结符或非终结符。 针对5条文法规则，分别提供5个类来实现，其中，终结符表达式direction，action和diatance对应DirectionNode类、ActionNode类和DistanceNode类，非终结符表达式expression和composite对应SentenceNode类和AndNode类。 可以通过抽象语法树来表示具有解释过程，例如机器人控制指令“down run 10 and left move 20”对应的抽象语法树如图4所示。 图4 机器人控制程序抽象语法树实例 机器人控制程序实例的基本结构如图5所示。 图5 机器人控制程序结构图 在图5中，AbstractNode充当抽象表达式角色，DirectionNode、ActionNode和DistanceNode充当终结符表达式角色，AndNode和SentenceNode充当非终结符表达式角色。 3.实例代码 (1)AbstractNode：抽象节点类，充当抽象表达式角色。 1234567namespace InterpreterSample&#123; abstract class AbstractNode &#123; public abstract string Interpret(); &#125;&#125; (2)AndNode：And节点类，充当非终结符表达式角色。 1234567891011121314151617181920namespace InterpreterSample&#123; class AndNode : AbstractNode &#123; private AbstractNode left; //And的左表达式 private AbstractNode right; //And的右表达式 public AndNode(AbstractNode left, AbstractNode right) &#123; this.left = left; this.right = right; &#125; //And表达式解释操作 public override string Interpret() &#123; return left.Interpret() + "再" + right.Interpret(); &#125; &#125;&#125; (3)SentenceNode：简单句子节点类，充当非终结符表达式角色。 12345678910111213141516171819202122namespace InterpreterSample&#123; class SentenceNode : AbstractNode &#123; private AbstractNode direction; private AbstractNode action; private AbstractNode distance; public SentenceNode(AbstractNode direction,AbstractNode action,AbstractNode distance) &#123; this.direction = direction; this.action = action; this.distance = distance; &#125; //简单句子的解释操作 public override string Interpret() &#123; return direction.Interpret() + action.Interpret() + distance.Interpret(); &#125; &#125;&#125; (4)DirectionNode：方向节点类，充当终结符表达式角色。 12345678910111213141516171819202122232425262728293031323334353637namespace InterpreterSample&#123; class DirectionNode : AbstractNode &#123; private string direction; public DirectionNode(string direction) &#123; this.direction = direction; &#125; //方向表达式的解释操作 public override string Interpret() &#123; if (direction.Equals("up")) &#123; return "向上"; &#125; else if (direction.Equals("down")) &#123; return "向下"; &#125; else if (direction.Equals("left")) &#123; return "向左"; &#125; else if (direction.Equals("right")) &#123; return "向右"; &#125; else &#123; return "无效指令"; &#125; &#125; &#125;&#125; (5)ActionNode：动作节点类，充当终结符表达式角色。 1234567891011121314151617181920212223242526272829namespace InterpreterSample&#123; class ActionNode : AbstractNode &#123; private string action; public ActionNode(string action) &#123; this.action = action; &#125; //动作（移动方式）表达式的解释操作 public override string Interpret() &#123; if (action.Equals("move")) &#123; return "移动"; &#125; else if (action.Equals("run")) &#123; return "快速移动"; &#125; else &#123; return "无效指令"; &#125; &#125; &#125;&#125; (6)DistanceNode：距离节点类，充当终结符表达式角色。 123456789101112131415161718namespace InterpreterSample&#123; class DistanceNode : AbstractNode &#123; private string distance; public DistanceNode(string distance) &#123; this.distance = distance; &#125; //距离表达式的解释操作 public override string Interpret() &#123; return this.distance; &#125; &#125;&#125; (7)InstructionHandler：指令处理类，工具类，提供相应的方法对输入指令进行处理。它将输入指令分隔为字符串数组，将第1个、第2个和第3个单词组合成一个句子，并存入栈中；如果发现有单词“and”，则将“and”后的第1个、第2个和第3个单词组合成一个新的句子作为“and”的右表达式，并从栈中取出原先所存句子作为左表达式，然后组合成一个And结点存入栈中。依此类推，直到整个指令解析结束。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;using System.Collections;namespace InterpreterSample&#123; class InstructionHandler &#123; private AbstractNode node; public void Handle(string instruction) &#123; AbstractNode left = null, right = null; AbstractNode direction = null, action = null, distance = null; Stack stack = new Stack(); //声明一个栈对象用于存储抽象语法树 string[] words = instruction.Split(' '); //以空格分隔指令字符串 for (int i = 0; i &lt; words.Length; i++) &#123; //本实例采用栈的方式来处理指令，如果遇到“and”，则将其后的三个单词作为三个终结符表达式连成一个简单句子SentenceNode作为“and”的右表达式，而将从栈顶弹出的表达式作为“and”的左表达式，最后将新的“and”表达式压入栈中。 if (words[i].Equals("and")) &#123; left = (AbstractNode)stack.Pop(); //弹出栈顶表达式作为左表达式 string word1= words[++i]; direction = new DirectionNode(word1); string word2 = words[++i]; action = new ActionNode(word2); string word3 = words[++i]; distance = new DistanceNode(word3); right = new SentenceNode(direction,action,distance); //右表达式 stack.Push(new AndNode(left,right)); //将新表达式压入栈中 &#125; //如果是从头开始进行解释，则将前三个单词组成一个简单句子SentenceNode并将该句子压入栈中 else &#123; string word1 = words[i]; direction = new DirectionNode(word1); string word2 = words[++i]; action = new ActionNode(word2); string word3 = words[++i]; distance = new DistanceNode(word3); left = new SentenceNode(direction,action,distance); stack.Push(left); //将新表达式压入栈中 &#125; &#125; this.node = (AbstractNode)stack.Pop(); //将全部表达式从栈中弹出 &#125; public string Output() &#123; string result = node.Interpret(); //解释表达式 return result; &#125; &#125;&#125; (8)Program：客户端测试类。 1234567891011121314151617181920using System;namespace InterpreterSample&#123; class Program &#123; static void Main(string[] args) &#123; //string instruction = "down run 10 and left move 20"; string instruction = "up move 5 and down run 10 and left move 5"; InstructionHandler handler = new InstructionHandler(); handler.Handle(instruction); string outString; outString = handler.Output(); Console.WriteLine(outString); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下:1向下快速移动10再向左移动20 如果将输入指令改为“up move 5 and down run 10 and left move 5”，则输出结果如下：1向上移动5再向下快速移动10再向左移动5 本实例对机器人控制指令的输出结果进行模拟，将英文指令翻译为中文指令，在真实情况下，系统将调用不同的控制程序对机器人进行控制，包括对移动方向、方式和距离的控制等。 解释器模式的优缺点与适用环境解释器模式为自定义语言的设计和实现提供了一种解决方案，用于定义一组文法规则并通过这组文法规则来解释语言中的句子。虽然解释器模式的使用频率不是特别高，但是它在正则表达式、XML文档解释等领域还是得到了广泛使用。 解释器模式的优点解释器模式的主要优点如下： (1)解释器模式易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。 (2)在解释器模式中，每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。 (3)实现文法较为容易。在抽象语法树中每一个表达式结点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成结点类代码。 (4)增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合开闭原则。 解释器模式的缺点解释器模式的主要缺点如下： (1)解释器模式对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多的文法规则，类的个数将会急剧增加，从而导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。 (2)其执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。 解释器模式的适用环境在以下情况下可以考虑使用解释器模式： (1)可以将一个需要解释执行的语言中的句子表示为一棵抽象语法树。 (2)一些重复出现的问题可以用一种简单的语言进行表达。 (3)一个语言的文法较为简单。对于复杂的文法，解释器模式中的文法类层次结构将变得很庞大而无法管理，此时最好使用语法分析程序生成器。 (4)执行效率不是关键问题。高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。 本章小结(1)解释器模式的目的是：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。解释器模式是一种类行为型模式。 (2)解释器模式包含抽象表达式、终结符表达式、非终结符表达式和环境类4个角色。其中，抽象表达式声明了抽象的解释操作，是所有终结符表达式和非终结符表达式的公共父类；终结符表达式是抽象表达式的子类，实现了与文法中的终结符相关联的解释操作；非终结符表达式也是抽象表达式的子类，实现了文法中非终结符的解释操作；环境类用于存储解释器之外的一些全局信息。 (3)解释器模式的主要优点包括易于改变和扩展文法，可以方便地实现一个简单的语言，实现文法较为容易，且增加新的解释表达式较为方便。其主要缺点是对于复杂文法难以维护，并且其执行效率较低。 (4)解释器模式适用的环境：可以将一个需要解释执行的语言中的句子表示为一棵抽象语法树；一些重复出现的问题可以用一种简单的语言进行表达；一个语言的文法较为简单；执行效率不是关键问题。 (5)用户可以使用文法规则来定义一个语言，还可以通过抽象语法树以图形方式直观地表示一个语言的构成，每一棵抽象语法树对应一个语言实例。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[访问者模式]]></title>
    <url>%2F2019%2F09%2F25%2F%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章导学 访问者模式是一种较为复杂的行为型设计模式，它包含访问者和被访问元素两个主要组成部分，这些被访问元素具有不同的类型，且不同的访问者可以对其施加不同的访问操作。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。 本章将学习访问者模式的定义与结构，理解访问者模式中对象结构的作用以及学会如何编程实现访问者模式，并掌握元素类和访问者类的设计原理及实现过程。 本章知识点 访问者模式的定义 访问者模式的结构 访问者模式的实现 访问者模式的应用 访问者模式的优缺点 访问者模式的适用环境 访问者模式与组合模式联用 访问者模式概述在医生开具处方单（药单）后，很多医院都存在着这样的处理流程：划价人员拿到处方单之后根据药品名称和数量计算总价，药房工作人员根据药品名称和数量准备药品，如图1所示。 图1 医院处方单处理示意图 在图1中，可以将处方单看成一个药品信息的集合，其中包含了一种或多种不同类型的药品信息，不同类型的工作人员（例如划价人员和药房工作人员）在操作同一个药品信息集合时将提供不同的处理方式，而且可能会增加新类型的工作人员来操作处方单。 在软件开发中，有时也需要处理像处方单这样的集合对象结构，在该对象结构中存储了多种不同类型的对象信息，而且对同一对象结构中的元素的操作方式并不唯一，可能需要提供多种不同的处理方式，还有可能增加新的处理方式。在设计模式中，有一种模式可以满足上述要求，它以不同的方式操作复杂对象结构，该模式就是访问者模式。 访问者模式是一种较为复杂的行为型设计模式，它包含访问者和被访问元素两个主要组成部分，这些被访问的元素通常具有不同的类型，且不同的访问者可以对它们进行不同的访问操作。例如处方单中的各种药品信息就是被访问的元素，而划价人员和药房工作人员就是访问者。访问者模式使得用户可以在不修改现有系统的情况下扩展系统的功能，为这些不同类型的元素增加新的操作。 在使用访问者模式时，被访问元素通常不是单独存在的，它们存储在一个集合中，这个集合被称为“对象结构”，访问者通过遍历对象结构实现对其中存储的元素的逐个操作。访问者模式的定义如下:1访问者模式：表示一个作用于某对象结构中的各个元素的操作。访问者模式让你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 访问者模式是一种对象行为型模式，它为操作存储不同类型元素的对象结构提供了一种解决方案，用户可以对不同类型的元素施加不同的操作。 访问者模式的结构与实现访问者模式的结构访问者模式的结构较为复杂，其结构如图2所示。 图2 访问者模式结构图 由图2可知，访问者模式包含以下5个角色。 (1)Visitor（抽象访问者）：抽象访问者为对象结构中的每一个具体元素类声明一个访问操作，从这个操作的名称或参数类型大家可以清楚地知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作。 (2)ConcreteVisitor（具体访问者）：具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。 (3)Element（抽象元素）：抽象元素一般是抽象类或者接口，它声明了一个Accept()方法，用于接受访问者的访问操作，该方法通常以一个抽象访问者作为参数。 (4)ConcreteElement（具体元素）：具体元素实现了Accept()方法，在Accept()方法中调用访问者的访问方法以便完成对一个元素的操作。 (5)Objectistructure（对象结构）：对象结构是一个元素的集合，用于存放元素对象，并且提供了遍历其内部元素的方法。对象结构可以结合组合模式来实现,也可以是一个简单的集合对象。 访问者模式的实现在访问者模式中，对象结构存储了不同类型的元素对象，以供不同的访问者访问。访问者模式包括两个层次结构：一个是访问者层次结构，提供了抽象访问者和具体访问者；另一个是元素层次结构，提供了抽象元素和具体元素。相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同的方式访问。在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性。 在访问者模式中，抽象访问者定义了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法，而具体访问者可以实现这些访问方法。这些访问方法的命名一般有两种方式：一种是直接在方法名中标明待访问元素对象的具体类型，例如VisitElementA(ElementA elementA)；另一种是统一命名为Visit()，通过参数类型的不同来定义一系列重载的Visit()方法。当然，如果所有的访问者对某一类型的元素的访问操作都相同，可以将操作代码移到抽象访问者类中，其典型代码如下： 12345678910abstract class Visitor&#123; public abstract void Visit(ConcreteElementA elementA); public abstract void Visit(ConcreteElementB elementB); public void Visit(ConcreteElementC elementC) &#123; //元素ConcreteElementC操作代码 &#125;&#125; 在这里使用了重载Visit()方法的方式来定义多个方法，用于操作不同类型的元素对象。在抽象访问者Visitor类的子类ConcreteVisitor中实现了抽象的访问方法，用于定义对不同类型元素对象的操作。具体访问者类的典型代码如下：123456789101112class ConcreteVisitor : Visitor &#123; public override void Visit(ConcreteElementA elementA) &#123; //元素ConcreteElementA操作代码 &#125; public override void Visit(ConcreteElementB elementB) &#123; //元素ConcreteElementB操作代码 &#125;&#125; 对于元素类而言，在其中一般都定义了一个Accept()方法，用于接收访问者的访问。典型的抽象元素类代码如下：1234interface Element&#123; void Accept(Visitor visitor);&#125; 需要注意的是，该方法传入了一个抽象访问者Visitor类型的参数，即针对抽象访问者进行编程，而不是具体访问者，在程序运行时再确定具体访问者的类型，并调用具体访问者对象的Visit()方法实现对元素对象的操作。在抽象元素类Element的子类中实现了Accept()方法，用于接受访问者的访问，在具体元素类中还可以定义不同类型的元素所特有的业务方法。其典型代码如下：123456789101112class ConcreteElementA : Element &#123; public void Accept(Visitor visitor) &#123; visitor.Visit(this); &#125; public void OperationA() &#123; //业务方法 &#125;&#125; 在具体元素类ConcreteElementA的Accept()方法中，通过调用Visitor类的Visit()方法实现对元素的访问，并以当前对象作为Visit()方法的参数。其具体执行过程如下： (1)调用具体元素类的Accept(Visitor visitor)方法，并将Visitor子类对象作为其参数。 (2)在具体元素类Accept(Visitor visitor)方法内部调用传入的Visitor对象的Visit()方法，例如Visit(ConcreteElementA elementA)，将当前具体元素类对象(this)作为参数，例如visitor.Visit(this)。 (3)执行Visitor对象的Visit()方法，在其中还可以调用具体元素对象的业务方法。 这种调用机制也称为“双重分派”，正因为使用了双重分派机制,使得增加新的访问者无须修改现有类库代码，只需将新的访问者对象作为参数传入具体元素对象的Accept()方法，程序运行时将回调在新增Visitor类中定义的Visit()方法，从而增加新的元素访问方式。 在访问者模式中，对象结构是一个集合，用于存储元素对象并接受访问者的访问。其典型代码如下：1234567891011121314151617181920212223242526using System;using System.Collections.Generic;class ObjectStructure&#123; private List&lt;Element&gt; list = new List&lt;Element&gt;(); //定义一个集合用于存储元素对象 //接受访问者的访问操作 public void Accept(Visitor visitor) &#123; foreach (Object obj in list) &#123; ((Element)obj).Accept(visitor); //遍历访问集合中的每一个元素 &#125; &#125; public void AddElement(Element element) &#123; list.Add(element); &#125; public void RemoveElement(Element element) &#123; list.Remove(element); &#125;&#125; 在对象结构中可以使用迭代器对存储在集合中的元素对象进行遍历，并逐个调用元素对象的Accept()方法，实现对元素对象的访问操作。 访问者模式的应用实例下面通过一个应用实例来进一步学习和理解访问者模式。 1.实例说明 某公司OA系统中包含一个员工信息管理子系统，该公司员工包括正式员工和临时工，每周人力资源部和财务部等部门需要对员工数据进行汇总，汇总数据包括员工工作时间、员工工资等。该公司的基本制度如下：(1)正式员工每周工作时间为40小时不同级别、不同部门的员工每周基本工资不同；如果超过40小时，超出部分按照100元/小时作为加班费；如果少于40小时所缺时间按照请假处理，请假所扣工资以80元/小时计算，直到基本工资扣除到零为止。除了记录实际工作时间外，人力资源部需记录加班时长或请假时长，作为员工平时表现的一项依据。(2)临时工每周工作时间不固定，基本工资按小时计算，不同岗位的临时工小时工资不同。人力资源部只需记录实际工作时间。人力资源部和财务部工作人员可以根据各自的需要对员工数据进行汇总处理，人力资源部负责汇总每周员工工作时间，而财务部负责计算每周员工工资。现使用访问者模式设计该系统，绘制类图并使用C#语言编程实现。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 员工数据汇总模块结构图 在图3中，FADepartment表示财务部，HRDepartment表示人力资源部，它们充当具体访问者类，其抽象父类Department充当抽象访问者类；EmployeeList充当对象结构，用于存储员工列表；FulltimeEmployee表示正式员工，ParttimeEmployee表示临时工，它们充当具体元素类，其父接口Employee充当抽象元素类。 3.实例代码 (1)Employee：员工类，充当抽象元素类。 1234567namespace VisitorSample&#123; interface Employee &#123; void Accept(Department handler); //接受一个抽象访问者访问 &#125;&#125; (2)FulltimeEmployee：全职员工类，充当具体元素类。 123456789101112131415161718192021222324252627282930313233343536373839namespace VisitorSample&#123; class FulltimeEmployee : Employee &#123; private string name; //员工姓名 private double weeklyWage; //员工周薪 private int workTime; //工作时间 public FulltimeEmployee(string name, double weeklyWage, int workTime) &#123; this.name = name; this.weeklyWage = weeklyWage; this.workTime = workTime; &#125; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public double WeeklyWage &#123; get &#123; return weeklyWage; &#125; set &#123; weeklyWage = value; &#125; &#125; public int WorkTime &#123; get &#123; return workTime; &#125; set &#123; workTime = value; &#125; &#125; public void Accept(Department handler) &#123; handler.Visit(this); //调用访问者的访问方法 &#125; &#125;&#125; (3)ParttimeEmployee：兼职员工类，充当具体元素类。 123456789101112131415161718192021222324252627282930313233343536373839namespace VisitorSample&#123; class ParttimeEmployee : Employee &#123; private string name; //员工姓名 private double hourWage; //员工时薪 private int workTime; //工作时间 public ParttimeEmployee(string name, double hourWage, int workTime) &#123; this.name = name; this.hourWage = hourWage; this.workTime = workTime; &#125; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public double HourWage &#123; get &#123; return hourWage; &#125; set &#123; hourWage = value; &#125; &#125; public int WorkTime &#123; get &#123; return workTime; &#125; set &#123; workTime = value; &#125; &#125; public void Accept(Department handler) &#123; handler.Visit(this); //调用访问者的访问方法 &#125; &#125;&#125; (4)Department：部门类，充当抽象访问者类。 123456789namespace VisitorSample&#123; abstract class Department &#123; //声明一组重载的访问方法，用于访问不同类型的具体元素 public abstract void Visit(FulltimeEmployee employee); public abstract void Visit(ParttimeEmployee employee); &#125;&#125; (5)FADepartment：财务部类，充当具体访问者类。 1234567891011121314151617181920212223242526272829303132333435using System;namespace VisitorSample&#123; class FADepartment : Department &#123; //实现财务部对全职员工的访问 public override void Visit(FulltimeEmployee employee) &#123; int workTime = employee.WorkTime; double weekWage = employee.WeeklyWage; if(workTime &gt; 40) &#123; weekWage = weekWage + (workTime - 40) * 100; &#125; else if(workTime &lt; 40) &#123; weekWage = weekWage - (40 - workTime) * 80; if(weekWage &lt; 0) &#123; weekWage = 0; &#125; &#125; Console.WriteLine("正式员工&#123;0&#125;实际工资为：&#123;1&#125;元。", employee.Name,weekWage); &#125; //实现财务部对兼职员工的访问 public override void Visit(ParttimeEmployee employee) &#123; int workTime = employee.WorkTime; double hourWage = employee.HourWage; Console.WriteLine("临时工&#123;0&#125;实际工资为：&#123;1&#125;元。", employee.Name, workTime * hourWage); &#125; &#125;&#125; (6)HRDepartment：人力资源部类，充当具体访问者类。 1234567891011121314151617181920212223242526272829using System;namespace VisitorSample&#123; class HRDepartment : Department &#123; //实现人力资源部对全职员工的访问 public override void Visit(FulltimeEmployee employee) &#123; int workTime = employee.WorkTime; Console.WriteLine("正式员工&#123;0&#125;实际工作时间为：&#123;1&#125;小时。", employee.Name, workTime); if(workTime &gt; 40) &#123; Console.WriteLine("正式员工&#123;0&#125;加班时间为：&#123;1&#125;小时。", employee.Name,workTime - 40); &#125; else if(workTime &lt; 40) &#123; Console.WriteLine("正式员工&#123;0&#125;请假时间为：&#123;1&#125;小时。", employee.Name,40 - workTime); &#125; &#125; //实现人力资源部对兼职员工的访问 public override void Visit(ParttimeEmployee employee) &#123; int workTime = employee.WorkTime; Console.WriteLine("临时工&#123;0&#125;实际工作时间为：&#123;1&#125;小时。", employee.Name, workTime); &#125; &#125;&#125; (7)EmployeeList：员工列表类，充当对象结构。 12345678910111213141516171819202122232425using System;using System.Collections;namespace VisitorSample&#123; class EmployeeList &#123; //定义一个集合用于存储员工对象 private ArrayList list = new ArrayList(); public void AddEmployee(Employee employee) &#123; list.Add(employee); &#125; //遍历访问员工集合中的每一个员工对象 public void Accept(Department handler) &#123; foreach(Object obj in list) &#123; ((Employee)obj).Accept(handler); &#125; &#125; &#125;&#125; (8)配置文件App.config：在配置文件中存储了具体访问者类的类名。 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="visitor" value="VisitorSample.FADepartment"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (9)Program：客户端测试类。 123456789101112131415161718192021222324252627282930313233343536using System;using System.Configuration;using System.Reflection;namespace VisitorSample&#123; class Program &#123; static void Main(string[] args) &#123; EmployeeList list = new EmployeeList(); Employee fte1, fte2, fte3, pte1, pte2; fte1 = new FulltimeEmployee("张无忌", 3200.00, 45); fte2 = new FulltimeEmployee("杨过", 2000.00, 40); fte3 = new FulltimeEmployee("段誉", 2400.00, 38); pte1 = new ParttimeEmployee("洪七公", 80.00, 20); pte2 = new ParttimeEmployee("郭靖", 60.00, 18); list.AddEmployee(fte1); list.AddEmployee(fte2); list.AddEmployee(fte3); list.AddEmployee(pte1); list.AddEmployee(pte2); Department dep; //读取配置文件 string visitorStr = ConfigurationManager.AppSettings["visitor"]; //反射生成对象 dep = (Department)Assembly.Load("VisitorSample").CreateInstance(visitorStr); list.Accept(dep); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12345正式员工张无忌的实际工资为：3700元。正式员工杨过的实际工资为：2000元。正式员工段誉的实际工资为：2240元。临时工洪七公的实际工资为：1600元。临时工郭靖的实际工资为：1080元。 如果需要更换具体访问者类，无须修改源代码，只需修改配置文件即可。例如将访问者类由财务部改为人力资源部，只需将存储在配置文件App.config中的具体访问者类FADepartment改为HRDepartment，代码如下：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="visitor" value="VisitorSample.HRDepartment"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 重新运行客户端程序，输出结果如下：1234567正式员工张无忌的实际工作时间为：45小时。 正式员工张无忌的加班时间为：5小时。 正式员工杨过的实际工作时间为：40小时。 正式员工段誉的实际工作时间为：38小时。 正式员工段誉的请假时间为：2小时。 临时工洪七公的实际工作时间为：20小时。 临时工郭靖的实际工作时间为：18小时。 如果要在系统中增加一种新的访问者，无须修改源代码，只需增加一个新的具体访问者类即可，在该具体访问者中封装了新的操作元素对象的方法。从增加新的访问者的角度来看，访问者模式符合开闭原则。 如果要在系统中增加一种新的具体元素，例如增加一种新的员工类型为“退休人员”，由于原有系统并未提供相应的访问接口（在抽象访问者中没有声明任何访问“退休人员”的方法），所以必须对原有系统进行修改，在原有的抽象访问者类和具体访问者类中增加相应的访问方法。从增加新的元素的角度来看，访问者模式违背了开闭原则。 综上所述，访问者模式与抽象工厂模式类似，对开闭原则的支持具有倾斜性，可以很方便地添加新的访问者，但是添加新的元素较为麻烦。 访问者模式与组合模式联用在访问者模式中，包含一个用于存储元素对象集合的对象结构，通常可以使用迭代器来遍历对象结构，同时具体元素之间可以存在整体与部分关系，有些元素作为容器对象，有些元素作为成员对象，因此可以使用组合模式来组织元素。引入组合模式后的访问者模式结构如图4所示。 图4 访问者模式与组合模式联用示意图 需要注意的是，在图4所示的结构中，由于叶子元素的遍历操作已经在容器元素中完成，因此要防止单独将已增加到容器元素中的叶子元素再次加入到对象结构中，对象结构中只保存容器元素和孤立的叶子元素。 访问者模式的优缺点与适用环境由于访问者模式的使用条件较为苛刻，本身结构也较为复杂，所以在实际应用中的使用频率不是特别高。当系统中存在一个较为复杂的对象结构，且不同访问者对其所采取的操作也不相同时，可以考虑使用访问者模式进行设计。在XML文档解析、编译器的设计、复杂集合对象的处理等领域访问者模式得到了一定的应用。 访问者模式的优点访问者模式的主要优点如下： (1)访问者模式增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合开闭原则。 (2)访问者模式将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。 (3)访问者模式让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。 访问者模式的缺点访问者模式的主要缺点如下: (1)增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了开闭原则的要求。 (2)破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问。 访问者模式的适用环境在以下情况下可以考虑使用访问者模式： (1)一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者模式中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作 (2)需要对一个对象结构中的对象进行很多不同的且不相关的操作，并需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。访问者模式使得用户可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。 (3)对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 本章小结(1)访问者模式用于表示一个作用于某对象结构中的各个元素的操作。访问者模式让你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。 (2)访问者模式包含抽象访问者、具体访问者、抽象元素、具体元素和对象结构5个角色。其中，抽象访问者为对象结构中的每一个具体元素类声明一个访问操作；具体访问者实现了每个由抽象访问者声明的操作；抽象元素声明了一个Accept()方法，用于接受访问者的访问操作；具体元素实现了Accept()方法，在Accept()方法中调用访问者的访问方法以便完成对一个元素的操作；对象结构是一个元素的集合，用于存放元素对象，并且提供了遍历其内部元素的方法。 (3)访问者模式的主要优点是增加新的访问操作很方便；将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中，类的职责更加清晰；让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。其主要缺点是增加新的元素类很困难，而且可能破坏系统的封装性。 (4)访问者模式适用的环境：一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作；需要对一个对象结构中的对象进行很多不同的且不相关的操作，并需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类；对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。 (5)在访问者模式中，包含一个用于存储元素对象集合的对象结构，通常可以使用迭代器来遍历对象结构，同时具体元素之间可以存在整体与部分关系，有些元素作为容器对象，有些元素作为成员对象，因此可以使用组合模式来组织元素。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[桥接模式]]></title>
    <url>%2F2019%2F09%2F25%2F%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 桥接模式为什么是结构型模式？ 某个类存在两个独立变化的维度，用毛笔和蜡笔怎么举例？ 型号可认为是毛笔的抽象部分，而颜色是毛笔的实现部分。怎么理解？ 任意组合子类，从而获得多维度组合对象。怎么理解？ 桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时在设计初期也需要考虑适配器模式，特别是那些涉及大量第三方应用接口的情况。怎么理解？ 用抽象关联来取代传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系。原来的多层继承是怎么写的？存在什么问题？怎么用桥接模式取代？ 将它们设计为两个独立的继承等级结构，为两个维度都提供抽象层，并建立抽象耦合。怎么做到？ 可以针对两个维度的抽象层编程，在程序运行时再动态地确定两个维度的子类，动态地组合对象。怎么理解？ 本章导学 桥接模式是一种很实用的结构型设计模式，如果系统中某个类存在两个独立变化的维度，通过桥接模式可以将这两个维度分离出来，使两者可以独立扩展。桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联来取代传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵活，并易于扩展，同时有效控制了系统中类的个数。 本章将学习桥接模式的定义与结构，通过实例来加深对桥接模式的理解，并学习如何将其应用于实际项目的开发，还将学习如何实现桥接模式和适配器模式的联用。 本章知识点 桥接模式的定义 桥接模式的结构 桥接模式的实现 桥接模式的应用 桥接模式与适配器模式联用 桥接模式的优缺点 桥接模式的适用环境 桥接模式概述毛笔和蜡笔是两种很常见的文具，它们都归属于画笔。假如需要大、中、小3种型号的画笔，能够分别绘制12种不同的颜色，如果使用蜡笔，需要准备3 ×12 = 36支，如果使用毛笔，只需要提供3种型号的毛笔，外加一个包含12种颜色的调色板即可，涉及的对象个数仅为3 + 12 = 15，远远小于36，却能实现与36支蜡笔同样的功能。如果增加一种新型号的画笔，并且也需要具有12种颜色，对应的蜡笔需增加12支，而毛笔只需增加一支。图1所示为毛笔与蜡笔示意图。 图1 毛笔与蜡笔示意图 通过分析不难得知：在蜡笔中，颜色和型号两个不同的变化维度（即两个不同的变化原因，如图2所示）耦合在一起，无论是对颜色进行扩展还是对型号进行扩展都势必会影响另一个维度；但在毛笔中，颜色和型号实现了分离，增加新的颜色或者型号对另一方没有任何影响。如果使用软件工程中的术语，可以认为在蜡笔中颜色和型号之间存在较强的耦合性，而毛笔很好地将二者解耦，使用起来非常灵活，扩展也更为方便。在软件开发中，也有一种设计模式可以用来处理与画笔类似的具有多变化维度的情况，它就是桥接模式。 图2 画笔中存在的两个独立变化维度示意图 在桥接模式中，将两个独立变化的维度（例如画笔的型号与颜色）设计为两个独立的继承等级结构，而不是将二者耦合在一起形成多层继承结构。桥接模式在抽象层建立起一个抽象关联，该关联关系类似一条连接两个独立继承结构的桥，故名桥接模式。 桥接模式的定义如下：1将抽象部分与它的实现部分解耦，使得两者都能够独立变化。 桥接模式是一种对象结构型模式，它又被称为柄体（Handle and Body）模式或接口（Interface）模式。桥接模式用一种巧妙的方式处理多层继承存在的问题，用抽象关联取代了传统的多层继承，将类之间的静态继承关系转换为动态的对象组合关系，使得系统更加灵话，并易于扩展，同时有效控制了系统中类的个数。 桥接模式的结构与实现桥接模式的结构桥接模式的结构如图3所示。 图3 桥接模式结构图 由图3可知，桥接模式包含以下4个角色： (1)Abstraction（抽象类）：它是用于定义抽象类的接口，通常是抽象类而不是接口，其中定义了一个Implementor（实现类接口）类型的对象并可以维护该对象，它与Implementor之间具有关联关系，既可以包含抽象业务方法，也可以包含具体业务方法。 (2)RefinedAbstraction（扩充抽象类）：它扩充由Abstraction定义的接口，通常情况下不再是抽象类而是具体类，实现了在Abstraction中声明的抽象业务方法，在RefinedAbstraction中可以调用在Implementor中定义的业务方法。 (3)Implementor（实现类接口）：它是定义实现类的接口，这个接口不一定要与Abstraction的接口完全一致，事实上这两个接口可以完全不同。一般而言，Implementor接口仅提供基本操作，而Abstraction定义的接口可能会做更多更复杂的操作。Implementor接口对这些基本操作进行了声明，而将具体实现交给其子类。通过关联关系，在Abstraction中不仅可以拥有自己的方法，还可以调用Implementor中定义的方法，使用关联关系来替代继承关系。 (4)ConcreteImplementor（具体实现类）：它具体实现了Implementor接口，在不同的Concretelmplementor中提供基本操作的不同实现，在程序运行时，Concretelmplementor对象将替换其父类对象，提供给抽象类具体的业务操作方法。 桥接模式的实现桥接模式是一个非常实用的设计模式，在桥接模式中体现了很多面向对象设计原则的思想，包括单一职责原则、开闭原则、合成复用原则、里氏代换原则、依赖倒转原则等。熟悉桥接模式将有助于用户深入理解这些设计原则，也有助于形成正确的设计思想和培养良好的设计风格。 在使用桥接模式时，用户首先应该识别出一个类所具有的两个独立变化的维度，将它们设计为两个独立的继承等级结构，为两个维度都提供抽象层，并建立抽象耦合。通常情况下，将具有两个独立变化维度的类的一些普通业务方法和与之关系最密切的维度设计为“抽象类”层次结构（抽象部分），而将另一个维度设计为“实现类”层次结构（实现部分）。例如：对于毛笔而言，由于型号是其固有的维度，因此可以设计一个抽象的毛笔类，在该类中声明并部分实现毛笔的业务方法，而将各种型号的毛笔作为其子类；颜色是毛笔的另一个维度，由于它与毛笔之间存在一种“设置”的关系，因此可以提供一个抽象的颜色接口，而将具体的颜色作为实现该接口的子类。在此，型号可认为是毛笔的抽象部分，而颜色是毛笔的实现部分，结构示意图如图4所示。 图4 毛笔结构示意图 在图4中，如果需要增加一种新型号的毛笔，只需扩展左侧的“抽象部分”，增加一个新的扩充抽象类；如果需要增加一种新的颜色，只需扩展右侧的“实现部分”，增加一个新的具体实现类。扩展非常方便，无须修改已有代码，且不会导致类的数目增长过快。 在具体编码实现时，由于在桥接模式中存在两个独立变化的维度，为了降低两者之间的耦合度，首先需要针对两个不同的维度提取抽象类和实现类接口，并建立一个抽象关联关系。对于“实现部分”维度，典型的实现类接口代码如下：1234interface Implementor&#123; void OperationImpl();&#125; 在实现Implementor接口的子类ConcreteImplementor中实现了在该接口中声明的方法，用于定义与该维度相对应的一些具体方法，代码如下：1234567class ConcreteImplementor&#123; public void OperationImpl() &#123; // 具体业务方法的实现 &#125;&#125; 对于另一“抽象部分”维度而言，其典型的抽象类代码如下：1234567891011abstract class Abstraction&#123; protected Implementor impl; // 定义实现类接口对象 public void SetImpl(Implementor impl) &#123; this.impl = impl; &#125; public abstract void Operation(); // 声明抽象业务方法&#125; 在抽象类Abstraction中定义了一个实现类接口类型的成员对象impl，再通过Setter方法或者构造方法以注入的方式给该对象赋值，一般将该对象的可见性定义为protected，以便在其子类中访问Implementor的方法，其子类一般称为扩充抽象类或细化抽象类（RefinedAbstraction），典型的RefinedAbstraction类代码如下：123456789class RefinedAbstraction : Abstraction&#123; public override void Operation() &#123; // 业务代码 impl.OperationImpl(); // 调用实现类的方法 // 业务代码 &#125;&#125; 对于客户端而言，可以针对两个维度的抽象层编程，在程序运行时再动态地确定两个维度的子类，动态地组合对象，将两个独立变化的维度完全解耦，以便能够灵活地扩充任一维度而对另一维度不造成任何影响。 桥接模式的应用实例下面通过一个应用实例来进一步学习和理解桥接模式。 1.实例说明 某软件公司要开发一个跨平台图像浏览系统，要求该系统能够显示BMP、JPG、GIF、PNG等多种格式的文件，并且能够在Windows、Linux、UNIX等多个操作系统上运行。系统首先将各种格式的文件解析为像素矩阵（Matrix），然后将像素矩阵显示在屏幕上，在不同的操作系统中可以调用不同的绘制函数来绘制像素矩阵。另外，系统需具有较好的扩展性，以便在将来支持新的文件格式和操作系统。试使用桥接模式设计该跨平台图像浏览系统。 2.实例类图 通过分析，本实例的结构如图5所示。 图5 跨平台图像浏览系统结构图 在图5中，Image充当抽象类，其子类JPGImage、PNGImage、BMPImage和GIFImage充当扩充抽象类；Imagelmp充当实现类接口，其子类WindowsImp、LinuxImp和UnixImp充当具体实现类。 3.实例代码 (1)Matrix：像素矩阵类，它是一个辅助类，各种格式的图像文件最终都会被转化为像素矩阵，不同的操作系统提供不同的方式显示像素矩阵。1234567namespace BridgeSample&#123; class Matrix &#123; // 代码省略 &#125;&#125; (2)ImageImp：抽象操作系统实现类，充当实现类接口。 1234567namespace BridgeSample&#123; interface ImageImp &#123; void DoPaint(Matrix m); // 显示像素矩阵m &#125;&#125; (3)WindowsImp：Windows操作系统实现类，充当具体实现类。 12345678910111213using System;namespace BridgeSample&#123; class WindowsImp : ImageImp &#123; public void DoPaint(Matrix m) &#123; // 调用Windows系统的绘制函数绘制像素矩阵 Console.Write("在Windows操作系统中显示图像："); &#125; &#125;&#125; (4)LinuxImp：Linux操作系统实现类，充当具体实现类。 12345678910111213using System;namespace BridgeSample&#123; class LinuxImp : ImageImp &#123; public void DoPaint(Matrix m) &#123; // 调用Linux系统的绘制函数绘制像素矩阵 Console.Write("在Linux操作系统中显示图像："); &#125; &#125;&#125; (5)UnixImp：UNIX操作系统实现类，充当具体实现类。 12345678910111213using System;namespace BridgeSample&#123; class UnixImp : ImageImp &#123; public void DoPaint(Matrix m) &#123; // 调用Unix系统的绘制函数绘制像素矩阵 Console.Write("在Unix操作系统中显示图像："); &#125; &#125;&#125; (6)Image：抽象图像类，充当抽象类。 123456789101112131415namespace BridgeSample&#123; abstract class Image &#123; protected ImageImp imp; // 注入实现类接口对象 public void SetImageImp(ImageImp imp) &#123; this.imp = imp; &#125; public abstract void ParseFile(string fileName); &#125;&#125; (7)JPGImage：JPG格式图像类，充当扩充抽象类。 123456789101112131415using System;namespace BridgeSample&#123; class JPGImage : Image &#123; public override void ParseFile(string fileName) &#123; // 模拟解析JPG文件并获得一个像素矩阵对象m; Matrix m = new Matrix(); imp.DoPaint(m); Console.WriteLine("&#123;0&#125;，格式为JPG。",fileName); &#125; &#125;&#125; (8)PNGImage：PNG格式图像类，充当扩充抽象类。 123456789101112131415using System;namespace BridgeSample&#123; class PNGImage : Image &#123; public override void ParseFile(string fileName) &#123; // 模拟解析PNG文件并获得一个像素矩阵对象m; Matrix m = new Matrix(); imp.DoPaint(m); Console.WriteLine("&#123;0&#125;，格式为PNG。", fileName); &#125; &#125;&#125; (9)BMPImage：BMP格式图像类，充当扩充抽象类。 123456789101112131415using System;namespace BridgeSample&#123; class BMPImage : Image &#123; public override void ParseFile(string fileName) &#123; // 模拟解析BMP文件并获得一个像素矩阵对象m; Matrix m = new Matrix(); imp.DoPaint(m); Console.WriteLine("&#123;0&#125;，格式为BMP。", fileName); &#125; &#125;&#125; (10)GIFImage：GIF格式图像类，充当扩充抽象类。 123456789101112131415using System;namespace BridgeSample&#123; class GIFImage : Image &#123; public override void ParseFile(string fileName) &#123; // 模拟解析GIF文件并获得一个像素矩阵对象m; Matrix m = new Matrix(); imp.DoPaint(m); Console.WriteLine("&#123;0&#125;，格式为GIF。", fileName); &#125; &#125;&#125; (11)配置文件App.config：在配置文件中存储了具体扩充抽象类和具体实现类类名。 123456789&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;!--RefinedAbstraction--&gt; &lt;add key="image" value="BridgeSample.JPGImage"/&gt; &lt;!--ConcreteImplementor--&gt; &lt;add key="os" value="BridgeSample.WindowsImp"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (12)Program：客户端测试类。 123456789101112131415161718192021222324252627using System;using System.Configuration;using System.Reflection;namespace BridgeSample&#123; class Program &#123; static void Main(string[] args) &#123; Image image; ImageImp imp; // 读取配置文件 string imageType = ConfigurationManager.AppSettings["image"]; string osType = ConfigurationManager.AppSettings["os"]; // 反射生成对象 image = (Image)Assembly.Load("BridgeSample").CreateInstance(imageType); imp = (ImageImp)Assembly.Load("BridgeSample").CreateInstance(osType); image.SetImageImp(imp); image.ParseFile("中国地图"); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：1在Windows操作系统中显示图像：中国地图，格式为JPG。 如果需要更换图像文件格式或者更换操作系统，只需修改配置文件即可。例如将配置文件App.config改为：123456789&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;!--RefinedAbstraction--&gt; &lt;add key="image" value="BridgeSample.BMPImage"/&gt; &lt;!--ConcreteImplementor--&gt; &lt;add key="os" value="BridgeSample.LinuxImp"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 再次运行程序，输出结果为:1在Linux操作系统中显示图像：中国地图，格式为BMP。 在实际使用时，可以通过分析图像文件格式扩展名来确定具体的文件格式，在程序运行时获取操作系统信息来确定操作系统类型，无须使用配置文件。当增加新的图像文件格式或者操作系统时，对于原有系统源代码无须做任何修改，只需增加一个对应的扩充抽象类或具体实现类即可，系统具有较好的可扩展性，完全符合开闭原则。 桥接模式与适配器模式联用在软件开发中，适配器模式通常可以与桥接模式联合使用。适配器模式可以解决两个已有接口间不兼容的问题，在这种情况下被适配的类往往是一个黑盒子，有时不想也不能改变这个被适配的类，也不能控制其扩展。适配器模式通常用于现有系统与第三方产品功能的集成，采用增加适配器的方式将第三方类集成到系统中。桥接模式则不同，用户可以通过接口继承或类继承的方式对系统进行扩展。 桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时在设计初期也需要考虑适配器模式，特别是那些涉及大量第三方应用接口的情况。 下面通过一个实例来说明适配器模式和桥接模式的联合使用： 在某系统的报表处理模块中，需要将报表显示和数据输出分开，系统可以有多种报表显示方式也可以有多种数据输出方式，例如可以将数据输出为文本文件，也可以输出为Excel文件，如果需要输出为Excel文件，则需要调用与Excel相关的API，而这个API是现有系统所不具备的，该API由厂商提供。因此，可以同时使用适配器模式和桥接模式来设计该模块，如图6所示。 图6 桥接模式与适配器模式联用示意图 桥接模式的优缺点与适用环境桥接模式的应用很广泛，在软件开发中如果一个类或一个系统有多个变化维度，都可以尝试使用桥接模式对其进行设计。桥接模式为多维度变化的系统提供了一套完整的解决方案，并且降低了系统的复杂度。 桥接模式的优点桥接模式的主要优点如下： (1)分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自具有自己的子类，以便任意组合子类，从而获得多维度组合对象。 (2)在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了单一职责原则，复用性较差，且类的个数非常多。桥接模式是比多层继承方案更好的解决方法，它极大地减少了子类的个数。 (3)桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，不需要修改原有系统，符合开闭原则。 桥接模式的缺点桥接模式的主要缺点如下： (1)桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。 (2)桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。 桥接模式的适用环境在以下情况下可以考虑使用桥接模式： (1)如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。 (2)抽象部分和实现部分可以以继承的方式独立扩展而互不影响，在程序运行时可以动态地将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。 (3)一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展。 (4)对于不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。 本章小结(1)桥接模式将抽象部分与它的实现部分解耦，使得两者都能够独立变化。桥接模式是一种对象结构型模式。 (2)桥接模式包含抽象类、扩充抽象类、实现类接口和具体实现类4个角色。其中，抽象类定义了一个实现类接口类型的对象并维护该对象；扩充抽象类扩充由抽象类定义的接口，实现了在抽象类中声明的抽象业务方法；实现类接口声明了一些基本操作，而将具体实现交给其子类完成；具体实现类具体实现了实现类接口，在不同的具体实现类中提供基本操作的不同实现。 (3)桥接模式的主要优点在于可以分离抽象接口及其实现部分，它是比多层继承方案更好的解决方法，极大地减少了子类的个数。此外，桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合开闭原则。其主要缺点在于会增加系统的理解与设计难度，且正确识别出系统中两个独立变化的维度并不是一件容易的事情。 (4)桥接模式适用的环境：需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系；抽象部分和实现部分可以以继承的方式独立扩展而互不影响；一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立地进行扩展；不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统。 (5)在使用桥接模式进行系统设计时，如果需要重用第三方应用接口，可与适配器模式一起联用，既可以保证系统的扩展性，又可以将第三方类集成到系统中。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰模式]]></title>
    <url>%2F2019%2F09%2F24%2F%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 抽象装饰类继承抽象构件类并引用它。怎么理解？ 对于扩展一个对象的功能，装饰模式比继承更加灵活。为什么？ 装饰模式为什么是一种结构型模式？ 装饰模式包含抽象构件、具体构件、抽象装饰类和具体装饰类4个角色。这四种如何组合？ 半透明模式和透明模式有什么区别？ 本章导学 装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和用于装饰的具体装饰类都可以独立变化，增加新的具体构件类和具体装饰类都非常方便，符合开闭原则。 本章将学习装饰模式的定义与结构，通过实例学习装饰模式的使用，并学习透明装饰模式和半透明装饰模式的区别与实现。 本章知识点 装饰模式的定义 装饰模式的结构 装饰模式的实现 装饰模式的应用 装饰模式的优缺点 装饰模式的适用环境 透明装饰模式与半透明装饰模式 装饰模式概述对新房进行装修并没有改变房屋用于居住的本质，但它可以让房子变得更漂亮、更温馨、更实用、更能满足居家的需求。在软件设计中，也有一种类似新房装修的技术可以对已有对象（新房）的功能进行扩展（装修），以获得更加符合用户需求的对象，使得对象具有更加强大的功能，这种技术在设计模式中被称为装饰模式。 装饰模式可以在不改变一个对象本身功能的基础上给对象增加额外的新行为，在现实生活中，这种情况也到处存在。例如一张照片，用户可以不改变照片本身，给它增加一个相框，使它具有防潮的功能，还可以根据需要给它增加不同类型的相框，甚至可以在一个小相框的外面再套一个大相框，如图1所示。 图1 装饰模式示意图 在软件设计中，装饰模式是一种用于替代继承的技术，它通过一种无须定义子类的方式给对象动态增加职责，使用对象之间的关联关系取代类之间的继承关系。在装饰模式中引入了装饰类，在装饰类中既可以调用待装饰的原有类的方法，还可以增加新的方法，以扩展原有类的功能。 装饰模式的定义如下：1动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。 装饰模式是一种对象结构型模式，它以对客户透明的方式动态地给一个对象附加上更多的责任，可以在不需要创建更多子类的情况下，让对象的功能得以扩展。 装饰模式的结构与实现装饰模式的结构装饰模式的结构如图2所示。 图2 装饰模式结构图 由图2可知，装饰模式包含以下4个角色。 (1)Component（抽象构件）：它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。 (2)ConcreteComponent（具体构件）：它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰类可以给它增加额外的职责（方法）。 (3)Decorator（抽象装饰类）：它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责通常在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。 (4)ConcreteDecorator（具体装饰类）：它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法，以扩展对象的行为。 装饰模式的实现在装饰模式中，抽象构件类一般设计为抽象类或者接口，在其中声明了抽象业务方法，当然，也可以在抽象构件类中实现一些所有具体构件类都共有的业务方法。抽象构件类的典型代码如下：1234abstract class Component&#123; public abstract void Operation(); &#125; 具体构件类作为抽象构件类的子类实现了在抽象构件类中声明的业务方法，通常在具体构件类中只提供基本功能的实现，一些复杂的功能需通过装饰类来进行扩展。其典型代码如下：1234567class ConcreteComponent : Component&#123; public override void Operation() &#123; // 基本功能的实现 &#125;&#125; 装饰模式的核心在于抽象装饰类的设计，其典型代码如下：1234567891011121314151617class Decorator : Component&#123; // 维持一个对抽象构建对象的引用 private Component component; // 注入一个抽象构件类型的对象 public Decorator(Component component) &#123; this.component = component; &#125; public override void Operation() &#123; // 调用原有业务方法 component.Operation(); &#125;&#125; 在抽象装饰类Decorator中定义了一个Component类型的对象component，维持一个对抽象构件对象的引用，并可以通过构造方法或Setter方法将一个Component类型的对象注入进来，同时由于Decorator类实现了抽象构件Component接口，因此需要实现在其中声明的业务方法Operation()。值得注意的是，在Decorator中并未真正实现Operation()方法，而是调用原有component对象的Operation()方法，它没有真正实施装饰，而是提供一个统一的接口，将具体装饰过程交给子类完成。 在Decorator的子类（即具体装饰类）中将继承Operation()方法并根据需要进行扩展，典型的具体装饰类代码如下：12345678910111213141516171819class ConcreteDecorator : Decorator&#123; public ConcreteDecorator (Component component) : base(component) &#123; &#125; public override void Operation() &#123; base.Operation(); // 调用原有业务方法 AddedBehavior(); // 调用新增业务方法 &#125; // 新增业务方法 public void AddedBehavior() &#123; // 功能的扩展 &#125;&#125; 在具体装饰类中可以调用抽象装饰类的Operation()方法，同时可以定义新的业务方法，例如AddedBehavior()，如果该方法不希望客户端单独调用，可以将其可见性设为私有（private）。 由于在抽象装饰类Decorator中注入的是Component类型的对象，因此可以将一个具体构件对象注入其中，再通过具体装饰类来进行装饰。此外，还可以将一个已经装饰过的Decorator子类的对象再注入其中进行多次装饰，从而实现对原有功能的多次扩展。 装饰模式的应用实例下面通过一个应用实例来进一步学习和理解装饰模式。 1.实例说明 某软件公司基于面向对象技术开发了一套图形界面构件库——VisualComponent，该构件库提供了大量的基本构件，如窗体、文本框、列表框等，由于在使用该构件库时，用户经常要求定制一些特殊的显示效果，如带滚动条的窗体、带黑色边框的文本框、既带滚动条又带黑色边框的列表框等，因此经常需要对该构件库进行扩展以增强其功能。现使用装饰模式来设计该图形界面构件库。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 图形界面构件库结构图 在图3中，VisualComponent充当抽象构件类，其子类Window、TextBox、ListBox充当具体构件类，VisualComponent类的另一个子类ComponentDecorator充当抽象装饰类，ComponentDecorator的子类ScrollBarDecorator和BlackBorderDecorator充当具体装饰类。 3.实例代码 (1)VisualComponent：抽象界面构件类，充当抽象构件类。为了突出与模式相关的核心代码，在本实例中对控件代码进行了大量的简化。1234567namespace DecoratorSample&#123; abstract class VisualComponent &#123; public abstract void Display(); &#125;&#125; (2)Window：窗体类，充当具体构件类。 123456789101112using System;namespace DecoratorSample&#123; class Window : VisualComponent &#123; public override void Display() &#123; Console.WriteLine("显示窗体！"); &#125; &#125;&#125; (3)TextBox：文本框类，充当具体构件类。 123456789101112using System;namespace DecoratorSample&#123; class TextBox : VisualComponent &#123; public override void Display() &#123; Console.WriteLine("显示文本框！"); &#125; &#125;&#125; (4)ListBox：列表框类，充当具体构件类。 123456789101112using System;namespace DecoratorSample&#123; class ListBox : VisualComponent &#123; public override void Display() &#123; Console.WriteLine("显示列表框！"); &#125; &#125;&#125; (5)ComponentDecorator：构件装饰类，充当抽象装饰类。 123456789101112131415161718namespace DecoratorSample&#123; class ComponentDecorator : VisualComponent &#123; private VisualComponent component; // 维持对抽象构件类型对象的引用 // 注入抽象构件类型的对象 public ComponentDecorator(VisualComponent component) &#123; this.component = component; &#125; public override void Display() &#123; component.Display(); &#125; &#125;&#125; (6)ScrollBarDecorator：滚动条装饰类，充当具体装饰类。 1234567891011121314151617181920212223using System;namespace DecoratorSample&#123; class ScrollBarDecorator : ComponentDecorator &#123; public ScrollBarDecorator(VisualComponent component) : base(component) &#123; &#125; public override void Display() &#123; this.SetScrollBar(); base.Display(); &#125; public void SetScrollBar() &#123; Console.WriteLine("为构件增加滚动条！"); &#125; &#125;&#125; (7)BlackBorderDecorator：黑色边框装饰类，充当具体装饰类。 1234567891011121314151617181920212223using System;namespace DecoratorSample&#123; class BlackBorderDecorator : ComponentDecorator &#123; public BlackBorderDecorator(VisualComponent component) : base(component) &#123; &#125; public override void Display() &#123; this.SetBlackBorder(); base.Display(); &#125; public void SetBlackBorder() &#123; Console.WriteLine("为构件增加黑色边框！"); &#125; &#125;&#125; (8)Program：客户端测试类。 1234567891011121314151617using System;namespace DecoratorSample&#123; class Program &#123; static void Main(string[] args) &#123; VisualComponent component, componentSB; // 使用抽象构件定义 component = new Window(); // 定义具体构件 componentSB = new ScrollBarDecorator(component); // 定义装饰后的构件 componentSB.Display(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12为构件增加滚动条！ 显示窗体！ 在客户端代码中，先创建一个Window类型的具体构件对象component，然后将component作为构造函数的参数注入具体装饰类ScrollBarDecorator中，得到一个装饰之后的对象componentSB，在调用componentSB的Display()方法后将得到一个有滚动条的窗体。如果希望得到一个既有滚动条又有黑色边框的窗体，不需要对原有类库进行任何修改，只需将客户端代码修改如下：1234567891011121314151617using System;namespace DecoratorSample&#123; class Program &#123; static void Main(string[] args) &#123; VisualComponent component, componentSB, componentBB; // 使用抽象构件定义 component = new Window(); // 定义具体构件 componentSB = new ScrollBarDecorator(component); // 定义装饰后的构件 componentBB = new BlackBorderDecorator(componentSB); // 将装饰了一次之后的对象继续注入到另一个装饰类中，进行第二次装饰 componentBB.Display(); Console.Read(); &#125; &#125;&#125; 再次编译并运行程序，输出结果如下：123为构件增加黑色边框！为构件增加滚动条！显示窗体！ 在上述客户端代码中，将装饰了一次之后的componentSB对象注入另一个装饰类BlackBorderDecorator中实现第二次装饰，得到一个经过两次装饰的对象componentBB，再调用componentBB的Display()方法即可得到一个既有滚动条又有黑色边框的窗体。 如果需要在原有系统中增加一个新的具体构件类或者新的具体装饰类，无须修改现有类库代码，只需将它们分别作为抽象构件类或者抽象装饰类的子类即可。 透明装饰模式与半透明装饰模式在装饰模式中，具体装饰类通过新增成员变量或者成员方法来扩展具体构件类的功能。在标准的装饰模式中，新增行为需在原有业务方法中调用，无论是具体构件对象还是装饰过的构件对象，对于客户端而言都是透明的，这种装饰模式被称为透明（Transparent）装饰模式。但是在某些情况下，有些新增行为可能需要单独被调用，此时，客户端不能再一致性地处理装饰之前的对象和装饰之后的对象，这种装饰模式被称为半透明（Semi-transparent）装饰模式。下面将对这两种装饰模式进行较为详细的介绍。 1.透明装饰模式 在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。即应该使用以下代码：1234Component component_o, component_d; // 使用抽象构件类型定义对象component_o = new ConcreteComponent();component_d = new ConcreteDecorator(component_o);component_d.Operation(); 而不应该使用以下代码：12ConcreteComponent component_o; // 使用具体构件类型定义对象component_o = new ConcreteComponent(); 或12ConcreteComponent component_d; // 使用具体构件类型定义对象component_d = new ConcreteComponent(); 对于多次装饰而言，在客户端中存在以下代码片段：12345678...Component component_o, component_d1,component_d2; // 全部使用抽象构件定义component_o = new ConcreteComponent();component_d1 = new ConcreteDecorator(component_o);component_d2 = new ConcreteDecorator(component_d1);component_d2.Operation();// 无法单独调用component_d2的AddedBehavior()方法... 使用抽象构件类型Component定义全部具体构件对象和具体装饰对象，客户端可以一致地使用这些对象，因此符合透明装饰模式的要求。 透明装饰模式可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别，此外，还可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象。在实现透明装饰模式时，要求具体装饰类的Operation()方法覆盖抽象装饰类的Operation()方法，除了调用原有对象的Operation()外还需要调用新增的AddedBehavior()方法来增加新行为。但是由于在抽象构件中并没有声明AddedBehavior()方法，因此，无法在客户端单独调用该方法，在本章上一节图形界面构件库的设计方案中使用的就是透明装饰模式。 2.半透明装饰模式 透明装饰模式的设计难度较大，而且有时需要单独调用新增的业务方法。为了能够调用到新增方法，不得不用具体装饰类型来定义装饰之后的对象，而具体构件可以继续使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式。也就是说，对于客户端而言，对具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的。客户端代码片段如下：123456789...Component component_o; // 使用抽象构件类型定义component_o = new ConcreteComponent();component_o.Operation();ConcreteDecorator component_d; // 使用具体装饰类型定义component_d = new ConcreteDecorator(component_o);component_d.Operation();component_d.AddedBehavior(); // 单独调用新增业务方法... 半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便；但是其最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。在实现半透明的装饰模式时，只需在具体装饰类中增加一个独立的AddedBehavior()方法来封装相应的业务处理即可，由于客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用AddedBehavior()方法。 装饰模式的优缺点与适用环境装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和用于装饰的具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。使用装饰模式将大大减少子类的个数，让系统扩展起来更加方便，而且更容易维护，是取代继承复用的有效方式之一。在软件开发中，装饰模式得到了较为广泛的应用。 装饰模式的优点装饰模式的主要优点如下： (1)对于扩展一个对象的功能，装饰模式比继承更加灵活，不会导致类的个数急剧增加。 (2)装饰模式可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。 (3)装饰模式可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。 (4)在装饰模式中，具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，且原有类库代码无须改变，符合开闭原则。 装饰模式的缺点装饰模式的主要缺点如下: (1)使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程度上影响程序的性能。 (2)装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也更困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 装饰模式的适用环境在以下情况下可以考虑使用装饰模式： (1)在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。 (2)当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两种：第一种是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二种是因为类已定义为不能被继承（例如C#语言中的密封类，即使用sealed关键字修饰的类）。 本章小结(1)装饰模式用于动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案，它是一种对象结构型模式。 (2)装饰模式包含抽象构件、具体构件、抽象装饰类和具体装饰类4个角色。其中，抽象构件是具体构件类和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法；具体构件实现了在抽象构件中声明的方法，装饰类可以给它增加额外的职责（方法）；抽象装饰类用于给具体构件增加职责，但是具体职责在其子类中实现；具体装饰类负责向构件添加新的职责。 (3)装饰模式的主要优点是在扩展功能时比继承更加灵活，不会导致类的个数急剧增加；它通过一种动态的方式来扩展一个对象的功能，可以对一个对象进行多次装饰，还通过使用不同的具体装饰类以及这些装饰类的排列组合，创造出很多不同行为的组合，得到功能更为强大的对象；具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，且原有类库代码无须改变，符合开闭原则。其主要缺点是使用装饰模式进行系统设计时将产生很多小对象；此外，装饰模式比继承更加易于出错，排错也更困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。 (4)装饰模式适用的环境：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时也可以使用装饰模式。 (5)装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允许用户在客户端声明具体装饰类型的对象，从而可以单独调用在具体装饰类中新增的方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[组合模式]]></title>
    <url>%2F2019%2F09%2F23%2F%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 组合模式使用面向对象的方式来处理树形结构。经常会遇到什么树形结构？ 组合模式的设计动机是用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象。怎么理解？ 组合模式为什么是结构型模式？ 组合模式的关键在于定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。怎么理解？ 组合模式是怎么使用递归的？ 容器构件维护一个列表。怎么理解？ 本章导学 组合模式关注那些包含叶子构件和容器构件的结构以及它们的组织形式，在叶子构件中不包含成员对象，而容器构件中可以包含成员对象，这些对象通过递归组合可构成一个树形结构。组合模式使用面向对象的方式来处理树形结构，它为叶子构件和容器构件提供了一个公共的抽象构件类，客户端可以针对抽象构件进行处理，而无须关心所操作的是叶子构件还是容器构件。 本章将学习组合模式的定义与结构，通过如何处理树形结构来学习组合模式的实现，结合实例学习如何在软件开发中应用组合模式，还将学习透明组合模式和安全组合模式的结构与区别。 本章知识点 组合模式的定义 组合模式的结构 组合模式的实现 组合模式的应用 组合模式的优缺点 组合模式的适用环境 透明组合模式与安全组合模式 组合模式概述树形结构在软件中随处可见，例如操作系统中的目录结构、应用软件中的菜单结构、办公系统中的公司组织结构等。在Windows操作系统中，就存在着图1所示的目录结构。 图1 Windows目录结构 与图1相对应的树形目录结构如图2所示。 图2 树形目录结构示意图 在图2中包含文件（黄色结点，例如“小龙女.jpg”和“九阴真经.txt”）和文件夹（白色结点，例如“我的资料”和“图像文件”）两类不同的元素，其中，在文件夹中可以包含文件，还可以继续包含子文件夹，但是在文件中不能再包含子文件或者子文件夹。在此，可以称文件夹为容器（Container），而不同类型的文件是其成员，又称为叶子（Leaf）。 对于所有与目录结构相类似的树形结构，当容器对象（例如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，例如子文件夹和文件）并调用执行，牵一而动百，其中使用了递归调用的机制来对整个结构进行处理。由于容器对象和叶子对象在功能上的区别，在使用这些对象的代码中必须有区别地对待容器对象和叶子对象，而实际上大多数情况下客户端希望一致地处理它们，因为对于这些对象的区别对待将会使程序非常复杂。 组合模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树结构的一部分，它描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象，这就是组合模式的模式动机。 组合模式的定义如下：1组合多个对象形成树形结构以表示具有部分——整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。 组合模式又称为“部分-整体”（Part-Whole）模式，属于对象结构型模式，它将对象组织到树形结构中，可以用来描述整体与部分的关系。 组合模式的结构与实现组合模式的结构组合模式的结构如图3所示。 图3 组合模式结构图 由图3可知，组合模式包含以下3个角色。 (1)Component（抽象构件）：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。 (2)Leaf（叶子构件）：它在组合结构中表示叶子结点对象，叶子结点没有子结点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过抛出异常、提示错误等方式进行处理。 (3)Composite（容器构件）：它在组合结构中表示容器结点对象，容器结点包含子结点，其子结点可以是叶子结点，也可以是容器结点，它提供一个集合用于存储子结点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子结点的业务方法。 组合模式的实现组合模式的关键在于定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立了一种聚合关联关系，在容器对象中既可以包含叶子，又可以包含容器，以此实现递归组合，形成一个树形结构。 如果不使用组合模式，客户端代码将过多地依赖于容器对象复杂的内部实现结构，容器对象内部实现结构的变化将引起客户代码的频繁变化，造成代码维护困难、可扩展性差等问题，组合模式的使用将在一定程度上解决这些问题。 下面通过简单的示例代码来分析组合模式的各个角色的用途和实现。 对于组合模式中的抽象构件角色，其典型代码如下：1234567abstract class Component&#123; public abstract void Add(Component c); // 增加成员 public abstract void Remove(Component c); // 删除成员 public abstract Component GetChild(int i); // 获取成员 public abstract void Operation(); // 业务方法&#125; 通常将抽象构件类设计为接口或抽象类，将所有子类共有方法的声明和实现放在抽象构件类中。对于客户端而言，将针对抽象构件编程，而无须关心其具体子类是容器构件还是叶子构件。 如果继承抽象构件的是叶子构件，其典型代码如下：1234567891011121314151617181920212223class Leaf : Component&#123; public override void Add(Component c) &#123; // 异常处理或错误提示 &#125; public override void Remove(Component c) &#123; // 异常处理或错误提示 &#125; public override Component GetChild(int i) &#123; // 异常处理或错误提示 return null; &#125; public override void Operation() &#123; // 叶子构件具体业务方法的实现 &#125;&#125; 作为抽象构件类的子类，在叶子构件中需要实现在抽象构件类中声明的所有方法，包括业务方法以及管理和访问子构件的方法，但是叶子构件不能再包含子构件，因此在叶子构件中实现子构件管理和访问方法时需要提供异常处理或错误提示。显然，这会给叶子构件的实现带来麻烦。 如果继承抽象构件的是容器构件，其典型代码如下：12345678910111213141516171819202122232425262728293031using System;using System.Collections.Generic;class Composite : Component&#123; private List&lt;Component&gt; list = new List&lt;Component&gt;(); public override void Add(Component c) &#123; list.Add(c); &#125; public override void Remove(Component c) &#123; list.Remove(c); &#125; public override Component GetChild(int i) &#123; return (Component)list[i]; &#125; public override void Operation() &#123; foreach(Object obj in list) &#123; // 容器构件具体业务方法的实现，将递归调用成员构件的业务方法 ((Component)obj).Operation(); &#125; &#125;&#125; 在容器构件中实现了在抽象构件中声明的所有方法，既包括业务方法，也包括用于访问和管理成员子构件的方法，如Add()、Remove()和GetChild()等方法。需要注意的是，在实现具体业务方法时，由于容器构件充当的是容器角色，包含成员构件，因此它将调用其成员构件的业务方法。在组合模式结构中，由于容器构件中仍然可以包含容器构件，因此在对容器构件进行处理时需要使用递归算法，即在容器构件的Operation()方法中递归调用其成员构件的Operation()方法。 组合模式的应用实例下面通过一个应用实例来进一步学习和理解组合模式。 1.实例说明 某软件公司要开发一个杀毒（AntiVirus）软件，该软件既可以对某个文件夹（Folder）杀毒，也可以对某个指定的文件（File）进行杀毒。该杀毒软件还可以根据各类文件的特点，为不同类型的文件提供不同的杀毒方式，例如图像文件（ImageFile）和文本文件（TextFile）的杀毒方式就有所差异。现使用组合模式来设计该杀毒软件的整体框架。 2.实例类图 通过分析，本实例的结构如图4所示。 图4 杀毒软件框架设计结构图 在图4中，AbstractFile充当抽象构件类，Folder充当容器构件类，ImageFile、TextFile和VideoFile充当叶子构件类。 3.实例代码 (1)AbstractFile：抽象文件类，充当抽象构件类。 12345678910namespace CompositeSample&#123; abstract class AbstractFile &#123; public abstract void Add(AbstractFile file); public abstract void Remove(AbstractFile file); public abstract AbstractFile GetChild(int i); public abstract void KillVirus(); &#125;&#125; (2)ImageFile：图像文件类，充当叶子构件类。 123456789101112131415161718192021222324252627282930313233343536using System;namespace CompositeSample&#123; class ImageFile : AbstractFile &#123; private string name; public ImageFile(string name) &#123; this.name = name; &#125; public override void Add(AbstractFile file) &#123; Console.WriteLine("对不起，不支持该方法！"); &#125; public override void Remove(AbstractFile file) &#123; Console.WriteLine("对不起，不支持该方法！"); &#125; public override AbstractFile GetChild(int i) &#123; Console.WriteLine("对不起，不支持该方法！"); return null; &#125; public override void KillVirus() &#123; // 模拟杀毒 Console.WriteLine("----对图像文件'&#123;0&#125;'进行杀毒",name); &#125; &#125;&#125; (3)TextFile：文本文件类，充当叶子构件类。 123456789101112131415161718192021222324252627282930313233343536using System;namespace CompositeSample&#123; class TextFile : AbstractFile &#123; private string name; public TextFile(string name) &#123; this.name = name; &#125; public override void Add(AbstractFile file) &#123; Console.WriteLine("对不起，不支持该方法！"); &#125; public override void Remove(AbstractFile file) &#123; Console.WriteLine("对不起，不支持该方法！"); &#125; public override AbstractFile GetChild(int i) &#123; Console.WriteLine("对不起，不支持该方法！"); return null; &#125; public override void KillVirus() &#123; // 模拟杀毒 Console.WriteLine("----对文本文件'&#123;0&#125;'进行杀毒",name); &#125; &#125;&#125; (4)VideoFile：视频文件类，充当叶子构件类。 123456789101112131415161718192021222324252627282930313233343536using System;namespace CompositeSample&#123; class VideoFile : AbstractFile &#123; private string name; public VideoFile(string name) &#123; this.name = name; &#125; public override void Add(AbstractFile file) &#123; Console.WriteLine("对不起，不支持该方法！"); &#125; public override void Remove(AbstractFile file) &#123; Console.WriteLine("对不起，不支持该方法！"); &#125; public override AbstractFile GetChild(int i) &#123; Console.WriteLine("对不起，不支持该方法！"); return null; &#125; public override void KillVirus() &#123; // 模拟杀毒 Console.WriteLine("----对视频文件'&#123;0&#125;'进行杀毒",name); &#125; &#125;&#125; (5)Folder：文件夹类，充当容器构件类。 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;using System.Collections.Generic;namespace CompositeSample&#123; class Folder : AbstractFile &#123; // 定义集合fileList，用于存储AbstractFile类型的成员 private List&lt;AbstractFile&gt; fileList = new List&lt;AbstractFile&gt;(); private string name; public Folder(string name) &#123; this.name = name; &#125; public override void Add(AbstractFile file) &#123; fileList.Add(file); &#125; public override void Remove(AbstractFile file) &#123; fileList.Remove(file); &#125; public override AbstractFile GetChild(int i) &#123; return (AbstractFile)fileList[i]; &#125; public override void KillVirus() &#123; Console.WriteLine("****对文件夹'&#123;0&#125;'进行杀毒",name); // 模拟杀毒 // 递归调用成员构件的killVirus()方法 foreach(Object obj in fileList) &#123; ((AbstractFile)obj).KillVirus(); &#125; &#125; &#125;&#125; (6)Program：客户端测试类。 1234567891011121314151617181920212223242526272829303132333435363738using System;using System.Collections.Generic;namespace CompositeSample&#123; class Program &#123; static void Main(string[] args) &#123; // 针对抽象构件编程 AbstractFile file1, file2, file3, file4, file5, folder1, folder2, folder3, folder4; folder1 = new Folder("我的资料"); folder2 = new Folder("图像文件"); folder3 = new Folder("文本文件"); folder4 = new Folder("视频文件"); file1 = new ImageFile("小龙女.jpg"); file2 = new ImageFile("张无忌.gif"); file3 = new TextFile("九阴真经.txt"); file4 = new TextFile("葵花宝典.doc"); file5 = new VideoFile("神雕侠侣.rmvb"); folder2.Add(file1); folder2.Add(file2); folder3.Add(file3); folder3.Add(file4); folder4.Add(file5); folder1.Add(folder2); folder1.Add(folder3); folder1.Add(folder4); // 从“我的资料”节点开始进行杀毒操作 folder1.KillVirus(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结构如下：123456789****对文件夹&apos;我的资料&apos;进行杀毒****对文件夹&apos;图像文件&apos;进行杀毒----对图像文件&apos;小龙女.jpg&apos;进行杀毒----对图像文件&apos;张无忌.gif&apos;进行杀毒****对文件夹&apos;文本文件&apos;进行杀毒----对文本文件&apos;九阴真经.txt&apos;进行杀毒----对文本文件&apos;葵花宝典.doc&apos;进行杀毒****对文件夹&apos;视频文件&apos;进行杀毒----对视频文件&apos;神雕侠侣.rmvb&apos;进行杀毒 在本实例中，抽象构件类声明了所有方法，包括用于管理和访问子构件的方法，如Add()方法和Remove()方法等，因此，在ImageFile等叶子构件类中实现这些方法时必须进行相应的异常处理或错误提示。在容器构件类Folder的KillVirus()方法中将递归调用其成员对象的KillVirus()方法，从而实现对整个树形结构的遍历。 如果需要更换操作结点，例如只对文件夹“文本文件”进行杀毒，客户端代码只需修改一行即可，将代码：1folder1.KillVirus(); 改为：1folder3.KillVirus(); 输出结果如下：123****对文件夹&apos;文本文件&apos;进行杀毒 ----对文本文件&apos;九阴真经.txt&apos;进行杀毒 ----对文本文件&apos;葵花宝典.doc&apos;进行杀毒 在具体实现时，可以创建图形化界面让用户来选择所需操作的根结点，无须修改源代码，符合开闭原则，客户端无须关心结点的层次结构，可以对所选结点进行统一处理，从而提高系统的灵活性。 透明组合模式与安全组合模式组合模式根据抽象构件类的定义形式不同，可以分为透明组合模式和安全组合模式。 1.透明组合模式 在透明组合模式中，抽象构件Component中声明了所有用于管理成员对象的方法，包括Add()、Remove()、以及GetChild()等方法，如图5所示，这样做的好处是确保了所有的构件类都有相同的接口。在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象。 图5 透明组合模式结构图 透明组合模式的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此为其提供Add()、Remove()及GetChild()等方法是没有意义的，这在编译阶段不会出错，但在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）。 2.安全组合模式 在安全组合模式中，抽象构件Component中没有声明任何用于管理成员对象的方法，而是在Composite类中声明并实现这些方法，如图6所示。这样做是安全的，因为根本向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法。 图6 安全组合模式结构图 安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，容器构件中用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。在实际应用中，安全组合模式的使用频率也非常高。 组合模式的优缺点与适用环境组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式。 组合模式的优点组合模式的主要优点如下： (1)组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，让客户端忽略了层次的差异，方便对整个层次结构进行控制。 (2)客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。 (3)在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合开闭原则。 (4)为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。 组合模式的缺点组合模式的主要缺点如下： 在增加新构件时很难对容器中的构件类型进行限制。有时希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。 组合模式的适用环境在以下情况下可以考虑使用组合模式： (1)在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。 (2)在一个使用面向对象语言开发的系统中需要处理一个树形结构。 (3)在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。 本章小结(1)组合模式用于组合多个对象形成树形结构以表示具有部分整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。组合模式又可以称为“部分整体”模式，是一种对象结构型模式。 (2)组合模式包含抽象构件、叶子构件和容器构件3个角色。其中，抽象构件为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现；叶子构件在组合结构中表示叶子结点对象，叶子结点没有子结点；容器构件在组合结构中表示容器结点对象，容器结点包含子结点，其子结点可以是叶子结点，也可以是容器结点，它提供一个集合用于存储子结点，实现了在抽象构件中定义的行为。 (3)组合模式的主要优点在于可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制；客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码;增加新的容器构件和叶子构件都很方便。其主要缺点是在增加新构件时很难对容器中的构件类型进行限制。 (4)组合模式适用的环境：在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们；在一个使用面向对象语言开发的系统中需要处理一个树形结构；在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。 (5)根据抽象构件类的定义形式不同，组合模式可以分为透明组合模式和安全组合模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2019%2F09%2F23%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F-3%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 适配器模式和代理模式有什么区别？ 本章导学 结构型模式关注如何将现有类或对象组织在一起形成更加强大的结构，在GOF设计模式中包含7种结构型设计模式，它们适用于不同的环境，使用不同的方式组合类与对象，使之可以协同工作。 适配器模式是一种使用频率非常高的结构型设计模式，如果在系统中存在不兼容的接口，可以通过引入一个适配器来使得原本因为接口不兼容而不能一起工作的两个类可以协同工作。 本章将对7种结构型模式进行简要的介绍，学习适配器模式的定义，掌握类适配器模式和对象适配器模式的结构与实现方式，并结合实例学习如何在实际软件项目开发中应用适配器模式，还将学习缺省适配器模式和双向适配器模式等适配器模式的扩展形式。 本章知识点 适配器模式的定义 适配器模式的结构 适配器模式的实现 适配器模式的应用 适配器模式的优缺点 适配器模式的适用环境 缺省适配器模式 双向适配器 结构型模式在面向对象软件系统中，每个类/对象都承担了一定的职责，它们可以相互协作，实现一些复杂的功能。结构型模式（Structural Pattern）关注如何将现有类或对象组织在一起形成更加强大的结构。不同的结构型模式从不同的角度组合类或对象，它们在尽可能满足各种面向对象设计原则的同时为类或对象的组合提供一系列巧妙的解决方案。 结构型模式可以描述两种不同的东西：类与类的实例（即对象）。根据这一点，结构型模式可以分为类结构型模式和对象结构型模式。类结构型模式关心类的组合，由多个类组合成一个更大的系统，在类结构型模式中一般只存在继承关系和实现关系；而对象结构型模式关心类与对象的组合，通过关联关系，在一个类中定义另一个类的实例对象，然后通过该对象调用相应的方法。根据合成复用原则，在系统中尽量使用关联关系来替代继承关系，因此，大部分结构型模式都是对象结构型模式。 在GoF设计模式中包含7种结构型模式，它们的名称、定义、学习难度和使用频率如表1所示。 表1 结构型模式一览表 名 称 定 义 学习难度 使用频率 适配器模式(Adapter Pattern) 将一个类的接口转换成客户希望的另一个接口。适配器模式让那些接口不兼容的类可以一起工作。 ★★☆☆☆ ★★★★☆ 桥接模式(Bridge Pattern) 将抽象部分与它的实现部分解耦，使得两者都能够独立变化。 ★★★☆☆ ★★★☆☆ 组合模式(Composite Pattern) 组合多个对象形成树形结构，以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。 ★★★☆☆ ★★★★☆ 装饰模式(Decorator Pattern) 动态地给一个对象增加一些额外的职责。就扩展功能而言，装饰模式提供了一种比使用子类更加灵活的替代方案。 ★★★☆☆ ★★★☆☆ 外观模式(Facade Pattern) 为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 ★☆☆☆☆ ★★★★★ 享元模式(Flyweight Pattern) 运用共享技术有效地支持大量细粒度对象的复用。 ★★★★☆ ★☆☆☆☆ 代理模式(Proxy Pattern) 给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 ★★★☆☆ ★★★★☆ 适配器模式概述众所周知，我们国家的生活用电的电压是220V，而笔记本电脑、手机等电子设备的工作电压没有这么高，为了使笔记本电脑、手机等设备可以使用220V的生活用电，需要电源适配器（AC Adapter)，也就是充电器或变压器，有了这个电源适配器，生活用电和笔记本电脑就可以兼容了。在这里，电源适配器充当了一个适配器的角色，如图1所示。 图1 电源适配器示意图 在软件开发中，有时也存在类似这种不兼容的情况，也可以像引入一个电源适配器那样引入一个称之为适配器的角色来协调这些存在不兼容的结构，这种设计方案即为适配器。 与电源适配器相似，在适配器模式中引入了一个被称为适配器（Adapter）的包装类，而它所包装的对象称为适配者（Adaptee），即被适配的类。适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器让那些由于接口不兼容而不能交互的类可以一起工作。 适配器模式可以将一个类的接口和另一个类的接口匹配起来，而无须修改原来的适配者接口和抽象目标类接口。 适配器模式的定义如下：1将一个类的接口转换成客户希望的另一个接口适配器模式让那些接口不兼容的类可以一起工作。 适配器模式的别名为包装器（Wrapper）模式，它既可以作为类结构型模式，也可以作为对象结构型模式，在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合。 适配器模式的结构与实现适配器模式包括类适配器和对象适配器。在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。下面分别对两种适配器进行结构分析。 适配器模式的结构类适配器模式的结构如图2所示。 图2 类适配器模式结构图 对象适配器模式的结构如图3所示。 图3 对象适配器模式结构图 由图2和图3可知，适配器模式包含以下3个角色。 (1)Target（目标抽象类）：目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类。在类适配器中，由于C#语言不支持多重继承，它只能是接口。 (2)Adapter（适配器类）：它可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配。适配器Adapter是适配器模式的核心，在类适配器中，它通过实现Target接口并继承Adaptee类来使二者产生联系，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。 (3)Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下甚至没有适配者类的源代码。 适配器模式的实现由于适配器模式包括类适配器模式和对象适配器模式两种形式，下面分别介绍这两种适配器模式的实现机制。 1.类适配器 根据图2所示的类适配器模式结构图，在类适配器中，适配者类Adaptee没有Request()方法，而客户期待这个方法，但在适配者类中实现了SpecificRequest()方法，该方法所提供的实现正是客户所需要的。为了使客户能够使用适配者类，提供了一个中间类，即适配器类Adapter，适配器类实现了抽象目标类接口Target，并继承了适配者类，在适配器类的Request()方法中调用所继承的适配者类的SpecificRequest()方法，达到了适配的目的。因为适配器类与适配者类是继承关系，所以这种适配器模式称为类适配器模式。典型的类适配器代码如下：1234567class Adapter : Adaptee, Target&#123; public void Request() &#123; base.SpecificRequest(); &#125;&#125; 2.对象适配器 根据图3所示的对象适配器模式结构图，在对象适配器中，客户端需要调用Request()方法，而适配者类Adaptee没有该方法，但是它所提供的SpecificRequest()方法却是客户端所需要的。为了使客户端能够使用适配者类，需要提供一个包装类Adapter，即适配器类。这个包装类包装了一个适配者的实例，从而将客户端与适配者衔接起来，在适配器的Request()方法中调用适配者的SpecificRequest()方法。因为适配器类与适配者类是关联关系（也可称为委派关系），所以这种适配器模式称为对象适配器模式。典型的对象适配器代码如下：1234567891011121314class Adapter : Target&#123; private Adaptee adaptee; // 维持一个对适配器对象的引用 public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void Request() &#123; adaptee.SpecificRequest(); // 转发调用 &#125;&#125; 适配器模式可以将一个类的接口和另一个类的接口匹配起来，使用的前提是不能或不想修改原来的适配者接口和抽象目标类接口。例如，购买了一些第三方类库或控件，但是没有源代码，此时使用适配器模式可以统一对象访问接口。 适配器模式更多的是强调对代码的组织，而不是功能的实现。在实际开发中，对象适配器的使用频率更高。 适配器模式的应用实例下面通过一个应用实例进一步学习和理解适配器模式。 1.实例说明 在为某学校开发教务管理系统时，开发人员发现需要对学生成绩进行排序和查找，该系统的设计人员已经开发了一个成绩操作接口ScoreOperation，在该接口中声明了排序方法Sort(int[])和查找方法Search(int[], int)，为了提高排序和查找的效率，开发人员决定重用现有算法库中的快速排序算法类QuickSortClass和二分查找算法类BinarySearchClass，其中，QuickSortClass的QuickSort(int[])方法实现了快速排序，BinarySearchClass的BinarySearch(int[], int)方法实现了二分查找。由于某些原因，开发人员已经找不到该算法库的源代码，无法直接通过复制和粘贴操作来重用其中的代码；而且部分开发人员已经针对ScoreOperation接口编程，如果再要求对该接口进行修改或要求大家直接使用QuickSortClass类和BinarySearchClass类将导致大量代码需要修改。现使用适配器模式设计一个系统，在不修改已有代码的前提下将类QuickSortClass和类BinarySearchClass的相关方法适配到ScoreOperation接口中。 2.实例类图 通过分析，本实例采用对象适配器模式来实现，如图4所示。 图4 算法库重用结构图 在图4中，ScoreOperation接口充当抽象目标，QuickSortClass和BinarySearchClass类充当适配者，OperationAdapter充当适配器。 3.实例代码 (1)ScoreOperation：抽象成绩操作类，充当目标接口。12345678namespace AdapterSample&#123; interface ScoreOperation &#123; int[] Sort(int[] array); // 成绩排序 int Search(int[] array, int key); // 成绩查找 &#125;&#125; (2)QuickSortClass：快速排序类，充当适配者。 123456789101112131415161718192021222324252627282930313233343536373839404142434445namespace AdapterSample&#123; class QuickSortClass &#123; public int[] QuickSort(int[] array) &#123; Sort(array,0,array.Length - 1); return array; &#125; public void Sort(int[] array, int p, int r) &#123; int q = 0; if (p &lt; r) &#123; q = Partition(array,p,r); Sort(array,p,q - 1); Sort(array,q + 1,r); &#125; &#125; public int Partition(int[] a, int p, int r) &#123; int x = a[r]; int j = p - 1; for (int i = p;i &lt;= r - 1;i++) &#123; if (a[i] &lt;= x) &#123; j++; Swap(a,j,i); &#125; &#125; Swap(a,j + 1,r); return j + 1; &#125; public void Swap(int[] a, int i, int j) &#123; int t = a[i]; a[i] = a[j]; a[j] = t; &#125; &#125;&#125; (3)BinarySearchClass：二分查找类，充当适配者。 1234567891011121314151617181920212223242526272829namespace AdapterSample&#123; class BinarySearchClass &#123; public int BinarySearch(int[] array, int key) &#123; int low = 0; int high = array.Length -1; while (low &lt;= high) &#123; int mid = (low + high) / 2; int midVal = array[mid]; if (midVal &lt; key) &#123; low = mid +1; &#125; else if (midVal &gt; key) &#123; high = mid -1; &#125; else &#123; return 1; // 找到元素返回1 &#125; &#125; return -1; // 未找到元素返回-1 &#125; &#125;&#125; (4)OperationAdapter：操作适配器，充当适配器。 123456789101112131415161718192021222324namespace AdapterSample&#123; class OperationAdapter : ScoreOperation &#123; private QuickSortClass sortObj; // 定义适配者QuickSortClass对象 private BinarySearchClass searchObj; // 定义适配者BinarySearchClass对象 public OperationAdapter() &#123; sortObj = new QuickSortClass(); searchObj = new BinarySearchClass(); &#125; public int[] Sort(int[] array) &#123; return sortObj.QuickSort(array); // 调用适配者类QuickSortClass的排序方法 &#125; public int Search(int[] array, int key) &#123; return searchObj.BinarySearch(array, key); // 调用适配者类BinarySearchClass的查找方法 &#125; &#125;&#125; (5)配置文件App.config：在配置文件中存储了适配器类的类名。 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="adapter" value="AdapterSample.OperationAdapter"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (6)Program：客户端测试类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657using System;using System.Configuration;using System.Reflection;namespace AdapterSample&#123; class Program &#123; static void Main(string[] args) &#123; ScoreOperation operation; // 针对抽象目标接口编程 // 读取配置文件 string adapterType = ConfigurationManager.AppSettings["adapter"]; // 反射生成对象 operation = (ScoreOperation)Assembly.Load("AdapterSample").CreateInstance(adapterType); int[] scores = &#123;84,76,50,69,90,91,88,96&#125;; // 定义成绩数组 int[] result; int score; Console.WriteLine("成绩排序结果："); result = operation.Sort(scores); // 遍历输出成绩 foreach (int i in result) &#123; Console.Write(i + ","); &#125; Console.WriteLine(); Console.WriteLine("查找成绩90："); score = operation.Search(result,90); if (score != -1) &#123; Console.WriteLine("找到成绩90。"); &#125; else &#123; Console.WriteLine("没有找到成绩90。"); &#125; Console.WriteLine("查找成绩92："); score = operation.Search(result,92); if (score != -1) &#123; Console.WriteLine("找到成绩92。"); &#125; else &#123; Console.WriteLine("没有找到成绩92。"); &#125; Console.Read(); &#125; &#125;&#125; 4．结果及分析 编译并运行程序，输出结果如下：123456成绩排序结果：50,69,76,84,88,90,91,96, 查找成绩 90：找到成绩 90。 查找成绩 92：没有找到成绩92。 在本实例中使用了对象适配器模式，同时引入了配置文件，将适配器类的类名存储在配置文件App.config中。如果需要使用其他排序算法类和查找算法类，可以增加一个新的适配器类，使用新的适配器来适配新的算法，原有代码无须修改。通过引入配置文件和反射机制，可以在不修改客户端代码的情况下使用新的适配器，无须修改源代码，符合开闭原则。 缺省适配器模式缺省适配器模式是适配器模式的一种变体，其应用也较为广泛。 缺省适配器模式（Default Adapter Pattern）的定义如下：1当不需要实现一个妾口所提供的所有方法时，可先设计一个抽象类实现该接口，并为接口中的每个方法提供一个默认实现（空方法），那么该抽象类的子类可以有选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况，又称为单接口适配器模式。 缺省适配器模式的结构如图5所示。 图5 缺省适配器模式结构图 由图5可知，在缺省适配器模式中，包含以下3个角色。 (1)ServiceInterface（适配者接口）：它是一个接口，通常在该接口中声明了大量的方法。 (2)AbstractServiceClass（缺省适配器)：缺省适配器模式的核心类，使用空方法的形式实现了在Servicelnterface接口中声明的方法。通常将它定义为抽象类，因为对它进行实例化没有任何意义。 (3)ConcreteServiceClass（具体业务类）：它是缺省适配器类的子类，在没有引入适配器之前，它需要实现适配者接口，因此需要实现在适配者接口中声明的所有方法，而对于一些无须使用的方法不得不提供空实现。在有了缺省适配器之后，可以直接继承该适配器类，根据需要有选择性地覆盖在适已器类中定义的方法。 其中，缺省适配器类的典型代码片段如下：123456abstract class AbstractServiceClass : ServiceInterface&#123; public void ServiceMethod1()&#123;&#125; // 空方法 public void ServiceMethod2()&#123;&#125; // 空方法 public void ServiceMethod3()&#123;&#125; // 空方法&#125; 双向适配器在对象适配器的使用过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，那么该适配器就是一个双向适配器，其结构示意图如图6所示。 图6 双向适配器模式示意图 双向适配器的实现较为复杂，其典型代码如下：1234567891011121314151617181920212223242526public class Adapter : Target, Adaptee&#123; // 同时维持对抽象目标类和适配者的引用 private Target target; private Adaptee adaptee; public Adapter(Target target) &#123; this.target = target; &#125; public Adapter(Adaptee adaptee) &#123; this.adaptee = adaptee; &#125; public void Request() &#123; adaptee.SpecificRequest(); &#125; public void SpecificRequest() &#123; target.Request(); &#125;&#125; 适配器模式的优点无论是对象适配器模式还是类适配器模式都具有以下优点： (1)将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。 (2)增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。 (3)灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合开闭原则。 具体来说，类适配器模式还具有以下优点： 由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。 对象适配器模式还具有以下优点： (1)一个对象适配器可以把多个不同的适配者适配到同一个目标。 (2)对象适配器模式可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据里氏代换原则，适配者的子类也可通过该适配器进行适配。 适配器模式的缺点类适配器模式的主要缺点如下： (1)对于C#Java等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者。 (2)适配者类不能为最终类，例如在C#中不能为sealed类。 (3)在C#Java等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。 对象适配器模式的主要缺点如下： 与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把该适配者类的子类当作真正的适配者进行适配，其实现过程较为复杂。 适配器模式的适用环境在以下情况下可以考虑使用适配器模式： (1)系统需要使用一些现有的类，而这些类的接口（例如方法名）不符合系统的需要，甚至没有这些类的源代码。 (2)创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作。 本章小结(1)结构型模式关注如何将现有类或对象组设计模式中一共包含7种结构型模式。 (2)适配器模式将一个类的接口转换成客户希望的另一个接口，适配器模式让那些接口不兼容的类可以一起工作。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。 (3)适配器模式包含目标抽象类、适配器类和适配者类3个角色。其中，目标抽象类定义客户所需的接口，可以是一个抽象类或接口，也可以是具体类；适配器类可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配；适配者类即被适配的角色 (4)适配器模式的主要优点是将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构；增加了类的透明性和复用性且让系统的灵活性和展性都非常好，此外，在类适配器模式中置换一些适配者的方法很方便;通过对象适配器模式可以把多个不同的适配者适配到同一个目标，还可以适配一个适配者的子类。类适配器模式的主要缺点是一次最多只能适配一个适配者类，不能同时适配多个适配者；适配者类不能为最终类，且类适配器模式中的目标抽象类只能为接口，不能为类。对象适配器模式的主要缺点是在适配器中置换适配者类的某些方法比较麻烦。 (5)适配器模式适用的环境：系统需要使用一些现有的类，而这些类的接口不符合系统的需要，甚至没有这些类的源代码;想创建一个可以重复使用的类，用于和一些彼此之间没有太大关联的类，包括一些可能在将来引进的类一起工作。 (6)缺省适配器模式是指当不需要实现一个接口所提供的所有方法时，可先设计一个日象类实现该接口，并为接口中的每个方法提供一个默认实现(空方法)，那么该抽象类的子 类可以有选择性地覆盖父类的某些方法来实现需求，它适用于不想使用一个接口中的所有方法的情况。 (7)在使用对象适配器的过程中，如果在适配器中同时包含对目标类和适配者类的引用，适配者可以通过它调用目标类中的方法，目标类也可以通过它调用适配者类中的方法，该适配器就是一个双向适配器。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F2019%2F09%2F22%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是基本方法？什么是模板方法？ 模板方法模式为什么是类行为型模式？ 钩子方法的引入使得子类可以控制父类的行为。怎么实现的？ 本章导学 模板方法模式是结构最简单的行为型设计模式，它是一种类行为模式，在其结构中只存在父类与子类之间的继承关系。通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供了一个称为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。模板方法模式提供了具体的模板方法来定义算法结构，而具体步骤的实现可以在其子类中完成。 本章将学习模板方法模式的定义与结构，学习模板方法模式中所包含的几种不同的方法，并通过实例来学习模板方法模式的应用，学会如何在实际软件项目开发中合理地使用模板方法模式。 本章知识点 模板方法模式的定义 模板方法模式的结构 模板方法模式的实现 模板方法模式的应用。 模板方法模式的优缺点 模板方法模式的适用环境 钩子方法的使用 模板方法模式概述在现实生活中，很多事情都包含几个实现步骤，例如请客吃饭，无论吃什么，一般都包含点单、吃东西、买单等几个步骤，通常情况下这几个步骤的次序是：点单-&gt;吃东西-&gt;买单。在这3个步骤中，点单和买单大同小异，最大的区别在于第二步——吃什么，吃面条和吃满汉全席可大不相同。请客吃饭示意图如图1所示。 图1 请客吃饭示意图 在软件开发中，开发人员有时也会遇到类似的情况，某个方法的实现需要多个步骤（类似“请客”），其中有些步骤是固定的（类似“点单”和“买单”)，而有些步骤并不固定，存在可变性（类似“吃东西”）。为了提高代码的复用性和系统的灵活性，可以使用一种称为模板方法模式的设计模式来对这类情况进行设计。在模板方法模式中，将实现功能的每一个步骤所对应的方法称为基本方法（例如“点单”、“吃东西”和“买单”），而调用这些基本方法同时定义基本方法的执行次序的方法称为模板方法（例如“请客”）。在模板方法模式中，可以将相同的代码放在父类中，例如将模板方法“请客”以及基本方法“点单”和“买单”的实现放在父类中，而对于基本方法“吃东西”，在父类中只做一个声明，将其具体实现放在不同的子类中，在一个子类中提供“吃面条”的实现，而另一个子类提供“吃满汉全席”的实现。通过使用模板方法模式，一方面提高了代码的复用性；另一方面还可以利用面向对象的多态性，在运行时选择一种具体子类，实现完整的“请客”方法，提高系统的灵活性和可扩展性。 模板方法模式的定义如下：1定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。 模板方法模式是一种基于继承的代码复用技术，它是一种类行为型模式。 模板方法模式是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。模板方法模式提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成。 模板方法模式的结构与实现模板方法模式的结构模板方法模式的结构比较简单，其核心是抽象类和其中的模板方法的设计，其结构如由图2可知，模板方法模式包含以下两个角色。 图2 模板方法模式结构图 (1)AbstracClass（抽象类）：在抽象类中定义了一系列基本操作（Primitive Operations），这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法（Template Method），用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。 (2)ConcreteClass（具体子类）：它是抽象类的子类，用于实现在父类中声明的抽象基本操作，以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。 模板方法模式的实现在实现模板方法模式时，开发抽象类的软件设计师和开发具体子类的软件设计师之间可以进行协作。一个设计师负责给出一个算法的轮廓和框架，另一些设计师则负责给出这个算法的各个逻辑步骤。实现这些具体逻辑步骤的方法即为基本方法，而将这些基本方法汇总起来的方法即为模板方法，模板方法模式的名字也因此而来。下面详细介绍模板方法和基本方法。 1.模板方法 一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加以修改地完全继承下来。模板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。由于模板方法是具体方法，因此，模板方法模式中的抽象层只能是抽象类，而不是接口。 2.基本方法 基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为3种，即抽象方法（Abstract Method）、具体方法（Concrete Method）和钩子方法（Hook Method）。 (1)抽象方法：一个抽象方法由抽象类声明、其具体子类实现。在C#语言中，一个抽象方法以abstract关键字标识。 (2)具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。 (3)钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常，在父类中给出的实现是一个空实现（可使用virtual关键字将其定义为虚函数），并以该空实现作为方法的默认实现，当然，钩子方法也可以提供一个非空的默认实现。 在模板方法模式中，钩子方法有两类：第一类钩子方法可以与一些具体步骤“挂钩”，以实现在不同条件下执行模板方法中的不同步骤，这类钩子方法的返回类型通常是bool类型，方法名一般为IsXXX()，用于对某个条件进行判断，如果条件满足，则执行某一步骤，否则不执行，代码片段如下：12345678910111213141516171819...// 模板方法public void TemplateMethod()&#123; Open(); Display(); // 通过钩子方法来确定某步骤是否执行 if (IsPrint) &#123; Print(); &#125;&#125;// 钩子方法public bool IsPrint()&#123; return true;&#125;... 在该段代码中，IsPrint()方法即钩子方法，它可以决定Print()方法是否执行，一般情况下，钩子方法的返回值为true，如果不希望某方法执行，可以在其子类中覆盖钩子方法，将其返回值改为false即可，这种类型的钩子方法可以控制方法的执行，对一个算法进行约束。 还有一类钩子方法就是实现体为空的具体方法，子类可以根据需要覆盖或者继承这些钩子方法，与抽象方法相比，这类钩子方法的好处在于子类如果没有覆盖父类中定义的钩子方法，编译可以正常通过，但是如果没有覆盖父类中声明的抽象方法，编译将报错。 在模板方法模式中，抽象类的典型代码如下：12345678910111213141516171819202122232425abstract class AbstracClass&#123; // 模板方法 public void TemplateMethod() &#123; PrimitiveOperation1(); PrimitiveOperation2(); PrimitiveOperation3(); &#125; // 基本方法——具体方法 public void PrimitiveOperation1() &#123; // 实现代码 &#125; // 基本方法——抽象方法 public abstract void PrimitiveOperation2(); // 基本方法——钩子方法 public virtual void PrimitiveOperation3() &#123; &#125;&#125; 在抽象类中，模板方法TemplateMethod()定义了算法的框架，在模板方法中调用基本方法以实现完整的算法，每一个基本方法（如PrimitiveOperation1()、PrimitiveOperation2()等）均实现了算法的一部分，对于所有子类都相同的基本方法可以在父类提供具体实现，例如PrimitiveOperation1()，否则在父类声明为抽象方法或钩子方法，由不同的子类提供不同的实现，例如PrimitiveOperation2()和PrimitiveOperation3()。 用户可在抽象类的子类中提供抽象步骤的实现，也可覆盖父类中已经实现的具体方法，具体子类的典型代码如下：123456789101112class ConcreteClass : AbstracClass&#123; public override void PrimitiveOperation2() &#123; // 实现代码 &#125; public override void PrimitiveOperation3() &#123; // 实现代码 &#125;&#125; 在模板方法模式中，由于面向对象的多态性，子类对象在运行时将覆盖父类对象，子类中定义的方法也将覆盖父类中定义的方法，因此程序在运行时，具体子类的基本方法将覆父类中定义的基本方法，子类的钩子方法将覆盖父类的钩子方法，从而可以通过在子类中实现的钩子方法对父类方法的执行进行约束，实现子类对父类行为的反向控制。 模板方法模式的应用实例下面通过一个应用实例来进一步学习和理解模板方法模式。 1.实例说明 某软件公司要为某银行的业务支撑系统开发一个利息计算模块，利息的计算流程如下：(1)系统根据账号和密码验证用户信息，如果用户信息错误，则系统显示出错提示。(2)如果用户信息正确，则根据用户类型的不同使用不同的利息计算公式计算利息（如活期账户和定期账户具有不同的利息计算公式）。(3)系统显示利息。现使用模板方法模式设计该利息计算模块。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 银行利息计算模块结构图 在图3中，Account充当抽象类角色，CurrentAccount和SavingAccount充当具体子类角色。 3.实例代码 (1)Account：账户类、充当抽象类。 123456789101112131415161718192021222324252627282930313233343536373839404142434445using System;namespace TemplateMethodSample&#123; abstract class Account &#123; // 基本方法——具体方法 public bool Validate(string account, string password) &#123; Console.WriteLine("账号：&#123;0&#125;", account); Console.WriteLine("密码：&#123;0&#125;", password); // 模拟登录 if (account.Equals("张无忌") &amp;&amp; password.Equals("123456")) &#123; return true; &#125; else &#123; return false; &#125; &#125; // 基本方法——抽象方法 public abstract void CalculateInterest(); // 基本方法——具体方法 public void Display() &#123; Console.WriteLine("显示利息！"); &#125; // 模板方法 public void Handle(string account, string password) &#123; if (!Validate(account,password)) &#123; Console.WriteLine("账户或密码错误！"); return; &#125; CalculateInterest(); Display(); &#125; &#125;&#125; (2)CurrentAccount：活期账户类，充当具体子类。 12345678910111213using System;namespace TemplateMethodSample&#123; class CurrentAccount : Account &#123; // 覆盖父类的抽象基本方法 public override void CalculateInterest() &#123; Console.WriteLine("按活期利率计算利息！"); &#125; &#125;&#125; (3)SavingAccount：定期账户类，充当具体子类。 12345678910111213using System;namespace TemplateMethodSample&#123; class SavingAccount : Account &#123; // 覆盖父类的抽象基本方法 public override void CalculateInterest() &#123; Console.WriteLine("按定期利率计算利息！"); &#125; &#125;&#125; (4)配置文件App.config：在配置文件中存储了具体子类的类名。 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="subClass" value="TemplateMethodSample.CurrentAccount"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (5)Program：客户端测试类。 123456789101112131415161718192021using System;using System.Configuration;using System.Reflection;namespace TemplateMethodSample&#123; class Program &#123; static void Main(string[] args) &#123; Account account; // 读取配置文件 string subClassStr = ConfigurationManager.AppSettings["subClass"]; // 反射生成对象 account = (Account)Assembly.Load("TemplateMethodSample").CreateInstance(subClassStr); account.Handle("张无忌", "123456"); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下:1234账号：张无忌 密码：123456 按活期利率计算利息！ 显示利息！ 如果需要更换具体子类，无须修改源代码，只需修改配置文件App.config即可。例如将活期账户（Current Account）改为定期账户（Saving Account），只需将存储在配置文件中的具体子类CurrentAccount改为SavingAccount，代码如下：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="subClass" value="TemplateMethodSample.SavingAccount"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 重新运行客户端程序，输出结果如下:1234账号：张无忌 密码：123456 按定期利率计算利息！显示利息！ 如果需要增加新的具体子类（新的账户类型），原有代码无须修改，完全符合开闭原则。 钩子方法的使用在模板方法模式中，父类提供了一个定义算法框架的模板方法，还提供了一系列抽象方法、具体方法和钩子方法，其中，钩子方法的引入使得子类可以控制父类的行为。最简单的钩子方法就是空方法，其代码如下：1public virtual void Display()&#123;&#125; 当然，用户也可以在钩子方法中定义一个默认的实现，如果子类不覆盖钩子方法，则执行父类的默认实现代码。 另一种钩子方法可以实现对其他方法进行约束，这种钩子方法通常返回一个bool类型，即返回true或false，用来判断是否执行某一个基本方法。下面通过一个实例来说明这种钩子方法的使用。 某软件公司要为销售管理系统提供一个数据图表显示功能，该功能的实现包括以下几个步骤：(1)从数据源获取数据。(2)将数据转换为XML格式。(3)以某种图表方式显示XML格式的数据。该功能支持多种数据源和多种图表显示方式，但所有的图表显示操作都基于XML格式的数据，因此可能需要对数据进行转换，如果从数据源获取的数据已经是XML数据，则无须转换。 由于该数据图表显示功能的3个步骤次序是固定的，且存在公共代码（例如数据格式转换代码），满足模板方法模式的适用条件，可以使用模板方法模式对其进行设计。因为数据格式不同，XML数据可以直接显示，而其他格式的数据需要进行转换，因此第(2)步“将数据转换为XML格式”的执行存在不确定性，为了解决这个问题，可以定义一个钩子方法IsNotXMLData()对数据转换方法进行控制。通过分析，该图表显示功能的基本结构如图4所示。 图4 数据图表显示功能结构图 用户可以将公共方法和框架代码放在抽象父类中，其代码如下：12345678910111213141516171819202122232425262728293031323334353637using System;namespace TemplateMethodSample&#123; abstract class DataViewer &#123; // 抽象方法：获取数据 public abstract void GetData(); // 具体方法：转换数据 public void ConvertData() &#123; Console.WriteLine("将数据转换为XML格式。"); &#125; // 抽象方法：显示数据 public abstract void DisplayData(); // 钩子方法：判断是否为XML格式的数据 public virtual bool IsNotXMLData() &#123; return true; &#125; // 模板方法 public void Process() &#123; GetData(); // 如果不是XML格式的数据则进行数据转换 if (IsNotXMLData()) &#123; ConvertData(); &#125; DisplayData(); &#125; &#125;&#125; 在上面的代码中，引入了一个钩子方法IsNotXMLData()，其返回类型为bool类型，在模板方法中通过它来对数据转换方法ConvertData()进行约束，该钩子方法的默认返回值为true，在子类中可以根据实际情况覆盖该方法，其中，用于显示XML格式数据的具体子类XMLDataViewer的代码如下：12345678910111213141516171819202122232425using System;namespace TemplateMethodSample&#123; class XMLDataViewer : DataViewer &#123; // 实现父类方法：获取数据 public override void GetData() &#123; Console.WriteLine("从XML文件中获取数据。"); &#125; // 实现父类方法：显示数据 public override void DisplayData() &#123; Console.WriteLine("以柱状图显示数据。"); &#125; // 覆盖父类的钩子方法 public override bool IsNotXMLData() &#123; return false; &#125; &#125;&#125; 在具体子类XMLDataViewer中覆盖了钩子方法IsNotXMLData()，返回false，表示该数据已为XML格式，无须执行数据转换方法ConvertData()。客户端代码如下：12345678910111213141516using System;namespace TemplateMethodSample&#123; class Program &#123; static void Main(string[] args) &#123; DataViewer dv; dv = new XMLDataViewer(); dv.Process(); Console.Read(); &#125; &#125;&#125; 该程序的运行结果如下：12从XML文件中获取数据。 以柱状图显示数据。 模板方法模式的优缺点与适用环境模板方法模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式。模板方法模式被广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序（如框架的初始化、测试流程的设置等）。 模板方法模式的优点模板方法模式的主要优点如下： (1)在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。 (2)模板方法模式是一种代码复用技术，在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励用户恰当地使用继承来实现代码复用。 (3)模板方法模式可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。 (4)在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。 模板方法模式的缺点模板方法模式的主要缺点如下: 模板方法模式需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统会更加庞大，设计也会更加抽象，此时，可结合桥接模式来进行设计。 模板方法模式的适用环境在以下情况下可以考虑使用模板方法模式： (1)对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而将一些可以改变的细节由其子类来实现，即一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。 (2)各子类中公共的行为应被提取出来，并集中到一个公共父类中，以避免代码重复。 (3)需要通过子类来决定父类算法中的某个步骤是否执行，实现子类对父类的反向控制。 本章小结(1)在模板方法模式中，定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。模板方法模式是一种基于继承的代码复用技术，它是一种类行为型模式。 (2)模板方法模式包含抽象类和具体子类两个角色。其中，在抽象类中定义了一系列基本操作并实现了一个模板方法，模板方法用于定义一个算法的框架；具体子类是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。 (3)模板方法模式的主要优点是在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序；提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为；可实现一种反向控制结构，且具有良好的可扩展性，符合单一职责原则和开闭原则。其主要缺点在于需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统会更加庞大，设计也更加抽象。 (4)模板方法模式适用的环境：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现；各子类中公共的行为应被提取出来，并集中到一个公共父类中，以避免代码重复；需要通过子类来决定父类算法中的某个步骤是否执行，实现子类对父类的反向控制。 (5)在模板方法模式中，模板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。基本方法是实现算法各个步骤的方法，是模板方法的组成部分，基本方法又可以分为抽象方法、具体方法和钩子方法。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[职责链模式]]></title>
    <url>%2F2019%2F09%2F22%2F%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F-2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 行为型模式分为类行为型模式和对象行为型模式两种。两者有什么区别？ 在一个不纯的职责链模式中，允许某个请求被一个具体处理者部分处理后向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收并处理。怎么理解？ C#语言中的异常处理（Exceptior Handlers）机制也是职责链模式的典型应用之一，不同的catch子句可以处理不同类型的异常，这些catch子句构成了一条处理异常对象的职责链。怎么理解？ 本章导学 行为型模式关注系统中对象之间的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。在GoF设计模式中包含11种行为型设计模式，它们适用于不同的环境，用于解决用户在软件设计中面临的不同问题。 在系统中如果存在多个对象可以处理同—请求，可以通过职责链模式将这些处理请求的对象连成一条链，让请求沿着该链进行传递。如果链上的对象可以处理该请求则进行处理，否则将请求转发给下家来处理。职责链模式可以将请求的发送者和接收者解耦，客户端无须关心请求的处理细节和传递过程，只需要将请求提交给职责链即可。 本章将对11种行为型模式进行简要的介绍，并学习职责链模式的定义和结构，通过实例来学习职责链模式的实现以及如何在软件开发中应用职责链模式。 本章知识点 行为型模式 职责链模式的定义 职责链模式的结构 职责链模式的实现 职责链模式的应用 职责链模式的优缺点 职责链模式的适用环境 纯与不纯的职责链模式 行为型模式在软件系统运行时，对象并不是孤立存在的，它们可以通过相互通信协作完成某些功能，一个对象在运行时也将影响其他对象的运行。行为型模式（Behavioral Pattern）关注系统中对象之间的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。行为型模式不仅仅关注类和对象本身，还重点关注它们之间的相互作用和职责划分。 行为型模式分为类行为型模式和对象行为型模式两种，其中，类行为型模式使用继承关系在几个类之间分配行为，主要通过多态等方式来分配父类与子类的职责；对象行为型模式则使用对象的关联关系来分配行为，主要通过对象关联等方式来分配两个或多个类的职责。根据合成复用原则，在系统中复用功能时要尽量使用关联关系来取代继承关系，因此，大部分行为型设计模式都属于对象行为型模式。 在GoF设计模式中包含11种行为型模式，它们的名称、定义、学习难度和使用频率如表1所示。 表1 行为型模式一览表 名 称 定 义 学习难度 使用频率 职责链模式（Chain of Responsibility Pattern） 避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求。将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。 ★★★☆☆ ★★☆☆☆ 命令模式（Command Pattern） 将一个请求封装为一个对象，从而让你可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。 ★★★☆☆ ★★★★☆ 解释器模式（Interpreter Pattern） 给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。 ★★★★★ ★☆☆☆☆ 迭代器模式（Iterator Pattern） 提供一种方法顺序访问一个聚合对象中的各个元素，且不用暴露该对象的内部表示。 ★★★☆☆ ★★★★★ 中介者模式（Mediator Pattern） 定义一个对象来封装一系列对象的交互。中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且让你可以独立地改变它们之间的交互。 ★★★☆☆ ★★☆☆☆ 备忘录模式（Memento Pattern） 在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。 ★★☆☆☆ ★★☆☆☆ 观察者模式（Observer Pattern） 定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。 ★★★☆☆ ★★★★★ 状态模式（State Pattern） 允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 ★★★☆☆ ★★★☆☆ 策略模式（Strategy Pattern） 定义一系列算法，将每一个算法封装起来，并让它们可以相互替换，策略模式让算法可以独立于使用它的客户变化。 ★☆☆☆☆ ★★★★☆ 模板方法模式（Template Method Pattern） 定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类不改变一个算法的结构即可重定义该算法的某些特定步骤。 ★★☆☆☆ ★★★☆☆ 访问者模式（Visitor Pattern） 表示一个作用于某对象结构中的各个元素的操作。访问者模式让你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。 ★★★★☆ ★☆☆☆☆ 职责链模式概述在很多情况下，可以处理某个请求的对象不止一个，例如大学里的奖学金审批，学生在向辅导员提交审批表之后，首先是辅导员签字审批，然后交给系主任签字审批，接着是院长审批，最后可能是校长审批。在这个过程中，奖学金申请表可以看成是一个请求对象，而不同级别的审批者都可以处理该请求对象，除了辅导员之外，学生不需要一一与其他审批者交互，只需要等待结果即可。在审批过程中如果某一个审批者认为不符合条件，则请求中止；否则将请求递交给下一个审批者，最后由校长来确定能否授予奖学金。该过程如图1所示 图1 奖学金审批示意图 在图1中，辅导员、系主任、院长、校长都可以处理奖学金申请表，他们构成了一个处理申请表的链式结构，申请表沿着这条链进行传递，这条链就称为职责链。职责链可以是一条直线、一个环或者一个树形结构，最常见的职责链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，职责链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理，客户端无须关心请求的处理细节以及请求的传递，只需将请求发送到链上，将请求的发送者和请求的处理者解耦，这就是职责链模式的模式动机。 图2 职责链模式结构图 由图2可知，职责链模式包含以下两个角色。 (1)Handler（抽象处理者）：它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。每一个处理者的下家还是一个处理者，故在抽象处理者中定义了一个抽象处理者类型的对象（如结构图中的successor）作为其对下家的引用，通过该引用，处理者可以连成一条链。 (2)ConcreteHandler（具体处理者）：它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中的下一个对象，以便请求的转发。 职责链模式的实现在职责链模式中，很多对象由每一个对象对其下家的引用连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。 职责链模式的核心在于抽象处理者类的设计，抽象处理者的典型代码如下:123456789101112abstract class Handler&#123; // 维持对下家的引用 protected Handler successor; public void SetSuccessor(Handler successor) &#123; this.successor = successor; &#125; public abstract void HandleRequest(string request);&#125; 在上述代码中，抽象处理者类定义了对下家的引用对象，以便将请求转发给下家，该对象的访问符可设为protected，在其子类中可以使用。在抽象处理者类中声明了抽象的请求处理方法，具体实现交由子类完成。 具体处理者是抽象处理者的子类，它有两个作用：一是处理请求，不同的具体处理者以不同的形式实现抽象请求处理方法HandleRequest()；二是转发请求，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。具体处理者类的典型代码如下：123456789101112131415public ConcreteHandler : Handler&#123; public override void HandleRequest(string request) &#123; if (请求满足条件) &#123; // 处理请求 &#125; else &#123; // 转发请求 this.successor.HandleRequest(request); &#125; &#125;&#125; 在具体处理类中通过对请求进行判断可以做出相应的处理。 需要注意的是，职责链模式并不负责创建职责链，职责链的创建工作必须由系统的其他部分来完成，一般是在使用该职责链的客户端中创建职责链。职责链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。典型的客户端代码片段如下：1234567891011...Handler handler1, handler2, handler3;handler1 = new ConcreteHandlerA();handler2 = new ConcreteHandlerB();handler3 = new ConcreteHandlerC();// 创建职责链handler1.SetSuccessor(handler2);handler2.SetSuccessor(handler3);// 发送请求，请求对象通常为自定义类型handler1.HandleRequest("请求对象");... 职责链模式的应用实例下面通过一个应用实例来进一步学习和理解职责链模式。 1.实例说明 某企业的SCM（Supply Chain Management，供应链管理）系统中包含一个采购审批子系统。该企业的采购审批是分级进行的，即根据采购金额的不同由不同层次的主管人员来审批，主任可以审批5万元以下（不包括5万元）的采购单，副董事长可以审批5万元至10万元（不包括10万元）的采购单，董事长可以审批10万元至50万元（不包括50万元）的采购单，50万元及以上的采购单则需要开董事会讨论决定，如图3所示。图3 采购单分级审批示意图现使用职责链模式设计并实现该系统。 2.实例类图 通过分析，本实例的结构如图4所示。 图4 采购单分级审批结构图 在图4中，抽象类Approver充当抽象处理者（抽象传递者），Director、VicePresident、President和Congress充当具体处理者（具体传递者），PurchaseRequest充当请求者。 3.实例代码 (1)PurchaseRequest：采购单类，充当请求者。 12345678910111213141516171819202122232425262728293031323334namespace CoRSample&#123; class PurchaseRequest &#123; private double amount; // 采购金额 private int number; // 采购单编号 private string purpose; // 采购目的 public PurchaseRequest(double amount, int number, string purpose) &#123; this.amount = amount; this.number = number; this.purpose = purpose; &#125; public double Amount &#123; get &#123; return amount; &#125; set &#123; amount = value; &#125; &#125; public int Number &#123; get &#123; return number; &#125; set &#123; number = value; &#125; &#125; public string Purpose &#123; get &#123; return purpose; &#125; set &#123; purpose = value; &#125; &#125; &#125;&#125; (2)Approver：审判者类，充当抽象处理者。12345678910111213141516171819202122namespace CoRSample&#123; abstract class Approver &#123; protected Approver successor; // 定义后继对象 protected string name; // 审批者姓名 public Approver(string name) &#123; this.name = name; &#125; // 设置后继者 public void SetSuccessor(Approver successor) &#123; this.successor = successor; &#125; // 抽象请求处理方法 public abstract void ProcessRequest(PurchaseRequest request); &#125;&#125; (3)Director：主任类，充当具体处理者。 1234567891011121314151617181920212223using System;namespace CoRSample&#123; class Director : Approver &#123; public Director(string name) : base(name) &#123; &#125; // 具体请求处理方法 public override void ProcessRequest(PurchaseRequest request) &#123; if (request.Amount &lt; 50000) &#123; Console.WriteLine("主任&#123;0&#125;审批采购单：&#123;1&#125;，金额：&#123;2&#125;元，采购目的：&#123;3&#125;。", this.name, request.Number, request.Amount, request.Purpose); //处理请求 &#125; else &#123; this.successor.ProcessRequest(request); // 转发请求 &#125; &#125; &#125;&#125; (4)VicePresident：副董事长类，充当具体处理类。 123456789101112131415161718192021222324using System;namespace CoRSample&#123; class VicePresident : Approver &#123; public VicePresident(string name) : base(name) &#123; &#125; // 具体请求处理方法 public override void ProcessRequest(PurchaseRequest request) &#123; if (request.Amount &lt; 100000) &#123; Console.WriteLine("副董事长&#123;0&#125;审批采购单：&#123;1&#125;，金额：&#123;2&#125;元，采购目的：&#123;3&#125;。", this.name, request.Number, request.Amount, request.Purpose); //处理请求 &#125; else &#123; this.successor.ProcessRequest(request); // 转发请求 &#125; &#125; &#125;&#125; (5)President：董事长类，充当具体处理者。 123456789101112131415161718192021222324using System;namespace CoRSample&#123; class President : Approver &#123; public President(string name) : base(name) &#123; &#125; // 具体请求处理方法 public override void ProcessRequest(PurchaseRequest request) &#123; if (request.Amount &lt; 500000) &#123; Console.WriteLine("董事长&#123;0&#125;审批采购单：&#123;1&#125;，金额：&#123;2&#125;元，采购目的：&#123;3&#125;。", this.name, request.Number, request.Amount, request.Purpose); //处理请求 &#125; else &#123; this.successor.ProcessRequest(request); // 转发请求 &#125; &#125; &#125;&#125; (6)Congress：董事会类，充当具体处理者。1234567891011121314151617using System;namespace CoRSample&#123; class Congress : Approver &#123; public Congress(string name) : base(name) &#123; &#125; // 具体请求处理方法 public override void ProcessRequest(PurchaseRequest request) &#123; Console.WriteLine("召开董事会审批采购单：&#123;0&#125;，金额：&#123;1&#125;元，采购目的：&#123;2&#125;。",request.Number, request.Amount, request.Purpose); // 处理请求 &#125; &#125;&#125; (7)Program：客户端测试类。 12345678910111213141516171819202122232425262728293031323334353637using System;namespace CoRSample&#123; class Program &#123; static void Main(string[] args) &#123; Approver wjzhang, gyang, jguo, meeting; wjzhang = new Director("张无忌"); gyang = new VicePresident("杨过"); jguo = new President("郭靖"); meeting = new Congress("董事会"); // 创建职责链 wjzhang.SetSuccessor(gyang); gyang.SetSuccessor(jguo); jguo.SetSuccessor(meeting); // 创建采购单 PurchaseRequest pr1 = new PurchaseRequest(45000, 10001, "购买倚天剑"); wjzhang.ProcessRequest(pr1); PurchaseRequest pr2 = new PurchaseRequest(60000, 10002, "购买《葵花宝典》"); wjzhang.ProcessRequest(pr2); PurchaseRequest pr3 = new PurchaseRequest(160000, 10003, "购买《金刚经》"); wjzhang.ProcessRequest(pr3); PurchaseRequest pr4 = new PurchaseRequest(800000, 10004, "购买桃花岛"); wjzhang.ProcessRequest(pr4); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：1234主任张无忌审批采购单：10001，金额：45000元，采购目的：购买倚天剑。 副董事长杨过审批采购单：10002，金额：60000元，采购目的：购买《葵花宝典》。 董事长郭靖审批采购单：10003，金额：160000元，采购目的：购买《金刚经》。 召开董事会审批采购单：10004，金额：800000元，采购目的：购买桃花岛。 如果需要在系统中增加一个新的具体处理者，如增加一个经理（Manager）角色，可以审批5万元至8万元（不包括8万元）的采购单，需要编写一个新的具体处理者类Manager，作为抽象处理者类Approver的子类，实现在Approver类中声明的抽象处理方法，如果采购金额大于等于8万元，则将请求转发给下家。其代码如下： Manager：经理类，充当具体处理者。 123456789101112131415161718192021222324using System;namespace CoRSample&#123; class Manager : Approver &#123; public Manager(string name) : base(name) &#123; &#125; // 具体请求处理方法 public override void ProcessRequest(PurchaseRequest request) &#123; if (request.Amount &lt; 80000) &#123; Console.WriteLine("经理&#123;0&#125;审批采购单：&#123;1&#125;，金额：&#123;2&#125;元，采购目的：&#123;3&#125;。", this.name, request.Number, request.Amount, request.Purpose); // 处理请求 &#125; else &#123; this.successor.ProcessRequest(request); // 转发请求 &#125; &#125; &#125;&#125; 由于链的创建过程由客户端负责，因此增加新的具体处理者类对原有类库无任何影响，无须修改已有类的源代码，符合开闭原则。 在客户端代码中，如果要将新的具体请求处理者应用在系统中，需要创建新的具体处理者对象，然后将该对象加入职责链中。在客户端测试代码中增加以下代码：12Approver rhuang;rhuang = new Manager("黄蓉"); 将建链代码改为：12345// 创建职责链wjzhang.SetSuccessor(rhuang); // 将“黄蓉”作为“张无忌”的下家rhuang.SetSuccessor(gyang); //将“杨过”作为“黄蓉”的下家gyang.SetSuccessor(jguo);jguo.SetSuccessor(meeting); 重新编译并运行程序，输出结果如下：1234主任张无忌审批采购单：10001，金额：45000元，采购目的：购买倚天剑 经理黄蓉审批采购单：10002，金额：60000元，采购目的：购买《葵花宝典》。 董事长郭靖审批采购单：10003，金额：160000元，采购目的：购买《金刚经》。 召开董事会审批采购单：10004，金额：800000元，采购目的：购买桃花岛。 纯与不纯的职责链模式职责链模式可分为纯的职责链模式和不纯的职责链模式两种类型。 1.纯的职责链模式 一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。在上一节的采购单审批实例中应用的是纯的职责链模式。 2.不纯的职责链模式 在一个不纯的职责链模式中，允许某个请求被一个具体处理者部分处理后向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收并处理。 在JavaScript的事件浮升（Event Bubbling）处理机制中使用了这种不纯的职责链模式，其基本原理是：当一个事件（例如鼠标单击事件）被触发后，界面组件（例如按钮、文本框等HTML，控件）将检测并调用相应的事件处理方法来处理事件，如果存在对应的事件处理方法则处理该事件，然后将该事件向上一级容器组件（例如DIV、TABLE等）传播，上级容器组件在接收到事件之后可以继续处理此事件并继续向上级容器组件传播，如此反复，直到事件到达顶层容器（例如BODY）组件为止；如果一直传到最顶层容器仍没有事件处理方法，则该事件不予处理。每一级组件在接收到事件时都可以处理此事件，而不论此事件是否在前一级已得到处理，且存在事件未被处理的情况。显然，这是不纯的职责链模式。 职责链模式的优缺点与适用环境职责链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递，请求发送者无须知道请求在何时、何处以及如何被处理，实现了请求发送者与处理者的解耦。在软件开发中，用户如果遇到有多个对象可以处理同一请求时可以应用职责链模式，例如在Web应用开发中创建多个过滤器（Filter）链来对请求数据进行过滤，在工作流系统中实现公文的分级审批等，使用职责链模式可以较好地解决此类问题。C#语言中的异常处理（Exceptior Handlers）机制也是职责链模式的典型应用之一，不同的catch子句可以处理不同类型的异常，这些catch子句构成了一条处理异常对象的职责链。 职责链模式的优点职责链模式的主要优点如下： (1)职责链模式使得一个对象无须知道是其他哪一个对象处理其请求，仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。 (2)请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象之间的相互连接。 (3)在给对象分配职责时，职责链可以带来更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。 (4)在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合开闭原则的。 职责链模式的缺点职责链模式的主要缺点如下： (1)由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因职责链没有被正确配置而得不到处理。 (2)对于比较长的职责链，请求的处理可能涉及多个处理对象，系统性能将受到一定的影响，而且在进行代码调试时不太方便。 (3)如果建链不当，可能会造成循环调用，导致系统陷入死循环。 职责链模式的适用环境在以下情况下可以考虑使用职责链模式： (1)有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。 (2)在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 (3)可动态指定一组对象处理请求，客户端可以动态地创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 本章小结(1)行为型模式关注系统中对象之间的交互，研究系统在运行时对象之间的相互通信与协作，进一步明确对象的职责。在GoF设计模式中一共包含11种行为型模式。 (2)在职责链模式中，为了避免将一个请求的发送者与接收者耦合在一起，让多个对象都有机会处理请求，将接收请求的对象连接成一条链，并且沿着这条链传递请求，直到有一个对象能够处理它为止。职责链模式是一种对象行为型模式。 (3)职责链模式包含抽象处理者和具体处理者两个角色。其中，抽象处理者定义了一个处理请求的接口，它定义了一个抽象处理者类型的对象，作为其对下家的引用，通过该引用，处理者可以连成一条链；具体处理者是抽象处理者的子类，可以处理用户请求，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者进行处理。 (4)职责链模式的主要优点是使得一个对象无须知道是其他哪一个对象处理其请求，降低了系统的耦合度，简化了对象之间的相互连接，给对象职责的分配带来更多的灵活性。同时，增加一个新的具体请求处理者较为方便。职责链模式的主要缺点在于不能保证请求一定会被处理；对于比较长的职责链，系统性能将受到一定影响；如果建链不当，可能会造成循环调用，导致系统陷入死循环。 (5)职责链模式适用的环境：有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定；在不明确指定接收者的情况下，向多个对象中的一个提交一个请求；可动态指定一组对象处理请求，客户端可以动态地创建职责链来处理请求，还可以改变链中处理者之间的先后次序。 (6)职责链模式可分为纯的职责链模式和不纯的职责链模式两种类型，其中，一个纯的职责链模式要求一个具体处理者对象要么承担全部责任，要么将责任推给下家，一个请求必须被某一个处理者对象所接收；在一个不纯的职责链模式中，允许某个请求被一个具体处理者部分处理后向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收并处理。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[代理模式]]></title>
    <url>%2F2019%2F09%2F21%2F%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章导学 代理模式是常用的结构型设计模式之一，当用户无法直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问，为了保证客户端使用的透明性，所访问的真实对象与代理对象需要实现相同的接口。根据代理模式的使用目的不同，代理模式又可以分为多种类型，例如保护代理、远程代理、虚拟代理、缓冲代理等，它们应用于不同的场合，满足用户的不同需求。 本章将学习代理模式的定义与结构，学习几种常见的代理模式的类型及其适用环境，学会如何实现简单的代理模式并理解远程代理、虚拟代理、缓冲代理、保护代理和智能引用代理的作用和实现原理。 本章知识点 代理模式的定义 代理模式的结构 代理模式的实现 代理模式的应用 代理模式的优缺点 代理模式的适用环境 远程代理 代理模式概述近年来，代购已逐步成为电子商务的一个重要分支。何谓代购，简单来说就是找人帮忙购买所需要的商品，当然代购者可能需要向实施代购的人支付一定的费用。代购通常分为两种类型：一种是因为在当地买不到某件商品，或者又因为当地这件商品的价格比其他地区的贵，因此托人在其他地区甚至国外购买该商品，然后通过快递发货或者直接携带回来；还有一种代购，由于消费者对想要购买的商品的相关信息缺乏，自己无法确定其实际价值而又不想被商家“宰”，只好委托中介机构帮忙讲价或代买。代购网站为此应运而生，它为消费者提供在线的代购服务，如果看中某国外购物网站上的商品，可以登录代购网站填写代购单并付款，代购网站会帮助购买，然后通过快递公司将商品发送给消费者。商品代购过程如图1所示。 图1 商品代购示意图 在软件开发中，也有一种设计模式可以提供与代购网站类似的功能。由于某些原因，客户端不想或不能直接访问一个对象，此时可以通过一个被称为“代理”的第三者来实现间接访问，该方案对应的设计模式被称为代理模式。 代理模式是一种应用很广泛的结构型设计模式，而且变化形式非常多，常见的代理形式包括远程代理、虚拟代理、缓冲代理、保护代理和智能引用代理等，后面将学习这些不同的代理形式。 代理模式（Proxy）的定义如下：1给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。 代理模式是一种对象结构型模式。在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。 代理模式的结构与实现代理模式的结构代理模式的结构比较简单，其核心是代理类，为了让客户端能够一致性地对待真实对象和代理对象，在代理模式中引入了抽象层。代理模式结构如图2所示。 图2 代理模式结构图 由图2可知，代理模式包含以下3个角色。 (1)Subject（抽象主题角色）：它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。 (2)Proxy（代理主题角色）：它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供了一个与真实主题角色相同的接口，以便在任何时候都可以代替真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯地调用真实主题对象中的操作。 (3)RealSubject（真实主题角色）：它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。 代理模式的实现代理模式的结构图比较简单，但在实际使用和实现过程中要复杂得多，特别是代理类的设计和实现。 抽象主题类声明了真实主题类和代理类的公共方法，它可以是接口、抽象类或具体类，客户端针对抽象主题类编程，一致性地对待真实主题和代理主题。典型的抽象主题类代码如下：1234abstract class Subject&#123; public abstract void Request();&#125; 真实主题类继承了抽象主题类，提供了业务方法的具体实现，其典型代码如下：1234567class RealSubject : Subject&#123; public override void Request() &#123; // 业务方法具体实现代码 &#125;&#125; 代理类也是抽象主题类的子类，它维持一个对真实主题对象的引用，调用在真实主题中实现的业务方法，在调用时可以在原有业务方法的基础上附加一些新的方法对功能进行扩展或约束。最简单的代理类实现代码如下：1234567891011121314151617181920212223class Proxy : Subject&#123; // 维持一个对真实主题对象的引用 private RealSubject realSubject = new RealSubject(); public void PreRequest() &#123; ... &#125; public override void Request() &#123; PreRequest(); // 调用真实主题对象的方法 realSubject.Request(); PostRequest(); &#125; public void PostRequest() &#123; ... &#125;&#125; 在实际开发过程中，代理类的实现要比上述代码复杂得多，代理模式根据其目的和实现方式的不同可分为很多种类，对其中常用的几种代理模式的简要说明如下。 (1)远程代理（Remote Proxy）：为一个位于不同地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以在同一台主机中，也可以在另一台主机中，远程代理又称为大使（Ambassador）。 (2)虚拟代理（Virtual Proxy）：如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。 (3)保护代理（Protect Proxy）：控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。 (4)缓冲代理（Cache Proxy）：为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。 (5)智能引用代理（Smart Reference Proxy）：当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。 在这些常用的代理模式中，有些代理类的设计非常复杂，例如远程代理类，它封装了底层网络通信和对远程对象的调用，其实现较为复杂。 代理模式的应用实例下面通过一个应用实例来进一步学习和理解代理模式。 1.实例说明 某软件公司承接了某信息咨询公司的收费商务信息查询系统的开发任务，该系统的基本需求如下：(1)在进行商务信息查询之前用户需要通过身份验证，只有合法用户才能够使用该查询系统。(2)在进行商务信息查询时系统需要记录查询日志，以便根据查询次数收取查询费用。该软件公司开发人员已完成了商务信息查询模块的开发任务，现希望能够以一种松耦合的方式向原有系统增加身份验证和日志记录功能，客户端代码可以无区别地对待原始的商务信息查询模块和增加新功能之后的商务信息查询模块，而且可能在将来还要在该信息查询模块中增加一些新的功能。现使用代理模式设计并实现该收费商务信息查询系统。 2.实例类图 通过分析，可以采用一种间接访问的方式实现该商务信息查询系统的设计，在客户端对象和信息查询对象之间增加一个代理对象，让代理对象来实现身份验证和日志记录等功能，而无须直接对原有的商务信息查询对象进行修改，如图3所示。 图3 商务信息查询系统设计方案示意图 在图3中，客户端对象通过代理对象间接访问具有商务信息查询功能的真实对象，在代理对象中除了调用真实对象的商务信息查询功能外，还增加了身份验证和日志记录等功能。使用代理模式设计该商务信息查询系统，结构如图4所示。 图4 商务信息查询系统结构图 在图4中，业务类AccessValidator用于验证用户身份，业务类Logger用于记录用户查询日志，Searcher充当抽象主题角色，RealSearcher充当真实主题角色，ProxySearcher充当代理主题角色。 3.实例代码 (1)AccessValidator：身份验证类，业务类，它提供方法Validate()来实现身份验证。 123456789101112131415161718192021using System;namespace ProxySample&#123; class AccessValidator &#123; // 模拟实现登录验证 public bool Validate(string userId) &#123; Console.WriteLine("在数据库中验证用户'" + userId + "'是否是合法用户？"); if (userId.Equals("杨过")) &#123; Console.WriteLine("'&#123;0&#125;'登录成功！",userId); return true; &#125; else &#123; Console.WriteLine("'&#123;0&#125;'登录失败！", userId); return false; &#125; &#125; &#125;&#125; (2)Logger：日志记录类，业务类，它提供方法Log()来保存日志。 123456789101112using System;namespace ProxySample&#123; class Logger &#123; // 模拟实现日志记录 public void Log(string userId) &#123; Console.WriteLine("更新数据库，用户'&#123;0&#125;'查询次数加1！",userId); &#125; &#125;&#125; (3)Searcher：抽象查询类，充当抽象主题角色，它声明了DoSearch()方法。1234567namespace ProxySample&#123; interface Searcher &#123; string DoSearch(string userId, string keyword); &#125;&#125; (4)RealSearcher：具体查询类，充当真实主题角色，它实现查询功能，提供方法DoSearch()来查询信息。12345678910111213using System;namespace ProxySample&#123; class RealSearcher : Searcher &#123; // 模拟查询商务信息 public string DoSearch(string userId, string keyword) &#123; Console.WriteLine("用户'&#123;0&#125;'使用关键词'&#123;1&#125;'查询商务信息！",userId,keyword); return "返回具体内容"; &#125; &#125;&#125; (5)ProxySearcher：代理查询类，充当代理主题角色。它是查询代理，维持了对RealSearcher对象、AccessValidator对象和Logger对象的引用。1234567891011121314151617181920212223242526272829303132333435363738namespace ProxySample&#123; class ProxySearcher : Searcher &#123; private RealSearcher searcher = new RealSearcher(); // 维持一个对真实主题的引用 private AccessValidator validator; private Logger logger; public string DoSearch(string userId, string keyword) &#123; // 如果身份验证成功，则执行查询 if (this.Validate(userId)) &#123; string result = searcher.DoSearch(userId, keyword); // 调用真实主题对象的查询方法 this.Log(userId); // 记录查询日志 return result; // 返回查询结果 &#125; else &#123; return null; &#125; &#125; // 创建访问验证对象并调用其Validate()方法实现身份验证 public bool Validate(string userId) &#123; validator = new AccessValidator(); return validator.Validate(userId); &#125; // 创建日志记录对象并调用其Log()方法实现日志记录 public void Log(string userId) &#123; logger = new Logger(); logger.Log(userId); &#125; &#125;&#125; (6)配置文件App.config：在配置文件中存储了代理主题类类名。123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="proxy" value="ProxySample.ProxySearcher"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (7)Program：客户端测试类。12345678910111213141516171819202122using System;using System.Configuration;using System.Reflection;namespace ProxySample&#123; class Program &#123; static void Main(string[] args) &#123; // 读取配置文件 string proxy = ConfigurationManager.AppSettings["proxy"]; // 反射生成对象，针对抽象编程，客户端无须分辨真实主题类和代理类 Searcher searcher; searcher = (Searcher)Assembly.Load("ProxySample").CreateInstance(proxy); String result = searcher.DoSearch("杨过", "玉女心经"); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：1234在数据库中验证用户&apos;杨过&apos;是否是合法用户？&apos;杨过&apos;登录成功！用户&apos;杨过&apos;使用关键词&apos;玉女心经&apos;查询商务信息！更新数据库，用户&apos;杨过&apos;查询次数加1！ 本实例是保护代理和智能引用代理的应用实例，在代理类ProxySearcher中实现对真实主题类的权限控制和引用计数，如果需要在访问真实主题时增加新的访问控制机制和新功能，只需增加一个新的代理类，再修改配置文件，在客户端代码中使用新增代理类即可，源代码无须修改，符合开闭原则。 远程代理远程代理（Remote Proxy）是一种常用的代理模式，它使得客户端程序可以访问在远程主机上的对象，远程主机可能具有更好的计算性能与处理速度，可以快速地响应并处理客户端的请求。远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户端完全可以认为被代理的远程业务对象是在本地而不是在远程，而远程代理对象承担了大部分的网络通信工作，并负责对远程业务方法的调用。 远程代理示意图如图5所示，客户端对象不能直接访问远程主机中的业务对象，只能采取间接访问的方式。远程业务对象在本地主机中有一个代理对象，该代理对象负责对远程业务对象的访问和网络通信，它对于客户端对象而言是透明的。客户端无须关心实现具体业务的是谁，只需要按照服务接口所定义的方式直接与本地主机中的代理对象交互即可。 在基于.NET平台的分布式技术，例如DCOM（Distribute Component Object Model，分布式组件对象模型）、Web Service中，都应用了远程代理模式。 图5 远程代理示意图 虚拟代理虚拟代理（Virtual Proxy）也是一种常用的代理模式，对于一些占用系统资源较多或者加载时间较长的对象，可以给这些对象提供一个虚拟代理。在真实对象创建成功之前虚拟代理扮演真实对象的替身，而当真实对象创建之后，虚拟代理将用户的请求转发给真实对象。 通常，在以下两种情况下可以考虑使用虚拟代理： (1)由于对象本身的复杂性或者网络等原因导致一个对象需要较长的加载时间，此时可以用一个加载时间相对较短的代理对象来代表真实对象。通常，在实现时可以结合多线程技术，一个线程用于显示代理对象，其他线程用于加载真实对象。这种虚拟代理模式可以应用在程序启动的时候，由于创建代理对象在时间和处理复杂度上要少于创建真实对象，因此，在程序启动时，可以用代理对象代替真实对象初始化，大大加速了系统的启动时间。当需要使用真实对象时，再通过代理对象来引用，而此时真实对象可能已经成功加载完毕，可以缩短用户的等待时间。 (2)当一个对象的加载十分耗费系统资源的时候，也非常适合使用虚拟代理。虚拟代理可以让那些占用大量内存或处理起来非常复杂的对象推迟到使用它们的时候才创建，而在此之前用一个相对来说占用资源较少的代理对象来代表真实对象，再通过代理对象来引用真实对象。为了节省内存，在第一次引用真实对象时再创建对象，并且该对象可以被多次重用，在以后每次访问时需要检测所需对象是否已经被创建，因此在访问该对象时需要进行 存在性检测，这需要消耗一定的系统时间，但是可以节省内存空间，这是一种用时间换取空间的做法。 无论是以上哪种情况，虚拟代理都是用一个“虚假”的代理对象来代表真实对象，通过代理对象来间接引用真实对象，可以在一定程度上提高系统的性能。 缓冲代理缓冲代理（Cache Proxy）也是一种较为常用的代理模式，它为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，从而避免某些方法的重复执行，优化系统性能。 在微软示例项目PetShop 4.0的业务逻辑层（Business Logic Layer，BLL）中定义了Product、Category、Item等类，它们封装了相关的业务方法，用于调用数据访问层（Data Access Layer，DAL）对象访问数据库，以获取相关数据。为了改进系统性能，PetShop 4.0为这些实现方法增加了缓存机制，引入一个新的对象去控制原来的BLL业务逻辑对象，这些新的对象对应于代理模式中的代理对象。在引入代理模式后，实现了在缓存级别上对业务对象的封装，增强了对业务对象的控制，如果需要访问的数据在缓存中已经存在，则无须再重复执行获取数据的方法，直接返回存储在缓存中的数据即可。由于原有业务对象（真实对象）和新增代理对象暴露在外的方法是一致的，所以对于调用方（即客户端）而言，调用代理对象与真实对象并没有实质的区别。 这些新引入的代理类包括ProductDataProxy、CategoryDataProxy和ItemDataProxy等。下面以PetShop.BLL.Product业务对象为例进行说明，PetShop 4.0为其建立了代理对象ProductDataProxy，并在ProductDataProxy的GetProductsByCategory()方法中调用了业务逻辑层Product类的GetProductsByCategory()方法，同时增加了缓存机制，如图6所示。 图6 PetShop 4.0缓存代理示意图 在ProductDataProxy类中存在以下代码片段：12345678910111213141516171819202122232425262728293031public static class ProductDataProxy&#123; private static readonly int productTimeout = int.Parse(ConfigurationManager.AppSettings ["ProductCacheDuration"]); private static readonly bool enableCaching = bool.Parse(ConfigurationManager. AppSettings["EnableCaching"]); public static IList GetProductsByCategory(string category) &#123; Product product = new Product(); // 如果缓存被禁用，则直接通过product对象来获取数据 if (!enableCaching) &#123; return product.GetProductsByCategory(category); &#125; string key = "product_by_category_" + category; // 从缓存中获取数据 IList data = (IList )HttpRuntime.Cache[key]; // 如果缓存中没有数据则执行如下代码 if (data == null) &#123; data = product.GetProductsByCategory(category); // 通过工厂创建AggregateCacheDependency对象 AggregateCacheDependency cd = DependencyFacade.GetProductDependency (); // 将数据存储在缓存中，并添加必要的AggregateCacheDependency对象 HttpRuntime.Cache.Add(key, data, cd, DateTime.Now.AddHours(product Timeout), Cache.NoSlidingExpiration, CacheItemPriority.High, null); &#125; return data; &#125; ……&#125; 在上述代码中，AggregateCacheDependency是从.NET Framework 2.0开始新增的一个类，它负责监视依赖项对象的集合。当这个集合中的任意一个依赖项对象发生改变时，该依赖项对象对应的缓存对象将被自动移除。在此不对AggregateCacheDependency进行详细说明。 与业务逻辑层Product对象的GetProductsByCategory()方法相比，上述代码增加了缓存机制。当缓存内不存在相关数据项时，直接调用业务逻辑层Product的GetProductsByCategory()方法来获取数据，并将其与对应的AggregateCacheDependency对象一起存储在缓存中。在ProductDataProxy类的每一个业务方法中都实例化了Product类，再调用Product类的相应方法，因此ProductDataProxy与Product之间属于依赖关系，这是标准代理模式的一种变形，可以按照标准代理模式对其进行改进，包括引入高层的抽象接口。 代理模式的优缺点与适用环境代理模式是常用的结构型设计模式之一，它为对象的间接访问提供了一个解决方案，可以对对象的访问进行控制。代理模式的类型较多，其中远程代理、虚拟代理、保护代理等在软件开发中的应用非常广泛。 代理模式的优点代理模式的共同优点如下： (1)代理模式能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。 (2)客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。 此外，不同类型的代理模式具有独特的优点，例如： (1)远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高了系统的整体运行效率。 (2)虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。 (3)缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。 (4)保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。 代理模式的缺点代理模式的主要缺点如下： (1)由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。 (2)实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。 代理模式的适用环境代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的环境： (1)当客户端对象需要访问远程主机中的对象时可以使用远程代理。 (2)当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。 (3)当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。 (4)当需要控制对一个对象的访问，为不同用户提供不同级别的访n权限时可以使用保护代理。 (5)当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。 本章小结(1)代理模式给某一个对象提供一个代理或占位符，并由代理对象来控制对原对象的访问。代理模式是一种对象结构型模式。 (2)代理模式包含抽象主题角色、代理主题角色和真实主题角色3个角色。其中，抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色包含了对真实主题的引用，可以在任何时候操作真实主题对象；真实主题角色实现了真实的业务操作。 (3)代理模式的主要优点是能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；系统具有较好的灵活性和可扩展性，客户端可以针对抽象主题角色进行编程，增加更换代理类无须修改源代码，符合开闭原则。其主要缺点是有些类型的代理模式可能会造成请求的处理速度变慢；实现代理模式需要一些额外的工作，而且有些代理模式的实现过程较为复杂。 (4)当客户端对象需要访问远程主机中的对象时可以使用远程代理。远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，从而提高系统的整体运行效率。 (5)当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理。虚拟代理可以在一定程度上节省系统的运行开销。 (6)当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。 (7)当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。 (8)当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[享元模式]]></title>
    <url>%2F2019%2F09%2F21%2F%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 提供了一个享元池用于存储已经创建好的享元对象。怎么理解？ 本章导学 当系统中存在大量相同或者相似的对象时，享元模式是一种值得考虑的解决方案，它通过共享技术实现相同或相似的细粒度对象的复用，从而节约内存空间，提高系统性能。在享元模式中提供了一个享元池用于存储已经创建好的享元对象，并通过享元工厂类将享元对象提供给客户端使用。 本章将学习享元模式的定义与结构，学习如何设计享元池和享元工厂，并结合实例学习如何实现无外部状态的享元模式以及有外部状态的享元模式。 本章知识点 享元模式的定义 享元模式的结构 享元模式的实现 享元模式的应用 享元模式的优缺点 享元模式的适用环境 有外部状态的享元模式 单纯享元模式与复合享元模式 享元模式概述如果一个软件系统在运行时所创建的相同或相似的对象数量太多，将导致运行代价过高，带来系统资源浪费、性能下降等问题。例如在一个文本字符串中存在很多重复的字符，如果每一个字符都用一个单独的对象来表示，将会占用较多的内存空间，那么如何避免系统中出现大量相同或相似的对象，同时又不影响客户端程序通过面向对象的方式对这些对象进行操作呢？享元模式正是为解决这一类问题而“诞生”。享元模式通过共享技术实现相同或相似对象的重用，在逻辑上每一个出现的字符都有一个对象与之对应，然而在物理上它们却共享同一个享元对象，这个对象可以出现在一个字符串的不同地方，相同的字符对象都指向同一个实例。在享元模式中，存储这些共享实例对象的地方称为享元池（Flyweight Pool），用户可以针对每一个不同的字符创建一个享元对象，将其放在享元池中，待需要时再从享元池中取出。字符享元对象示意图如图1所示。 图1 字符享元对象示意图 享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了内部状态（Intrinsic State）和外部状态（Extrinsic State）。下面对享元的内部状态和外部状态进行简单的介绍。 (1)内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享。例如字符的内容，不会随外部环境的变化而变化，无论在任何环境下字符“a”始终是“a”，都不会变成“b”。 (2)外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态通常由客户端保存，并在享元对象被创建之后，需要使用的时候再传入享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。例如字符的颜色，可以在不同的地方有不同的颜色，例如有的“a”是红色的，有的“a”是绿色的，字符的大小也是如此，有的“a”是五号字，有的“a”是四号字。而且字符的颜色和大小是两个独立的外部状态，它们可以独立变化，相互之间没有影响，客户端可以在使用时将外部状态注入享元对象中。 正因为区分了内部状态和外部状态，可以将具有相同内部状态的对象存储到享元池中，享元池中的对象是可以实现共享的，需要的时候将对象从享元池中取出，即可实现对象的复用。通过向取出的对象注入不同的外部状态，可以得到一系列相似的对象，而这些对象在内存中实际上只存储一份。 享元模式的定义如下：1运用共享技术有效地支持大量细粒度对象的复用。 享元模式要求能够被共享的对象必须是细粒度对象，它又称为轻量级模式，享元模式是一种对象结构型模式。 享元模式的结构与实现享元模式的结构享元模式结构较为复杂，通常结合工厂模式一起使用，在它的结构图中包含了一个享元工厂类，其结构如图2所示。 图2 享元模式结构图 由图2可知，享元模式包含以下4个角色。 (1)Flyweight（抽象享元类）：它通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法设置外部数据（外部状态）。 (2)ConcreteFlyweight（具体享元类）：它实现了抽象享元类，其实例称为享元对象，并在具体享元类中为内部状态提供了存储空间。通常可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。 (3)UnsharedConcretelyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，用户可以将不能被共享的子类设计为非共享具体享元类，当需要一个非共享具体享元类的对象时可以直接通过实例化创建。 (4)FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计。当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在），返回新创建的实例并将其存储在享元池中。 享元模式的实现享元类Flyweight的设计是享元模式的要点之一，为了提高系统的可扩展性，通常要定义一个抽象享元类作为所有具体享元类的公共父类。典型的抽象享元类代码如下：1234abstract class Flyweight&#123; public abstract void Operation(string extrinsicState);&#125; 在具体享元类ConcreteFlyweight中要将内部状态和外部状态分开处理，通常将内部状态作为具体享元类的成员变量，而将外部状态通过注入的方式添加到具体享元类中。典型的具体享元类代码如下：12345678910111213141516class ConcreteFlyweight : Flyweight&#123; // 内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的 private string intrinsicState; public ConcreteFlyweight(string intrinsicState) &#123; this.intrinsicState = intrinsicState; &#125; // 外部状态extrinsicState在使用时由外部设置，不保存在享元对象中，即使是同一个对象，在每一次调用时可以传入不同的外部状态 public override void Operation(string extrinsicState) &#123; //实现业务方法 &#125; &#125; 除了可以共享的具体享元类以外，用户在使用享元模式时，有时还需要处理不需要共享的抽象享元类Flyweight的子类，这些子类被定义为非共享具体享元类UnsharedConcreteFlyweight。其典型代码如下：1234567class UnsharedConcreteFlyweight : Flyweight&#123; public override void Operation(string extrinsicState) &#123; // 实现业务方法 &#125;&#125; 在享元模式中引入了享元工厂类FlyweightFactory，享元工厂类的作用在于提供一个用于存储享元对象的享元池，当用户需要对象时，首先从享元池中获取，如果享元池不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。典型的享元工厂类的代码如下：1234567891011121314151617181920class FlyweightFactory&#123; // 定义一个Hashtable用于存储享元对象，实现享元池 private Hashtable flyweights = new Hashtable(); public Flyweight GetFlyweight(string key) &#123; // 如果对象存在，则直接从享元池获取 if (flyweights.ContainsKey(key)) &#123; return (Flyweight)flyweights[key]; &#125; else // 如果对象不存在，先创建一个新的对象添加到享元池中，然后返回 &#123; Flyweight fw = new ConcreteFlyweight("state"); flyweights.Add(key,fw); return fw; &#125; &#125;&#125; 享元模式的应用实例下面通过一个应用实例来进一步学习和理解享元模式。 1.实例说明 某软件公司要开发一个围棋软件，其界面效果如图3所示。图3 围棋软件界面效果图该软件公司开发人员通过对围棋软件进行分析发现，在图3中，围棋棋盘中包含大量的黑子和白子，它们的形状、大小都一模一样，只是出现的位置不同而已。如果将每一个棋子都作为一个独立的对象存储在内存中，将导致该围棋软件在运行时所需的内存空间较大，如何降低运行代价、提高系统性能是需要解决的一个问题。为了解决该问题，现使用享元模式来设计该围棋软件的棋子对象。 2.实例类图 通过分析，本实例的结构如图4所示。 图4 围棋棋子结构图 在图4中，IgoChessman充当抽象享元类，BlackIgoChessman和WhiteIgoChessman充当具体享元类，IgoChessmanFactory充当享元工厂类。 3.实例代码 (1)IgoChessman：围棋棋子类，充当抽象享元类。 1234567891011121314using System;namespace FlyweightSample&#123; abstract class IgoChessman &#123; public abstract string GetColor(); public void Display() &#123; Console.WriteLine("棋子颜色：" + this.GetColor()); &#125; &#125;&#125; (2)BlackIgoChessman：黑色棋子类，充当具体享元类。 12345678910namespace FlyweightSample&#123; class BlackIgoChessman : IgoChessman &#123; public override string GetColor() &#123; return "黑色"; &#125; &#125;&#125; (3)WhiteIgoChessman：白色棋子类，充当具体享元类。 12345678910namespace FlyweightSample&#123; class WhiteIgoChessman : IgoChessman &#123; public override string GetColor() &#123; return "白色"; &#125; &#125;&#125; (4)IgoChessmanFactory：围棋棋子工厂类，充当享元工厂类，使用单例模式对其进行设计。 1234567891011121314151617181920212223242526272829303132using System.Collections;namespace FlyweightSample&#123; class IgoChessmanFactory &#123; private static IgoChessmanFactory instance = new IgoChessmanFactory(); private Hashtable ht; // 使用Hashtable来存储享元对象，充当享元池 private IgoChessmanFactory() &#123; ht = new Hashtable(); IgoChessman black, white; black = new BlackIgoChessman(); ht.Add("b", black); white = new WhiteIgoChessman(); ht.Add("w", white); &#125; // 返回享元工厂类的唯一实例 public static IgoChessmanFactory GetInstance() &#123; return instance; &#125; // 通过key来获取存储在Hashtable中的享元对象 public IgoChessman GetIgoChessman(string color) &#123; return (IgoChessman)ht[color]; &#125; &#125;&#125; (5)Program：客户端测试类。 123456789101112131415161718192021222324252627282930313233343536using System;namespace FlyweightSample&#123; class Program &#123; static void Main(string[] args) &#123; IgoChessman black1,black2,black3,white1,white2; IgoChessmanFactory factory; // 获取享元工厂对象 factory = IgoChessmanFactory.GetInstance(); // 通过享元工厂获取三颗黑子 black1 = factory.GetIgoChessman("b"); black2 = factory.GetIgoChessman("b"); black3 = factory.GetIgoChessman("b"); Console.WriteLine("判断两颗黑子是否相同：" + (black1 == black2)); // 通过享元工厂获取两颗白子 white1 = factory.GetIgoChessman("w"); white2 = factory.GetIgoChessman("w"); Console.WriteLine("判断两颗白子是否相同：" + (white1 == white2)); // 显示棋子 black1.Display(); black2.Display(); black3.Display(); white1.Display(); white2.Display(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：1234567判断两颗黑子是否相同：True判断两颗白子是否相同：True棋子颜色：黑色 棋子颜色：黑色 棋子颜色：黑色 棋子颜色：白色 棋子颜色：白色 从输出结果可以看出，虽然在客户端代码中获取了3个黑子对象和两个白子对象，但是3个黑子的内存地址相同，两个白子的内存地址也相同，也就是说，实际上只有两个对象。在实现享元工厂类时使用了单例模式和简单工厂模式，确保了享元工厂对象的唯一性，并提供了工厂方法向客户端返回享元对象。 有外部状态的享元模式在上一节的应用实例中，对围棋棋子进行进一步分析，不难发现，虽然黑色棋子和白色棋子可以共享，但是它们将显示在棋盘的不同位置，如何让相同的黑子或者白子能够多次重复显示但位于一个棋盘的不同地方？解决方法之一就是将棋子的位置定义为棋子的一个外部状态，在需要时再进行设置。因此，在图4的基础上增加了一个新的类Coordinates（坐标类），用于存储每一个棋子的位置，修改之后的结构如图5所示。 图5 引入外部状态之后的围棋棋子结构图 在图5中，除了增加一个坐标类Coordinates以外，抽象享元类IgoChessman中的Display()方法也将对应增加一个Coordinates类型的参数，用于在显示棋子时指定其坐标。Coordinates类的代码如下：1234567891011121314151617181920212223242526namespace FlyweightSample&#123; class Coordinates &#123; private int x; private int y; public Coordinates(int x, int y) &#123; this.x = x; this.y = y; &#125; public int X &#123; get &#123; return x; &#125; set &#123; x = value; &#125; &#125; public int Y &#123; get &#123; return y; &#125; set &#123; y = value; &#125; &#125; &#125;&#125; 修改之后的IgoChessman类代码如下：1234567891011121314using System;namespace FlyweightSample&#123; abstract class IgoChessman &#123; public abstract string GetColor(); public void Display(Coordinates coord) &#123; Console.WriteLine("棋子颜色：&#123;0&#125;，棋子位置：&#123;1&#125;，&#123;2&#125;", this.GetColor(),coord.X,coord.Y); &#125; &#125;&#125; 将客户端测试代码修改如下：123456789101112131415161718192021222324252627282930313233343536using System;namespace FlyweightSample&#123; class Program &#123; static void Main(string[] args) &#123; IgoChessman black1,black2,black3,white1,white2; IgoChessmanFactory factory; // 获取享元工厂对象 factory = IgoChessmanFactory.GetInstance(); // 通过享元工厂获取三颗黑子 black1 = factory.GetIgoChessman("b"); black2 = factory.GetIgoChessman("b"); black3 = factory.GetIgoChessman("b"); Console.WriteLine("判断两颗黑子是否相同：" + (black1 == black2)); // 通过享元工厂获取两颗白子 white1 = factory.GetIgoChessman("w"); white2 = factory.GetIgoChessman("w"); Console.WriteLine("判断两颗白子是否相同：" + (white1 == white2)); // 显示棋子，同时设置棋子的坐标位置 black1.Display(new Coordinates(1, 2)); black2.Display(new Coordinates(3, 4)); black3.Display(new Coordinates(1, 3)); white1.Display(new Coordinates(2, 5)); white2.Display(new Coordinates(2, 4)); Console.Read(); &#125; &#125;&#125; 编译并运行程序，输出结果如下：1234567判断两颗黑子是否相同：True判断两颗白子是否相同：True棋子颜色：黑色，棋子位置：1，2 棋子颜色：黑色，棋子位置：3，4 棋子颜色：黑色，棋子位置：1，3棋子颜色：白色，棋子位置：2，5棋子颜色：白色，棋子位置：2，4 从输出结果可以看到，在每次调用Display()方法时，都设置了不同的外部状态——坐标值，因此相同的棋子对象虽然具有相同的颜色，但是它们的坐标值不同，将显示在棋盘的不同位置。 单纯享元模式和复合享元模式标准的享元模式结构图中既包含可以共享的具体享元类，也包含不可以共享的非共享具体享元类。但是在实际使用的过程中，有时候会用到两种特殊的享元模式：单纯享元模式和复合享元模式，下面对这两种特殊的享元模式进行简单的介绍。 1.单纯享元模式 在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。单纯享元模式的结构如图6所示。 图6 单纯享元模式结构图 2.复合享元模式 将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。复合享元模式的结构如图7所示。 图7 复合享元模式结构图 通过使用复合享元模式，可以让复合享元类CompositeConcreteFlyweight中所包含的每个单纯享元ConcreteFlyweight都具有相同的外部状态，而这些单纯享元的内部状态往往不同。如果希望为多个内部状态不同的享元对象设置相同的外部状态，可以考虑使用复合享元模式。 享元模式的优缺点与适用环境当系统中存在大量相同或者相似的对象时，享元模式是一种较好的解决方案，它通过共享技术实现相同或相似的细粒度对象的复用，从而节约了内存空间，提高了系统性能。相比其他结构型设计模式，享元模式的使用频率并不算太高，但是作为一种以“节约内存，提高性能”为出发点的设计模式，它在软件开发中还是得到了一定程度的应用。 享元模式的优点享元模式的主要优点如下： (1)享元模式可以减少内存中对象的数量，使得相同或者相似的对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。 (2)在享元模式中，外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。 享元模式的缺点享元模式的主要缺点如下： (1)享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。 (2)为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。 享元模式的适用环境在以下情况下可以考虑使用享元模式： (1)一个系统有大量相同或者相似的对象，造成了内存的大量耗费。 (2)对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。 (3)在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，在需要多次重复使用享元对象时才值得使用享元模式。 本章小结(1)享元模式运用共享技术有效地支持大量细粒度对象的复用。通过使用享元模式，系统只需使用少量的对象，而这些对象都很相似，状态变化很小，因此可以实现对象的多次复用，享元模式是一种对象结构型模式。 (2)享元模式包含抽象享元类、具体享元类、非共享具体享元类和享元工厂类4个角色。其中，在抽象享元类中声明了具体享元类公共的方法；具体享元类实现了抽象享元接口，为内部状态提供了存储空间；非共享具体享元是不能被共享的抽象享元类的子类；享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中。 (3)享元模式的主要优点是可以极大地减少内存中对象的数量，使得相同或相似的对象在内存中只保存一份，从而节约系统资源，提高系统性能。其主要缺点是使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化；此外，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。 (4)享元模式适用的环境：一个系统有大量相同或者相似的对象，造成内存的大量耗费；对象的大部分状态都可以外部化，可以将这些外部状态传入对象中；需要多次重复使用享元对象。 (5)享元模式以共享的方式高效地支持大量细粒度对象的重用，享元对象能做到共享的关键是区分了内部状态和外部状态。内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，内部状态可以共享；外部状态是随环境改变而改变的、不可以共享的状态。 (6)在单纯享元模式中，所有的具体享元类都是可以共享的，不存在非共享具体享元类。将一些单纯享元对象使用组合模式加以组合，还可以形成复合享元对象。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2F2019%2F09%2F21%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 中介者模式为什么是行为型模式？为什么是迪米特法则的一个典型应用？ 中介者模式的核心在于中介者类的引入，中介者类维护一个同事类的列表。怎么理解？ 像QQ群一样，QQ群维护了其他用户的QQ。怎么理解？ 本章导学 对于对象之间存在复杂交互关系的系统，中介者模式提供了一种简化复杂交互的解决方案，它通过引入中介者，将原本对象之间的两两交互转化为每个对象与中介者之间的交互，中介者可以对对象之间的通信进行控制与协调，降低了原有系统的耦合度，使得系统更加灵活，也更易于扩展。 本章将学习中介者模式的定义与结构，理解为何以及如何引入中介者角色，学会编程实现中介者模式以及理解如何通过中介者模式来简化对象之间的复杂交互关系。 本章知识点 中介者模式的定义 中介者模式的结构 中介者模式的实现 中介者模式的应用 中介者模式的优缺点 中介者模式的适用环境 中介者模式概述在QQ聊天中存在两种聊天方式：第一种是用户与用户直接聊天，第二种是通过QQ群聊天，如图1所示。如果使用图1（a）所示方式，一个用户要与其他用户聊天或发送文件，通常需要加其他用户为好友，用户与用户之间存在多对多的联系，这将导致系统中用户之间的关系非常复杂，一个用户如果将相同的信息或文件发送给其他所有用户，必须一个一个地发送，于是QQ群产生了，如图1（b）所示。如果使用QQ群，一个用户可以向多个用户发送相同的信息和文件而无须一一发送，只需将信息或文件发送到群中或上传为群共享文件即可，群的作用就是将发送者所发送的信息和文件转发给每一个接收者。通过引入群的机制，将极大地减少系统中用户之间的两两通信，用户与用户之间的联系可以通过群来实现。 图1 QQ聊天示意图 在软件系统中，某些类/对象之间的相互调用关系错综复杂，类似QQ用户之间的关系，此时，特别需要一个类似“QQ群”一样的中间类来协调这些类/对象之间的复杂关系，以降低系统的耦合度。中介者模式为此而“诞生”，它通过在系统中增加中介者对象来降低原有类/对象之间的复杂引用关系。 下面对中介者模式的模式动机做进一步说明： 如果在一个系统中对象之间的联系呈现为网状结构，如图2所示，对象之间存在着大量的多对多联系，将导致系统非常复杂，这些对象既会影响其他对象，也会被其他对象所影响，这些对象被称为同事对象，它们之间通过彼此的相互作用实现系统的行为。在网状结构中，几乎每个对象都需要与其他对象发生相互作用，而这种相互作用表现为一个对象与另外一个对象的直接耦合，这将导致一个过度耦合的系统。 图2 对象之间存在复杂关系的网状结构 中介者模式可以使对象之间的关系数量急剧减少，通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，如图3所示。在这个星形结构中，同事对象不再直接与另一个对象联系，它通过中介者对象与另一个对象发生相互作用。中介者对象的存在保证了对象结构上的稳定，也就是说，系统的结构不会因为新对象的引入带来大量的修改工作。 图3 引入中介者对象的星形结构 如果在一个系统中对象之间存在着多对多的相互关系，可以将对象之间的一些交互行为从各个对象中分离出来，集中封装在一个中介者对象中，并由该中介者进行统一协调，这样对象之间多对多的复杂关系就转化为相对简单的一对多关系。 中介者模式的定义如下：1定义一个对象来封装一系列对象的交互。中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且让你可以独立地改变它们之间的交互。 中介者模式又称为调停者模式，它是一种对象行为型模式。在中介者模式中，通过引入中介者来简化对象之间的复杂交互，中介者模式是迪米特法则的一个典型应用。 中介者模式的结构与实现中介者模式的结构在中介者模式中，引入了用于协调其他对象/类之间相互调用的中介者类，为了让系统具有更好的灵活性和可扩展性，通常还提供了抽象中介者，其结构如图4所示。 图4 中介者模式结构图 由图4可知，中介者模式包含以下4个角色。 (1)Mediator（抽象中介者）：它定义一个接口，该接口用于与各同事对象之间进行通信。 (2)ConcreteMediator（具体中介者）：它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，维持了对各个同事对象的引用。 (3)Colleague（抽象同事类）：它定义各个同事类公有的方法，并声明了一些抽象方法供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用与中介者通信。 (4)ConcreteColleague（具体同事类）：它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。 中介者模式的实现中介者模式的核心在于中介者类的引入，在中介者模式中，中介者类承担了两个方面的职责。 (1)中转作用（结构性）：通过中介者提供的中转作用，各个同事对象不再需要显式地引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用。该中转作用属于中介者在结构上的支持。 (2)协调作用（行为性）：中介者可以更进一步对同事之间的关系进行封装，同事可以一致地和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。 在中介者模式中，典型的抽象中介者类代码如下： 12345678910111213141516using System.Collections.Generic;abstract class Mediator&#123; // 用于存储同事对象 protected List&lt;Colleague&gt; colleague = new List&lt;Colleague&gt;(); // 注册方法，用于增加同事对象 public void Register(Colleague colleague) &#123; colleague.Add(colleague); &#125; // 声明抽象的业务方法 public abstract void Operation();&#125; 在抽象中介者中可以定义一个同事类的集合，用于存储同事对象并提供注册方法，同时声明了具体中介者类所具有的方法。在具体中介者类中将实现这些抽象方法，典型的具体中介者类代码如下：12345678910class ConcreteMediator : Mediator&#123; // 实现业务方法，封装同事之间的调用 public override void Operation() &#123; ... ((Colleague)(colleagues[0])).Method1(); // 通过中介者调用同事类的方法 .. &#125;&#125; 在具体中介者类中将调用同事类的方法，调用时可以增加一些自己的业务代码对调用进行控制。 在抽象同事类中维持了一个抽象中介者的引用，用于调用中介者的方法。典型的抽象同事类代码如下：123456789101112131415161718abstract class Colleague&#123; // 维持一个抽象中介者的引用 protected Mediator mediator; public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125; public abstract void Method1(); // 声明自身方法，处理自己的行为 // 定义依赖方法，与中介者进行通信 public void Method2() &#123; mediator.Operation(); &#125;&#125; 在抽象同事类中声明了同事类的抽象方法，在具体同事类中将实现这些方法。典型的具体同事类代码如下：12345678910111213class ConcreteColleague : Colleague&#123; public ConcreteColleague(Mediator mediator) : base(mediator) &#123; &#125; // 实现自身方法 public override void Method1() &#123; ... &#125;&#125; 在具体同事类ConcreteColleague中实现了在抽象同事类中声明的方法，其中，方法Method1()是同事类的自身方法（Self-Method），用于处理自己的行为，而方法Method2()是依赖方法（Depend-Method），用于调用在中介者中定义的方法，依赖中介者完成相应的行为，例如调用另一个同事类的相关方法。 中介者模式的应用实例下面通过一个应用实例来进一步学习和理解中介者模式。 1.实例说明 某软件公司要开发一套CRM系统，其中包含一个客户信息管理模块，所设计的“客户信息管理窗口”界面效果图如图5所示。图5 “客户信息管理窗口”界面效果图 通过分析发现，在图5中，界面组件之间存在着较为复杂的交互关系：如果删除一个客户，将从客户列表（List）中删掉对应的项，客户选择组合框（ComboBox）中的客户名称也将减少一个；如果增加一个客户信息，则客户列表中将增加一个客户，且组合框中也将增加一项。 为了更好地处理界面组件之间的交互，现使用中介者模式设计该系统。 2.实例类图 为了协调界面组件对象之间的复杂交互关系，可引入一个中介者类，其结构如图6所示。 图6 引入中介者类的“客户信息管理窗口”结构示意图 图6只是一个结构示意图，在具体实现时，为了确保系统具有更好的灵活性和可扩展性，需要定义抽象中介者和抽象组件类，其中，抽象组件类是所有具体组件类的公共父类，完整类图如图7所示。 图7 “客户信息管理窗口”结构图 在图7中，Component充当抽象同事类，Button、List、ComboBox和TextBox充当具体同事类，Mediator充当抽象中介者类，ConcreteMediator充当具体中介者类，ConcreteMediator维持了对具体同事类的引用，为了简化ConcreteMediator类的代码，在其中只定义了一个Button对象和一个TextBox对象。 3.实例代码 (1)Mediator：抽象中介者类。 1234567namespace MediatorSample&#123; abstract class Mediator &#123; public abstract void ComponentChanged(Component c); &#125;&#125; (2)ConcreteMediator：具体中介者类。 12345678910111213141516171819202122232425262728293031323334353637383940using System;namespace MediatorSample&#123; class ConcreteMediator : Mediator &#123; // 维持对各个同事对象的引用 public Button addButton; public List list; public TextBox userNameTextBox; public ComboBox cb; // 封装同事对象之间的交互 public override void ComponentChanged(Component c) &#123; // 单击按钮 if (c == addButton) &#123; Console.WriteLine("--单击增加按钮--"); list.Update(); cb.Update(); userNameTextBox.Update(); &#125; // 从列表框选择客户 else if (c == list) &#123; Console.WriteLine("--从列表框选择客户--"); cb.Select(); userNameTextBox.SetText(); &#125; // 从组合框选择客户 else if (c == cb) &#123; Console.WriteLine("--从组合框选择客户--"); cb.Select(); userNameTextBox.SetText(); &#125; &#125; &#125;&#125; (3)Component：抽象组件类，充当抽象同事类。 1234567891011121314151617181920namespace MediatorSample&#123; abstract class Component &#123; protected Mediator mediator; public void SetMediator(Mediator mediator) &#123; this.mediator = mediator; &#125; // 转发调用 public void Changed() &#123; mediator.ComponentChanged(this); &#125; public abstract void Update(); &#125;&#125; (4)Button：按钮类，充当具体同事类。 12345678910namespace MediatorSample&#123; class Button : Component &#123; public override void Update() &#123; // 按钮不产生响应 &#125; &#125;&#125; (5)List：列表框类，充当具体同事类。 1234567891011121314151617using System;namespace MediatorSample&#123; class List : Component &#123; public override void Update() &#123; Console.WriteLine("列表框增加一项：张无忌。"); &#125; public void Select() &#123; Console.WriteLine("列表框选中项：小龙女。"); &#125; &#125;&#125; (6)ComboBox：组合框类，充当具体同事类。 1234567891011121314151617using System;namespace MediatorSample&#123; class ComboBox : Component &#123; public override void Update() &#123; Console.WriteLine("组合框增加一项：张无忌。"); &#125; public void Select() &#123; Console.WriteLine("组合框选中项：小龙女。"); &#125; &#125;&#125; (7)TextBox：文本框类，充当具体同事类。 1234567891011121314151617using System;namespace MediatorSample&#123; class TextBox : Component &#123; public override void Update() &#123; Console.WriteLine("客户信息增加成功后文本框清空。"); &#125; public void SetText() &#123; Console.WriteLine("文本框显示：小龙女。"); &#125; &#125;&#125; (8)Program：客户端测试类。 12345678910111213141516171819202122232425262728293031323334353637using System;namespace MediatorSample&#123; class Program &#123; static void Main(string[] args) &#123; // 定义中介者对象 ConcreteMediator mediator; mediator = new ConcreteMediator(); // 定义同事对象 Button addBT = new Button(); List list = new List(); ComboBox cb = new ComboBox(); TextBox userNameTB = new TextBox(); addBT.SetMediator(mediator); list.SetMediator(mediator); cb.SetMediator(mediator); userNameTB.SetMediator(mediator); mediator.addButton = addBT; mediator.list = list; mediator.cb = cb; mediator.userNameTextBox = userNameTB; addBT.Changed(); Console.WriteLine("-----------------------------"); list.Changed(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12345678--单击增加按钮-- 列表框增加一项：张无忌。 组合框增加一项：张无忌。 客户信息增加成功后文本框清空。-------------------------------从列表框选择客户-- 组合框选中项：小龙女。 文本框显示：小龙女。 在引入中介者后，同事之间的复杂交互由中介者间接实现，当某个组件类的Changed()方法被调用时，中介者的ComponentChanged()方法将被调用，在中介者的ComponentChanged()方法中再逐个调用与该组件有交互的其他组件的相关方法。如果某个组件类需要与新的组件进行交互，无须修改已有组件类的源代码，只需修改中介者或者对现有中介者进行扩展即可，系统具有更好的灵活性和可扩展性。 扩展中介者与同事类本节将对上一节中的“客户信息管理窗口”进行改进，在窗口的下端能够及时显示当前系统中客户信息的总数，如图8所示。 图8 修改之后的“客户信息管理窗口”界面图 从图8中不难发现，可以通过增加一个文本标签(Label)来显示客户信息总数，而且当用户单击“增加”按钮或者“删除”按钮时，将改变文本标签的内容。 由于使用了中介者模式，在原有系统中增加新的组件（即新的同事类）将变得很容易，至少有以下两种解决方案。 方案(1)：增加一个界面组件类Label，修改原有具体中介者类ConcreteMediator，增加一个对Label对象的引用，然后修改ComponentChanged()方法中其他相关组件对象的业务处理代码，原有组件类无须任何修改，客户端代码需针对新增组件Label进行适当修改。 方案(2)：与方案(1)类似，首先增加一个Label类，但不修改原有具体中介者类ConcreteMediator的代码，而是增加一个ConcreteMediator的子类SubConcreteMediator来实现对Label对象的引用，然后在新增的中介者类SubConcreteMediator中通过覆盖ComponentChanged()方法实现所有组件(包括新增组件Label)之间的交互，同样，原有组件类无须做任何修改，客户端代码需少许修改。 引入Label之后的“客户信息管理窗口”类结构示意图如图9所示。 图9 增加Label组件类后的“客户信息管理窗口”结构示意图 由于方案(2)无须修改ConcreteMediator类，更符合开闭原则，因此选择方案(2)对新增Label类进行处理，对应的完整类图如图10所示。 图10 修改之后的“客户信息管理窗口”结构图 在图10中新增了具体同事类Label和具体中介者类SubConcreteMediator，代码如下： Label.cs 文本标签类，充当具体同事类 123456789101112using System;namespace MediatorSample&#123; class Label : Component &#123; public override void Update() &#123; Console.WriteLine("文本标签内容改变，客户信息总数加1。"); &#125; &#125;&#125; SubConcreteMediator.cs 新增具体中介者类 12345678910111213141516171819202122232425262728293031323334353637using System;namespace MediatorSample&#123; class SubConcreteMediator : ConcreteMediator &#123; // 增加对Label对象的引用 public Label label; public override void ComponentChanged(Component c) &#123; // 单击按钮 if (c == addButton) &#123; Console.WriteLine("--单击增加按钮--"); list.Update(); cb.Update(); userNameTextBox.Update(); label.Update(); // 文本标签更新 &#125; // 从列表框选择客户 else if (c == list) &#123; Console.WriteLine("--从列表框选择客户--"); cb.Select(); userNameTextBox.SetText(); &#125; // 从组合框选择客户 else if (c == cb) &#123; Console.WriteLine("--从组合框选择客户--"); cb.Select(); userNameTextBox.SetText(); &#125; &#125; &#125;&#125; 修改客户端测试代码如下：1234567891011121314151617181920212223242526272829303132333435363738using System;namespace MediatorSample&#123; class Program &#123; static void Main(string[] args) &#123; // 用新增具体中介者定义中介者对象 SubConcreteMediator mediator; mediator = new SubConcreteMediator(); Button addBT = new Button(); List list = new List(); ComboBox cb = new ComboBox(); TextBox userNameTB = new TextBox(); Label label = new Label(); addBT.SetMediator(mediator); list.SetMediator(mediator); cb.SetMediator(mediator); userNameTB.SetMediator(mediator); label.SetMediator(mediator); mediator.addButton = addBT; mediator.list = list; mediator.cb = cb; mediator.userNameTextBox = userNameTB; mediator.label = label; addBT.Changed(); Console.WriteLine("-----------------------------"); list.Changed(); Console.Read(); &#125; &#125;&#125; 编译并运行程序，输出结果如下：123456789--单击增加按钮-- 列表框增加一项：张无忌。 组合框增加一项：张无忌。 客户信息增加成功后文本框清空。文本标签内容改变，客户信息总数加1。-------------------------------从列表框选择客户-- 组合框选中项：小龙女。 文本框显示：小龙女。 由于在本实例中不同的组件类(即不同的同事类)拥有的方法并不完全相同，因此，中介者类没有针对抽象同事类编程，导致在具体中介者类中需要维持对具体同事类的引用，客户端代码无法完全透明地对待所有同事类和中介者类。在某些情况下，如果设计得当，可以在客户端透明地对同事类和中介者类编程，这样系统将具有更好的灵活性和可扩展性。 在中介者模式的实际使用过程中，如果需要引入新的具体同事类，只需继承抽象同事类并实现其中的方法即可，由于具体同事类之间并无直接的引用关系，因此原有所有同事类无须进行任何修改，它们与新增同事对象之间的交互可以通过修改或者增加具体中介者类来实现；如果需要在原有系统中增加新的具体中介者类，只需继承抽象中介者类（或已有的具体中介者类）并覆盖其中定义的方法即可，在新的具体中介者中可以通过不同的方式来处理对象之间的交互，也可以增加对新增同事的引用和调用。在客户端中只需修改少许代码（如果引入配置文件可以不用修改任何代码）就可以实现中介者类的更换。 中介者模式的优缺点与适用环境中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星形结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。中介者模式在事件驱动类软件中的应用较为广泛，特别是基于GUI(Graphical User Interface，图形用户界面）的应用软件，此外，在类与类之间存在错综复杂的关联关系的系统中，中介者模式也得到了较好的应用。 中介者模式的优点中介者模式的主要优点如下： (1)中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星形结构。 (2)可将各同事对象解耦，中介者模式有利于各同事之间的松耦合，可以独立地改变和复用每一个同事和中介者，增加新的中介者类和新的同事类都比较方便，更好地符合开闭原则。 (3)可以减少子类的生成，中介者模式将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使得各个同事类可被重用，无须直接对同事类进行扩展。 中介者模式的缺点中介者模式的主要缺点如下： 在具体中介者类中包含了大量的同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。 中介者模式的适用环境在以下情况下可以考虑使用中介者模式： (1)系统中对象之间存在着复杂的引用关系，系统结构混乱且难以理解。 (2)一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。 (3)用户想通过一个中间类来封装多个类中的行为，又不想生成太多的子类，此时可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。 本章小结(1)中介者模式通过定义一个对象来封装一系列对象的交互。中介者模式使各对象之间不需要显式地相互引用，从而使其耦合松散，而且让你可以独立地改变它们之间的交互。 (2)中介者模式包含抽象中介者、具体中介者、抽象同事类和具体同事类4个角色。其中，抽象中介者定义一个接口，该接口用于和各同事对象之间进行通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用；抽象同事类定义各个同事类公有的方法，并声明了一些抽象方法供子类实现；具体同事类是抽象同事类的子类，每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者间接完成与其他同事类的通信。 (3)中介者模式的主要优点包括它简化了对象之间的交互，可将各同事对象解耦，还可以减少子类的生成。其主要缺点是在具体中介者类中包含了大量的同事之间的交互细节可能会导致具体中介者类非常复杂，使得系统难以维护。 (4)中介者模式适用的环境：系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；用户想通过一个中间类来封装多个类中的行为，又不想生成太多的子类。 (5)在中介者模式中，中介者类承担了中转和协调双重职责。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态模式]]></title>
    <url>%2F2019%2F09%2F21%2F%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 有些对象也像水一样具有多种状态，这些状态在某些情况下能够相互转换。游戏中是什么对象？ 统一由环境类来负责状态之间的转换和由具体状态类来负责状态之间的转换有什么不同？ 本章导学 状态模式是一种较为复杂的设计模式，用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中的某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。 本章将学习状态模式的定义与结构，分析状态模式的特点，并结合实例学习状态模式的实现过程，学会如何在实际软件项目开发中应用状态模式。 本章知识点 状态模式的定义 状态模式的结构 状态模式的实现 状态模式的应用 状态模式的优缺点 状态模式的适用环境 共享状态 使用环境类实现状态的转换 状态模式概述“人有悲欢离合，月有阴晴圆缺”，包括人在内，很多事物都具有多种状态，而且在不同状态下会具有不同的行为，这些状态在特定条件下还将发生相互转换。就像水，它可以凝固成冰，也可以受热蒸发后变成水蒸气，水可以流动，冰可以雕刻，水蒸气可以扩散。可以用UML状态图来描述H2O的3种状态，如图1所示。 图1 H2O的3种状态（未考虑临界点） 在软件系统中，有些对象也像水一样具有多种状态，这些状态在某些情况下能够相互转换，而且对象在不同的状态下也将具有不同的行为。通常可以使用复杂的条件判断语句（例如if…else…语句）来进行状态的判断和转换操作，这会导致代码的可维护性和灵活性下降，特别是出现新的状态时，代码的扩展性很差，客户端代码也需要进行相应的修改，违背了开闭原则。为了解决状态的转换问题，并降低客户端代码与对象状态之间的耦合度，可以使用一种被称为状态模式的设计模式。 状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中的某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。对于客户端而言，无须关心对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。 状态模式的定义如下：1允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。 状态模式又称为状态对象（Objects for States），它是一种对象行为型模式。 状态模式的结构与实现状态模式的结构在状态模式中引入了抽象状态类和具体状态类，它们是状态模式的核心，其结构如图2所示。 由图2可知，状态模式包含以下3个角色。 图2 状态模式结构图 (1)Context（环境类）：环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性，且在不同状态下对象的行为有所不同，所以将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象。 (2)State（抽象状态类）：它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现了这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。 (3)Concretestate（具体状态类）：它是抽象状态类的子类，每一个具体状态类实现一个与环境类的一个状态相关的行为，对应环境类的一个具体状态，不同的具体状态类其行为有所不同。 状态模式的实现在状态模式中，将对象在不同状态下的行为封装到不同的状态类中，为了让系统具有更好的灵活性和可扩展性，同时对各状态下的共有行为进行封装，需要对状态进行抽象化，引入了抽象状态类角色。其典型代码如下：12345abstract class State&#123; // 声明抽象业务方法，不同的具体状态类可以有不同的实现 public abstract void Handle();&#125; 在抽象状态类的子类（即具体状态类）中实现了在抽象状态类中声明的业务方法，不同的具体状态类可以提供完全不同的方法实现。实际使用时，在一个状态类中可能包含多个业务方法，如果在具体状态类中某些业务方法的实现完全相同，则可以将这些方法移至抽象状态类，实现代码的复用。典型的具体状态类代码如下：1234567class ConcreteState : State&#123; public override void Handle() &#123; // 方法具体实现代码 &#125;&#125; 环境类维持一个对抽象状态类的引用，通过SetState()方法可以向环境类注入不同的状态对象，再在环境类的业务方法中调用状态对象的方法。其典型代码如下：123456789101112131415161718class Context&#123; private State state; // 维持一个对抽象状态对象的引用 private int value; // 其他属性值，该属性值的变化可能会导致对象的状态发生变化 // 设置状态对象 public void SetState(State state) &#123; this.state = state; &#125; public void Request() &#123; // 其他代码 state.Handle(); // 调用状态对象的业务方法 // 其他代码 &#125;&#125; 环境类实际上是真正拥有状态的对象，只是将环境类中与状态有关的代码提取出来封装到专门的状态类中。在状态模式结构图中，环境类Context与抽象状态类State间存在着单向关联关系，在Context中定义了一个State对象。在实际使用时，它们之间可能存在更为复杂的关系，State与Context之间可能也存在依赖或者双向关联关系。 在状态模式的使用过程中，一个对象的状态之间还可以进行相互转换，通常有两种实现状态转换的方式。 (1)统一由环境类来负责状态之间的转换，此时，环境类还充当了状态管理器（StateManager）角色，在环境类的业务方法中通过对某些属性值的判断实现状态转换，也可以提供一个专门的方法用于实现属性判断和状态转换，代码片段如下：123456789101112131415...public void ChangeState()&#123; // 判断属性值，根据属性值进行状态转换 if (value == 0) &#123; this.SetState(new ConcreteStateA()); &#125; else if (value == 1) &#123; this.SetState(new ConcreteStateB()); &#125; ...&#125;... (2)由具体状态类来负责状态之间的转换，可以在具体状态类的业务方法中判断环境类的某些属性值，再根据情况为环境类设置新的状态对象，实现状态变换。同样，也可以提供一个专门的方法来负责属性值的判断和状态转换。此时，状态类与环境类之间将存在依赖或关联关系，因为状态类需要访问环境类中的属性值，具体状态类ConcreteStateA的代码片段如下：123456789101112131415...public void ChangeState(Context ctx)&#123; // 根据环境对象中的属性值进行状态转换 if (ctx.value == 1) &#123; ctx.SetState(new ConcreteStateB()); &#125; else if (ctx.value == 2) &#123; ctx.SetState(new ConcreteStateC()); &#125; ...&#125;... 状态模式的应用实例下面通过一个应用实例来进一步学习和理解状态模式。 1.实例说明 某软件公司要为一银行开发一套信用卡业务系统，银行账户（Account）是该系统的核心类之一，通过分析，该软件公司开发人员发现在系统中账户存在3种状态，且在不同状态下账户存在不同的行为，具体说明如下：(1)如果账户中余额大于等于0，则账户的状态为正常状态（NormalState），此时用户既可以向该账户存款也可以从该账户取款。(2)如果账户中余额小于0，并且大于-2000，则账户的状态为透支状态（OverdraftState），此时用户既可以向该账户存款也可以从该账户取款，但需要按天计算利息。(3)如果账户中余额等于-2000，那么账户的状态为受限状态（RestrictedState），此时用户只能向该账户存款，不能再从中取款，同时也将按天计算利息。(4)根据余额的不同，以上3种状态可发生相互转换。现使用状态模式设计并实现银行账户状态的转换。 2.实例类图 通过对银行账户类进行分析，可以绘制出图3所示的UML状态图。 图3 银行账户状态图 在图3中，NormalState表示正常状态，OverdraftState表示透支状态，RestrictedState表示受限状态。在这3种状态下账户对象拥有不同的行为，方法Deposit()用于存款，Withdraw()用于取款，ComputeInterest()用于计算利息，StateCheck()用于在每一次执行存款和取款操作后根据余额来判断是否要进行状态转换并实现状态转换，相同的方法在不同的状态下可能会有不同的实现。 使用状态模式对银行账户状态进行设计，所得的结构如图4所示。 图4 银行账户结构图 在图4中，Account充当环境类角色，AccountState充当抽象状态类角色，NormalState、OverdraftState和RestrictedState充当具体状态类角色。 3.实例代码 (1)Account：银行账户，充当环境类。 Account.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354using System;namespace StateSample&#123; class Account &#123; private AccountState state; // 维持一个对抽象状态对象的引用 private string owner; // 开户名 private double balance = 0; // 账户余额 public Account(string owner, double init) &#123; this.owner = owner; this.balance = init; this.state = new NormalState(this); // 设置初始状态 Console.WriteLine("&#123;0&#125;开户，初始金额为&#123;1&#125;", this.owner ,init); Console.WriteLine("---------------------------------------------"); &#125; public double Balance &#123; get &#123; return balance; &#125; set &#123; balance = value; &#125; &#125; public void SetState(AccountState state) &#123; this.state = state; &#125; public void Deposit(double amount) &#123; Console.WriteLine("&#123;0&#125;存款&#123;1&#125;", this.owner,amount); state.Deposit(amount); // 调用状态对象的Deposit()方法 Console.WriteLine("现在余额为&#123;0&#125;", this.Balance); Console.WriteLine("现在帐户状态为&#123;0&#125;",this.state.GetType().ToString()); Console.WriteLine("---------------------------------------------"); &#125; public void Withdraw(double amount) &#123; Console.WriteLine("&#123;0&#125;取款&#123;1&#125;",this.owner, amount); state.Withdraw(amount); // 调用状态对象的Withdraw()方法 Console.WriteLine("现在余额为&#123;0&#125;", this.Balance); Console.WriteLine("现在帐户状态为&#123;0&#125;", this.state.GetType().ToString()); Console.WriteLine("---------------------------------------------"); &#125; public void ComputeInterest() &#123; state.ComputeInterest(); // 调用状态对象的ComputeInterest()方法 &#125; &#125;&#125; (2)AccountState：账户状态类，充当抽象状态类。 AccountState.cs 1234567891011121314151617namespace StateSample&#123; abstract class AccountState &#123; private Account acc; public Account Acc &#123; get &#123; return acc; &#125; set &#123; acc = value; &#125; &#125; public abstract void Deposit(double amount); public abstract void Withdraw(double amount); public abstract void ComputeInterest(); public abstract void StateCheck(); &#125;&#125; (3)NormalState：正常状态类，充当具体状态类。 NormalState.cs 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051using System;namespace StateSample&#123; class NormalState : AccountState &#123; public NormalState(Account acc) &#123; this.Acc = acc; &#125; public NormalState(AccountState state) &#123; this.Acc = state.Acc; &#125; public override void Deposit(double amount) &#123; Acc.Balance = Acc.Balance + amount; StateCheck(); &#125; public override void Withdraw(double amount) &#123; Acc.Balance = Acc.Balance - amount; StateCheck(); &#125; public override void ComputeInterest() &#123; Console.WriteLine("正常状态，无须支付利息！"); &#125; // 状态转换 public override void StateCheck() &#123; if (Acc.Balance &gt; -2000 &amp;&amp; Acc.Balance &lt;= 0) &#123; Acc.SetState(new OverdraftState(this)); &#125; else if (Acc.Balance == -2000) &#123; Acc.SetState(new RestrictedState(this)); &#125; else if (Acc.Balance &lt; -2000) &#123; Console.WriteLine("操作受限！"); &#125; &#125; &#125;&#125; (4)OverdraftState：透支状态类，充当具体状态类。 OverdraftState.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546using System;namespace StateSample&#123; class OverdraftState : AccountState &#123; public OverdraftState(AccountState state) &#123; this.Acc = state.Acc; &#125; public override void Deposit(double amount) &#123; Acc.Balance = Acc.Balance + amount; StateCheck(); &#125; public override void Withdraw(double amount) &#123; Acc.Balance = Acc.Balance - amount; StateCheck(); &#125; public override void ComputeInterest() &#123; Console.WriteLine("计算利息！"); &#125; // 状态转换 public override void StateCheck() &#123; if (Acc.Balance &gt; 0) &#123; Acc.SetState(new NormalState(this)); &#125; else if (Acc.Balance == -2000) &#123; Acc.SetState(new RestrictedState(this)); &#125; else if (Acc.Balance &lt; -2000) &#123; Console.WriteLine("操作受限！"); &#125; &#125; &#125;&#125; (5)RestrictedState：受限状态类，充当具体状态类。 RestrictedState.cs 1234567891011121314151617181920212223242526272829303132333435363738394041using System;namespace StateSample&#123; class RestrictedState : AccountState &#123; public RestrictedState(AccountState state) &#123; this.Acc = state.Acc; &#125; public override void Deposit(double amount) &#123; Acc.Balance = Acc.Balance + amount; StateCheck(); &#125; public override void Withdraw(double amount) &#123; Console.WriteLine("帐号受限，取款失败"); &#125; public override void ComputeInterest() &#123; Console.WriteLine("计算利息！"); &#125; // 状态转换 public override void StateCheck() &#123; if (Acc.Balance &gt; 0) &#123; Acc.SetState(new NormalState(this)); &#125; else if (Acc.Balance &gt; -2000) &#123; Acc.SetState(new OverdraftState(this)); &#125; &#125; &#125;&#125; (6)Program：客户端测试类。 Program.cs 1234567891011121314151617181920using System;namespace StateSample&#123; class Program &#123; static void Main(string[] args) &#123; Account acc = new Account("段誉", 0.0); acc.Deposit(1000); acc.Withdraw(2000); // ① acc.Deposit(3000); acc.Withdraw(4000); // ② acc.Withdraw(1000); // ③ acc.ComputeInterest(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：123456789101112131415161718192021222324段誉开户，初始金额为0---------------------------------------------段誉存款1000现在余额为1000现在账户状态为StateSample.NormalState---------------------------------------------①段誉取款2000现在余额为-1000现在账户状态为StateSample.OverdraftState---------------------------------------------段誉存款3000现在余额为2000现在账户状态为StateSample.NormalState---------------------------------------------②段誉取款4000现在余额为-2000现在账户状态为StateSample.RestrictedState---------------------------------------------③段誉取款1000账号受限，取款失败现在余额为-2000现在账户状态为StateSample.RestrictedState---------------------------------------------计算利息！ ①②③部分对应客户端代码中3次调用取款方法Withdraw()的输出结果，由于对象状态不一样，因此这3次输出结果有所差异。第一次取款后账户状态由正常状态（NormalState）变为透支状态（OverdraftState）；第二次取款后账户状态由正常状态（NormalState）变为受限状态（RestrictedState）；在第三次取款时，由于账户状态已经为受限状态，因此取款失败。这3次取款操作体现了对象在不同状态下具有不同的行为，而且对象的转换是自动的，客户端无须关心其转换细节。 共享状态在有些情况下，多个环境对象可能需要共享同一个状态，如果希望在系统中实现多个环境对象共享一个或多个状态对象，那么需要将这些状态对象定义为环境类的静态成员对象。下面通过一个简单实例来说明如何实现共享状态。 某系统要求两个开关对象要么都处于开的状态，要么都处于关的状态，在使用时它们的状态必须保持一致，开关可以由开转换到关，也可以由关转换到开。试使用状态模式来实现开关的设计。 通过分析，其结构如图5所示。 图5 开关及其状态设计结构图 开关类的代码如下： Switch.cs 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;namespace SwitchStateSample&#123; class Switch &#123; private static SwitchState currentState, onState, offState; // 定义三个静态的状态对象 private string name; public Switch(string name) &#123; this.name = name; onState = new OnState(); offState = new OffState(); currentState = onState; &#125; public void SetState(SwitchState state) &#123; currentState = state; &#125; public static SwitchState GetState(string type) &#123; if (type.Equals("on")) &#123; return onState; &#125; else &#123; return offState; &#125; &#125; // 打开开关 public void On() &#123; Console.Write(name); currentState.On(this); &#125; // 关闭开关 public void Off() &#123; Console.Write(name); currentState.Off(this); &#125; &#125;&#125; 抽象状态类的代码如下： SwitchState.cs 12345678namespace SwitchStateSample&#123; abstract class SwitchState &#123; public abstract void On(Switch s); public abstract void Off(Switch s); &#125;&#125; 两个具体状态类的代码如下： OnState.cs 123456789101112131415161718using System;namespace SwitchStateSample&#123; class OnState : SwitchState &#123; public override void On(Switch s) &#123; Console.WriteLine("已经打开！"); &#125; public override void Off(Switch s) &#123; Console.WriteLine("关闭！"); s.SetState(Switch.GetState("off")); &#125; &#125;&#125; OffState.cs 123456789101112131415161718using System;namespace SwitchStateSample&#123; class OffState : SwitchState &#123; public override void On(Switch s) &#123; Console.WriteLine("打开！"); s.SetState(Switch.GetState("on")); &#125; public override void Off(Switch s) &#123; Console.WriteLine("已经关闭！"); &#125; &#125;&#125; 编写以下客户端代码进行测试： Program.cs 1234567891011121314151617181920212223using System;namespace SwitchStateSample&#123; class Program &#123; static void Main(string[] args) &#123; Switch s1, s2; s1 = new Switch("开关1"); s2 = new Switch("开关2"); s1.On(); s2.On(); s1.Off(); s2.Off(); s2.On(); s1.On(); Console.Read(); &#125; &#125;&#125; 输出结果如下：123456开关1已经打开！开关2已经打开！开关1关闭！开关2已经关闭！开关2打开！开关1已经打开！ 从输出结果可以得知：两个开关共享相同的状态，如果第一个开关关闭，则第二个开关也将关闭，再次关闭时将输出“已经关闭”，打开时也将得到类似结果。 使用环境类实现状态的转换在状态模式中实现状态转换时，具体状态类可通过调用环境类Context的SetState()方法进行状态的转换操作，也可以统一由环境类Context实现状态的转换。此时，增加新的具体状态类可能需要修改其他具体状态类或者环境类的源代码，否则系统无法转换到新增状态。但是对于客户端而言，无须关心状态类，可以为环境类设置默认的状态类，而将状态的转换工作交给具体状态类或环境类来完成，具体的转换细节对于客户端而言是透明的。 在之前的“银行账户状态转换”实例中，通过具体状态类来实现状态的转换，在每一个具体状态类中都包含一个StateCheck()方法，在该方法内部实现状态的转换。除此之外，还可以通过环境类来实现状态转换，环境类作为一个状态管理器，统一实现各种状态之间的转换操作。 下面通过一个包含循环状态的简单实例来说明如何使用环境类实现状态转换。 现要开发一个屏幕放大镜工具，其具体功能描述如下：用户单击“放大镜”按钮之后屏幕将放大一倍，再单击一次“放大镜”按钮屏幕再放大一倍，第三次单击该按钮后屏幕将还原到默认大小。试使用状态模式来设计该屏幕放大镜工具。 通过分析，可以定义3个屏幕状态类NormalState、LargerState和LargestState来对应屏幕的3种状态，分别是正常状态、二倍放大状态和四倍放大状态，屏幕类Screen充当环境类，其结构如图6所示。 图6 屏幕放大镜工具结构图 本实例的核心代码如下： Screen.cs：屏幕类 1234567891011121314151617181920212223242526272829303132333435363738394041424344using System;namespace ScreenStateSample&#123; class Screen &#123; // 枚举所有的状态，currentState表示当前状态 private ScreenState currentState, normalState, largerState, largestState; public Screen() &#123; this.normalState = new NormalState(); // 创建正常状态对象 this.largerState = new LargerState(); // 创建二倍放大状态对象 this.largestState = new LargestState(); // 创建四倍放大状态对象 this.currentState = normalState; // 设置初始状态 this.currentState.Display(); &#125; public void SetState(ScreenState state) &#123; this.currentState = state; &#125; // 单击事件处理方法，封转了对状态类中业务方法的调用和状态的转换 public void OnClick() &#123; if (this.currentState == normalState) &#123; this.SetState(largerState); this.currentState.Display(); &#125; else if (this.currentState == largerState) &#123; this.SetState(largestState); this.currentState.Display(); &#125; else if (this.currentState == largestState) &#123; this.SetState(normalState); this.currentState.Display(); &#125; &#125; &#125;&#125; ScreenState.cs：抽象状态类 123456789using System;namespace ScreenStateSample&#123; abstract class ScreenState &#123; public abstract void Display(); &#125;&#125; NormalState.cs：正常状态类 123456789101112using System;namespace ScreenStateSample&#123; class NormalState : ScreenState &#123; public override void Display() &#123; Console.WriteLine("正常大小！"); &#125; &#125;&#125; LargerState.cs：二倍状态类 123456789101112using System;namespace ScreenStateSample&#123; class LargerState : ScreenState &#123; public override void Display() &#123; Console.WriteLine("二倍大小！"); &#125; &#125;&#125; LargerState.cs：四倍状态类 123456789101112using System;namespace ScreenStateSample&#123; class LargestState : ScreenState &#123; public override void Display() &#123; Console.WriteLine("四倍大小！"); &#125; &#125;&#125; 在上述代码中，所有的状态转换操作都由环境类Screen来实现，此时，环境类充当了状态管理器角色。如果需要增加新的状态，例如“八倍状态类”，需要修改环境类，这在一定程度上违背了开闭原则，但对其他状态类没有任何影响。 编写以下客户端代码进行测试： Program.cs：客户端测试类 1234567891011121314151617using System;namespace ScreenStateSample&#123; class Program &#123; static void Main(string[] args) &#123; Screen screen = new Screen(); screen.OnClick(); screen.OnClick(); screen.OnClick(); Console.Read(); &#125; &#125;&#125; 输出结果如下：1234正常大小！二倍大小！四倍大小！正常大小！ 状态模式的优缺点与适用环境状态模式将一个对象在不同状态下的不同行为封装在一个个状态类中，通过设置不同的状态对象可以让环境对象拥有不同的行为，而状态转换的细节对于客户端而言是透明的，方便了客户端的使用。在实际开发中，状态模式具有较高的使用频率，在工作流、游戏等软件中状态模式都得到了广泛的应用，例如公文状态的转换、游戏中角色的升级等。 状态模式的优点状态模式的主要优点如下： (1)状态模式封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。 (2)状态模式将所有与某个状态有关的行为放到一个类中，只需注入一个不同的状态对象即可使环境对象拥有不同的行为。 (3)状态模式允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以避免使用庞大的条件语句将业务方法和状态转换代码交织在一起。 (4)状态模式可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。 状态模式的缺点状态模式的主要缺点如下： (1)状态模式会增加系统中类和对象的个数，导致系统运行开销增大。 (2)其结构与实现都较为复杂，如果使用不当将导致程序结构和代码混乱，增加系统设计的难度。 (3)状态模式对开闭原则的支持并不太好，增加新的状态类需要修改负责状态转换的源代码，否则无法转换到新增状态，而且修改某个状态类的行为也需要修改对应类的源代码。 状态模式的适用环境在以下情况下可以考虑使用状态模式： (1)对象的行为依赖于它的状态（例如某些属性值），状态的改变将导致行为的变化。 (2)在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。 本章小结(1)在状态模式中，允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。状态模式是一种对象行为型模式。 (2)状态模式包含环境类、抽象状态类和具体状态类3个角色。其中，环境类是拥有多种状态的对象；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现了这些方法；具体状态类是抽象状态类的子类，每一个具体状态类实现一个与环境类的一个状态相关的行为，对应环境类的一个具体状态，不同的具体状态类其行为有所不同。 (3)状态模式的主要优点包括它封装了状态的转换规则，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中；允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块；可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。其主要缺点包括状态模式会增加系统中类和对象的个数，导致系统运行开销增大；如果使用不当将导致程序结构和代码混乱，增加系统设计的难度；此外，状态模式对开闭原则的支持并不太好。 (4)状态模式适用的环境：对象的行为依赖于它的状态，状态的改变将导致行为的变化；在代码中包含大量与对象状态有关的条件语句。 (5)如果需要在系统中实现多个环境对象共享一个或多个状态对象，可以将这些状态对象定义为环境类的静态成员对象。 (6)在状态模式中，可以在具体状态类中实现状态之间的转换，也可以统一由环境类来负责状态之间的转换。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观察者模式]]></title>
    <url>%2F2019%2F09%2F21%2F%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章导学 在软件系统中，对象并不是孤立存在的，一个对象行为的改变可能会导致一个或多个其他与之存在依赖关系的对象行为发生改变。观察者模式用于描述对象之间的依赖关系，为实现多个对象之间的联动提供了一种解决方案，它是一种使用频率非常高的设计模式。 本章将学习观察者模式的定义与结构，分析观察者模式的实现原理，通过实例学习如何编程实现观察者模式并理解观察者模式在.NET事件处理中的应用。 本章知识点 观察者模式的定义 观察者模式的结构 观察者模式的实现 观察者模式的应用 观察者模式的优缺点 观察者模式的适用环境 观察者模式与.NET中的委托事件模型 观察者模式概述“红灯停，绿灯行”，在日常生活中，交通信号灯装点着城市，指挥着日益拥挤的城市交通。当红灯亮起，来往的汽车将停止；而绿灯亮起，汽车可以继续前行。在这个过程中，交通信号灯是汽车（更准确地说应该是汽车驾驶员）的观察目标，而汽车是观察者。随着交通信号灯的变化，汽车的行为也将随之变化，一盏交通信号灯可以指挥多辆汽车。交通信号与汽车示意图如图1所示。 图1 交通信号与汽车示意图 在软件系统中，有些对象之间也存在着类似交通信号灯和汽车之间的关系，一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变，它们之间将产生联动，正所谓“牵一发而动全身”。为了更好地描述对象之间存在的这种一对多（包括一对一）的联动，观察者模式应运而生，它定义了对象之间一种一对多的依赖关系，让一个对象的改变能够影响其他对象。 观察者模式是使用频率较高的设计模式之一，用于建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在观察者模式中，发生改变的对象称为观察目标，被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，用户可以根据需要增加和删除观察者，使得系统更易于扩展。 观察者模式的定义如下：1定义对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。 观察者模式又称为发布-订阅（Publish-Subscribe）模式、模型-视图（Model-View）模式、源-监听器（Source-Listener）模式或从属者（Dependents）模式。观察者模式是一种对象行为型模式。 观察者模式的结构与实现观察者模式的结构观察者模式结构中通常包括观察目标和观察者两个继承层次结构，其结构如图2所示。 图2 观察者模式结构图 由图2可知，观察者模式包含以下4个角色。 (1)Subject（目标）：目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以被任意数量的观察者观察，它提供一系列方法来增加和删除观察者对象，同时定义了通知方法Notify()。目标类可以是接口，也可以是抽象类或具体类。 (2)ConcreteSubject（具体目标）：具体目标是目标类的子类，通常包含经常发生改变的数据，当它的状态发生改变时，将向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务方法（如果有）。如果无须扩展目标类，具体目标类则可以省略。 (3)Observer（观察者）：观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法Update()，因此又称为抽象观察者。 (4)ConcreteObserver（具体观察者）：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者Observer中定义的Update()方法。通常在实现时，可以调用具体目标类的Attach()方法将自己添加到目标类的集合中或通过Detach()方法将自己从目标类的集合中删除。 观察者模式的实现观察者模式描述了如何建立对象与对象之间的依赖关系，以及如何构造满足这种需求的系统。观察者模式包含观察目标和观察者两类对象，一个目标可以有任意数目的与之相依赖的观察者，一旦观察目标的状态发生改变，所有的观察者都将得到通知。作为对这个通知的响应，每个观察者都将监视观察目标的状态，以使其状态与目标状态同步，这种交互也称为发布-订阅（Publish-Subscribe），观察目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通知。下面通过演示代码来对观察者模式进行进一步分析。首先定义一个抽象目标类Subject，其典型代码如下： Subject.cs 12345678910111213using System.Collections;abstract class Subject&#123; // 定义一个观察者集合用于存储所有观察者对象 protected ArrayList observers = new ArrayList(); // 声明抽象注册方法，用于向观察者集合中增加一个观察者 public abstract void Attach(Observer observer); // 声明抽象注销方法，用于在观察者集合中删除一个观察者 public abstract void Detach(Observer observer); // 声明抽象通知方法 public abstract void Notify();&#125; 具体目标类ConcreteSubject是实现了抽象目标类Subject的一个具体子类，它实现了上述3个方法，其典型代码如下： ConcreteSubject.cs 12345678910111213141516171819202122class ConcreteSubject : Subject&#123; public override void Attach(Observer observer) &#123; observers.Add(observer); &#125; public override void Detach(Observer observer) &#123; observers.Remove(observer); &#125; // 实现通知方法 public override void Notify() &#123; // 遍历观察者集合，调用每一个观察者的响应方法 foreach(object obs in observers) &#123; ((Observer)obs).Update(); &#125; &#125;&#125; 抽象观察者角色一般定义为一个接口，通常只声明一个Update()方法，为不同观察者的更新（响应）行为定义相同的接口，这个方法在其子类中实现，不同的观察者具有不同的响应方法。抽象观察者Observer的典型代码如下： Observer.cs 1234interface Observer&#123; void Update();&#125; 在具体观察者ConcreteObserver中实现了Update()方法，其典型代码如下： ConcreteObserver.cs 12345678class ConcreteObserver : Observer&#123; // 实现响应方法 public void Update() &#123; // 具体更新代码 &#125;&#125; 在有些更加复杂的情况下，具体观察者类ConcreteObserver的Update()方法在执行时需要使用到具体目标类ConcreteSubject中的状态（属性），因此在ConcreteObserver与ConcreteSubject之间有时候还存在关联或依赖关系，在ConcreteObserver中定义一个ConcreteSubject实例，通过该实例获取存储在ConcreteSubject中的状态。如果ConcreteObserver的Update()方法不需要使用ConcreteSubject中的状态属性，则可以对观察者模式的标准结构进行简化，在具体观察者ConcreteObserver和具体目标ConcreteSubject之间无须维持对象引用。 如果在具体层之间具有关联关系，系统的扩展性将受到一定的影响，增加新的具体目标类有时候需要修改原有观察者的代码，在一定程度上违背了开闭原则，如果原有观察者类无须关联新增的具体目标，则系统扩展性不受影响。 在客户端代码中，首先创建具体目标对象以及具体观察者对象，然后调用目标对象的Attach()方法，将这个观察者对象在目标对象中登记，也就是将它加入到目标对象的观察者集合中，代码片段如下：123456...Subject subject = new ConcreteSubject();Observer observer = new ConcreteObserver();subject.Attach(observer);subject.Notify();... 客户端在调用目标对象的Notify()方法时，将调用在其观察者集合中注册的观察者对象的Update()方法。 观察者模式的应用实例下面通过一个应用实例来进一步学习和理解观察者模式。 1.实例说明 在某多人联机对战游戏中，多个玩家可以加入同一战队组成联盟，当战队中的某一成员受到敌人攻击时将给所有其他盟友发送通知，盟友收到通知后将做出响应。现使用观察者模式设计并实现该过程，以实现战队成员之间的联动。 2.实例类图 通过分析，不难发现在该系统中战队成员之间的联动过程可以简单描述如下： 联盟成员受到攻击-&gt;发送通知给盟友-&gt;盟友做出响应。 如果按照上述思路来设计系统，一个战队联盟成员在受到攻击时需要通知他的每一位盟友，每个联盟成员都需要持有其他所有盟友的信息，这将导致系统开销较大，因此可以引入一个新的角色——指挥部（战队控制中心）来负责维护和管理每个战队所有成员的信息。当一个联盟成员受到攻击时，将向对应的指挥部发送请求信息，指挥部逐一通知每个盟友，盟友再做出响应，如图3所示。 图3 多人联机对战游戏中对象的联动 在图3中，受攻击的联盟成员将与指挥部产生联动，指挥部还将与其他盟友产生联动。 通过分析，本实例的结构如图4所示。 图4 多人联机对战游戏结构图 在图4中，AllyControlCenter充当抽象目标类，ConcreteAllyControlCenter充当具体目标类，IObserver充当抽象观察者，Player充当具体观察者。 3.实例代码 (1)AllyControlCenter：指挥部（战队控制中心类），充当抽象目标类。 AllyControlCenter.cs 1234567891011121314151617181920212223242526272829303132333435363738using System;using System.Collections.Generic;namespace ObserverSample&#123; abstract class AllyControlCenter &#123; protected string allyName; // 战队名称 protected List&lt;IObserver&gt; players = new List&lt;IObserver&gt;(); // 定义一个集合用于存储战队成员 public void SetAllyName(string allyName) &#123; this.allyName = allyName; &#125; public string GetAllyName() &#123; return this.allyName; &#125; // 注册方法 public void Join(IObserver obs) &#123; Console.WriteLine("&#123;0&#125;加入&#123;1&#125;战队！", obs.Name, this.allyName); players.Add(obs); &#125; // 注销方法 public void Quit(IObserver obs) &#123; Console.WriteLine("&#123;0&#125;退出&#123;1&#125;战队！", obs.Name, this.allyName); players.Remove(obs); &#125; // 声明抽象通知方法 public abstract void NotifyObserver(string name); &#125;&#125; (2)ConcreteAllyControlCenter：具体指挥部类，充当具体目标类。 ConcreteAllyControlCenter.cs 12345678910111213141516171819202122232425262728using System;namespace ObserverSample&#123; class ConcreteAllyControlCenter : AllyControlCenter &#123; public ConcreteAllyControlCenter(string allyName) &#123; Console.WriteLine("&#123;0&#125;战队组建成功！", allyName); Console.WriteLine("----------------------------"); this.allyName = allyName; &#125; // 实现通知方法 public override void NotifyObserver(string name) &#123; Console.WriteLine("&#123;0&#125;战队紧急通知，盟友&#123;1&#125;遭受敌人攻击！", this.allyName, name); // 遍历观察者集合，调用每一个盟友（自己除外）的支援方法 foreach(object obs in players) &#123; if (!((IObserver)obs).Name.Equals(name)) &#123; ((IObserver)obs).Help(); &#125; &#125; &#125; &#125;&#125; (3)IObserver：抽象观察者类。 IObserver.cs 1234567891011121314namespace ObserverSample&#123; interface IObserver &#123; string Name &#123; get; set; &#125; void Help(); // 声明支援盟友方法 void BeAttacked(AllyControlCenter acc); // 声明遭受攻击方法 &#125;&#125; (4)Player：战队成员类，充当具体观察者类。 Player.cs 123456789101112131415161718192021222324252627282930313233using System;namespace ObserverSample&#123; class Player : IObserver &#123; private string name; public Player(string name) &#123; this.name = name; &#125; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; // 支援盟友方法的实现 public void Help() &#123; Console.WriteLine("坚持住，&#123;0&#125;来救你！", this.name); &#125; // 遭受攻击方法的实现，当遭受攻击时将调用战队控制中心类的通知方法NotifyObserver()来通知盟友 public void BeAttacked(AllyControlCenter acc) &#123; Console.WriteLine("&#123;0&#125;被攻击！", this.name); acc.NotifyObserver(name); &#125; &#125;&#125; (5)Program：客户端测试类。 Program.cs 12345678910111213141516171819202122232425262728293031323334using System;namespace ObserverSample&#123; class Program &#123; static void Main(string[] args) &#123; // 定义观察目标对象 AllyControlCenter acc; acc = new ConcreteAllyControlCenter("金庸群侠"); // 定义四个观察者对象 IObserver player1, player2, player3, player4; player1 = new Player("杨过"); acc.Join(player1); player2 = new Player("令狐冲"); acc.Join(player2); player3 = new Player("张无忌"); acc.Join(player3); player4 = new Player("段誉"); acc.Join(player4); // 某成员遭受攻击 player1.BeAttacked(acc); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：1234567891011金庸群侠战队组建成功！----------------------------杨过加入金庸群侠战队！令狐冲加入金庸群侠战队！张无忌加入金庸群侠战队！段誉加入金庸群侠战队！杨过被攻击！金庸群侠战队紧急通知，盟友杨过遭受敌人攻击！坚持住，令狐冲来救你！坚持住，张无忌来救你！坚持住，段誉来救你！ 在本实例中，实现了两次对象之间的联动，当一个游戏玩家Player对象的BeAttacked()方法被调用时，将调用指挥部AllyControlCenter的NotifyObserver()方法来进行处理，而在NotifyObserver()方法中又将调用其他Player对象的Help()方法。Player的BeAttacked()方法、AllyControlCenter的NotifyObserver()方法以及Player的Help()方法构成了一个联动触发链，执行顺序如下： Player.BeAttacked()->AllyControlCenter.NotifyObserver()->Player.Help()。 观察者模式与.NET中的委托事件模型.NET中的委托事件模型是观察者模式在.NET中的经典应用。在WinForm编程中需要编写事件处理程序对所发生的事件（例如鼠标单击、菜单项选取等）做出反应，并执行相应的操作。事件被触发后，将执行响应该事件的一个或多个事件处理程序，可以将一个事件分配给多个事件处理程序（注册），还可以根据需要动态更改处理事件的方法。产生事件的对象（例如按钮、文本框、菜单等）称为事件的发送者（事件源对象），接收并响应事件的对象称为事件的接收者（事件处理对象）。与观察者模式相对应，事件源对象充当观察目标角色，事件处理对象充当具体观察者角色，如果事件源对象的某个事件触发，则调用事件处理对象中的事件处理程序对事件进行处理。 在.NET中，如果需要从WinForm控件获取事件，先提供一个委托（Delegate）类型的Event Handler，然后将它注册到事件源。在这里委托对象充当了抽象观察者的角色，所有事件处理方法都必须和委托方法具有相同的函数签名。 C#事件注册方法的语法如下：1eventSource.someEvent += new SomeEventHandler(someMethod); 在该语法中，eventSource表示事件源，someEvent表示定义在事件源中的事件，SomeEventHandler表示用于处理事件的委托，someMethod表示与委托SomeEventHandler具有相同函数签名的事件处理方法。用户只需修改someMethod，即可实现相同的事件对应不同的事件处理程序。 在.NET事件中，事件源并不需要知道哪些对象或方法会收到将要发生的通知，它只持有与签名相符合的方法的引用，即委托；还可以通过多重传送事件来实现一个事件有多个订阅者，即通过委托将多个方法添加到该事件中，当该事件被触发时，同时执行对应的多个事件处理方法。 下面通过一个简单的自定义事件来进一步说明.NET事件中的观察者模式。首先定义一个包含委托和事件的类EventTest，代码如下： EventTest.cs 12345678910111213141516171819202122232425262728using System;namespace ObserverExtend&#123; class EventTest &#123; // 定义一个委托 public delegate void UserInput(object sender, EventArgs e); // 定义一个此委托类型的事件 public event UserInput OnUserInput; // 模拟事件触发，当输入“0”时引发事件 public void Method() &#123; bool flag = false; Console.WriteLine("请输入数字："); while (!flag) &#123; if (Console.ReadLine() == "0") &#123; OnUserInput(this, new EventArgs()); &#125; &#125; &#125; &#125;&#125; 在类EventTest中定义了一个委托UserInput和一个事件OnUserInput，EventTest充当观察目标类的角色，而委托充当抽象观察者角色，在方法Method()中引发了事件，即调用与委托具有相同函数签名的方法，方法Method()即为目标类的通知方法。 在客户端测试类Program中提供了具体的事件处理方法，并将该方法和事件绑定在一起，这个过程称为订阅事件。Program类的代码如下： Program.cs 123456789101112131415161718192021222324252627282930313233using System;namespace ObserverExtend&#123; class Program &#123; public Program(EventTest test) &#123; // 注册事件或订阅事件 test.OnUserInput += new EventTest.UserInput(Handler); test.OnUserInput += new EventTest.UserInput(HandlerMore); // 注销事件或取消订阅 // test.OnUserInput -= new EventTest.UserInput(Handler); &#125; public void Handler(object sender, EventArgs e) &#123; Console.WriteLine("数据输入结束！"); &#125; public void HandlerMore(object sender, EventArgs e) &#123; Console.WriteLine("真的结束了！"); &#125; static void Main(string[] args) &#123; EventTest test = new EventTest(); Program program = new Program(test); test.Method(); &#125; &#125;&#125; 在Program的构造函数中订阅了事件，在此处，通过委托将两个方法添加到事件中，即该事件有两个订阅者，当事件触发时同时触发这些方法的执行。Program类充当了具体观察者角色，可以对目标类的事件做出响应，在此，方法Handler()和HandlerMore()即为响应方法。编译并运行程序，输出结果如下：123456请输入数字： 321数据输入结束！真的结束了！ 如果在另一个类中也需要处理该事件，无须修改EventTest类的源代码，只需要按照委托的规范编写事件处理程序并订阅事件即可，系统具有很好的扩展性，相同的目标可以对应于不同的观察者，相同的事件可以对应于不同的事件处理程序。.NET中的事件处理模型是观察者模式的一种变形，它与观察者模式的实现原理本质上是一致的。 观察者模式与MVC在当前流行的MVC（Model-View-Controller）架构中也应用了观察者模式，MVC是一种架构模式，它包含3个角色：模型（Model）、视图（View）和控制器（Controller）。其中，模型可对应于观察者模式中的观察目标，而视图对应于观察者，控制器可充当两者之间的中介者。当模型层的数据发生改变时，视图层将自动改变其显示内容。MVC结构示意图如图5所示。 图5 MVC结构示意图 在图5中，模型层提供的数据是视图层所观察的对象，在视图层中包含两个用于显示数据的图表对象，一个是柱状图，一个是饼状图，相同的数据拥有不同的图表显示方式，如果模型层的数据发生改变，两个图表对象将随之发生变化，这意味着图表对象依赖模型层提供的数据对象，因此数据对象的任何状态改变都应立即通知它们。同时，这两个图表之间相互独立，不存在任何联系，而且图表对象的个数没有任何限制，用户可以根据需要再增加新的图表对象，例如折线图。在增加新的图表对象时，无须修改原有类库，符合开闭原则。 观察者模式的优缺点与适用环境观察者模式是一种使用频率非常高的设计模式，无论是移动应用、Web应用还是桌面应用，观察者模式几乎无处不在，它为实现对象之间的联动提供了一套完整的解决方案，凡是涉及一对一或者一对多的对象交互场景都可以使用观察者模式。观察者模式广泛应用于各种编程语言的GUI事件处理的实现，在基于事件的XML解析技术以及Web事件处理中也都使用了观察者模式。 观察者模式的优点观察者模式的主要优点如下： (1)观察者模式可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。 (2)在观察目标和观察者之间建立一个抽象的耦合，观察目标只需要维持一个抽象观察者的集合，无须了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。 (3)观察者模式支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。 (4)观察者模式符合开闭原则，增加新的具体观察者无须修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下增加新的观察目标也很方便。 观察者模式的缺点观察者模式的主要缺点如下： (1)如果一个观察目标对象有很多直接和间接观察者，将所有的观察者都通知到会花费很多时间。 (2)如果在观察者和观察目标之间存在循环依赖，观察目标会触发它们进行循环调用，可能导致系统崩溃。 (3)观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而只是知道观察目标发生了变化。 观察者模式的适用环境在以下情况下可以考虑使用观察者模式： (1)一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。 (2)一个对象的改变将导致一个或多个其他对象发生改变，且不知道具体有多少对象将发生改变，也不知道这些对象是谁。 (3)需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……可以使用观察者模式创建一种链式触发机制。 本章小结(1)在观察者模式中，定义了对象之间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象都得到通知并被自动更新。观察者模式是一种对象行为型模式。 (2)观察者模式包含目标、具体目标、观察者和具体观察者4个角色。其中，目标是指被观察的对象；具体目标是目标类的子类，通常包含经常发生改变的数据，当它的状态发生改变时，将向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；具体观察者是观察者的子类，实现在观察者中声明的更新数据的方法。 (3)观察者模式的主要优点是可以实现表示层和数据逻辑层的分离；在观察目标和观察者之间建立一个抽象的耦合；支持广播通信且符合开闭原则。其主要缺点是将所有的观察者都通知到会花费很多时间；如果存在循环调用可能导致系统崩溃；没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而只是知道观察目标发生了变化。 (4)观察者模式适用的环境：一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用；一个对象的改变将导致一个或多个其他对象也发生改变，且并不知道具体有多少对象将发生改变，也不知道这些对象是谁；需要在系统中创建一个触发链。 (5).NET中的委托事件模型是观察者模式在.NET中的经典应用。事件源对象充当观察目标角色，事件处理对象充当具体观察者角色，如果事件源对象的某个事件触发，则调用事件处理对象中的事件处理程序对事件进行处理。 (6)MVC架构中应用了观察者模式，其中模型对应于观察者模式中的观察目标，视图对应于观察者，控制器可充当两者之间的中介者。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[外观模式]]></title>
    <url>%2F2019%2F09%2F20%2F%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F-2%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 外观模式是迪米特法则的一种具体实现。什么是迪米特法则？怎么实现的？ 使用外观模式要引入一个新的外观角色，怎么理解？ 抽象外观类可以解决传统的外观模式违反开闭原则的缺点。怎么理解？ 外观模式为什么是结构型设计模式？ 客户端通过外观角色来间接访问子系统。怎么理解？ 本章导学 外观模式是一种使用频率非常高的结构型设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。 本章将学习外观模式的定义与结构，结合实例学习如何使用外观模式并分析外观模式的优缺点。 本章知识点 外观模式的定义 外观模式的结构 外观模式的实现 外观模式的应用 外观模式的优缺点 外观模式的适用环境 抽象外观类 外观模式概述不知道大家有没有比较过自己泡茶和去茶馆喝茶的区别，如果是自己泡茶，需要自行准备茶叶、茶具和开水，如图1（a）所示，而去茶馆喝茶，最简单的方式就是跟茶馆服务员说想要一杯什么样的茶，是铁观音、碧螺春还是西湖龙井。正因为茶馆有服务员，顾客无须直接和茶叶、茶具、开水等交互，整个泡茶过程由服务员来完成，顾客只需与服务员交互即可，整个过程非常简单、省事，如图1（b）所示。 图1 两种喝茶方式示意图 在软件开发中，有时为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于涉及的类比较多，导致使用时代码较为复杂，此时，特别需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户类只需与该类交互。外观模式通过引入一个新的外观类（Facade）来实现该功能，外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。在外观模式中，需要交互的业务类被称为子系统（SubSystem）。如果没有外观类，那么每个客户类需要和多个子系统之间进行复杂的交互，系统的耦合度将很大，如图2（a）所示；而引入外观类之后，客户类只需要直接与外观类交互，客户类与子系统之间原有的复杂引用关系由外观类来实现，从而降低了系统的耦合度，如图2（b）所示。 图2 外观模式示意图 在外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外观角色打交道，而不需要与子系统内部的很多对象打交道。 外观模式（Facade）的定义如下：1为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。 外观模式又称为门面模式，它是一种对象结构型模式。外观模式是迪米特法则的一种具体实现，通过引入一个新的外观角色来降低原有系统的复杂度，同时降低客户类与子系统的耦合度。 外观模式的结构与实现外观模式的结构外观模式没有一个一般化的类图描述，通常使用如图2（b）所示的示意图来表示外观模式。图3所示的类图也可以作为描述外观模式的结构图。 图3 外观模式结构图 由图3可知，外观模式包含以下两个角色。 (1)Facade（外观角色）：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统，传递给相应的子系统对象处理。 (2)SubSystem（子系统角色）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。 外观模式的实现外观模式的主要目的在于降低系统的复杂程度，在面向对象软件系统中，类与类之间的关系越多，不表示系统设计得越好，反而表示系统中类之间的耦合度太大，这样的系统在维护和修改时都缺乏灵活性，因为一个类的改动会导致多个类发生变化，而外观模式的引入在很大程度上降低了类与类之间的耦合关系。引入外观模式之后，增加新的子系统或者移除子系统都非常方便，客户类无须进行修改（或者极少的修改），只需要在外观类中增加或移除对子系统的引用即可。从这一点来说，外观模式在一定程度上并不符合开闭原则，增加新的子系统需要对原有系统进行一定的修改，虽然这个修改工作量不大。 外观模式中所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统。子系统类通常是一些业务类，实现了一些具体的、独立的业务功能，其典型代码如下： 1234567891011121314151617181920212223class SubSystemA&#123; public void MethodA() &#123; // 业务实例代码 &#125;&#125;class SubSystemB&#123; public void MethodB() &#123; // 业务实例代码 &#125;&#125;class SubSystemC&#123; public void MethodC() &#123; // 业务实例代码 &#125;&#125; 在引入外观类之后，与子系统业务类之间的交互统一由外观类来完成，在外观类中通常存在以下代码：12345678910111213class Facade&#123; private SubSystemA obj1 = new SubSystemA(); private SubSystemB obj2 = new SubSystemB(); private SubSystemC obj3 = new SubSystemC(); public void Method() &#123; obj1.MethodA(); obj2.MethodB(); obj3.MethodC(); &#125;&#125; 由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互。引入外观类后，客户端代码变得非常简单，其典型代码如下：12345678class Program&#123; static void Main(string[] args) &#123; Facade facade = new Facade(); facade.Method(); &#125;&#125; 外观模式的应用实例下面通过一个应用实例来进一步学习和理解外观模式。 1.实例说明 某软件公司要开发一个可应用于多个软件的文件加密模块，该模块可以对文件中的数据进行加密并将加密之后的数据存储在一个新文件中，具体的流程包括3个部分，分别是读取源文件、加密、保存加密之后的文件，其中，读取文件和保存文件使用流来实现，加密操作通过求模运算实现。这3个操作相对独立，为了实现代码的独立重用，让设计更符合单一职责原则，这3个操作的业务代码封装在3个不同的类中。现使用外观模式设计该文件加密模块。 2.实例类图 通过分析，本实例的结构如图4所示。 图4 文件加密模块结构图 在图4中，EncryptFacade充当外观类，FileReader、CipherMachine和FileWriter充当子系统类。 3.实例代码 (1)FileReader：文件读取类、充当子系统类。 123456789101112131415161718192021222324252627282930313233343536373839404142using System;using System.Text;using System.IO;namespace FacadeSample&#123; class FileReader &#123; public string Read(string fileNameSrc) &#123; Console.Write("读取文件，获取明文："); FileStream fs = null; StringBuilder sb = new StringBuilder(); try &#123; fs = new FileStream(fileNameSrc, FileMode.Open); int data; while((data = fs.ReadByte())!= -1) &#123; sb = sb.Append((char)data); &#125; fs.Close(); Console.WriteLine(sb.ToString()); &#125; catch(FileNotFoundException e) &#123; Console.WriteLine("文件不存在！"); &#125; catch(IOException e) &#123; Console.WriteLine("文件操作错误！"); &#125; return sb.ToString(); &#125; &#125;&#125; (2)CipherMachine：数据加密类，充当子系统类。 1234567891011121314151617181920212223242526using System;using System.Text;namespace FacadeSample&#123; class CipherMachine &#123; public string Encrypt(string plainText) &#123; Console.Write("数据加密，将明文转换为密文："); string es = ""; char[] chars = plainText.ToCharArray(); foreach(char ch in chars) &#123; string c = (ch % 7).ToString(); es += c; &#125; Console.WriteLine(es); return es; &#125; &#125;&#125; (3)FileWriter：文件保存类，充当子系统类。 12345678910111213141516171819202122232425262728293031323334using System;using System.IO;using System.Text;namespace FacadeSample&#123; class FileWriter &#123; public void Write(string encryptStr,string fileNameDes) &#123; Console.WriteLine("保存密文，写入文件。"); FileStream fs = null; try &#123; fs = new FileStream(fileNameDes, FileMode.Create); byte[] str = Encoding.Default.GetBytes(encryptStr); fs.Write(str,0,str.Length); fs.Flush(); fs.Close(); &#125; catch(FileNotFoundException e) &#123; Console.WriteLine("文件不存在！"); &#125; catch(IOException e) &#123; Console.WriteLine(e.Message); Console.WriteLine("文件操作错误！"); &#125; &#125; &#125;&#125; (4)EncryptFacade：加密外观类，充当外观类。 12345678910111213141516171819202122232425namespace FacadeSample&#123; class EncryptFacade &#123; // 维持对其他对象的引用 private FileReader reader; private CipherMachine cipher; private FileWriter writer; public EncryptFacade() &#123; reader = new FileReader(); cipher = new CipherMachine(); writer = new FileWriter(); &#125; // 调用其他对象的业务方法 public void FileEncrypt(string fileNameSrc, string fileNameDes) &#123; string plainStr = reader.Read(fileNameSrc); string encryptStr = cipher.Encrypt(plainStr); writer.Write(encryptStr, fileNameDes); &#125; &#125;&#125; (5)Program：客户端测试类 1234567891011121314151617using System;using System.Configuration;using System.Reflection;namespace FacadeSample&#123; class Program &#123; static void Main(string[] args) &#123; EncryptFacade ef = new EncryptFacade(); ef.FileEncrypt("src.txt", "des.txt"); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：123读取文件，获取明文：Hello World!数据加密，将明文转换为密文：233364062325保存密文，写入文件。 在本实例中，对文件src.txt中的数据进行加密，该文件内容为“Hello World!”，加密之后将密文保存到另一个文件des.txt中，程序运行后保存在文件中的密文为“233364062325”。在加密类CipherMachine中，采用求模运算对明文进行加密，将明文中的每一个字符除以一个整数（本例中为7，可以由用户来进行设置）后取余数作为密文。 抽象外观类在标准的外观模式结构图中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类对系统进行改进，在一定程度上解决该问题。在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的。 下面通过一个具体实例来学习如何使用抽象外观类。 如果在上一节应用实例“文件加密模块”中需要更换一个加密类，不再使用原有的基于求模运算的加密类CipherMachine，而改为基于移位运算的新加密类NewCipherMachine，其代码如下：12345678910111213141516171819202122232425262728293031323334353637383940using System;namespace FacadeSample&#123; class NewCipherMachine &#123; public string Encrypt(string plainText) &#123; Console.Write("数据加密，将明文转换为密文："); string es = ""; int key = 10;// 设置密钥，移位数为10 char[] chars = plainText.ToCharArray(); foreach(char ch in chars) &#123; int temp = Convert.ToInt32(ch); // 小写字母移位 if (ch &gt;= 'a' &amp;&amp; ch &lt;= 'z') &#123; temp += key % 26; if (temp &gt; 122) temp -= 26; if (temp &lt; 97) temp += 26; &#125; // 大写字母移位 if (ch &gt;= 'A' &amp;&amp; ch &lt;= 'Z') &#123; temp += key % 26; if (temp &gt; 90) temp -= 26; if (temp &lt; 65) temp += 26; &#125; es += ((char)temp).ToString(); &#125; Console.WriteLine(es); return es; &#125; &#125;&#125; 如果不增加新的外观类，只能通过修改原有外观类EncryptFacade的源代码来实现加密类的更换，将原有的对CipherMachine类型对象的引用改为对NewCipherMachine类型对象的引用，这违背了开闭原则，因此需要通过增加新的外观类来实现对子系统对象引用的改变。 如果增加一个新的外观类NewEncryptFacade与FileReader类、FileWriter类及新增加的NewCipherMachine类进行交互，虽然原有系统类库无须做任何修改，但是因为在客户端代码中原来针对EncryptFacade类进行编程，现在需要改为NewEncryptFacade类，因此需要修改客户端源代码。 如何在不修改客户端代码的前提下使用新的外观类呢？解决方法之一是引入一个抽象外观类，客户端针对抽象外观类编程，而在运行时再确定具体外观类。引入抽象外观类之后的文件加密模块结构如图5所示。 图5 引入抽象外观类之后的文件加密模块结构图 在图5中，客户类Client针对抽象外观类AbstractEncryptFacade进行编程，AbstractEncryptFacade代码如下：1234567namespace FacadeSample&#123; abstract class AbstractEncryptFacade &#123; public abstract void FileEncrypt(string fileNameSrc, string fileNameDes); &#125;&#125; 新增具体加密外观类NewEncryptFacade的代码如下：1234567891011121314151617181920212223namespace FacadeSample&#123; class NewEncryptFacade : AbstractEncryptFacade &#123; private FileReader reader; private NewCipherMachine cipher; private FileWriter writer; public NewEncryptFacade() &#123; reader = new FileReader(); cipher = new NewCipherMachine(); writer = new FileWriter(); &#125; public override void FileEncrypt(string fileNameSrc, string fileNameDes) &#123; string plainStr = reader.Read(fileNameSrc); string encryptStr = cipher.Encrypt(plainStr); writer.Write(encryptStr, fileNameDes); &#125; &#125;&#125; 配置文件App.config中存储了具体外观类的类名，其代码如下：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="facade" value="FacadeSample.NewEncryptFacade"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 将客户端测试代码修改如下：123456789101112131415161718192021using System;using System.Configuration;using System.Reflection;namespace FacadeSample&#123; class Program &#123; static void Main(string[] args) &#123; AbstractEncryptFacade ef; // 针对抽象外观类编程 // 读取配置文件 string facadeString = ConfigurationManager.AppSettings["facade"]; // 反射生成对象 ef = (AbstractEncryptFacade)Assembly.Load("FacadeSample").CreateInstance(facadeString); ef.FileEncrypt("src.txt", "des.txt"); Console.Read(); &#125; &#125;&#125; 编译并运行程序，输出结果如下：123读取文件，获取明文：Hello World!数据加密，将明文转换为密文：Rovvy gybvn!保存密文，写入文件。 原有外观类EncryptFacade也需作为抽象外观类AbstractEncryptFacade的子类，更换具体外观类时只需修改配置文件，无须修改源代码，符合开闭原则。 外观模式的优缺点与适用环境外观模式是一种使用频率非常高的设计模式，它通过引入一个外观角色来简化客户端与子系统之间的交互，为复杂的子系统调用提供一个统一的入口，使子系统与客户端的耦合度降低，且客户端调用非常方便。外观模式并不给系统增加任何新功能，它仅仅是简化调用接口。在几乎所有的软件中都能够找到外观模式的应用，如绝大多数B/S系统都有一个首页或者导航页面，大部分C/S系统都提供了菜单或者工具栏，在这里，首页和导航页面就是B/S系统的外观角色，而菜单和工具栏就是C/S系统的外观角色，通过它们用户可以快速访问子系统，降低了系统的复杂程度，所有涉及与多个业务对象交互的环境都可以考虑使用外观模式进行重构。 外观模式的优点外观模式的主要优点如下： (1)它对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。 (2)它实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。 (3)一个子系统的修改对其他子系统没有任何影响，而且子系统的内部变化也不会影响到外观对象。 外观模式的缺点外观模式的主要缺点如下： (1)外观模式不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。 (2)如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。 外观模式的适用环境在以下情况下可以考虑使用外观模式： (1)当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。 (2)客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。 (3)在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度。 本章小结(1)外观模式为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。 (2)外观模式包含外观和子系统两个角色。其中，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任，客户端通过外观角色来间接访问子系统；在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能，每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求。 (3)外观模式主要优点是对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。其主要缺点是不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性；如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。 (4)外观模式适用的环境：要为访问一系列复杂的子系统提供一个简单入口；客户端程序与多个子系统之间存在很大的依赖性；在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而是通过外观类建立联系，降低层之间的耦合度。 (5)用户可以通过抽象外观类对系统进行改进，引入抽象外观类之后，客户端针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而只需对应地增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，并且通过修改配置文件达到不修改任何源代码更换外观类的目的。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[中介者模式]]></title>
    <url>%2F2019%2F09%2F19%2F%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 中介者模式可以从更宏观的角度来看待问题。怎么理解？ 抽象中介者的public abstract void Send(string message, Colleague colleague);这行代码怎么理解？ 最关键的问题在于ConcreteMediator这个类必须要知道所有的ConcreteColleague。这句话怎么理解？这样会有什么问题？ 联合国中介者模式又叫做调停者模式。其实就是中间人或者调停者的意思。 联合国就是一个调停者、中介者的角色。国与国之间的关系，就类似于不同的对象与对象之间的关系，这就要求对象之间需要知道其他所有对象，尽管将一个系统分割成许多对象通常可以增加其可复用性，但是对象间相互连接的激增又会降低其可复用性。 这是因为大量的连接使得一个对象不可能在没有其他对象的支持下工作，系统表现为一个不可分割的整体，所以，对系统的行为进行任何较大的改动就十分困难了。 ‘迪米特法则’认为，如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用。如果其中一个类需要调用另一个类的某一个方法的话，可以通过第三者转发这个调用。所以，国与国之间完全可以通过‘联合国’这个中介者来发生关系，而不用直接通信。 通过中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，每个具体对象不再通过直接的联系与另一个对象发生相互作用，而是通过‘中介者’对象与另一个对象发生相互作用。中介者对象的设计，使得系统的结构通过中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构不会因为新对象的引入造成大量的修改工作。 之前解释‘迪米特法则’的时候，是以公司的IT部门的管理为例子，让一个刚进公司的人去求任何一个不认识的IT部同事帮忙是有困难的，但如果是有IT主管来协调工作，就不至于发生第一天上班却没有电脑进行工作的局面。IT主管就是一个‘中介者’对象。 中介者模式中介者模式的定义如下：1用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。 中介者模式（Mediator）结构图 Colleague叫做抽象同事类，而ConcreteColleague是具体同事类，每个具体同事只知道自己的行为，而不了解其他同事类的情况，但它们却都认识中介者对象。Mediator是抽象中介者，定义了同事对象到中介者对象的接口，ConcreteMediator是具体中介者对象，实现抽象类的方法，它需要知道所有具体同事类，并从具体同事接收消息，向具体同事对象发出命令。 Mediator类 抽象中介者类 12345abstract class Mediator&#123; // 定义一个抽象的发送消息方法，得到同事对象和发送信息 public abstract void Send(string message, Colleague colleague);&#125; Colleague类 抽象同事类 12345678910abstract class Colleague&#123; protected Mediator mediator; // 构造方法，得到中介者对象 public Colleague(Mediator mediator) &#123; this.mediator = mediator; &#125;&#125; ConcreteMediator类 具体中介者类 1234567891011121314151617181920212223242526272829class ConcreteMediator : Mediator&#123; // 需要了解所有的具体同事对象 private ConcreteColleague1 colleague1; private ConcreteColleague2 colleague2; public ConcreteColleague1 Colleague1 &#123; set &#123; colleague1 = value; &#125; &#125; public ConcreteColleague2 Colleague2 &#123; set &#123; colleague2 = value; &#125; &#125; // 重写发送信息的方法，根据对象做出选择判断，通知对象 public override void Send(string message, Colleague colleague) &#123; if (colleague == colleague1) &#123; colleague2.Notify(message); &#125; else &#123; colleague1.Notify(message); &#125; &#125;&#125; ConcreteColleague1和ConcreteColleague2等各种同事对象12345678910111213141516171819202122232425262728293031323334353637class ConcreteColleague1 : Colleague&#123; public ConcreteColleague1(Mediator mediator) : base(mediator) &#123; &#125; public void Send(string message) &#123; // 发送信息时通常是中介者发送出去的 mediator.Send(message, this); &#125; public void Notify(string message) &#123; Console.WriteLine("同事1得到信息:" + message); &#125;&#125;class ConcreteColleague2 : Colleague&#123; public ConcreteColleague2(Mediator mediator) : base(mediator) &#123; &#125; public void Send(string message) &#123; mediator.Send(message, this); &#125; public void Notify(string message) &#123; Console.WriteLine("同事2得到信息:" + message); &#125;&#125; 客户端 123456789101112131415161718192021class Program&#123; static void Main(string[] args) &#123; ConcreteMediator m = new ConcreteMediator(); // 让两个具体同事类认识中介者对象 ConcreteColleague1 c1 = new ConcreteColleague1(m); ConcreteColleague2 c2 = new ConcreteColleague2(m); // 让中介者认识各个具体同事类对象 m.Colleague1 = c1; m.Colleague2 = c2; // 具体同事类对象的发送信息都是通过中介者转发 c1.Send("吃过饭了吗?"); c2.Send("没有呢，你打算请客？"); Console.Read(); &#125;&#125; 由于有了Mediator，使得ConcreteColleague1和ConcreteColleague2在发送消息和接收信息时其实是通过中介者来完成的，这就减少了它们之间的耦合度了。 安理会做中介下面让美国和伊拉克之间的对话都通过联合国安理会作为中介来完成。 美国和伊拉克都是国家，所以有一个国家抽象类和两个具体国家类。‘联合国’是Mediator还是ConcreteMediator取决于未来是否有可能扩展中介者对象，联合国除了安理会，还有如国际劳工组织、教科文组织、世界卫生组织、世界贸易组织等等很多机构，所以Mediator应该是‘联合国机构’，而‘安理会’是一个具体的中介者。 如果不存在扩展情况，那么Mediator可以与ConcreteMediator合二为一。 代码结构图 联合国机构类 相当于Mediator类 12345678910// 联合国机构abstract class UnitedNations&#123; /// &lt;summary&gt; /// 声明 /// &lt;/summary&gt; /// &lt;param name="message"&gt;声明信息&lt;/param&gt; /// &lt;param name="colleague"&gt;声明国家&lt;/param&gt; public abstract void Declare(string message, Country colleague);&#125; 国家类 相当于Colleague类 12345678910// 国家abstract class Country&#123; protected UnitedNations mediator; public Country(UnitedNations mediator) &#123; this.mediator = mediator; &#125;&#125; 美国类 相当于ConcreteColleague1类 1234567891011121314151617181920 // 美国class USA : Country&#123; public USA(UnitedNations mediator) : base(mediator) &#123; &#125; // 声明 public void Declare(string message) &#123; mediator.Declare(message, this); &#125; // 获得消息 public void GetMessage(string message) &#123; Console.WriteLine("美国获得对方信息：" + message); &#125;&#125; 伊拉克类 相当于ConcreteColleague2类 1234567891011121314151617181920// 伊拉克class Iraq : Country&#123; public Iraq(UnitedNations mediator) : base(mediator) &#123; &#125; // 声明 public void Declare(string message) &#123; mediator.Declare(message, this); &#125; // 获得消息 public void GetMessage(string message) &#123; Console.WriteLine("伊拉克获得对方信息：" + message); &#125;&#125; 联合国安理会 相当于ConcreteMediator类 123456789101112131415161718192021222324252627282930// 联合国安全理事会class UnitedNationsSecurityCouncil : UnitedNations&#123; private USA colleague1; private Iraq colleague2; // 联合国安理会了解所有的国家，所以拥有美国和伊拉克的对象属性 public USA Colleague1 &#123; set &#123; colleague1 = value; &#125; &#125; public Iraq Colleague2 &#123; set &#123; colleague2 = value; &#125; &#125; // 重写了“声明”方法，实现了两个对象间的通信 public override void Declare(string message, Country colleague) &#123; if (colleague == colleague1) &#123; colleague2.GetMessage(message); &#125; else &#123; colleague1.GetMessage(message); &#125; &#125;&#125; 客户端 123456789101112131415161718class Program&#123; static void Main(string[] args) &#123; UnitedNationsSecurityCouncil UNSC = new UnitedNationsSecurityCouncil(); USA c1 = new USA(UNSC); Iraq c2 = new Iraq(UNSC); UNSC.Colleague1 = c1; UNSC.Colleague2 = c2; c1.Declare("不准研制核武器，否则要发动战争！"); c2.Declare("我们没有核武器，也不怕侵略。"); Console.Read(); &#125;&#125; 结果显示 12伊拉克获得对方信息：不准研制核武器，否则要发动战争。美国获得对方信息：我们没有核武器，也不怕侵略。 最关键的问题在于ConcreteMediator这个类必须要知道所有的ConcreteColleague，这样的设计可以减少了ConcreteColleague类之间的耦合，但这又使得ConcreteMediator责任太多了，如果它出了问题，则整个系统都会有问题。 中介者模式优缺点如果联合国安理会出了问题，会对世界都造成影响。所以说，中介者模式很容易在系统中应用，也很容易在系统中误用。当系统出现了‘多对多’交互复杂的对象群时，不要急于使用中介者模式，而要先反思系统在设计上是不是合理。 中介者模式的优点： 1.Mediator的出现减少了各个Colleague的耦合，使得可以独立地改变和复用各个Colleague类和Mediator，比如任何国家的改变不会影响到其他国家，而只是与安理会发生变化。 2.简化了对象协议，用Mediator和各Colleague间的一对多的交互来替代多对多的交互。一对多的关系更易于理解，维护和扩展。 3.由于把对象如何协作进行了抽象，将中介作为一个独立的概念并将其封装在一个对象中，这样关注的对象就从对象各自本身的行为转移到它们之间的交互上来，也就是站在一个更宏观的角度去看待系统。比如巴以冲突，本来只能算是国与国之间的矛盾，因此各自的看法可能都比较狭隘，但站在联合国安理会的角度，就可以从全球化、也更客观角度来看待这个问题，在调停和维和上做出贡献。 4.可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展。 中介者模式的缺点： 具体中介者类ConcreteMediator可能会因为ConcreteColleague的越来越多，而变得非常复杂，反而不容易维护。 由于ConcreteMediator控制了集中化，于是就把交互复杂性变为了中介者的复杂性，这就使得中介者会变得比任何一个ConcreteColleague都复杂。事实上，联合国安理会秘书长的工作是非常繁忙的。也正因为此，中介者模式的优点来自集中控制，其缺点也是它，使用时要考虑清楚。 中介者模式的应用**计算器程序** 它上面有菜单控件、文本控件、多个按钮控件和一个Form窗体，每个控件的类代码都被封装，所以它们的实例是不会知道其他控件对象的存在的，比如点击数字按钮要在文本框中显示数字。如果是在Button类中编写给TextBox类实例的Text属性赋值的代码，会造成两个类有耦合，这显然是非常不合理的。 实际情况是它们都有事件机制，而事件的执行都是在Form窗体的代码中完成，也就是说所有的控件的交互都是由Form窗体来作中介，操作各个对象，这是典型的中介者模式应用。 **数据库** 世界上存在着各种各样的数据库，不同数据库有各自的应用场景，对于同一份数据，最开始可能使用关系型数据库（如MySQL）进行存储查询，使用Redis作为缓存数据库，当数据量较大时使用MySQL进行查询可能较慢，所以需要将数据同步到Elasticsearch或者列式数据库如Hbase中进行大数据查询。 如何设计数据同步方案是一个重要的问题。数据源众多，目标端也众多，设计得不好可能 “牵一发而动全身”。 如果我们这样设计：每个数据源直接同步数据到目标端数据库的，如果数据库有N个，那么最多可能的同步作业将达到N * N个，当修改了其中一个数据库的某些配置，可能需要修改另外的N - 1个数据库的同步作业。 现在介绍另一种方案，DataX是阿里巴巴集团内被广泛使用的离线数据同步工具/平台，实现包括MySQL、Oracle、SqlServer、Postgre、HDFS、Hive、ADS、HBase、TableStore(OTS)、MaxCompute(ODPS)、DRDS等各种异构数据源之间高效的数据同步功能。 DataX 其实相当于一个中介，从数据源读取数据，写入到目标端，数据源不再需要维护到目标端的同步作业，只需要与DataX通信即可。DataX体现了中介者模式的思想。 中介者模式一般应用于一组对象以定义良好但是复杂的方式进行通信的场合，比如刚才得到的窗体Form对象，以及想定制一个分布在多个类中的行为，而又不想生成太多的子类的场合。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>大话设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 最简单的抽象命令类万年不变是什么意思？ 命令模式为什么是行为型模式？是如何将请求发送者与请求接收者解耦的？ 什么是命令对象？为什么实现了间接引用？ 是怎么做到可以在不修改现有系统源代码的情况下让相同的发送者对应不同的接收者的？ 命令模式的核心在于引入了抽象命令类和具体命令类。怎么理解？ 可以在具体命令类里直接new请求接收者，也可以在客户端注入。怎么理解？ “用不同的请求对客户进行参数化”，客户端只需要将具体命令对象作为参数注入请求发送者。怎么理解？ 将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。怎么理解？ 一个调用者并不需要在设计时确定其接收者，因此只与抽象命令类之间存在关联关系。怎么理解？ 在具体命令类里写代码时直接new Receiver了。怎么理解？ 本章导学 命令模式是常用的行为型模式之一，它将请求发送者与请求接收者解耦，请求发送者通过命令对象来间接引用接收者，使得系统具有更好的灵活性，可以在不修改现有系统源代码的情况下让相同的发送者对应不同的接收者。 本章将学习命令模式的定义与结构，结合实例学习如何实现命令模式，并理解命令队列、请求日志、撤销操作和宏命令的实现原理。 本章知识点 命令模式的定义 命令模式的结构 命令模式的实现 命令模式的应用 实现命令队列 记录请求日志 实现撤销操作 宏命令 命令模式的优缺点 命令模式的适用环境 命令模式概述在现实生活中，人们通过使用开关来控制一些电器的打开和关闭，例如电灯或者排气扇。在购买开关时，购买者可能并不知道它将来到底用于控制什么电器，也就是说，开关与电灯、排气扇并无直接关系，一个开关在安装之后可能用来控制电灯，也可能用来控制排气扇或者其他电器设备。开关与电器之间通过电线建立连接，如果开关打开，则电线通电，电器工作；反之，开关关闭，电线断电，电器停止工作。相同的开关可以通过不同的电线来控制不同的电器，如图1所示。 图1 开关与电灯、排气扇示意图 在图1中，可以将开关理解成一个请求的发送者，用户通过它来发送一个“开灯”请求，而电灯是“开灯”请求的最终接收者和处理者，开关和电灯之间并不存在直接耦合关系，它们通过电线连接在一起，使用不同的电线可以连接不同的请求接收者，只需更换一根电线，相同的发送者（开关）即可对应不同的接收者（电器）。 在软件开发中也存在很多与开关和电器类似的请求发送者和接收者对象，例如一个按钮，它可能是一个“关闭窗口”请求的发送者，而按钮单击事件处理类则是该请求的接收者。为了降低系统的耦合度，将请求的发送者和接收者解耦，可以使用一种被称为命令模式的设计模式来设计系统。在命令模式中，发送者与接收者之间引入了新的命令对象（类似图1中的电线），将发送者的请求封装在命令对象中，再通过命令对象来调用接收者的方法。 命令模式可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。 命令模式的定义如下:1将一个请求封装为一个对象，从而让你可以用不同的请求对客户进行参数化，对请求排队或者记录请求日志，以及支持可撤销的操作。 命令模式是一种对象行为型模式，其别名为动作（Action）模式或事务（Transaction）模式。命令模式的定义比较复杂，提到了很多术语，例如“用不同的请求对客户进行参数化”、“对请求排队”、“记录请求日志”、“支持可撤销操作”等。 命令模式的结构与实现命令模式的结构命令模式的核心在于引入了抽象命令类和具体命令类，通过命令类来降低发送者和接收者的耦合度，请求发送者只需指定一个命令对象，再通过命令对象来调用请求接收者的处理方法即可，其结构如图2所示。 图2 命令模式结构图 由图2可知，命令模式包含以下4个角色。 (1)Command（抽象命令类）：抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的Execute()等方法，通过这些方法可以调用请求接收者的相关操作。 (2)ConcreteCommand（具体命令类）：具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。具体命令类在实现Execute()方法时，将调用接收者对象的相关操作。 (3)Invoker（调用者）：调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的Execute()方法，从而实现间接调用请求接收者的相关操作。 (4)Receiver（接收者）：接收者执行与请求相关的操作，具体实现对请求的业务处理。 命令模式的实现命令模式的本质是对请求进行封装，一个请求对应于一个命令，将发出命令的责任和执行命令的责任分开。每一个命令都是一个操作：请求的一方发出请求要求执行一个操作；接收的一方收到请求，并执行相应的操作。命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求如何被接收、操作是否被执行、何时被执行，以及是怎么被执行的。 命令模式的关键在于引入了抽象命令类，请求发送者针对抽象命令类编程，只有实现了抽象命令类的具体命令才与请求接收者相关联。在最简单的抽象命令类中只包含了一个抽象的Execute()方法，每个具体命令类将一个Receiver类型的对象作为一个实例变量进行存储，从而具体指定一个请求的接收者，不同的具体命令类提供了Execute()方法的不同实现，并调用不同接收者的请求处理方法。 典型的抽象命令类代码如下：1234abstract class Command&#123; public abstract void Execute();&#125; 对于请求发送者（即调用者）而言，将针对抽象命令类进行编程，可以通过构造函数或者Setter方法在运行时注入具体命令类对象，并在业务方法中调用命令对象的Execute()方法。其典型代码如下：1234567891011121314151617181920212223class Invoker&#123; private Command command; // 构造注入 public Invoker(Command command) &#123; this.command = command; &#125; public Command command &#123; get&#123; return command; &#125; // 设值注入 set&#123; command = value; &#125; &#125; // 业务方法，用于调用命令类的方法 public void Call() &#123; command.Execute(); &#125;&#125; 具体命令类继承了抽象命令类，它与请求接收者相关联，实现了在抽象命令类中声明的Execute()方法，并在实现时调用接收者的请求响应方法Action()。其典型代码如下：1234567891011class ConcreteCommand : Command&#123; // 维持一个对请求接收者对象的引用 private Receiver receiver; public override void Execute() &#123; // 调用请求接收者的业务处理方法Action() receiver.Action(); &#125;&#125; 请求接收者Receiver具体实现对请求的业务处理，它拥有Action()方法，用于执行与请求相关的操作。其典型代码如下：1234567class Receiver&#123; public void Action() &#123; // 具体操作 &#125;&#125; 命令模式的应用实例下面通过一个应用实例来进一步学习和理解命令模式。 1.实例说明 为了用户使用方便，某系统提供了一系列功能键，用户可以自定义功能键的功能，例如功能键FunctionButton可以用于退出系统（由SystemExitClass类来实现），也可以用于显示帮助文档（由DisplayHelpClass类来实现）。用户可以通过修改配置文件来改变功能键的用途，现使用命令模式来设计该系统，使得功能键类与功能类之间解耦，可为同一个功能键设置不同的功能。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 功能键设置结构图 在图3中，FunctionButton充当请求调用者，SystemExitClass和DisplayHelpClass充当请求接收者，Command是抽象命令类，ExitCommand和HelpCommand充当具体命令类。 3.实例代码 (1)FunctionButton：功能键，充当请求调用者（请求发送者）。 FunctionButton.cs 1234567891011121314151617181920212223using System;namespace CommandSample&#123; class FunctionButton &#123; private Command command; // 维持一个抽象命令对象的引用 // 为功能键注入命令 public Command Command &#123; get&#123; return command; &#125; set&#123; command = value; &#125; &#125; // 发送请求的方法 public void Click() &#123; Console.WriteLine("单击功能键！"); command.Execute(); &#125; &#125;&#125; (2)Command：抽象命令类 Command.cs 1234567namespace CommandSample&#123; abstract class Command &#123; public abstract void Execute(); &#125;&#125; (3)ExitCommand：退出命令类，充当具体命令类 ExitCommand.cs 123456789101112131415161718namespace CommandSample&#123; class ExitCommand : Command &#123; private SystemExitClass seObj; // 维持对请求接收者的引用 public ExitCommand() &#123; seObj = new SystemExitClass(); &#125; // 命令执行方法，将调用请求接收者的业务方法 public override void Execute() &#123; seObj.Exit(); &#125; &#125;&#125; (4)HelpCommand：帮助命令类，充当具体命令类。 HelpCommand.cs 123456789101112131415161718namespace CommandSample&#123; class HelpCommand : Command &#123; private DisplayHelpClass hcObj; // 维持对请求接收者的引用 public HelpCommand() &#123; hcObj = new DisplayHelpClass(); &#125; // 命令执行方法，将调用请求接收者的业务方法 public override void Execute() &#123; hcObj.Display(); &#125; &#125;&#125; (5)SystemExitClass：退出系统模拟实现类，充当请求接收者。 SystemExitClass.cs 123456789101112using System;namespace CommandSample&#123; class SystemExitClass &#123; public void Exit() &#123; Console.WriteLine("退出系统"); &#125; &#125;&#125; (6)DisplayHelpClass：显示帮助文档模拟实现类，充当请求接收者。 DisplayHelpClass.cs 123456789101112using System;namespace CommandSample&#123; class DisplayHelpClass &#123; public void Display() &#123; Console.WriteLine("显示帮助文档！"); &#125; &#125;&#125; (7)配置文件App.config：在配置文件中存储了具体命令类的类名。 App.config 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="command" value="CommandSample.ExitCommand" /&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (8)Program：客户端测试类。 Program.cs 123456789101112131415161718192021222324252627using System;using System.Configuration;using System.Reflection;namespace CommandSample&#123; class Program &#123; static void Main(string[] args) &#123; FunctionButton fb = new FunctionButton(); Command command; // 定义命令对象 // 读取配置文件 string commandStr = ConfigurationManager.AppSettings["command"]; // 反射生成对象 command = (Command)Assembly.Load("CommandSample").CreateInstance(commandStr); // 将命令对象注入功能键 fb.Command = command; // 调用功能键的业务方法 fb.Click(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12单击功能键！退出系统！ 如果需要更换具体命令类，无需修改源代码，只需修改配置文件，例如将退出命令改为帮助命令，只需将存储在配置文件中的具体命令类类名ExitCommand改为HelpCommand。其代码如下：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="command" value="CommandSample.HelpCommand" /&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 重新运行客户端程序，输出结果如下：12单击功能键！显示帮助文档！ 如果在系统中增加了新的功能，功能键需要与新功能对应，只需要对应增加一个新的具体命令类，在新的具体命令类中调用新功能类的业务方法，然后将该具体命令类的对象通过配置文件注入功能键即可，原有代码无须修改，符合开闭原则。 在命令模式中，每一个具体命令类对应一个请求的处理者（接收者），通过向请求发送者注入不同的具体命令对象可以使相同的发送者对应不同的接收者，从而实现“将一个请求封装为一个对象，用不同的请求对客户进行参数化”，客户端只需要将具体命令对象作为参数注入请求发送者，无须直接操作请求的接收者。 实现命令队列当一个请求发送者发送一个请求时，有不止一个请求接收者产生响应，这些请求接收者将逐个执行业务方法，完成对请求的处理。此时，可以通过命令队列来实现。 命令队列的实现方法有多种形式，其中最常用、灵活性最好的一种方式是增加一个CommandQueue类，由该类负责存储多个命令对象，而不同的命令对象可以对应不同的请求接收者。CommandQueue类的典型代码如下: CommandQueue.cs 1234567891011121314151617181920212223242526272829using System.Collections.Generic;namespace CommandSample&#123; class CommandQueue &#123; // 定义一个List来存储命令队列 private List&lt;Command&gt; commands = new List&lt;Command&gt;(); public void AddCommand(Command command) &#123; commands.Add(command); &#125; public void RemoveCommand(Command command) &#123; commands.Remove(command); &#125; // 循环调用每一个命令对象的Execute()方法 public void Execute() &#123; foreach(object command in commands) &#123; ((Command)command).Execute(); &#125; &#125; &#125;&#125; 在增加了命令队列类CommandQueue以后，请求发送者Invoker将针对CommandQueue编程。其代码修改如下： Invoker.cs 1234567891011121314151617181920212223242526namespace CommandSample&#123; class Invoker &#123; // 维持一个CommandQueue对象的引用 private CommandQueue commandQueue; // 构造注入 public Invoker(CommandQueue commandQueue) &#123; this.commandQueue = commandQueue; &#125; // 设值注入 public void SetCommandQueue(CommandQueue commandQueue) &#123; this.commandQueue = commandQueue; &#125; // 调用CommandQueue类的Execute()方法 public void Call() &#123; commandQueue.Execute(); &#125; &#125;&#125; 命令队列与人们常说的“批处理”有点类似。批处理，顾名思义，可以对一组命令对象进行批量处理，当一个发送者发送请求后，将有一系列接收者对请求作出响应。命令队列可以用于设计批处理应用程序，如果请求接收者的接收次序没有严格的先后次序，还可以使用多线程技术并发调用命令对象的Execute()方法，从而提高程序的执行效率。 记录请求日志请求日志就是将请求的历史记录保存下来，通常以日志文件（Log File）的形式永久存储在计算机中。很多系统都提供了日志文件，例如Windows日志文件，Oracle日志文件等，日志文件可以记录用户对系统的一些操作（例如对数据的更改）。请求日志文件可以实现很多功能，其常用功能如下： (1)一旦系统发生故障，日志文件可以为系统提供一种恢复机制，在请求日志文件中可以记录用户对系统的每一步操作，从而让系统能够顺利地恢复到某一个特定的状态。 (2)请求日志也可以用于实现批处理，在一个请求日志文件中可以存储一系列命令对象，例如一个命令队列。 (3)用户可以将命令队列中的所有命令对象都存储在一个日志文件中，每执行一个命令则从日志文件中删除一个对应的命令对象，防止因为断电或者系统重启等原因造成请求丢失，而且可以避免重新发送全部请求时造成某些命令的重复执行，只需读取日志文件，再继续执行文件中剩余的命令即可。 在实现请求日志时，可以将发送请求的命令对象通过序列化写到日志文件中，此时命令类必须使用属性[Serializable]标记为可序列化。 实现撤销操作在命令模式中，用户可以通过对命令类进行修改使得系统支持撤销（Undo）操作和恢复（Redo）操作，下面通过一个简单实例来学习如何在命令模式中实现撤销操作。 设计一个简易计算器，该计算器可以实现简单的数学运算，还可以对运算实施撤销操作。 使用命令模式设计可得到图4所示的结构图，其中，计算器界面类CalculatorForm充当请求发送者，实现了数据求和功能的加法类Adder充当请求接收者，界面类可间接调用加法类中的Add()方法实现加法运算，并且提供了可撤销加法运算的Undo()方法。 图4 简易计算器结构图 在实例中，加法类Adder充当请求接收者，其代码如下： Adder.cs 123456789101112131415namespace CommandUndoSample&#123; class Adder &#123; // 定义初始值为0 private int num = 0; // 加法操作，每次将传入的值与num做加法运算，再将结果返回 public int Add(int value) &#123; num += value; return num; &#125; &#125;&#125; AbstractCommand充当抽象命令类，声明了Execute()方法和撤销方法Undo()。其代码如下： AbstractCommand.cs 12345678namespace CommandUndoSample&#123; abstract class AbstractCommand &#123; public abstract int Execute(int value); public abstract int Undo(); &#125;&#125; AddCommand充当具体命令类，实现了在抽象命令类AbstractCommand中声明的Execute()方法和撤销方法Undo()。其代码如下： AddCommand.cs 123456789101112131415161718192021namespace CommandUndoSample&#123; class AddCommand : AbstractCommand &#123; private Adder adder = new Adder(); private int value; // 实现抽象命令类中声明的Execute()方法，调用加法类的加法操作 public override int Execute(int value) &#123; this.value = value; return adder.Add(value); &#125; // 实现抽象命令类中声明的Undo()方法，通过加一个相反数来实现加法的逆向操作 public override int Undo() &#123; return adder.Add(-value); &#125; &#125;&#125; CalculatorForm充当请求发送者，它引用一个抽象命令AbstractCommand类型的对象command，通过该command对象间接调用请求接收者Adder类的业务处理方法。其代码如下： CalculatorForm.cs 1234567891011121314151617181920212223242526272829using System;namespace CommandUndoSample&#123; class CalculatorForm &#123; private AbstractCommand command; public AbstractCommand Command &#123; get&#123; return command; &#125; set&#123; command = value; &#125; &#125; // 调用命令对象的Execute()方法执行运算 public void Compute(int value) &#123; int i = Command.Execute(value); Console.WriteLine("执行运算，运算结果为：" + i); &#125; // 调用命令对象的Undo()方法执行撤销 public void Undo() &#123; int i = Command.Undo(); Console.WriteLine("执行撤销，运算结果为：" + i); &#125; &#125;&#125; 在客户端测试类Program中定义了抽象命令类型的命令对象command，还创建了请求发送者对象form，通过调用form对象的Compute()方法实现加法运算，还可以调用Undo()方法撤销最后一次加法运算。其代码如下。 Program.cs 12345678910111213141516171819202122using System;namespace CommandUndoSample&#123; public class Program &#123; static void Main(string[] args) &#123; CalculatorForm form = new CalculatorForm(); AbstractCommand command; command = new AddCommand(); form.Command = command; form.Compute(10); form.Compute(5); form.Compute(10); form.Undo(); // 撤销 Console.Read(); &#125; &#125;&#125; 编译并运行程序，输出结果如下：1234执行运算，运算结果为：10执行运算，运算结果为：15执行运算，运算结果为：25执行撤销，运算结果为：15 需要注意的是，在本实例中只能实现一步撤销操作，因为没有保存命令对象的历史状态，用户可以通过引入一个命令集合或其他方式来存储每一次操作时命令的状态，从而实现多次撤销操作。除了撤销操作外，还可以采用类似的方式实现恢复（Redo）操作，即恢复所撤销的操作（或称为二次撤销）。 宏命令宏命令（Macro Command）又称为组合命令（Composite Command），它是组合模式和命令模式联用的产物。宏命令是一个具体命令类，它拥有一个集合，在该集合中包含了对其他命令对象的引用。通常，宏命令不直接与请求接收者交互，而是通过它的成员来调用接收者的方法。当调用宏命令的Execute()方法时，将递归调用它所包含的每个成员命令的Execute()方法。一个宏命令的成员可以是简单命令，还可以继续是宏命令。执行一个宏命令将触发多个具体命令的执行，从而实现对命令的批处理。宏命令结构如图5所示。 图5 宏命令结构图 命令模式的优缺点与适用环境命令模式是一种使用频率非常高的设计模式，它可以将请求发送者与接收者解耦，请求发送者通过命令对象来间接引用请求接收者，使得系统具有更好的灵活性与可扩展性。在基于GUI的软件开发，无论是计算机桌面应用还是手机移动应用中，命令模式都得到了广泛的应用。 命令模式的优点命令模式的主要优点如下： (1)命令模式降低了系统的藕合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现了完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。 (2)通过使用命令模式，新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响其他类，所以增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足开闭原则的要求。 (3)使用命令模式可以比较容易地设计一个命令队列或宏命令（组合命令）。 (4)命令模式为请求的撤销（Undo）和恢复（Redo）操作提供了一种设计和实现方案。 命令模式的缺点命令模式的主要缺点如下： 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，所以在某些系统中可能需要提供大量的具体命令类,，这将影响命令模式的使用。 命令模式的适用环境在以下情况下可以考虑使用命令模式： (1)系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。 (2)系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期。换而言之，最初的请求发出者可能已经不在了，但命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。 (3)系统需要支持命令的撤销（Undo）操作和恢复（Redo）操作。 (4)系统需要将一组操作组合在一起形成宏命令。 本章小结(1)在命令模式中，将一个请求封装为一个对象，从而让你可以用不同的请求对客户进行参数化，将请求排队或者记录请求日志以及支持可撤销的操作。命令模式是一种对象行为型模式。 (2)命令模式包含抽象命令类、具体命令类、调用者和接收者4个角色。其中，抽象命令类声明了用于执型请求的Execute()等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，在实现Execute()方法时，将调用接收者对象的相关操作；调用者即请求发送者，它通过命令对象来执行请求；接收者执行与请求相关的操作，具体实现对请求的业务处理。 (3)命令模式的主要优点包括降低了系统的耦合度，增加新的命令很容易，可以比较容易地设计一个命令队列或宏命令，还为请求的撤销和恢复操作提供了一种设计和实现方案。其主要缺点是使用命令模式可能会导致某些系统有过多的具体命令类。 (4)命令模式适用的环境：系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；系统需要在不同的时间指定请求、将请求排队和执行请求；系统需要支持命令的撤销操作和恢复操作；系统需要将一组操作组合在一起形成宏命令。 (5)如果一个请求发送者发送一个请求后，有不止一个请求接收者产生响应，此时，可以使用命令队列来存储多个命令对象，每个命令对象对应一个请求接收者。 (6)用户可以将命令对象通过序列化写到日志文件中，实现对请求日志的存储。 (7)在命令模式中，用户可以通过对命令类进行修改使得系统支持撤销操作和恢复操作。 (8)宏命令又称为组合命令，它是组合模式和命令模式联用的产物。宏命令是一个具体命令类，它拥有一个集合，在该集合中包含了对其他命令对象的引用。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单例模式]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 饿汉式单例与懒汉式单例有什么区别？ 本章导学 单例模式是结构最简单的设计模式，在它的核心结构中只包含一个被称为单例类的特殊类。通过单例模式可以确保系统中的一个类只有一个实例，而且该实例易被外界访问，从而方便对实例个数进行控制，节约系统资源。 本章将学习如何使用单例模式来确保系统中某个类的实例对象的唯一性，学习单例模式的实现方式以及如何在实际项目开发中合理地使用单例模式。 本章知识点 单例模式的定义 单例模式的结构 单例模式的实现 单例模式的应用 单例模式的优缺点 单例模式的适用环境 饿汉式单例和懒汉式单例 单例模式概述对于一个软件系统中的某些类而言，只有一个实例很重要。例如，一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或ID（序号）生成器等。在Windows操作系统中只能打开一个任务管理器窗口，如图1所示。如果不使用机制对窗口对象进行唯一化，势必会弹出多个窗口。如果这些窗口显示的内容完全一致，则是重复对象，浪费内存资源；如果这些窗口显示的内容不一致，则意味着在某一瞬间系统有多个状态，与实际不符，也会给用户带来误解，不知道哪一个才是真实的状态。因此，有时确保系统中某个对象的唯一性（即一个类只能有一个实例）非常重要。 图1 Windows任务管理器 如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个统一的全局变量可以确保对象随时都可以被访问，但不能防止创建多个对象。一个更好的解决办法是让类自身负责创建和保存它的唯一实例，并保证不能创建其他实例，它还提供了一个访问该实例的方法，这就是单例模式的动机。 单例模式的定义如下：1确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。 单例模式是一种对象创建型模式。单例模式有3个要点：一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。 单例模式的结构与实现单例模式的结构单例模式是结构最简单的设计模式，它只包含一个类，即单例类。单例模式的结构如图2所示。 图2 单例模式结构图 由图2可知，单例模式只包含一个单例角色——Singleton（单例），在单例类的内部创建它的唯一实例，并通过静态方法GetInstance()让客户端可以使用它的唯一实例。为了防止在外部对单例类实例化，将其构造函数的可见性设为private，并在单例类内部定义了一个Singleton类型的静态对象，作为供外部共享访问的唯一实例。 单例模式的实现单例模式的目的是保证一个类有且仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类——Singleton，单例类拥有一个私有构造函数，确保用户无法通过new关键字直接实例化它。除此之外，单例类中还包含一个静态私有成员变量与静态公有的工厂方法，该工厂方法负责检验实例的存在性并实例化自己，然后存储在静态成员变量中，以确保只有一个实例被创建。 通常，单例模式的实现代码如下：12345678910111213141516171819class Singleton&#123; private static Singleton instance = null; // 静态私有成员变量 // 私有构造函数 private Singleton() &#123; &#125; // 静态公有工厂方法，返回唯一实例 public static Singleton GetInstance() &#123; if(instance == null) instance = new Singleton(); return instance; &#125;&#125; 为了测试单例类所创建对象的唯一性，可以编写以下客户端测试代码：123456789101112131415161718using System;class Program&#123; static void Main(string[] args) &#123; Singleton s1 = Singleton.GetInstance(); Singleton s2 = Singleton.GetInstance(); // 判断两个对象是否相同 if (s1 == s2) &#123; Console.WriteLine("两个对象是相同实例。"); &#125; Console.Read(); &#125;&#125; 编译代码并运行，输出结果为：1两个对象是相同实例。 说明两次调用Getinstance()所获取的对象是同一实例对象，且无法在外部对Singletor进行实例化，因此能够确保系统中只有唯一的一个Singleton对象。 在单例模式的实现过程中，用户需要注意以下3点： (1)单例类构造函数的可见性为private。 (2)提供一个类型为自身的静态私有成员变量。 (3)提供一个公有的静态工厂方法。 单例模式的应用实例下面通过一个应用实例来进一步学习和理解单例模式。 1.实例说明 某软件公司承接了一个服务器负载均衡（Load Balance）软件的开发工作，该软件运行在一台负载均衡服务器上，可以将并发访问和数据流量分发到服务器集群中的多台设备上进行并发处理，提高了系元的整体处理能力，缩短了响应时间。由于集群中的服务器需要动态刑减，且客户端请求需要统一分发，因此需要确保负载均衡器的唯一性，只能有一个负载均衡器来负责服务器的管理和请求的分发，否则将会带来服务器状态的不一致以及请求分配冲突等问题。如何确保负载均衡器的唯一性是该软件成功的关键，试使用单例模式设计服务器负载均衡器。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 服务器负载均衡结构图 在图3中，将负载均衡器LoadBalancer设计为单例角色，其中包含一个存储服务器信息的集合serverList，每次在serverList中随机选择一台服务器来响应客户端的请求。 3.实例代码 (1)LoadBalancer：负载均衡器类，充当单例角色。在真实环境下该类非常复杂，包括大量初始化的工作和业务方法，考虑到代码的可读性和易理解性，在此只列出部分与模式相关的核心代码。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849using System;using System.Collections;namespace SingletonSample&#123; class LoadBalancer &#123; // 私有静态成员变量，存储唯一实例 private static LoadBalancer instance = null; // 服务器集合 private ArrayList serverList = null; // 私有构造函数 private LoadBalancer() &#123; serverList = new ArrayList(); &#125; // 公有静态成员方法，返回唯一实例 public static LoadBalancer GetLoadBalancer() &#123; if (instance == null) &#123; instance = new LoadBalancer(); &#125; return instance; &#125; // 增加服务器 public void AddServer(string server) &#123; serverList.Add(server); &#125; // 删除服务器 public void RemoveServer(string server) &#123; serverList.Remove(server); &#125; // 使用Random类随机获取服务器 public string GetServer() &#123; Random random = new Random(); int i = random.Next(serverList.Count); return serverList[i].ToString(); &#125; &#125;&#125; (2)Program：客户端测试类。12345678910111213141516171819202122232425262728293031323334353637using System;namespace SingletonSample&#123; class Program &#123; static void Main(string[] args) &#123; // 创建四个LoadBalancer对象 LoadBalancer balancer1,balancer2,balancer3,balancer4; balancer1 = LoadBalancer.GetLoadBalancer(); balancer2 = LoadBalancer.GetLoadBalancer(); balancer3 = LoadBalancer.GetLoadBalancer(); balancer4 = LoadBalancer.GetLoadBalancer(); // 判断服务器负载均衡器是否相同 if (balancer1 == balancer2 &amp;&amp; balancer2 == balancer3 &amp;&amp; balancer3 == balancer4) &#123; Console.WriteLine("服务器负载均衡器具有唯一性！"); &#125; // 增加服务器 balancer1.AddServer("Server 1"); balancer1.AddServer("Server 2"); balancer1.AddServer("Server 3"); balancer1.AddServer("Server 4"); // 模拟客户端请求的分发，如果输出结果全为同一个server，可以将i适当放大，例如改为"i &lt; 100" for (int i = 0; i &lt; 10; i++) &#123; string server = balancer1.GetServer(); Console.WriteLine("分发请求至服务器： " + server); &#125; Console.Read(); &#125; &#125;&#125; 4．结果及分析 编译并运行程序，输出结果如下：1234567891011服务器负载均衡器具有唯一性! 分发请求至服务器: Server 1 分发请求至服务器: Server 1 分发请求至服务器: Server 1 分发请求至服务器: Server 1 分发请求至服务器: Server 2 分发请求至服务器: Server 2 分发请求至服务器: Server 2 分发请求至服务器: Server 2 分发请求至服务器: Server 3 分发请求至服务器: Server 3 虽然创建了4个LoadBalancer对象，但是它们实际上是同一个对象，因此，通过使用单例模式可以确保LoadBalancer对象的唯一性。 饿汉式单例与懒汉式单例1.饿汉式单例类 饿汉式单例类（Eager Singleton）是实现起来最简单的单例类，饿汉式单例类结构如图4所示。 图4 饿汉式单例类图 从图4中可以看出，由于在定义静态变量的时候实例化了单例类，因此在类加载时单例对象就已创建，代码如下：1234567891011class EagerSingleton&#123; private static EagerSingleton instance = new EagerSingleton(); private EagerSingleton() &#123;&#125; public static EagerSingleton GetInstance() &#123; return instance; &#125;&#125; 当类被加载时，静态变量instance会被初始化，此时类的私有构造函数会被调用，单例类的唯一实例将被创建。 2.懒汉式单例类与双重检查锁定 与饿汉式单例类相同的是，懒汉式单例类（Lazy Singleton）的构造函数也是私有的。与饿汉式单例类不同的是，懒汉式单例类在第一次被引用时将自己实例化，在懒汉式单例类被加载时不会将自己实例化。懒汉式单例类结构如图5所示。 图5 懒汉式单例类图 从图5中可以看出，在懒汉式单例类中，不是在定义静态变量时实例化单例类，而是在第一次调用静态工厂方法时实例化单例类。前面应用实例中的负载均衡器类LoadBalancer就是采用懒汉式单例来实现的。 但是懒汉式单例存在一个很严重的问题：如果在高并发、多线程环境下实现懒汉式单例类，在某一时刻可能会有多个线程需要使用单例对象，即会有多个线程同时调用GetInstance()方法，可能会造成创建多个实例对象，这将违背单例模式的设计意图。为了防止生成多个单例对象，需要使用C#语言中的lock关键字，lock关键字锁定的代码片段称为临界区，可以确保当一个线程位于代码的临界区时，另一个线程不能进入临界区。如果其他线程试图进入锁定的代码，则将一直等待，直到该对象被释放为止。修改之后的懒汉式单例类代码如下：123456789101112131415161718192021222324252627class LazySingleton&#123; private static LazySingleton instance = null; // 程序运行时创建一个静态只读的辅助对象 private static readonly object syncRoot = new object(); private LazySingleton()&#123;&#125; public static LazySingleton GetInstance() &#123; // 第一重判断，先判断实例是否存在，不存在再加锁处理 if (instance == null) &#123; // 加锁的程序在某一时刻只允许一个线程访问 lock(syncRoot) &#123; // 第二重判断 if (instance == null) &#123; instance = new LazySingleton(); // 创建单例实例 &#125; &#125; &#125; return instance; &#125;&#125; 在上面给出的懒汉式单例类实现代码中，对静态工厂方法GetInstance()中创建单例对象的代码进行了加锁、由于在调用时无法确定该单例对象是否已创建，因此需要使用辅助对象syncRoot来进行代码锁定。为了不影响程序的性能，此处只锁定创建单例对象的代码，并未锁定整个方法。如果实例存在则直接返回，如果实例未创建则加锁后再创建。 为了更好地对单例对象的创建进行控制，此处使用了一种被称为双重检查锁定（Double-Check Locking）的双重判断机制。在双重检查锁定中，当实例不存在且同时有两个线程调用GetInstance()方法时，它们都可以通过第一重“instance==null”判断，并且由于lock锁定机制，只有一个线程进入lock中执行创建代码，另一个线程处于排队等待状态，必须等待第一个线程执行完毕才可以进入lock锁定的代码，如果此时不进行第二重“instance-=null”判断，第二个线程并不知道实例已经创建，将继续创建新的实例，还是会产生多个单例对象，违背了单例模式的设计思想，因此需要进行双重检查。 3.饿汉式单例类与懒汉式单例类比较 饿汉式单例类在类被加载时就将自己实例化，它的优点在于无须考虑多个线程同时访问的问题，可以确保实例的唯一性；从调用速度和反应时间角度来讲，由于单例对象一开始就得以创建，因此要优于懒汉式单例。但是无论系统在运行时是否需要使用该单例对象，由于在类加载时该对象就需要创建，因此从资源利用效率角度来讲，饿汉式单例不及懒汉式单例，而且在系统加载时由于需要创建饿汉式单例对象，加载时间可能会比较长。 懒汉式单例类在第一次使用时创建，无须一直占用系统资源，实现了延迟加载，但是必须处理多个线程同时访问的问题，特别是当单例类作为资源控制器，在实例化时必然会涉及大量时间，这意味着出现多线程同时首次引用此类的概率变得较大，需要通过双重检查锁定等机制进行控制，这将导致系统性能受到一定影响。 单例模式的优缺点与适用环境单例模式作为一种目标明确、结构简单、理解容易的设计模式，在软件开发中使用频率相当高，在很多应用软件和框架中都得以广泛应用。 单例模式的优点单例模式的主要优点如下： (1)单例模式提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以可以严格控制客户怎样访问它以及何时访问它。 (2)由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，使用单例模式无疑可以提高系统的性能。 (3)单例模式允许可变数目的实例。基于单例模式可以进行扩展，使用与控制单例对象相似的方法来获得指定个数的实例对象，既节省系统资源，又解决了由于单例对象共享过多有损性能的问题（自行提供指定数目实例对象的类可称为多例类）。 单例模式的缺点单例模式的主要缺点如下： (1)由于单例模式中没有抽象层，因此，单例类的扩展有很大的困难。 (2)单例类的职责过重，在一定程度上违背了单一职责原则。因为单例类既提供了业务方法，又提供了创建对象的方法（工厂方法），将对象的创建和对象本身的功能耦合在一起 (3)现在很多面向对象语言（如C#、Java）的运行环境都提供了自动垃圾回收技术，因此，实例化的共享对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，在下次利用时又将重新实例化，这将导致共享的单例对象状态丢失。 单例模式的适用环境在以下情况下可以考虑使用单例模式： (1)系统只需要一个实例对象，例如系统要求提供一个唯一的序列号生成器或资源管理器，或者因为资源消耗太大而只允许创建一个对象。 (2)客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。 本章小结(1)单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供了全局访问的方法。单例模式是一种对象创建型模式。 (2)单例模式只包含一个单例角色。单例类的构造函数为私有，它提供一个自身类型的静态私有成员变量和一个公有的静态工厂方法。 (3)单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重，将太多的功能耦合在一起 (4)单例模式适用的环境：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。 (5)饿汉式单例在类加载的时候创建唯一实例，懒汉式单例在第一次调用静态工厂方法时创建唯一实例。 (6)在懒汉式单例类中，为了确保线程安全，避免创建多个单例对象，需要使用双重检查锁定机制来对单例对象的创建进行控制。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型模式]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章导学 原型模式是一种特殊的创建型模式，它通过复制一个已有对象来获取更多相同或者相似的对象。原型模式可以提高相同类型对象的创建效率，简化创建过程。 本章将学习原型模式的工作原理和结构，学习如何通过C#语言来实现原型模式，理解浅克隆和深克隆两种机制的异同，并通过实例学习如何实现浅克隆和深克隆。 本章知识点 原型模式的定义 原型模式的结构 浅克隆与深克隆 原型模式的实现 原型模式的应用 原型模式的优缺点 原型模式的适用环境 原型管理器 原型模式概述【西游记】中“孙悟空拔毛变小猴”的故事几乎人人皆知，孙悟空可以用毫毛根据自己的形象，复制出很多和自己长得一模一样的“身外身”来，如图1所示。 图1 孙悟空拔毛变小猴 孙悟空这种根据自己的形象复制（克隆）出多个身外身的技巧，在面向对象软件设计领域被称为原型模式，孙悟空则被称为原型对象。在面向对象系统中，也可以通过复制一个原型对象得到多个与原型对象一模一样的新对象，这就是原型模式的动机。 原型模式的定义如下：1使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。 原型模式是一种对象创建型模式，它的工作原理很简单：将一个原型对象传给要发动创建的对象（即客户端对象），这个要发动创建的对象通过请求原型对象复制自己来实现创建过程。由于在软件系统中经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在软件开发中具有较高的使用频率。原型模式是一种“另类”的创建型模式，创建新对象（也称为克隆对象）的工厂就是原型类自身，工厂方法由负责复制原型对象的克隆方法来实现。 需要注意的是，通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常，对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式对克隆对象进行修改以后，可以得到一系列相似但不完全相同的对象。 原型模式的结构与实现原型模式的结构原型模式的结构如图2所示。 图2 原型模式结构图 由图2可知，原型模式包含以下3个角色。 (1)Prototype（抽象原型类）：它是声明克隆方法的接口，是所有具体原型类的公共父类，它可以是抽象类也可以是接口，甚至可以是具体实现类。 (2)ConcretePrototype（具体原型类）：它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。 (3)Client（客户类）：在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类Prototype编程，因此，用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。 浅克隆与深克隆根据在复制原型对象的同时是否复制包含在原型对象中引用类型的成员变量，原型模式的克隆机制分为两种：浅克隆（Shallow Clone）和深克隆（Deep Clone）。 1.浅克隆 在浅克隆中，如果原型对象的成员变量是值类型（如int、double、byte、bool、char等基本数据类型），将复制一份给克隆对象；如果原型对象的成员变量是引用类型（如类、接口、数组等复杂数据类型），则将引用对象的地址复制一份给克隆对象，也就是说，原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当原型对象被复制时，只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制，如图3所示。 图3 浅克隆示意图 2.深克隆 在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将被复制，如图4所示。 图4 深克隆示意图 原型模式的实现实现原型模式的关键在于如何实现克隆方法，下面介绍两种在C#语言中常用的克隆实现方法。 1.通用的克隆实现方法 通用的克隆实现方法是在具体原型类的克隆方法中创建一个与自身类型相同的对象并将其返回，是创建的同时将相关参数传入新创建的对象中，保证它们的成员变量相同。示意代码如下：1234567891011121314151617181920212223abstract class Prototype&#123; public abstract Prototype Clone();&#125;class ConcretePrototype : Prototype&#123; private string attr; //成员变量 public string Attr &#123; get &#123; return attr; &#125; set &#123; attr = value; &#125; &#125; // 克隆方法 public override Prototype Clone() &#123; ConcretePrototype prototype = new ConcretePrototype(); prototype.Attr = this.Attr; return prototype; &#125;&#125; 在客户类中只需要创建一个ConcretePrototype对象作为原型对象，然后调用其Clone()方法即可得到对应的克隆对象，如下面的代码片段所示：1234...ConcretePrototype prototype = new ConcretePrototype();ConcretePrototype copy = (ConcretePrototype)prototype.Clone();... 此方法是原型模式的通用实现方法，与编程语言本身的特性无关，除C#外，其他面向对象编程语言也可以使用这种形式来实现对原型的克隆。 在原型模式的通用实现方法中，可通过手工编写Clone()方法来实现浅克隆和深克隆。对于引用类型的对象，可以在Clone()方法中通过赋值的方式来实现复制，这是一种浅克隆实现方案；如果在Clone()方法中通过创建一个全新的成员对象来实现复制，则是一种深克隆实现方案。C#语言中的字符串（string/String）对象存在特殊性，只要两个字符串的内容相同，无论是直接赋值还是创建新对象，它们在内存中始终只有一份。 2.C#中的MemberwiseClone()方法和ICloneable接口 在C#语言中，提供了一个MemberwiseClone()方法用于实现浅克隆，该方法使用起来很方便，直接调用一个已有对象的MemberwiseClone()方法即可实现克隆。如下面的代码所示：12345678910111213141516171819202122// 成员类class Member&#123;&#125;class ConcretePrototypeA&#123; private Member member; // 成员对象 public Member Member &#123; get &#123; return member; &#125; set &#123; member = value; &#125; &#125; // 克隆方法 public ConcretePrototypeA Clone() &#123; return (ConcretePrototypeA)this.MemberwiseClone(); // 浅克隆 &#125;&#125; 在客户类中可以直接调用原型对象的Clone()方法来创建新的对象，如下面的代码片段所示：1234567...ConcretePrototypeA prototype, copy;prototype = new ConcretePrototypeA();copy = prototype.Clone();Console.WriteLine(prototype == copy);Console.WriteLine(prototype.Member == copy.Member);... 在上述客户类代码片段中，输出语句“Console.WriteLine(prototype==copy);”的输出结果为“False”，输出语句“Console.WriteLine(prototype.Member==copy.Member);”的输出结果为“True”，表明此处的克隆方法为浅克隆。 除了MemberwiseClone()方法以外，在C#语言中还提供了一个ICloneable接口，它也可以用来创建当前对象的副本，其代码如下:1234public interface ICloneable&#123; object Clone();&#125; ICloneable接口充当了抽象原型类的角色，具体原型类通常作为实现该接口的子类，如下面的代码所示：12345678910111213141516171819class ConcretePrototypeB : ICloneable // 实现ICloneable接口&#123; private Member member; public Member Member &#123; get &#123; return member; &#125; set &#123; member = value; &#125; &#125; // 实现深克隆 public object Clone() &#123; ConcretePrototypeB copy = (ConcretePrototypeB)this.MemberwiseClone(); Member newMember = new Member(); copy.Member = newMember; return copy; &#125;&#125; 客户端代码片段如下：1234567...ConcretePrototypeB prototype, copy;prototype = new ConcretePrototypeB();copy = (ConcretePrototypeB)prototype.Clone();Console.WriteLine(prototype == copy);Console.WriteLine(prototype.Member == copy.Member);... 在此客户类代码片段中，输出语句“Console.WriteLine(prototype==copy);”的输出结果为“False”，输出语句“Console.WriteLine(prototype.Member==copy.Member);”的输出结果也为“False”，表明此处的克隆方法为深克隆。 在实现ICloneable接口时，通常提供的是除MemberwiseClone()以外的深克隆方法。除了通过直接创建新的成员对象来手工实现深克隆外，还可以通过反射、序列化等方式来实现深克隆，在使用序列化实现时要求所有被引用的对象都必须是可序列化的（Serializable）。在下一节的应用实例中将学习如何使用序列化来实现深克隆。 原型模式的应用实例下面通过一个应用实例来进一步学习和理解原型模式。 1.实例说明 在使用某OA系统时，有些岗位的员工发现他们每周的工作都大同小异，因此在填写工作周报时很多内容都是重复的，为了提高工作周报的创建效率，大家迫切地希望有一种机制能够快速创建相同或者相似的周报，包括创建周报的附件。试使用原型模式对该OA系统中的工作周报创建模块进行改进。 2.实例类图 通过分析，本实例的结构如图5所示。 图5 工作周报创建模块结构图 在图5中，WeeklyLog充当原型角色，Clone()方法为克隆方法，用于实现原型对象的克隆，Attachment充当成员类。 3.实例代码 (1)WeeklyLog：周报类，充当原型角色。在真实环境下该类比较复杂，考虑到代码的可读性，在此只列出部分与模式相关的核心代码。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687using System;using System.IO;using System.Collections;using System.Runtime.Serialization.Formatters.Binary;using System.Runtime.Serialization;namespace PrototypeSample&#123; [Serializable] class WeeklyLog &#123; private Attachment attachment; private string name; private string date; private string content; public Attachment Attachment &#123; get &#123; return attachment; &#125; set &#123; attachment = value; &#125; &#125; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public string Date &#123; get &#123; return date; &#125; set &#123; date = value; &#125; &#125; public string Content &#123; get &#123; return content; &#125; set &#123; content = value; &#125; &#125; /* //使用MemberwiseClone()方法实现浅克隆 public WeeklyLog Clone() &#123; return this.MemberwiseClone() as WeeklyLog; &#125; */ //使用序列化方式实现深克隆 public WeeklyLog Clone() &#123; WeeklyLog clone = null; FileStream fs = new FileStream("Temp.dat", FileMode.Create); BinaryFormatter formatter = new BinaryFormatter(); try &#123; formatter.Serialize(fs, this); &#125; catch (SerializationException e) &#123; Console.WriteLine("Failed to serialize. Reason: " + e.Message); throw; &#125; finally &#123; fs.Close(); &#125; FileStream fs1 = new FileStream("Temp.dat", FileMode.Open); BinaryFormatter formatter1 = new BinaryFormatter(); try &#123; clone = (WeeklyLog)formatter1.Deserialize(fs1); &#125; catch (SerializationException e) &#123; Console.WriteLine("Failed to deserialize. Reason: " + e.Message); throw; &#125; finally &#123; fs.Close(); &#125; return clone; &#125; &#125;&#125; (2)Attachment：附件类。 123456789101112131415161718192021using System;namespace PrototypeSample&#123; [Serializable] class Attachment &#123; private string name; public string Name &#123; get &#123; return name; &#125; set &#123; name = value; &#125; &#125; public void Download() &#123; Console.WriteLine("下载附件，文件名为&#123;0&#125;。",name); &#125; &#125;&#125; (3)Program：客户端测试类。 12345678910111213141516171819using System;namespace PrototypeSample&#123; class Program &#123; static void Main(string[] args) &#123; WeeklyLog log_previous, log_new; log_previous = new WeeklyLog(); Attachment attachment = new Attachment(); log_previous.Attachment = attachment; log_new = log_previous.Clone(); Console.WriteLine("周报是否相同？&#123;0&#125;",(log_previous == log_new)?"是":"否"); Console.WriteLine("附件是否相同？&#123;0&#125;",(log_previous.Attachment == log_new.Attachment)?"是":"否"); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12周报是否相同？否附件是否相同？是 从输出结果可以得知，在本实例中周报对象被成功复制，但是附件对象并没有被复制，实现了浅克隆。 5.深克隆解决方案 为了能够在复制周报的同时复制附件对象，需要采用深克隆机制。本节将介绍如何通过序列化的方式来实现深克隆，使用序列化实现深克隆包含两个步骤。 首先必须将周报类WeeklyLog和附件类Attachment标记为可序列化（Serializable），如下所示：123456789101112[Serializable]class WeeklyLog&#123; private Attachment attachment; ...&#125;[Serializable]class Attachment&#123; ...&#125; 然后将周报类WeeklyLog的Clone()方法修改如下：12345678910111213141516171819202122232425262728293031323334353637// 使用序列化方式实现深克隆public WeeklyLog Clone()&#123; WeeklyLog clone = null; FileStream fs = new FileStream("Temp.dat", FileMode.Create); BinaryFormatter formatter = new BinaryFormatter(); try &#123; formatter.Serialize(fs, this); // 序列化 &#125;catch(SerializationException e) &#123; Console.WriteLine("Failed to serialize. Reason: " + e.Message); throw; &#125;finally &#123; fs.Close(); &#125; FileStream fs1 = new FileStream("Temp.dat", FileMode.Open); BinaryFormatter formatter1 = new BinaryFormatter(); try &#123; clone = (WeeklyLog)formatter1.Deserialize(fs1); // 反序列化 &#125;catch(SerializationException e) &#123; Console.WriteLine("Failed to serialize. Reason: " + e.Message); throw; &#125;finally &#123; fs1.Close(); &#125; return clone;&#125; 重新执行客户端类Program，输出结果如下：12周报是否相同？否附件是否相同？否 从输出结果可以得知，本实例中，在成功复制周报对象的同时附件对象也被复制，实现了深克隆。 在上述深克隆实现代码中，通过使用FileStream类和BinaryFormatter类可实现对象的序列化和反序列化操作，首先使用序列化将当前对象写入流中，然后使用反序列化从流中获取对象。由于在序列化时一个对象的成员对象将伴随该对象一起被写入流中，在反序列化时将得到一个包含成员对象的新对象，因此可采用序列化和反序列化联用来实现深克隆。 原型管理器原型管理器（Prototype Manager）将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象来获得。在原型管理器中针对抽象原型类进行编程，以便于扩展，其结构如图6所示。 图6 带原型管理器的原型模式 图6中典型的原型管理器PrototypeManager类的实现代码片段如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647using System.Collections;namespace PrototypeManagerSample&#123; abstract class Prototype &#123; public abstract Prototype Clone(); &#125; class ConcretePrototypeA : Prototype &#123; public override Prototype Clone() &#123; return (ConcretePrototypeA)this.MemberwiseClone(); &#125; &#125; class ConcretePrototypeB : Prototype &#123; public override Prototype Clone() &#123; return (ConcretePrototypeB)this.MemberwiseClone(); &#125; &#125; class PrototypeManager &#123; Hashtable ht = new Hashtable(); public PrototypeManager() &#123; ht.Add("A", new ConcretePrototypeA()); ht.Add("B", new ConcretePrototypeB()); &#125; public void Add(string key, Prototype prototype) &#123; ht.Add(key,prototype); &#125; public Prototype Get(string key) &#123; Prototype clone = null; clone = ((Prototype)ht[key]).Clone(); return clone; &#125; &#125;&#125; 在实际开发中，可以将PrototypeManager设计为单例类，确保系统中有且仅有一个PrototypeManager对象，既有利于节省系统资源，还可以更地对原型管理器对象进行控制. 原型模式的优缺点与适用环境原型模式作为一种快速创建大量相同或相似对象的方式，在软件开发中的应用较为广泛，很多软件提供的复制（Ctrl+C）和粘贴（Ctrl+V）操作就是原型模式的典型应用。 原型模式的优点原型模式的主要优点如下： (1)当要创建的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。 (2)扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统没有任何影响。 (3)原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。 (4)可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用（例如恢复到某一历史状态），可辅助实现撤销操作。 原型模式的缺点原型模式的主要缺点如下： (1)需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了开闭原则。 (2)在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。 原型模式的适用环境在以下情况下可以考虑使用原型模式： (1)创建新对象成本较大（例如初始化需要占用较长的时间，占用太多的CPU资源或网络资源），新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改。 (2)系统要保存对象的状态，而对象的状态变化很小。 (3)需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。 本章小结(1)在原型模式中，使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。原型模式是一种对象创建型模式。 (2)原型模式包含抽象原型类、具体原型类和客户类3个角色。其中，抽象原型类是声明克隆方法的接口，是所有具体原型类的公共父类；具体原型类实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。 (3)根据在复制原型对象的同时是否复制包含在原型对象中引用类型的成员变量，原型模式的克隆机制可分为浅克隆和深克隆。在浅克隆中，当原型对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有被复制；在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将被复制。 (4)在C#语言中，提供了一个MemberwiseClone()方法用于实现克隆，此还提供了用于充当抽象原型角色的ICloneable接口。 (5)原型模式的主要优点是当要创建的对象实例较为复杂时，可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率，而且具有较好的扩展性；其主要缺点在于需要为每一个类配备一个克隆方法，因此在对已有类进行改造时比较麻烦，需要修改源代码，并且在实现深克隆时需要编写较为复杂的代码。 (6)原型模式适用的环境：创建新对象成本较大，新对象可以通过复制已有对象来获得；系统要保存对象的状态，而对象的状态变化很小；需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。 (7)原型管理器将多个原型对象存储在一个集合中供客户端使用，它是一个专门负责克隆对象的工厂，其中定义了一个集合用于存储原型对象，如果需要某个原型对象的一个克隆，可以通过复制集合中对应的原型对象获得。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[建造者模式]]></title>
    <url>%2F2019%2F09%2F18%2F%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 建造者模式包含4个角色。是哪4个？ 在建造者模式的定义中提到了复杂对象，那么什么是复杂对象？ 如果将抽象工厂模式看成一个汽车配件生产厂，生成不同类型的汽车配件，那么建造者模式就是一个汽车组装厂，通过对配件进行组装返回一辆完整的汽车。怎么理解？ 建造者模式中还引入了一个指挥者类Director，该类主要有两个作用：一方面隔离了客户端与创建过程；另一方面控制产品对象的创建过程。怎么理解？ 建造者客户端new一个指挥者，new一个具体建造者，然后调用指挥者的无参方法即可创建一个产品对象。怎么理解？ 抽象建造者是直接new了产品，然后对属性的不同赋值交给子类去完成。怎么理解？ Director可以省略吗？ 本章导学 建造者模式是一种较为复杂的创建型模式，它将客户端与包含多个组成部分的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需知道所需建造者的类型即可。建造者模式关注如何逐步创建一个复杂的对象，不同的具体建造者定义了不同的创建过程，且具体建造者相互独立，更换建造者或增加新的建造者非常方便，系统具有较好的扩展性。 本章将学习建造者模式的定义与结构，理解建造者模式中各个组成元素作用，并通过实例来学习如何实现建造者模式。 本章知识点 建造者模式的定义 建造者模式的结构 建造者模式的实现 建造者模式的应用 建造者模式的优缺点 建造者模式的适用环境 指挥者类的作用与变化 建造者模式概述无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分（部件），例如汽车，它包括车轮、方向盘、发动机等多种部件。对于大多数用户而言，并不知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，如图1所示。 图1 复杂对象（汽车）示意图 如何将这些部件组装成一辆完整的汽车并返回给用户，是建造者模式需要解决的问题。建造者模式可以将部件本身和它们的组装过程分开，关注如何一步步创建一个包含多个组成部分的复杂对象，用户只需要指定复杂对象的类型即可得到该对象，而无须知道其内部的具体构造细节。 建造者模式的定义如下：1将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 建造者模式是一种对象创建型模式，它将客户端与包含多个部件的复杂对象的创建过程分离，客户端无须知道复杂对象的内部组成部分与装配方式，只需知道所需建造者的类型即可。建造者模式关注如何逐步创建一个复杂的对象，不同的建造者定义了不同的创建过程。 建造者模式的结构与实现建造者模式的结构建造者模式的结构如图2所示。 图2 建造者模式结构图 由图2可知，建造者模式包含以下4个角色。 (1)Builder（抽象建造者）：它为创建一个产品Product对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是BuildPartX()（例如图2中的BuildPartA()、BuildPartB()等），它们用于创建复杂对象的各个部件；另一类方法是GetResult()，它们用于返回复杂对象。Builder既可以是抽象类，也可以是接口。 (2)ConcreteBuilder（具体建造者）：它实现了Builder接口，实现各个部件的具体构造和装配方法，定义并明确所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象（该方法也可由抽象建造者实现）。 (3)Product（产品）：它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。 (4)Director（指挥者）：指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其Construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者Setter方法将该对象传入指挥者类中。 建造者模式的实现在建造者模式的定义中提到了复杂对象，那么什么是复杂对象，简单来说，复杂对象是指包含多个成员变量的对象，这些成员变量也称为部件或零件。如汽车包括方向盘、发动机、轮胎等部件，电子邮件包括发件人、收件人、主题、内容、附件等部件。一个典型的复杂对象类示例的代码如下：123456789101112131415161718192021222324class Product&#123; private string partA; private string partB; private string partC; public string PartA &#123; get &#123; return partA; &#125; set &#123; partA = value; &#125; &#125; public string PartB &#123; get &#123; return partB; &#125; set &#123; partB = value; &#125; &#125; public string PartC &#123; get &#123; return partC; &#125; set &#123; partC = value; &#125; &#125;&#125; 在抽象建造者类中定义了产品的创建方法和返回方法，其典型代码如下：12345678910111213abstract class Builder&#123; protected Product product = new Product(); public abstract void BuildPartA(); public abstract void BuildPartB(); public abstract void BuildPartC(); public Product GetResult() &#123; return product; &#125;&#125; 在抽象类Builder中声明了一系列抽象的BuildPartX()方法用于创建复杂产品的各个部件，具体建造过程在ConcreteBuilder中实现，此外，Builder还提供了一个GetResult()方法用于返回一个已创建好的完整产品对象。 在ConcreteBuilder中实现了这些BuildPartX()方法，通过调用Product的Setter方法可以给产品对象的成员变量设值，不同的具体建造者在实现BuildPartX()方法时将有所区别。典型的具体建造者类代码如下：1234567891011121314151617class ConcreteBuilder1 : Builder&#123; public override void BuildPartA() &#123; product.PartA = "A1"; &#125; public override void BuildPartB() &#123; product.PartB = "B1"; &#125; public override void BuildPartC() &#123; product.PartC = "C1"; &#125;&#125; 此外，在建造者模式中还引入了一个指挥者类Director，该类主要有两个作用：一方面隔离了客户端与创建过程；另一方面控制产品对象的创建过程，包括某个BuildPartX()方法是否被调用以及多个BuildPartX()方法调用的先后次序等。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，便可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。在实际生活中也存在类似指挥者一样的角色，如一个客户去购买计算机，计算机销售人员相当于指挥者，只要客户确定计算机的类型，计算机销售人员就可以通知计算机组装人员给客户组装一台计算机。指挥者类的示例代码如下：1234567891011121314151617181920212223class Director&#123; private Builder builder; public Director(Builder builder) &#123; this.builder = builder; &#125; public void SetBuilder(Builder builder) &#123; this.builder = builder &#125; public Product Construct() &#123; builder.BuildPartA(); builder.BuildPartB(); builder.BuildPartC(); return builder.GetResult(); &#125;&#125; 在指挥者类中可以注入一个抽象建造者类型的对象，它提供了一个建造方法Construct()，在该方法中调用了builder对象的构造部件的方法，最后返回一个产品对象。 对于客户端而言，只需关心具体建造者的类型，无须关心产品对象的具体组装过程。通常，客户类代码片段如下：12345...Builder builder = new ConcreteBuilder1();Director director = new Director(builder);Product product = director.Construct();... 用户可以通过配置文件来存储具体建造者类ConcreteBuilder1的类名，使得在更换新的建造者时无须修改源代码，系统扩展更为方便。 建造者模式与抽象工厂模式都是较为复杂的创建型模式，建造者模式返回一个完整的复杂产品，抽象工厂模式返回一系列相关的产品；在抽象工厂模式中，客户端通过选择具体工厂来生成所需对象，而在建造者模式中，客户端通过指定具体建造者类型来指导Director类如何去生成对象，侧重逐步构造一个复杂对象，然后将结果返回。如果将抽象工厂模式看成一个汽车配件生产厂，生成不同类型的汽车配件，那么建造者模式就是一个汽车组装厂，通过对配件进行组装返回一辆完整的汽车。 建造者模式的应用实例下面通过一个应用实例来进一步学习和理解建造者模式。 1.实例说明 某游戏软件公司决定开发一款基于角色扮演的多人在线网络游戏，玩家可以在游戏中扮演虚拟世界中的一个特定角色，角色根据不同的游戏情节和统计数据（例如力量、魔法、技能等）具有不同的能力，角色也会随着不断升级而拥有更加强大的能力。作为该游戏的一个重要组成部分，需要对游戏角色进行设计，而且随着该游戏的升级将不断增加新的角色。通过分析发现，游戏角色是一个复杂对象，它包含性别、面容等多个组成部分，不同类型的游戏角色，其性别、面容、服装、发型等外部特性有所差异，例如“天使”拥有美丽的面容和披肩的长发，并身穿一袭白裙；而“恶魔”极其丑陋，留着光头并穿一件刺眼的黑衣。无论是何种造型的游戏角色，它的创建步骤都大同小异，都需要逐步创建其组成部分，再将各组成部分装配成一个完整的游戏角色。现使用建造者模式来实现游戏角色的创建。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 游戏角色创建结构图 在图3中，ActorController充当指挥者，ActorBuilder充当抽象建造者，HeroBuilder、AngelBuilder和DevilBuilder充当具体建造者，Actor充当复杂产品。 3.实例代码 (1)Actor：游戏角色类，充当复杂产品对象。考虑到代码的可读性，在此只列出了部分成员变量，且成员变量的类型均为string，真实情况下，有些成员变量的类型需用户自定义。1234567891011121314151617181920212223242526272829303132333435363738394041namespace BuilderSample&#123; class Actor &#123; private string type; //角色类型 private string sex; //性别 private string face; //面容 private string costume; //服装 private string hairstyle; //发型 public string Type &#123; get &#123; return type; &#125; set &#123; type = value; &#125; &#125; public string Sex &#123; get &#123; return sex; &#125; set &#123; sex = value; &#125; &#125; public string Face &#123; get &#123; return face; &#125; set &#123; face = value; &#125; &#125; public string Costume &#123; get &#123; return costume; &#125; set &#123; costume = value; &#125; &#125; public string Hairstyle &#123; get &#123; return hairstyle; &#125; set &#123; hairstyle = value; &#125; &#125; &#125;&#125; (2)ActorBuilder：游戏角色建造者，充当抽象建造者。 1234567891011121314151617181920namespace BuilderSample&#123; //角色建造者：抽象建造者 abstract class ActorBuilder &#123; protected Actor actor = new Actor(); public abstract void BuildType(); public abstract void BuildSex(); public abstract void BuildFace(); public abstract void BuildCostume(); public abstract void BuildHairstyle(); //工厂方法，返回一个完整的游戏角色对象 public Actor CreateActor() &#123; return actor; &#125; &#125;&#125; (3)HeroBuilder：英雄角色建造者，充当具体建造者。 123456789101112131415161718192021222324252627282930namespace BuilderSample&#123; class HeroBuilder : ActorBuilder &#123; public override void BuildType() &#123; actor.Type = "英雄"; &#125; public override void BuildSex() &#123; actor.Sex = "男"; &#125; public override void BuildFace() &#123; actor.Face = "英俊"; &#125; public override void BuildCostume() &#123; actor.Costume = "盔甲"; &#125; public override void BuildHairstyle() &#123; actor.Hairstyle = "飘逸"; &#125; &#125;&#125; (4)AngelBuilder：天使角色建造者，充当具体建造者。 123456789101112131415161718192021222324252627282930namespace BuilderSample&#123; class AngelBuilder : ActorBuilder &#123; public override void BuildType() &#123; actor.Type = "天使"; &#125; public override void BuildSex() &#123; actor.Sex = "女"; &#125; public override void BuildFace() &#123; actor.Face = "漂亮"; &#125; public override void BuildCostume() &#123; actor.Costume = "白裙"; &#125; public override void BuildHairstyle() &#123; actor.Hairstyle = "披肩长发"; &#125; &#125;&#125; (5)DevilBuilder：恶魔角色建造者，充当具体建造者。 123456789101112131415161718192021222324252627282930namespace BuilderSample&#123; class DevilBuilder : ActorBuilder &#123; public override void BuildType() &#123; actor.Type = "恶魔"; &#125; public override void BuildSex() &#123; actor.Sex = "妖"; &#125; public override void BuildFace() &#123; actor.Face = "丑陋"; &#125; public override void BuildCostume() &#123; actor.Costume = "黑衣"; &#125; public override void BuildHairstyle() &#123; actor.Hairstyle = "光头"; &#125; &#125;&#125; (6)ActorController：角色控制器，充当指挥者。 123456789101112131415161718namespace BuilderSample&#123; class ActorController &#123; //逐步构建复杂产品对象 public Actor Construct(ActorBuilder ab) &#123; Actor actor; ab.BuildType(); ab.BuildSex(); ab.BuildFace(); ab.BuildCostume(); ab.BuildHairstyle(); actor = ab.CreateActor(); return actor; &#125; &#125;&#125; (7)配置文件App.config：在配置文件中存储了具体建造者类的类名。 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="builder" value="BuilderSample.AngelBuilder"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (8)Program：客户端测试类。 1234567891011121314151617181920212223242526272829using System;using System.Configuration;using System.Reflection;namespace BuilderSample&#123; class Program &#123; static void Main(string[] args) &#123; ActorBuilder ab; //针对抽象建造者编程 //读取配置文件 string builderType = ConfigurationManager.AppSettings["builder"]; //反射生成对象 ab = (ActorBuilder)Assembly.Load("BuilderSample").CreateInstance(builderType); ActorController ac = new ActorController(); Actor actor; actor = ac.Construct(ab); //通过指挥者创建完整的建造者对象 Console.WriteLine("&#123;0&#125;的外观：",actor.Type); Console.WriteLine("性别：&#123;0&#125;",actor.Sex); Console.WriteLine("面容：&#123;0&#125;",actor.Face); Console.WriteLine("服装：&#123;0&#125;",actor.Costume); Console.WriteLine("发型：&#123;0&#125;",actor.Hairstyle); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：12345天使的外观： 性别：女 面容：漂亮 服装：白裙 发型：披肩长发 如果需要更换具体角色建造者，只需修改配置文件即可，例如将配置文件中key为“builder”的键值对的value值改为“BuilderSample.HeroBuilder”，再次运行程序，输出结果如下：12345英雄的外观： 性别：男 面容：英俊 服装：盔甲 发型：飘逸 当需要增加新的具体角色建造者时，只需将新增具体角色建造者作为抽象角色建造者的子类，然后修改配置文件即可，原有代码无须修改，完全符合开闭原则。 指挥者类的深入讨论指挥者类Director是建造者模式的重要组成部分，简单的Director类用于指导具体建造者构建产品，它按一定次序调用Builder的BuildPartX()方法，控制调用的先后次序，并向客户端返回一个完整的产品对象。下面讨论几种Director的变化形式。 1.省略Director 在有些情况下，为了简化系统结构，可以将Director和抽象建造者Builder进行合并，在Builder中提供了逐步构建复杂产品对象的Construct()方法。由于Builder类通常为抽象类，因此可以将Construct()方法定义为静态（static）方法，以便客户端能够直接调用。如果将游戏角色实例中的指挥者类ActorController省略，ActorBuilder类的代码修改如下：12345678910111213141516171819202122232425namespace BuilderSample&#123; //角色建造者：抽象建造者 abstract class ActorBuilder &#123; protected static Actor actor = new Actor(); public abstract void BuildType(); public abstract void BuildSex(); public abstract void BuildFace(); public abstract void BuildCostume(); public abstract void BuildHairstyle(); public static Actor Construct(ActorBuilder ab) &#123; ab.BuildType(); ab.BuildSex(); ab.BuildFace(); ab.BuildCostume(); ab.BuildHairstyle(); return actor; &#125; &#125;&#125; 此时对应的客户端代码也将发生修改，代码片段如下：1234567...ActorBuilder ab;string builderType = ConfigurationManager.AppSettings["builder"];ab = (ActorBuilder)Assembly.Load("BuildExtend").CreateInstance(builderType);Actor actor;actor = ActorBuilder.Construct(ab);... 除此之外，还有一种更简单的处理方法，可以将Construct()方法中的参数去掉，直接在Construct()方法中调用BuildPartX()方法，代码如下：123456789101112131415161718192021abstract class ActorBuilder&#123; protected Actor actor = new Actor(); public abstract void BuildType(); public abstract void BuildSex(); public abstract void BuildFace(); public abstract void BuildCostume(); public abstract void BuildHairstyle(); public Actor Construct() &#123; this.BuildType(); this.BuildSex(); this.BuildFace(); this.BuildCostume(); this.BuildHairstyle(); return actor; &#125;&#125; 客户端代码片段如下：1234567...ActorBuilder ab;string builderType = ConfigurationManager.AppSettings["builder"];ab = (ActorBuilder)Assembly.Load("BuildExtend").CreateInstance(builderType);Actor actor;actor = ab.Construct();... 此时，Construct()方法定义了BuildPartX()方法的调用次序，为BuildPartX()方法的执行提供了一个流程模板，这与后面将要学习的模板方法模式非常类似。 以上两种对Director类的省略方式都不影响系统的灵活性和可扩展性，同时还简化了系统结构，但加重了抽象建造者类的职责。如果Construct()方法较为复杂，待构建产品的组成部分较多，建议将Construct()方法单独封装在Director中，这样更符合单一职责原则。 2.钩子方法的引入 建造者模式除了逐步构建一个复杂产品对象外，还可以通过Director类来更加精细地控制产品的创建过程，例如增加一类称为钩子方法（Hook Method）的特殊方法来控制是否调用某个BuildPartX()方法。 钩子方法的返回类型通常为bool类型，方法名一般为IsXXX()，钩子方法定义在抽象建造者类中。例如可以在游戏角色的抽象建造者类ActorBuilder中定义一个方法IsBareheaded()，用于判断某个角色是否为“光头（Bareheaded）”，在ActorBuilder中为之提供一个默认实现，其返回值为false，代码如下：123456789101112131415161718192021abstract class ActorBuilder&#123; protected Actor actor = new Actor(); public abstract void BuildType(); public abstract void BuildSex(); public abstract void BuildFace(); public abstract void BuildCostume(); public abstract void BuildHairstyle(); // 钩子方法，需要使用virtual关键字 public virtual bool IsBareheaded() &#123; return false; &#125; public Actor CreateActor() &#123; return actor; &#125;&#125; 如果某个角色无须构建头发部件，例如“恶魔（Devil）”，则对应的具体建造者DevilBuilder将覆盖IsBareheaded()方法，并将返回值改为true，代码如下：123456789101112131415161718192021222324252627282930313233class DevilBuilder : ActorBuilder&#123; public override void BuildType() &#123; actor.Type = "恶魔"; &#125; public override void BuildSex() &#123; actor.Sex = "妖"; &#125; public override void BuildFace() &#123; actor.Face = "丑陋"; &#125; public override void BuildCostume() &#123; actor.Costume = "黑衣"; &#125; public override void BuildHairstyle() &#123; actor.Hairstyle = "光头"; &#125; // 覆盖钩子方法 public override bool IsBareheaded() &#123; return true; &#125; &#125; 同时，指挥者类ActorController的代码修改如下：123456789101112131415161718192021class ActorController&#123; // 逐步构建复杂产品对象 public Actor Construct(ActorBuilder ab) &#123; Actor actor; ab.BuildType(); ab.BuildSex(); ab.BuildFace(); ab.BuildCostume(); // 通过钩子方法来控制产品的构建 if (!ab.IsBareheaded()) &#123; ab.BuildHairstyle(); &#125; actor = ab.CreateActor(); return actor; &#125;&#125; 当在客户端代码中指定具体建造者类型并通过指挥者来实现产品的逐步构建时，将调用钩子方法IsBareheaded()来判断游戏角色是否有头发，如果IsBareheaded()方法返回true，即没有头发，将跳过构建发型的方法BuildHairstyle()，否则执行BuildHairstyle()方法。通过引入钩子方法，可以在Director中对复杂产品的构建进行精细的控制，不仅指定BuildPartX()方法的执行顺序，还可以控制是否需要执行某个BuildPartX()方法。 建造者模式的优缺点与适用环境建造者模式的核心在于如何逐步构建一个包含多个组成部件的完整对象，使用相同的构建过程构建不同的产品。在软件开发中，如果需要创建复杂对象并希望系统具备很好的灵活性和可扩展性，可以考虑使用建造者模式。 建造者模式的优点建造者模式的主要优点如下： (1)在建造者模式中，客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。 (2)每一个具体建造者都相对独立，与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，用户使用不同的具体建造者即可得到不同的产品对象。由于指挥者类针对抽象建造者编程，增加新的具体建造者无须修改原有类库的代码，系统扩展方便，符合开闭原则。 (3)用户可以更加精细地控制产品的创建过程，将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。 建造者模式的缺点建造者模式的主要缺点如下： (1)建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，例如很多组成部分不相同，则不适合使用建造者模式，因此其使用范围受到一定的限制。 (2)如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本。 建造者模式的适用环境在以下情况下可以考虑使用建造者模式： (1)需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量。 (2)需要生成的产品对象的属性相互依赖，需要指定其生成顺序。 (3)对象的创建过程独立于创建该对象的类。在建造者模式中通过引入指挥者类，将创建过程封装在指挥者类中，而不在建造者类和客户类中。 (4)隔离复杂对象的创建和使用，并使得相同的创建过程创建不同的产品。 本章小结(1)建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一种对象创建型模式。 (2)建造者模式包含抽象建造者、具体建造者、产品和指挥者4个角色。其中，抽象建造者为创建一个产品对象的各个部件声明抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，还可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，在其Construct()建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造 (3)在建造者模式中引入了一个指挥者角色，它主要有两个作用：一方面可以隔离客户端与创建过程；另一方面可以控制产品对象的创建过程。 (4)建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象；可以很方便地替换具体建造者或增加新的具体建造者；还可以更加精细地控制产品的创建过程。其主要缺在于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，并不适合使用建造者模式；此外，如果产品的内部变化复杂，可能会需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大，增加了系统的理解难度和运行成本。 (5)建造者模式适用的环境:需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员变量；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使相同的创建过程可以创建不同的产品。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[抽象工厂模式]]></title>
    <url>%2F2019%2F09%2F17%2F%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F-1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么系统中会存在大量的工厂类？可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产。怎么理解？ 产品等级结构即产品的继承结构是什么意思？ 产品族又是什么？ 一个工厂产生多个类，这些类都有不同的抽象父类。怎么理解？ 抽象工厂模式与工厂方法模式最大的区别是什么？ 本章导学 抽象工厂模式是常用的创建型设计模式之一，它比工厂方法模式的抽象程度更高。在工厂方法模式中，每一个具体工厂只需要生产一种具体产品，但是在抽象工厂模式中，一个具体工厂可以生产一组相关的具体产品，这样的一组产品称为产品族，产品族中的每一个产品都分属于某一个产品继承等级结构。 本章将通过实例来学习抽象工厂模式，分析抽象工厂模式的结构及特点，并学习如何在实际软件项目开发中合理地使用抽象工厂模式。 本章知识点 产品等级结构与产品族 抽象工厂模式的定义 抽象工厂模式的结构 抽象工厂模式的实现 抽象工厂模式的应用 抽象工厂模式的优缺点 抽象工厂模式的适用环境 开闭原则的倾斜性 产品等级结构与产品族工厂方法模式通过引入工厂等级结构，解决了简单工厂模式中工厂类职责太重的问题，但由于工厂方法模式中的每个具体工厂只有一个或者一组重载的工厂方法，只能生产一种产品，可能会导致系统中存在大量的工厂类，势必会增加系统的开销。有时可能需要一个工厂能够提供多种产品对象，而不是单一的产品对象，例如一个电器工厂，它可以生产电视机、电冰箱、空调等多种电器，而不是只生产某一种电器。此时，可以考虑将一些相关的产品组成一个“产品族”，由同一个工厂来统一生产，这就是本章将要学习的抽象工厂模式的基本思想。 为了更好地理解抽象工厂模式，先引入以下两个概念。 (1)产品等级结构：产品等级结构即产品的继承结构，例如一个抽象类是电视机，其子类包括海尔电视机、海信电视机、TCL电视机，则抽象电视机与具体品牌的电视机之间构成了一个产品等级结构，抽象电视机是父类，而具体品牌的电视机是其子类。 (2)产品族：在抽象工厂模式中，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。例如海尔电器工厂生产的海尔电视机、海尔电冰箱，海尔电视机位于电视机产品等级结构中，海尔电冰箱位于电冰箱产品等级结构中，海尔电视机、海尔电冰箱构成了一个产品族。 产品等级结构与产品族示意图如图1所示。 图1 产品等级结构与产品族示意图 在图1中，不同颜色的多个正方形、圆形和椭圆形分别构成了3个不同的产品等级结构，而相同颜色的正方形、圆形和椭圆形构成了一个产品族，每一个形状对象都位于某个产品族，并属于某个产品等级结构。在图1中共有5个产品族，分属于3个不同的产品等级结构，只要指明一个产品所处的产品族以及它所属的等级结构，就可以唯一地确定这个产品。 抽象工厂模式概述当系统所提供的工厂生产的具体产品并不是一个简单的对象，而是多个位于不同产品等级结构、属于不同类型的具体产品时就可以使用抽象工厂模式。 抽象工厂模式是所有形式的工厂模式中最为抽象和最具一般性的一种形式。抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对的是一个产品等级结构，而抽象工厂模式需要面对多个产品等级结构，一个工厂等级结构可以负责多个不同产品等级结构中的产品对象的创建。当一个工厂等级结构可以创建出分属于不同产品等级结构的一个产品类中的所有对象时，抽象工厂模式比工厂方法模式更为简单、更有效率。抽象工厂模式示意图如图2所示。 图2 抽象工厂模式示意图 在图2中，每一个具体工厂可以生产属于一个产品族的所有产品，例如生产颜色相同的正方形、圆形和椭圆形，所生产的产品又位于不同的产品等级结构中。如果使用工厂方法模式，图2所示的结构需要提供15个具体工厂，而使用抽象工厂模式只需要提供5个具体工厂，极大地减少了系统中类的个数。 抽象工厂模式为创建一组对象提供了一种解决方案。与工厂方法模式相比，抽象工厂模式中的具体工厂不只是创建一种产品，而是负责创建一族产品。 抽象工厂模式的定义如下：1提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 抽象工厂模式又称为工具（Kit）模式，它是一种对象创建型模式。 抽象工厂模式的结构与实现抽象工厂模式的结构在抽象工厂模式中，每一个具体工厂都提供了多个工厂方法用于产生多种不同类型的产品，这些产品构成了一个产品族。抽象工厂模式的结构如图3所示。 图3 抽象工厂模式结构图 由图3可知，抽象工厂模式包含以下4个角色。 (1)AbstractFactory（抽象工厂）：它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。 (2)ConcreteFactory（具体工厂）：它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。 (3)AbstractProduct（抽象产品）：它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。 (4)ConereteProduct（具体产品）：它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。 抽象工厂模式的实现在抽象工厂中声明了多个工厂方法，用于创建不同类型的产品，抽象工厂可以是接口，也可以是抽象类或者具体类。其典型代码如下：123456abstract class AbstractFactory&#123; public abstract AbstractProductA CreateProductA(); // 工厂方法一 public abstract AbstractProductB CreateProductB(); // エ厂方法二 ...&#125; 具体工厂实现了抽象工厂，每一个具体的工厂方法创建一个特定的产品对象，而同一个具体工厂所创建的产品对象构成了一个产品族。对于每一个具体工厂类，其典型代码如下：123456789101112131415class ConcreteFactory1 : AbstractFactory&#123; // 工厂方法1 public override AbstractProductA CreateProductA() &#123; return new ConcreteProductA1(); &#125; // 工厂方法2 public override AbstractProductB CreateProductB() &#123; return new ConcreteProductB1(); &#125; ...&#125; 与工厂方法模式一样，抽象工厂模式也可为每一种产品提供一组重载的工厂方法，以不同的方式来创建产品对象。 抽象工厂模式的应用实例下面通过一个应用实例来进一步学习和理解抽象工厂模式。 1.实例说明 某软件公司要开发一套界面皮肤库，可以对基于.NET平台的桌面软件进行界面美化。用户在使用时可以通过菜单来选择皮肤，不同的皮肤将提供视觉效果不同的按钮、文本框、组合框等界面元素，例如春天（Spring）风格的皮肤将提供浅绿色的按钮、绿色边框的文本框和绿色边框的组合框，而夏天（Summer）风格的皮肤则提供浅蓝色的按钮、蓝色边框的文本框和蓝色边框的组合框，其结构示意图如图4所示。该皮肤库需要具备良好的灵活性与可扩展性，用户可以自由选择不同的皮肤，开发人员可以在不修改既有代码的基础上增加新的皮肤。现使用抽象工厂模式来设计该界面皮肤库。 图4 界面皮肤库结构示意图 2.实例类图 通过分析，本实例的结构如图5所示。 图5 界面皮肤库结构图 在图5中，SkinFactory接口充当抽象工厂，其子类SpringSkinFactory和SurmerSkinFactory充当具体工厂，接口Button、TextField和ComboBox充当抽象产品，其子类SpringButton、SpringTextField、SpringComboBox和SummerButton、SummerTextField、SummerComboBox充当具体产品。 3.实例代码 (1) Button：按钮接口，充当抽象产品。 Button.cs 1234567namespace AbstractFactorySample&#123; interface Button &#123; void Display(); &#125;&#125; (2)SpringButton：Spring按钮类，充当具体产品。 SpringButton.cs 123456789101112using System;namespace AbstractFactorySample&#123; class SpringButton : Button &#123; public void Display() &#123; Console.WriteLine("显示浅绿色按钮。"); &#125; &#125;&#125; (3)SummerButton：Summer按钮类，充当具体产品。 SummerButton.cs 123456789101112using System;namespace AbstractFactorySample&#123; class SummerButton : Button &#123; public void Display() &#123; Console.WriteLine("显示浅蓝色按钮。"); &#125; &#125;&#125; (4)TextField：文本框接口，充当抽象产品。 TextField.cs 1234567namespace AbstractFactorySample&#123; interface TextField &#123; void Display(); &#125;&#125; (5)SpringTextField：Spring文本框，充当具体产品。 SpringTextField.cs 123456789101112using System;namespace AbstractFactorySample&#123; class SpringTextField : TextField &#123; public void Display() &#123; Console.WriteLine("显示绿色边框文本框。"); &#125; &#125;&#125; (6)SummerTextField：Summer文本框类，充当具体产品。 SummerTextField.cs 123456789101112using System;namespace AbstractFactorySample&#123; class SummerTextField : TextField &#123; public void Display() &#123; Console.WriteLine("显示蓝色边框文本框。"); &#125; &#125;&#125; (7)ComboBox：组合框接口，充当抽象产品。 ComboBox.cs 1234567namespace AbstractFactorySample&#123; interface ComboBox &#123; void Display(); &#125;&#125; (8)SpringComboBox：Spring组合框类，充当具体产品。 SpringComboBox.cs 123456789101112using System;namespace AbstractFactorySample&#123; class SpringComboBox : ComboBox &#123; public void Display() &#123; Console.WriteLine("显示绿色边框组合框。"); &#125; &#125;&#125; (9)SummerComboBox：Summer组合框类，充当具体产品。 SummerComboBox.cs 123456789101112using System;namespace AbstractFactorySample&#123; class SummerComboBox : ComboBox &#123; public void Display() &#123; Console.WriteLine("显示蓝色边框组合框。"); &#125; &#125;&#125; (10)SkinFactory：界面皮肤工厂接口，充当抽象工厂。 SkinFactory.cs 123456789namespace AbstractFactorySample&#123; interface SkinFactory &#123; Button CreateButton(); TextField CreateTextField(); ComboBox CreateComboBox(); &#125;&#125; (11)SpringSkinFactory：Spring皮肤工厂，充当具体工厂。 SpringSkinFactory.cs 1234567891011121314151617181920namespace AbstractFactorySample&#123; class SpringSkinFactory : SkinFactory &#123; public Button CreateButton() &#123; return new SpringButton(); &#125; public TextField CreateTextField() &#123; return new SpringTextField(); &#125; public ComboBox CreateComboBox() &#123; return new SpringComboBox(); &#125; &#125;&#125; (12)SummerSkinFactory：Summer皮肤工厂，充当具体工厂。 SummerSkinFactory.cs 1234567891011121314151617181920namespace AbstractFactorySample&#123; class SummerSkinFactory : SkinFactory &#123; public Button CreateButton() &#123; return new SummerButton(); &#125; public TextField CreateTextField() &#123; return new SummerTextField(); &#125; public ComboBox CreateComboBox() &#123; return new SummerComboBox(); &#125; &#125;&#125; (13)配置文件App.config：在配置文件中存储了具体工厂类类名。 App.config 123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="factory" value="AbstractFactorySample.SpringSkinFactory"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; (14)Program：客户端测试类。 Program.cs 123456789101112131415161718192021222324252627282930313233using System;using System.Configuration;using System.Reflection;namespace AbstractFactorySample&#123; class Program &#123; static void Main(string[] args) &#123; // 使用抽象层定义 SkinFactory factory; Button bt; TextField tf; ComboBox cb; // 读取配置文件 string factoryType = ConfigurationManager.AppSettings["factory"]; // 反射生成对象 factory = (SkinFactory)Assembly.Load("AbstractFactorySample").CreateInstance(factoryType); bt = factory.CreateButton(); tf = factory.CreateTextField(); cb = factory.CreateComboBox(); bt.Display(); tf.Display(); cb.Display(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下:123显示浅绿色的按钮。 显示绿色边框的文本框 显示绿色边框的组合框。 如果需要更换皮肤，只需修改配置文件即可，例如将春天风格的皮肤改为夏天风格的皮肤，只需将存储在配置文件中的具体工厂类SpringSkinFactory改为SummerSkinFactory即可，代码如下:123456&lt;?xml version = "1.0" encoding = "utf-8" ?&gt; &lt;configuration &gt; &lt;appSettings&gt; &lt;add key = "factory" value ="AbstractFactorySample. SummerSkinFactory"/ &gt; &lt;/appSettings &gt; &lt;/configuration &gt; 重新运行客户端程序，输出结果如下:123显示浅蓝色的按钮。 显示蓝色边框的文本框 显示蓝色边框的组合框。 在实际环境中，可以提供一个可视化界面，例如菜单或者窗口来修改配置文件，用户须直接修改配置文件。如果需要增加新的皮肤，只需增加一族新的具体组件并对应提供一个新的具体工厂，修改配置文件中的具体工厂类的类名即可使用新的皮肤，原有代码无须修改，符合开闭原则。 开闭原则的倾斜性在上一节设计的界面皮肤库中可以较为方便地增加新类型的皮肤，但是该设计方案存在一个非常严重的问题：如果在设计之初因为考虑不全面，忘记为某种类型的界面组件（以单选按钮RadioButton为例）提供不同皮肤下的风格化显示，那么在向系统中增加单选按钮时将非常麻烦，无法在满足开闭原则的前提下增加单选按钮，原因是抽象工厂SkinFactory中根本没有提供创建单选按钮的方法，如果需要增加单选按钮，首先要修改抽象工厂接口SkinFactory，在其中增加声明创建单选按钮的方法，然后逐个修改具体工厂类，增加相应方法，以便在不同的皮肤库中创建单选按钮，此外还需要修改客户端，否则单选按钮无法应用于现有系统。 抽象工厂模式无法很好地解决此类问题，这也是抽象工厂模式的最大缺点所在。在抽象工厂模式中，增加新的产品族很方便，但是增加新的产品等级结构很麻烦，抽象工厂模式的这种特性称为开闭原则的倾斜性。开闭原则要求系统对扩展开放，对修改关闭，通过扩展达到增强其功能的目的，对于涉及多个产品族与多个产品等级结构的系统，其功能增强包括以下两个方面。 (1)增加产品族：对于增加新的产品族，抽象工厂模式很好地支持了开闭原则，只需增加具体产品并对应增加一个新的具体工厂即可，对已有代码无须做任何修改。 (2)增加新的产品等级结构：对于增加新的产品等级结构，需要修改所有的工厂角色的方法违背了开闭原则。 正因为抽象工厂模式存在开闭原则的倾斜性，它以一种倾斜的方式来满足开闭原则，为增加新产品族提供方便，但不能为增加新产品结构提供这样的方便，因此要求设计人员在设计之初就要全面考虑，不要在设计完成之后再向系统中增加新的产品等级结构，也不要删除已有的产品等级结构，否则将会导致系统出现较大的修改，为后续的维护工作带来诸多麻烦。 抽象工厂模式的优缺点与适用环境抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和API类库的设计中。抽象工厂模式是软件开发中最常用的设计模式之一。 抽象工厂模式的优点抽象工厂模式的主要优点如下: (1)抽象工厂模式隔离了具体类的生成，使得客户端并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。 (2)当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。 (3)抽象工厂模式增加新的产品族很方便，无须修改已有系统，符合开闭原则。 抽象工厂模式的缺点抽象工厂模式的主要缺点如下: 增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了开闭原则。 抽象工厂模式的适用环境在以下情况下可以考虑使用抽象工厂模式: (1)一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。 (2)系统中有多于一个的产品族，但每次只使用其中某一产品族，可以通过配置文件等方式使用户能够动态地改变产品族，也可以很方便地增加新的产品族。 (3)属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。 (4)产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构. 本章小结(1)在抽象工厂模式中，产品等级结构即产品的继承结构，产品族是指由同一个工厂生产的，位于不同产品等级结构中的一组产品。 (2)抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，开发人员无须指定具体的类。抽象工厂模式是一种对象创建型模式。 (3)抽象工厂模式包含抽象工厂、具体工厂、抽象产品和具体产品4个角色。其中，抽象工厂声明了一组用于创建一族产品的方法，每一个方法对应一种产品；具体工厂实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中；抽象产品为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法；具体产品定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。 (4)抽象工厂模式的主要优点是隔离了具体类的生成，使得客户端不需要知道什么被创建；当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象；增加新的产品族很方便，无须修改已有系统，符合开闭原则。其主要缺点是增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，违背了开闭原则。 (5)抽象工厂模式适用的环境：一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节；系统中有多于一个的产品族，但每次只使用其中某一产品族；属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来；产品等级结构稳定，在设计完成后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。 (6)抽象工厂模式以一种倾斜的方式来满足开闭原则。对于增加新的产品族，抽象工厂模式很好地支持了开闭原则；对于增加新的产品等级结构，需要修改所有的工厂角色，违背了开闭原则。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工厂方法模式]]></title>
    <url>%2F2019%2F09%2F17%2F%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 工厂方法模式比简单工厂优势在哪里？ 本章导学 工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的缺陷，能更好地符合开闭原则的要求，在增加新的具体产品对象时不需要对已有系统做任何修改。 本章将通过克服简单工厂模式的不足来引出工厂方法模式，并通过实例来学习工厂方法模式，理解工厂方法模式的结构及特点，学习如何在实际软件项目开发中合理地使用工厂方法模式。 本章知识点 工厂方法模式的定义 工厂方法模式的结构 工厂方法模式的实现 工厂方法模式的应用 工厂方法模式的优缺点 工厂方法模式的适用环境 配置文件与反射 工厂方法的重载 工厂方法的隐藏 工厂方法模式概述考虑这样一个系统，使用简单工厂模式设计的按钮工厂类可以返回一个具体类型的按钮实例，例如矩形按钮、圆形按钮、菱形按钮等。在这个系统中，如果需要增加一种新类型的按钮，例如椭圆形按钮，那么除了增加一个新的具体产品类之外，还需要修改工厂类的代码就使得整个设计在一定程度上违背了开闭原则，如图1所示。 图1 使用简单工厂模式设计的按钮工厂 下面对该系统进行修改，不再提供一个按钮工厂类来统一负责所有产品的创建，而是将具体按钮的创建过程交给专门的工厂子类去完成。先定义一个抽象的按钮工厂类，再定义具体的工厂类来生产矩形按钮、圆形按钮、菱形按钮等，它们实现了在抽象按钮工厂类中声明的方法。这种抽象化的结果是使这种结构可以在不修改具体工厂类的情况下引进新的产品，如果出现新的按钮类型，只需要为这种新类型的按钮定义一个具体的工厂类就可以创建该新按钮的实例，这种改进的设计方案即为工厂方法模式。工厂方法模式通过引入抽象的工厂类，使得它具有超越简单工厂模式的优越性，让系统更加符合开闭原则，改进后的按钮工厂如图2所示。 图2 使用工厂方法模式改进后的按钮工厂 在工厂方法模式中，不再提供一个统一的工厂类来创建所有的产品对象，而是针对不同的产品提供不同的工厂，系统提供了一个与产品等级结构对应的工厂等级结构。 工厂方法模式的定义如下：1定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。 工厂方法模式简称为工厂模式（Factory Pattern），又可称为虚拟构造器模式（Virtual Constructor Pattern）或多态工厂模式（Polymorphic Factory Pattern），工厂方法模式是一种类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。 工厂方法模式的结构与实现工厂方法模式的结构工厂方法模式提供一个抽象工厂接口来声明抽象工厂方法，而由其子类来具体实现工厂方法，创建具体的产品对象。工厂方法模式的结构如图3所示。 图3 工厂方法模式结构图 由图3可知，工厂方法模式包含以下4个角色。 (1)Product（抽象产品）：它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。(2)ConcreteProduct（具体产品）：它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。(3)Factory（抽象工厂）：在抽象工厂类中，声明了工厂方法（Factory Method），用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。(4)ConcreteFactory（具体工厂）：它是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，由客户端调用，返回一个具体产品类的实例。 工厂方法模式的实现与简单工厂模式相比，工厂方法模式最重要的特点是引入了抽象工厂角色，抽象工厂可以是接口，也可以是抽象类或者具体类。其典型代码如下:1234interface Factory&#123; Product FactoryMethod();&#125; 在抽象工厂中声明了工厂方法但并未实现工厂方法，具体产品对象的创建由其子类负责，客户端针对抽象工厂编程，可在运行时指定具体工厂类，具体工厂类实现了工厂方法，不同的具体工厂可以创建不同的具体产品。其典型代码如下：1234567class ConcreteFactory : Factory &#123; public Product FactoryMethod() &#123; return new ConcreteProduct(); &#125;&#125; 在实际使用时，具体工厂类在实现工厂方法时除了创建具体产品对象之外，还可以负责产品对象的初始化工作以及一些资源和环境配置工作，例如连接数据库、创建文件等。 在客户端代码中，开发人员只需关心工厂类即可，不同的具体工厂可以创建不同的产品。典型的客户端代码片段如下：123456...Factory factory;factory = new ConcreteFactory(); // 可通过配置文件实现Product product;product = factory.FactoryMethod();... 开发人员可以通过配置文件来存储具体工厂类ConcreteFactory的类名，更换新的具体工厂时无须修改源代码，系统扩展更为方便。 工厂方法模式的应用实例下面通过一个应用实例来进一步学习和理解工厂方法模式。 1.实例说明 某系统运行日志记录器（Logger）可以通过多种途径保存系统的运行日志，例如通过文件记录或数据库记录，用户可以通过修改配置文件灵活地更换日志记录方式。在设计各类日志记录器时，开发人员发现需要对日志记录器进行一些初始化工作，初始化参数的设置过程较为复杂，而且某些参数的设置有严格的先后次序，否则可能会发生记录失败。为了更好地封装记录器的初始化过程并保证多种记录器切换的灵活性，现使用工厂方法模式设计该系统(在.NET平台下常用的日志记录工具有Log4net，NLog等，.NETFramework也提供了一些用于记日志的类，例如Debug.Trace、TraceSource等)。 2.实例类图 通过分析，本实例的结构如图4所示。 图4 日志记录器结构图 在图4中，Logger接口充当抽象产品，其子类FileLogger和DatabaseLogger充当具体产品，LoggerFactory接口充当抽象工厂，其子类FileLoggerFactory和DatabaseLoggerFactory充当具体工厂。 3.实例代码 (1)Logger：日志记录器接口，充当抽象产品角色。 1234567namespace FactoryMethodSample&#123; interface Logger &#123; void WriteLog(); &#125;&#125; (2)DatabaseLogger：数据库日志记录器，充当具体产品角色。 123456789101112using System;namespace FactoryMethodSample&#123; class DatabaseLogger : Logger &#123; public void WriteLog() &#123; Console.WriteLine("数据库日志记录。"); &#125; &#125;&#125; (3)FileLogger：文件日志记录器，充当具体产品角色。 123456789101112using System;namespace FactoryMethodSample&#123; class FileLogger : Logger &#123; public void WriteLog() &#123; Console.WriteLine("文件日志记录。"); &#125; &#125;&#125; (4)LoggerFactory：日志记录器工厂接口，充当抽象工厂角色。 1234567namespace FactoryMethodSample&#123; interface LoggerFactory &#123; Logger CreateLogger(); &#125;&#125; (5)DatabaseLoggerFactory：数据库日志记录器工厂类，充当具体工厂角色。 1234567891011121314namespace FactoryMethodSample&#123; class DatabaseLoggerFactory : LoggerFactory &#123; public Logger CreateLogger() &#123; // 连接数据库，代码省略 // 创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); // 初始化数据库日志记录器，代码省略 return logger; &#125; &#125;&#125; (6)FileLoggerFactory：文件日志记录器工厂类，充当具体工厂角色。 12345678910111213namespace FactoryMethodSample&#123; class FileLoggerFactory : LoggerFactory &#123; public Logger CreateLogger() &#123; // 创建文件日志记录器对象 Logger logger = new FileLogger(); // 创建文件，代码省略 return logger; &#125; &#125;&#125; (7)Program：客户端测试类。 12345678910111213141516171819using System;using System.Configuration;namespace FactoryMethodSample&#123; class Program &#123; static void Main(string[] args) &#123; LoggerFactory factory; Logger logger; factory = new FileLoggerFactory(); // 可引入配置文件实现 logger = factory.CreateLogger(); logger.WriteLog(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：1文件日志记录。 如果需要更换日志记录器，只需修改客户端代码中的具体工厂类类名即可。例如将FileL.oggerFactory改为DatabaseLoggerFactory，则输出结果如下：1数据库日志记录。 如果需要增加并使用新的日志记录器，只需要对应增加一个新的具体工厂类，再在客户端代码中修改具体工厂类类名，原有类库的源代码无须做任何修改。 通过引入配置文件并使用反射机制，可以实现在不修改客户端代码的基础上更换具体工厂类，在下一节将详细说明其实现过程，让系统更加符合开闭原则，具备更好的灵活性和可扩展性。 配置文件与反射在上节中的日志记录器实例中，在更换日志记录器时需要修改客户端代码，对于客户端而言并不符合开闭原则，本节将介绍如何在不修改任何客户端代码的基础上更换或增加新的日志记录方式。 在实际应用开发中，可以对具体工厂类的实例化过程进行改进，在客户端代码中不直接使用new关键字来创建工厂对象，而是将具体工厂类的类名存储在配置文件（例如XML文件）中，再通过程序集的反射机制，读取配置文件中存储的类名字符串生成对象。 例如将上一节的具体日志记录器工厂类类名FileLoggerFactory，存储在以下XML格式的文档中：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="factory" value="FactoryMethodSample.FileLoggerFactory"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 在该文件中，FactoryMethodSample为工厂类所在命名空间的名称，FilelLoggerFactory为具体工厂类类名。在.NET中，配置文件一般以config作为扩展名，例如App.config、Web.config等。 下面对.NET反射机制做一个简单的介绍： 反射（Reflection）是.NET的重要机制之一，通过反射，可以在运行时获得.NET中每一个类型（包括类、结构、委托、接口和枚举等）的成员，包括方法、属性、事件，以及构造函数等，还可以获得每个成员的名称、限定符和参数等。由于获取了构造函数的信息，因此可以通过类名来直接创建对象，即使这个对象的类型在编译时是未知的。 由于在.NET的程序集（Assembly）中封装了类型元数据信息，因此可以先通过Assembly的Load(“程序集名称”)方法加载一个程序集，再通过其CreateInstance(“命名空间.类”)方法根据类名创建一个object类型的对象，用户可以根据需要将其转换为所需类型。示意代码如下：1234// 导入命令空间using System.Reflection;object obj = Assembly.Load("程序集名称").CreateInstance("命名空间.类"); 在上述代码中，“命名空间.类”可以存储在配置文件中，使用ConfigurationManager类的AppSettings属性可以获取存储在配置文件中的类名字符串。 引入配置文件和反射机制后，在客户端测试代码中，无须直接使用new关键字来创建具体的工厂类，而是将具体工厂类的类名放在配置文件中，再通过读取配置文件和反射机制来动态创建对象。客户端代码修改如下:1234567891011121314151617181920212223using System;using System.Configuration;using System.Reflection;namespace FactoryMethodSample&#123; class Program &#123; static void Main(string[] args) &#123; LoggerFactory factory; // 针对抽象工厂类编程 Logger logger; // 针对抽象产品类编程 // 读取配置文件 string factoryString = ConfigurationManager.AppSettings["factory"]; // 反射生成对象 factory = (LoggerFactory)Assembly.Load("FactoryMethodSample").CreateInstance(factoryString); logger = factory.CreateLogger(); logger.WriteLog(); Console.Read(); &#125; &#125;&#125; 需要注意的是，在使用配置文件和反射机制生成对象时，首先需要导入System.Configuration和System.Reflection两个命名空间，否则无法使用ConfigurationManager类来读取配置文件，也无法使用Assembly类来反射创建对象；其次，在客户端代码中要遵循依赖倒转原则、针对抽象工厂和抽象产品编程，否则无法保证系统的可扩展性。 在引入配置文件和反射机制后，如果需要增加一种新类型的日志记录方式，只需以下4个步骤： (1)新的日志记录器类需要继承抽象日志器类Logger。 (2)增加一个新的具体日志记录器工厂，继承抽象日志记录器工厂类LoggerFactory，并实现其中的工厂方法CreateLogger()，返回具体的日志记录器对象。 (3)修改配置文件App.config，以新增的具体日志记录器工厂类的类名字符串替换原有工厂类的类名字符串。 (4)编译新增的具体日志记录器类和具体日志记录器工厂类，运行客户端测试类即可使用新的日志记录方式，而原有类库代码无须做任何修改，完全符合开闭原则。 通过上述重构可以使系统更加灵活，由于很多设计模式都关注系统的可扩展性和灵活性，因此都定义了抽象层，在抽象层中声明业务方法，而将具体业务方法的实现放在实现层中。为了更好地体现这些设计模式的特点，本书在很多设计模式中都使用配置文件和反射机制来创建对象。 工厂方法的重载在某些情况下，可以通过多种方式来初始化同一个产品类。例如4.3节所提到的日志记录器类，可以为各种日志记录器提供默认实现；还可以为数据库日志记录器提供数据库连接字符串，为文件日志记录器提供文件路径；也可以将相关参数封装在一个object类型的对象中，通过object对象将配置参数传入工厂类。此时，可以提供一组重载的工厂方法，以不同的方式对产品对象进行创建。当然，对于同一个具体工厂而言，无论使用哪种工厂方法，所创建的产品类型均要相同。图5所示为重载的工厂方法结构图。 图5 重载的工厂方法结构图 引入重载方法后，抽象工厂类LoggerFactory的代码修改如下：123456interface LoggerFactory&#123; Logger CreateLogger(); Logger CreateLogger(string args); Logger CreateLogger(object obj);&#125; 具体工厂类DatabaseLoggerFactory的代码修改如下：1234567891011121314151617181920212223242526272829class DatabaseLoggerFactory : LoggerFactory &#123; public Logger CreateLogger() &#123; //连接数据库，代码省略 //创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); //初始化数据库日志记录器，代码省略 return logger; &#125; public Logger CreateLogger(string args) &#123; //连接数据库，代码省略 //创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); //初始化数据库日志记录器，代码省略 return logger; &#125; public Logger CreateLogger(object obj) &#123; //连接数据库，代码省略 //创建数据库日志记录器对象 Logger logger = new DatabaseLogger(); //初始化数据库日志记录器，代码省略 return logger; &#125; &#125; 在抽象工厂中声明了多个重载的工厂方法，在具体工厂中实现了这些工厂方法，这些方法可以包含不同的业务逻辑，以满足产品对象的多样化创建需求。 工厂方法的隐藏有时为了进一步简化客户端的使用，还可以对客户端隐藏工厂方法，此时，在工厂类中直接调用产品类的业务方法，在客户端无须调用工厂方法创建产品对象，直接使用工厂对象即可调用所创建的产品对象中的业务方法。 如果对客户端隐藏工厂方法，那么图4所示的日志记录器的结构图可修改为图6所示。 图6 隐藏工厂方法的日志记录器结构图 在图6中，抽象工厂类LoggerFactory的代码修改如下：123456789101112// 将接口改为抽象类abstract class LoggerFactory&#123; // 在工厂类中直接调用日志记录器类的业务方法WriteLog() public void WriteLog() &#123; Logger logger = this.CreateLogger(); logger.WriteLog(); &#125; public abstract Logger CreateLogger();&#125; 客户端代码修改如下：12345678910111213141516171819202122using System;using System.Configuration;using System.Reflection;namespace FactoryMethodSample&#123; class Program &#123; static void Main(string[] args) &#123; LoggerFactory factory; // 针对抽象工厂类编程 // 读取配置文件 string factoryString = ConfigurationManager.AppSettings["factory"]; // 反射生成对象 factory = (LoggerFactory)Assembly.Load("FactoryMethodSample").CreateInstance(factoryString); factory.WriteLog(); // 直接使用工厂对象来调用产品对象的业务方法 Console.Read(); &#125; &#125;&#125; 通过把业务方法的调用移至工厂类中，可以直接使用工厂对象来调用产品对象的业务方法，客户端无须再直接使用工厂方法来创建产品对象。在某些情况下也可以使用这种设计方案。 工厂方法模式的优缺点与适用环境工厂方法模式是简单工厂模式的延伸，它继承了简单工厂模式的优点，同时还弥补了简单工厂模式的不足。工厂方法模式是使用频率最高的设计模式之一，是很多开源框架和API的核心模式。 工厂方法模式的优点工厂方法模式的主要优点如下： (1)在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂即可，无须关心创建细节，甚至无须知道具体产品类的类名。 (2)基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以被称为多态工厂模式，就是因为所有的具体工厂类都具有同一抽象父类。 (3)使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品即可，这样，系统的可扩展性也就变得非常好，完全符合开闭原则。 工厂方法模式的缺点工厂方法模式的主要缺点如下： (1)在添加新产品时，需要编写新的具体产品类，而且要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。 (2)由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度。 工厂方法模式的适用环境以下情况下可以考虑使用工厂方法模式： (1)客户端不知道它所需要的对象的类。在工厂方法模式中，客户端不需要知道具体产品类的类名，只需知道所对应的工厂即可，具体产品对象由具体工厂类创建，可将具体工一类的类名存储在配置文件或数据库中。 (2)抽象工厂类通过其于类来指定创建哪个对象。在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使系统更容易扩展。 本章小结(1)在工厂方法模式中，定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类，它是一种类创建型模式。 (2)工厂方法模式包含抽象产品、具体产品、抽象工厂和具体工厂4个角色。其中，抽象产品是定义产品的接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建；抽象工厂声明了工厂方法，用于返回一个产品；具体工厂是抽象工厂类的子类，实现了在抽象工厂中声明的工厂方法，返回一个具体产品类的实例。 (3)工厂方法模式的主要优点是提供了专门的工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节；能够让工厂自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部；在系统中加入新产品时，完全符合开闭原则。其主要缺点是系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，会给系统带来一些额外的开销；增加了系统的抽象性和理解难度。 (4)工厂方法模式适用的环境：客户端不知道它所需要的对象的类；抽象工厂类通过其子类来指定创建哪个对象。 (5)通过引入配置文件和反射机制，将具体工厂类类名存储在配置文件中，然后使用反射机制生成工厂对象，使得系统可以在不修改任何已有代码的基础上增加新的产品类，完全符合开闭原则。 (6)在抽象工厂中可以声明多个重载的工厂方法，在具体工厂中实现了这些工厂方法，这些方法可以包含不同的业务逻辑，以满足产品对象的多样化创建需求。 (7)在工厂类中可以直接调用产品类的业务方法，客户端无须调用工厂方法创建产品对象，直接使用工厂对象即可调用所创建的产品对象中的业务方法，实现对工厂方法的隐藏。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[简单工厂模式]]></title>
    <url>%2F2019%2F09%2F17%2F%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是简单工厂模式？为什么简单？和工厂模式相比有什么缺点？ 两个类A和B之间的关系应该仅仅是A创建B或者是A使用B，而不能两种关系都有。怎么理解？ 防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中。怎么理解？ 从一组工厂方法中选择一个意义明确的工厂方法，比从一组名称相同参数不同的构造函数中选择一个构造函数要方便很多。怎么理解？ 本章导学 创建型模式关注对象的创建过程，是一类最常见的设计模式，在软件开发中的应用非常广泛。创建型模式描述如何将对象的创建和使用分离，让用户在使用对象时无须关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展。 简单工厂模式是最简单的设计模式之一，它虽然不属于GoF的23种设计模式，但是应用也较为频繁，同时它也是学习其他创建型模式的基础。在简单工厂模式中，只需要记住一个简单的参数即可获得所需的对象实例，它提供专门的核心工厂类来负责对象的创建，实现对象的创建和使用分离。 本章将对6种创建型模式进行简要的介绍，并通过实例来学习简单工厂模式，理解简单工厂模式的结构及特点，学习如何在实际软件项目开发中合理地使用简单工厂模式。 本章知识点 创建型模式 简单工厂模式的定义 简单工厂模式的结构 简单工厂模式的实现 简单工厂模式的应用 简单工厂模式的优缺点 简单工厂模式的适用环境 创建型模式软件系统在运行时，类将实例化成对象，并由这些对象协作完成各项业务功能。创建型模式（Creational Pattern）关注对象的创建过程，是一类最常用的设计模式，在软件开发中的应用非常广泛。创建型模式对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离，对用户隐藏了类的实例创建细节。 创建型模式描述如何将对象的创建和使用分离，让用户在使用对象时无须关心对象的创建细节，从而降低系统的耦合度，让设计方案更易于修改和扩展。每一个创建型模式都通过采用不同的解决方案来回答3个问题：创建什么（What），由谁创建（Who）和何时创建（When）。 在GoF设计模式中，包含5种创建型模式，通常将一种非GoF设计模式——简单工厂模式作为学习其他工厂模式的基础，这5种设计模式的名称、定义、学习难度和使用频率如表1所示。 表1 创建型模式一览表 模式名称 定 义 学习难度 使用频率 简单工厂模式(Simple Factory Pattern) 定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。 ★★☆☆☆ ★★★☆☆ 工厂方法模式(Factory Method Pattern) 定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化。工厂方法模式让一个类的实例化延迟到其子类。 ★★☆☆☆ ★★★★★ 抽象工厂模式(Abstract Factory Pattern) 提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。 ★★★★☆ ★★★★★ 建造者模式(Builder Pattern) 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。 ★★★★☆ ★★☆☆☆ 原型模式(Prototype Pattern) 使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。 ★★★☆☆ ★★★☆☆ 单例模式(Singleton Pattern) 确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例。 ★☆☆☆☆ ★★★★☆ 简单工厂模式概述简单工厂模式并不属于GoF的23种经典设计模式，但通常将它作为学习其他工厂模式的基础，下面通过一个简单实例来引出简单工厂模式。 考虑一个水果农场，当用户需要某一种水果时，该农场能够根据用户所提供的水果名称返回该水果。在此，水果农场被称为工厂（Factory），而生产出的水果被称为产品（Product），水果的名称则被称为参数，工厂可以根据参数的不同返回不同的产品，这就是简单工厂模式的动机。该过程的示意图如图1所示，用户无须知道苹果（Apple）、橙（Orange）、香蕉（Banana）如何创建，只需要知道水果的名称即可得到对应的水果。 图1 简单工厂模式示意图 作为最简单的设计模式之一，简单工厂模式的设计思想和实现过程都比较简单，其基本实现流程如下： 首先将需要创建的各种不同产品对象的相关代码封装到不同的类中，这些类称为具体产品类，而将它们公共的代码进行抽象和提取后封装在一个抽象产品类中，每一个具体产品类都是抽象产品类的子类；然后提供一个工厂类用于创建各种产品，在工厂类中提供一个创建产品的工厂方法，该方法可以根据所传入参数的不同创建不同的具体产品对象；客户端只需调用工厂类的工厂方法并传入相应的参数即可得到一个产品对象。 简单工厂模式（Simple Factory Pattern）的定义如下：1定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。 由于在简单工厂模式中用于创建实例的方法通常是静态（static）方法，所以简单工厂模式又被称为静态工厂方法（Static Factory Method）模式，它是一种类创建型模式。简单工厂模式的要点在于：如果需要什么，只需要传入一个正确的参数，就可以获取所需要的对象，而无须知道其创建细节。 简单工厂模式的结构与实现简单工厂模式的结构简单工厂模式的结构比较简单，其核心是工厂类的设计，其结构如图2所示。 图2 简单工厂模式结构图 由图2可知，简单工厂模式包含以下3个角色。 (1)Factory（工厂角色）：工厂角色即工厂类，它是简单工厂模式的核心，负责实现创建所有产品实例的内部逻辑；工厂类可以被外界直接调用，创建所需的产品对象；在工厂类中提供了静态的工厂方法FactoryMethod()，它的返回类型为抽象产品类型Product。 (2)Product（抽象产品角色）：它是工厂类所创建的所有对象的父类，封装了各种产品对象的公共方法，它的引入将提高系统的灵活性，使得在工厂类中只需定义一个通用的工厂方法，因为所有创建的具体产品对象都是其子类对象。 (3)ConcreteProduct（具体产品角色）：它是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。每一个具体产品角色都继承了抽象产品角色，需要实现在抽象产品中声明的抽象方法。 简单工厂模式的实现在简单工厂模式中，客户端通过工厂类来创建一个产品类的实例，而无须直接使用new关键字来创建对象，它是工厂模式家族中最简单的一员。 在使用简单工厂模式时，首先需要对产品类进行重构，不能设计一个包罗万象的产品类，而需要根据实际情况设计一个产品层次结构，将所有产品类公共的代码移至抽象产品类，并在抽象产品类中声明一些抽象方法，以供不同的具体产品类来实现。典型的抽象产品类代码如下：1234567891011abstract class Product&#123; // 所有产品类的公共业务方法 public void MethodSame() &#123; // 公共方法的实现 &#125; // 声明抽象业务方法 public abstract void MethodDiff();&#125; 在具体产品类中实现了抽象产品类中声明的抽象业务方法，不同的具体产品类可以提供不同的实现。典型的具体产品类代码如下：1234567891011121314151617class ConcreteProductA : Product&#123; // 实现业务方法 public override void MethodDiff() &#123; // 业务方法的实现 &#125;&#125;class ConcreteProductB : Product&#123; // 实现业务方法 public override void MethodDiff() &#123; // 业务方法的实现 &#125;&#125; 简单工厂模式的核心是工厂类，在没有工厂类之前，客户端一般会使用new关键字来直接创建产品对象，而在引入工厂类之后，客户端可以通过工厂类来创建产品。在简单工厂模式中，工厂类提供了一个静态工厂方法供客户端使用，根据所传入参数的不同可以创建不同的产品对象。典型的工厂类代码如下:1234567891011121314151617181920class Factory&#123; // 静态工厂方法 public static Product GetProduct(string arg) &#123; Product product = null; if(arg.Equals("A")) &#123; product = new ConcreteProductA(); // 初始化设置product &#125; else if(arg.Equals("B")) &#123; product = new ConcreteProductB(); // 初始化设置product &#125; return product; &#125;&#125; 在客户端代码中，通过调用工厂类的工厂方法即可得到产品对象。其典型代码如下：12345678910class Program&#123; static void Main(string[] args) &#123; Product product; product = Factory.GetProduct("A"); // 通过工厂类创建产品对象 product.MethodSame(); product.MethodDiff(); &#125;&#125; 简单工厂模式的应用实例下面通过一个应用实例来进一步学习和理解简单工厂模式。 1.实例说明 某软件公司要基于C#语言开发一套图表库，该图表库可以为应用系统提供多种不同外观的图表，例如柱状图（HistogramChart）、饼状图（PieChart）、折线图（LineChart）等。该软件公司图表库设计人员希望为应用系统开发人员提供一套灵活易用的图表库，通过设置不同的参数即可得到不同类型的图表，而且可以较为方便地对图表库进行扩展，以便能够在将来增加一些新类型的图表。现使用简单工厂模式来设计该图表库。 2.实例类图 通过分析，本实例的结构如图3所示。 图3 图表库结构图 在图3中，Chart接口充当抽象产品类，其子类HistogramChart、PieChart和LineChart充当具体产品类，ChartFactory充当工厂类。 3.实例代码 (1)Chart：抽象图标接口，充当抽象产品类。 1234567namespace SimpleFactorySample&#123; interface Chart &#123; void Display(); &#125;&#125; (2)HistogramChart：柱状图类，充当具体产品类。 1234567891011121314151617using System;namespace SimpleFactorySample&#123; class HistogramChart : Chart &#123; public HistogramChart() &#123; Console.WriteLine("创建柱状图！"); &#125; public void Display() &#123; Console.WriteLine("显示柱状图！"); &#125; &#125;&#125; (3)PieChart：饼状图类，充当具体产品类。 1234567891011121314151617using System;namespace SimpleFactorySample&#123; class PieChart : Chart &#123; public PieChart() &#123; Console.WriteLine("创建饼状图！"); &#125; public void Display() &#123; Console.WriteLine("显示饼状图！"); &#125; &#125;&#125; (4)LineChart：折线图类，充当具体产品类。 1234567891011121314151617using System;namespace SimpleFactorySample&#123; class LineChart : Chart &#123; public LineChart() &#123; Console.WriteLine("创建折线图！"); &#125; public void Display() &#123; Console.WriteLine("显示折线图！"); &#125; &#125;&#125; (5)ChartFactory：图表工厂类，充当工厂类。 123456789101112131415161718192021222324252627282930using System;namespace SimpleFactorySample&#123; class ChartFactory &#123; // 静态工厂方法 public static Chart GetChart(string type) &#123; Chart chart = null; if (type.Equals("histogram")) &#123; chart = new HistogramChart(); Console.WriteLine("初始化设置柱状图！"); &#125; else if (type.Equals("pie")) &#123; chart = new PieChart(); Console.WriteLine("初始化设置饼状图！"); &#125; else if (type.Equals("line")) &#123; chart = new LineChart(); Console.WriteLine("初始化设置折线图！"); &#125; return chart; &#125; &#125;&#125; (6)Program：客户端测试类。1234567891011121314151617using System;namespace SimpleFactorySample&#123; class Program &#123; static void Main(string[] args) &#123; Chart chart; chart = ChartFactory.GetChart("histogram"); // 通过静态工厂方法创建产品 chart.Display(); Console.Read(); &#125; &#125;&#125; 4.结果及分析 编译并运行程序，输出结果如下：123创建柱状图! 初始化设置柱状图! 显示柱状图 在客户端测试类中，使用工厂类ChartFactory的静态工厂方法创建产品对象，如果需要更换产品，只需修改静态工厂方法中的参数即可。例如将柱状图改为饼状图，只需将代码：1chart = ChartFactory.GetChart("histogram"); 改为：1chart = ChartFactory.GetChart("pie"); 编译并运行程序，输出结果如下：123创建饼状图! 初始化设置饼状图! 显示饼状图! 不难发现，本实例在创建具体Chart对象时，必须通过修改客户端代码中静态工厂方法的参数来更换具体产品对象，客户端代码需要重新编译，这对于客户端而言，违背了开闭原则。 下面介绍一种常用的解决方案，可以实现在不修改客户端代码的前提下让客户端能够更换具体产品对象。 首先将静态工厂方法的参数存储在XML格式的配置文件App.config中，如下所示：123456&lt;?xml version="1.0" encoding="utf-8" ?&gt;&lt;configuration&gt; &lt;appSettings&gt; &lt;add key="chartType" value="histogram"/&gt; &lt;/appSettings&gt;&lt;/configuration&gt; 然后将客户端代码修改如下：1234567891011121314151617181920using System;using System.Configuration;namespace SimpleFactorySample&#123; class Program &#123; static void Main(string[] args) &#123; Chart chart; // 读取配置文件 string chartStr = ConfigurationManager.AppSettings["chartType"]; chart = ChartFactory.GetChart(chartStr); // 通过静态工厂方法创建产品 chart.Display(); Console.Read(); &#125; &#125;&#125; 编译并运行程序，输出结果如下：123创建柱状图！ 初始化设置柱状图! 显示柱状图！ 在上述客户端代码中，通过使用ConfigurationManager类的AppSettings属性可以获取存储在配置文件（例如App.config）中的字符串，在C#源代码中不包含任何与具体图表对象相关的信息，如果需要更换具体图表对象，只需修改配置文件App.config即可，无须修改任何源代码，符合开闭原则。 需要注意的是，在某些版本的Visual Studio中需要手动引入组件“System.Configuration”，否则无法使用ConfigurationManager类。步骤如下: 在“解决方案资源管理器”项目树形结构中的“引用”结点上右击，在快捷菜单中选择“添加引用”命令，在弹出的对话框中选择“.NET”选项卡，选中名称为“System.Configuration”的组件，即可添加该组件，并使用其中的ConfigurationManager等类。 创建对象与使用对象本节将讨论工厂类的作用以及如何通过工厂类来创建对象。在一个面向对象软件系统中，与一个对象相关的职责通常有3种：对象本身所具有的职责、创建对象的职责和使用对象的职责。对象本身的职责比较容易理解，就是对象自身所具有的一些数据和行为，可通过一些公开的（public）方法来实现。本节将重点讨论创建对象的职责和使用对象的职责。 在C#语言中，通常有以下几种创建对象的方式： (1)使用new关键字直接创建对象。 (2)通过反射机制创建对象（工厂方法模式）将学习此方式。 (3)通过克隆方法创建对象（原型模式）将学习此方式。 (4)通过工厂类创建对象。 毫无疑问，在客户端代码中直接使用new关键字是最简单的创建对象的方式，但是它的灵活性较差，下面通过一个简单的实例来加以说明：123456789101112131415161718class Login&#123; private UserDAO udao; public Login() &#123; // 创建对象 udao = new OracleUserDAO(); &#125; public void Execute() &#123; // 其他代码 // 使用对象 udao.FindUserById(); // 其他代码 &#125;&#125; 以上代码中，在Login类中定义了一个UserDAO类型的对象udao，在Login的构造函数中创建了OracleUserDAO类型的udao对象，并在Execute()方法中调用了udao对象的FindUserById()方法。Login类负责创建一个UserDAO子类的对象并使用该对象的方法来完成相应的业务处理，也就是说，Login既负责udao的创建又负责udao的使用，创建对象和使用对象的职责耦合在一起，这样的设计会导致一个很严重的问题：如果在Login中希望能够使用UserDAO的另一个子类，例如SQLServerUserDAO类型的对象，必须修改Login类的源代码，这将违背开闭原则。 当遇到这种情况时，最常用的一种解决方法是将udao对象的创建职责从Login类中移除，在Login类之外创建对象，由专门的工厂类来负责udao对象的创建。通过引入工厂类，让客户类（例如Login）不涉及对象的创建，对象的创建者也不会涉及对象的使用。引入工厂类UserDAOFactory之后的结构如图4所示。 图4 引入工厂类之后的结构图 工厂类的引入将降低因为产品或工厂类改变所造成的维护工作量。如果UserDAO的某个子类的构造函数发生改变或者需要添加或移除不同的子类，只要维护UserDAOFactory的代码，不会影响到Login；如果UserDAO接口发生改变，例如添加、移除方法或改变方法名，只需要修改Login，不会给UserDAOFactory带来任何影响。 所有的工厂模式都强调一点：两个类A和B之间的关系应该仅仅是A创建B或者是A使用B，而不能两种关系都有。将对象的创建和使用分离，使得系统更加符合单一职责原则，有利于对功能的复用和系统的维护。 此外，将对象的创建和使用分离还有一个好处：防止用来实例化一个类的数据和代码在多个类中到处都是，可以将有关创建的知识搬移到一个工厂类中。因为有时创建一个对象不只是简单调用其构造函数，还需要设置一些参数，可能还需要配置环境，如果将这些代码散落在每一个创建对象的客户类中，势必会出现代码重复、创建蔓延的问题，而这些客户类其实无须承担对象的创建工作，它们只需使用已创建好的对象就可以了。此时，可以引入工厂类来封装对象的创建逻辑和客户代码的实例化配置选项。 使用工厂类还有一个优点，一个类可能拥有多个构造函数，而在C#、Java等语言中构造函数的名称都与类名相同，客户端只能通过传入不同的参数来调用不同的构造函数创建对象，从构造函数和参数列表中大家很难了解不同构造函数所构造的产品的差异。如果将对象的创建过程封装在工厂类中，可以提供一系列名称完全不同的工厂方法，每一个工厂方法对应一个构造函数，客户端就可以以一种更加可读、易懂的方式来创建对象，而且，从一组工厂方法中选择一个意义明确的工厂方法，比从一组名称相同参数不同的构造函数中选择一个构造函数要方便很多，如图5所示。 图5 矩形工厂与矩形类 在图5中，矩形工厂类RectangleFactory提供了CreateRectangle()和CreateSquare()两个工厂方法，一个用于创建长方形，一个用于创建正方形，这两个方法比直接通过构造函数来创建长方形或正方形意义更加明确，在一定程度上降低了客户端调用时出错的概率。 但是，并不需要为系统中的每一个类都配备一个工厂类，如果一个类很简单，而且不存在太多变化，其构造过程也很简单，此时就无须为其提供工厂类，直接在使用之前实例化即可，例如C#语言中的String类（或string），就无须为它专门提供一个StringFactory，这样做反而会导致工厂泛滥，增加系统的复杂度。 以上关于创建对象和使用对象的讨论也适用于工厂方法模式和抽象工厂模式。 简单工厂模式的简化有时为了简化简单工厂模式，可以将抽象产品类和工厂类合并，将静态工厂方法移到抽象产品类中，如图6所示。 图6 简化的简单工厂模式 在图6中，客户端可以通过调用产品父类的静态工厂方法，根据不同参数创建不同类理的产品子类对象，这种方法在很多类库和框架中也广泛存在。 简单工厂模式的优缺点与适用环境简单工厂模式提供了专门的工厂类用于创建对象，将对象的创建和对象的使用分离开，它作为一种最简单的工厂模式在软件开发中得到了较为广泛的应用。 简单工厂模式的优点简单工厂模式的主要优点如下： (1)工厂类包含必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以免除直接创建产品对象的职责，而仅仅“消费”产品，简单工厂模式实现了对象创建和使用的分离。 (2)客户端无须知道所创建的具体产品类的类名，只需知道具体产品类所对应的参数即可，对于一些复杂的类名，通过简单工厂模式可以在一定程度上减少使用者的记忆量。 (3)通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。 简单工厂模式的缺点简单工厂模式的主要缺点如下： (1)由于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响。 (2)使用简单工厂模式势必会增加系统中类的个数（引入了新的工厂类），增加了系统的复杂度和理解难度。 (3)系统扩展困难，一旦添加新产品不得不修改工厂逻辑，在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护。 (4)简单工厂模式由于使用了静态工厂方法，造成工厂角色无法形成基于继承的等级结构。在C#语言中，不能通过类的实例对象来访问静态方法和静态变量，无法在客户端代码中针对工厂父类编程，而在运行时使用工厂子类对象来覆盖父类，因此，工厂类不能得到很好的扩展。 简单工厂模式的适用环境在以下情况下可以考虑使用简单工厂模式： (1)工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑过于复杂。 (2)客户端只知道传入工厂类的参数，对于如何创建对象并不关心。 本章小结(1)创建型模式关注对象的创建过程，它对类的实例化过程进行了抽象，能够将软件模块中对象的创建和对象的使用分离，对用户隐藏了类的实例创建细节。在GoF设计模式中一共包含5种创建型模式，通常将简单工厂模式作为学习其他工厂模式的基础，简单工厂模式不是GoF设计模式。 (2)在简单工厂模式中，定义一个工厂类，它可以根据参数的不同返回不同类的实例，被创建的实例通常都具有共同的父类。简单工厂模式是一种类创建型模式。 (3)简单工厂模式包含工厂角色、抽象产品角色和具体产品角色3个角色。其中，工厂角色是简单工厂模式的核心，负责实现创建产品实例的内部逻辑；抽象产品角色是工厂类所创建的所有对象的父类，封装了各种产品对象的公共方法；具体产品角色是简单工厂模式的创建目标，所有被创建的对象都充当这个角色的某个具体类的实例。 (4)简单工厂模式的主要优点在于实现了对象创建和使用的分离；客户端无须知道所创建的具体产品类的类名，只需知道具体产品类所对应的参数即可；通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。其主要缺点在于工厂类集中了所有产品的创建逻辑，职责过重，一旦不能正常工作，整个系统都要受到影响；增加了系统中类的个数且增加了系统的复杂度和理解难度系统扩展困难，一旦添加新产品不得不修改工厂逻辑，且工厂角色无法形成基于继承的等级结构。 (5)简单工厂模式适用的环境：工厂类负责创建的对象比较少，由于创建的对象较少，不会造成工厂方法中的业务逻辑太过复杂；客户端只知道传入工厂类的参数，对于如何创建对象并不关心。 (6)将对象的创建和使用分离，使得系统更加符合单一职责原则，有利于对功能的复用和系统的维护。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式概述与UML类图]]></title>
    <url>%2F2019%2F09%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E6%A6%82%E8%BF%B0%E4%B8%8EUML%E7%B1%BB%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 类模式处理类和子类之间的关系，对象模式处理对象间的关系。各举一个例子。 UML图中的1..*是什么意思？实心菱形是什么意思？ 聚合和组合有什么关系和区别？ 设计模式1.使用桥接模式时系统中的类必须存在两个独立变化的维度，在使用组合模式时系统中必须存在整体和部分的层次结构。 2.设计模式根据范围分类，即模式主要是处理类之间的关系还是处理对象之间的关系，模式可分为类模式和对象模式两种类型。 (1)类模式：此类模式处理类和子类之间的关系，这些关系通过继承建立，在编译时就被确定下来，是一种静态模式。 (2)对象模式：此类模式处理对象间的关系，这些关系在运行时变化，更具动态性。 UML类和类的UML表示在UML2.0的13种图形中，类图是使用最广泛的图形之一，它用于描述系统中所包含的类以及它们之间的相互关系，每一个设计模式的结构都可以使用类图来表示。类图帮助人们简化对系统的理解，是系统分析和设计阶段的重要产物，也是系统编码的重要模型依据。 1.类 类（Class）封装了数据和行为，是面向对象的重要组成部分，它是具有相同属性、操作、关系的对象集合的总称。在系统中，每个类都具有一定的职责，职责指的是类要完成什么样的功能，要承担什么样的义务。一个类可以有多种职责，设计得好的类通常有且仅有一种职责。在定义类的时候，将类的职责分解成为类的属性和操作（即方法）。类的属性即类的数据职责，类的操作即类的行为职责。设计类是面向对象设计中最重要的组成部分，也是最复杂和最耗时的部分。 在软件系统运行时，类将被实例化成对象（Object），对象对应于某个具体的事物，是类的实例（Instance）。 类图（Class Diagram）使用出现在系统中的不同类来描述系统的静态结构，它用来描述不同的类以及它们之间的关系。 2.类的UML图示 在UML中，类使用包含类名、属性和操作且带有分隔线的长方形来表示，例如定义一个Employee类，它包含属性name、age和name和email，以及操作ModifyInfo()，在UML类图中该类如图1所示。 图1 类的UML图示 图1对应的C#代码片段如下：1234567891011public class Employee &#123; private string name; private int age; private string email; public void ModifyInfo() &#123; ... &#125;&#125; 在UML类图中，类一般由三部分组成： (1)第一部分是类名，每个类都必须有一个名字，类名是一个字符串。 (2)第二部分是类的属性（Attributes），属性是指类的性质，即类的成员变量。一个类可以有任意多个属性，也可以没有属性。 UML规定属性的表示方式如下：1可见性 名称:类型[ = 默认值] 其中： ①“可见性”表示该属性对于类外的元素而言是否可见，包括公有（public）、私有（private）和受保护（protected）3种，在类图中分别用符号“+”、“-”和“#”表示。在C#语言中还新增了internal和protected internal两种可见性，其中，internal表示程序集内可见，protected internal表示程序集内可见或者子类可见，分别用符号“i”和“r”表示。为了保证数据的封装性，属性的可见性通常为private，它们通过公有的Getter方法和Setter方法供外界使用。 ②“名称”表示属性名，用一个字符串表示，按照C#语言的命名规范，属性命名采用驼峰命名法（Camel Case），即属性名中的第一个单词全小写，之后每个单词的首字母大写。 ③“类型”表示属性的数据类型，可以是基本数据类型，也可以是用户自定义类型。 ④“默认值”是一个可选项，即属性的初始值。 (3)第三部分是类的操作（Operations），操作是类的任意一个实例对象都拥有的行为，是类的成员方法。 UML规定操作的表示方式如下：1可见性 名称(参数列表) [ : 返回类型] 其中：①“可见性”的定义与属性的可见性定义相同。 ②“名称”即方法名或操作名，用一个字符串表示，按照C#语言的命名规范，方法命名采用帕斯卡命名法（Pascal Case），即方法名中的每个单词首字母都大写。 ③“参数列表”表示方法的参数，其语法与属性的定义相似，参数个数是任意的，多个参数之间用逗号“,”隔开。 ④“返回类型”是一个可选项，表示方法的返回值类型，依赖于具体的编程语言，可以是基本数据类型，也可以是用户自定义类型，还可以是空类型（void），如果是构造方法，则无返回类型。 类之间的关系在软件系统中，类并不是孤立存在的，类与类之间存在着各种关系，对于不同类型的关系，UML提供了不同的表示方式。 1.关联关系 关联（Association）关系是类与类之间最常用的一种关系，它是一种结构化关系，用于表示一类对象与另一类对象之间有联系，如汽车和轮胎、师傅和徒弟、班级和学生等。在UML类图中，用实线连接有关联关系的对象所对应的类，在使用C、C++和Java等编程语1言实现关联关系时，通常将一个类的对象作为另一个类的成员变量。在使用类图表示关联关系时可以在关联线上标注角色名，一般使用一个表示两者之间关系的动词或者名词表示角色名（有时该名词为实例对象名），关系的两端代表两种不同的角色，因此在一个关联关系中可以包含两个角色名，角色名不是必需的，可以根据需要增加，其目的是使类之间的关系更加明确。 例如在一个登录界面类LoginForm中包含一个Button类型的注册按钮loginButton，它们之间可以表示为关联关系，代码实现时可以在LoginForm中定义一个名为loginButton的属性对象，其类型为Button，如图2所示。 图2 关联关系实例 图2对应的C#代码片段如下： 12345678910public class LoginForm&#123; private Button loginButton; ...&#125;public class Button&#123; ...&#125; 在UML中，关联关系通常又包含以下几种形式。 (1)双向关联：默认情况下，关联是双向的。例如顾客（Customer）购买商品（Product）并拥有商品，反之，卖出的商品总有某个顾客与之相关联。因此，Customer类和Product类之间具有双向关联关系，如图3所示。 图3 双向关联实例 图3对应的C#代码片段如下：1234567891011public class Customer&#123; private Product[] products; ...&#125;public class Product&#123; private Customer customer; ...&#125; (2)单向关联：类的关联关系也可以是单向的，单向关联用带箭头的实线表示。例如顾客（Customer）拥有地址（Address），则Customer类与Address类具有单向关系，如图4所示。 图4 单向关联实例 图4对应的C#代码片段如下：12345678910public class Customer&#123; private Address address; ...&#125;public class Address&#123; ...&#125; (3)自关联：在系统中可能会存在一些类的属性对象类型为该类本身，这种特殊的关联关系称为自关联。例如，一个结点类（Node）的成员又是结点Node类型的对象，如图5所示。 图5 自关联实例 图5对应的C#代码片段如下：12345public class Node&#123; private Node subNode; ...&#125; (4)多重性关联：多重性关联关系又称为重数性（Multiplicity）关联关系，表示两个关联对象在数量上的对应关系。在UML中，对象之间的多重性可以直接在关联直线上用一个数字或一个数字范围表示。 对象之间可以存在多种多重性关联关系，常见的多重性表示方式如表1所示。 表1 多重性表示方式列表 表示方式 多重性说明 1..1 表示另一个类的一个对象只与该类的一个对象有关系 0..* 表示另一个类的一个对象与该类的零个或多个对象有关系 1..* 表示另一个类的一个对象与该类的一个或多个对象有关系 0..1 表示另一个类的一个对象没有或只与该类的一个对象有关系 m..n 表示另一个类的一个对象与该类最少m个最多n个对象有关系 例如一个界面（Form）可以拥有零个或多个按钮（Button），但是一个按钮只能属于一个界面，因此，一个Form类的对象可以与零个或多个Button类的对象相关联，但一个Button类的对象只能与一个Form类的对象关联，如图6所示。 图6 多重性关联实例 图5对应的C#代码片段如下：12345678910public class Form&#123; private Button[] buttons; // 定义一个集合对象 ...&#125;public class Button&#123; ...&#125; (5)聚合关系：聚合（Aggregation）关系表示整体与部分的关系。在聚合关系中，成员对象是整体对象的一部分，但是成员对象可以脱离整体对象独立存在。在UML中，聚合关系用带空心菱形的直线表示。例如汽车发动机（Engine）是汽车（Car）的组成部分，但是汽车发动机可以独立存在，因此，汽车和发动机是聚合关系，如图7所示。 图7 聚合关系实例 在用代码实现聚合关系时，成员对象通常作为构造方法、Setter方法或业务方法的参数注入整体对象中。图7对应的C#代码片段如下： 12345678910111213141516171819202122public class Car&#123; private Engine engine; // 构造注入 public Car(Engine engine) &#123; this.engine = engine; &#125; public Engine Engine &#123; get &#123; return engine; &#125; set &#123; engine = value; &#125; // 设值注入 &#125; ...&#125;public class Engine&#123; ...&#125; (6)组合关系：组合（Composition）关系也表示类之间整体和部分的关系，但是在组合关系中整体对象可以控制成员对象的生命周期，一旦整体对象不存在，成员对象也将不存在，成员对象与整体对象之间具有同生共死的关系。在UML中，组合关系用带实心菱形的直线表示。例如人的头（Head）与嘴巴（Mouth），嘴巴是头的组成部分之一，如果头没了，嘴巴也就没了，因此头和嘴巴是组合关系，如图8所示。 图8 组合关系实例 在用代码实现组合关系时，通常在整体类的构造方法中直接实例化成员类。图8对应的C#代码片段如下：123456789101112131415public class Head&#123; private Mouth mouth; public Head() &#123; mouth = new Mouth(); // 实例化成员类 &#125; ...&#125;public class Mouth&#123; ...&#125; 2.依赖关系 依赖（Dependency）关系是一种使用关系，特定事物的改变有可能会影响到使用该事物的其他事物，在需要表示一个事物使用另一个事物时使用依赖关系。大多数情况下，依赖关系体现在某个类的方法使用另一个类的对象作为参数。在UML中，依赖关系用带箭头的 虚线表示，由依赖的一方指向被依赖的一方。例如驾驶员开车，在Driver类的Drive()方法中将Car类型的对象car作为一个参数传递，以便在Drive()方法中能够调用car的Move()方法，驾驶员的Drive()方法依赖车的Move()方法，因此类Driver依赖类Car，如图9所示。 图9 依赖关系实例 在系统实施阶段，依赖关系通常通过3种方式来实现，第一种也是最常用的一种方式，如图9所示，将一个类的对象作为另一个类中方法的参数，第二种方式是在一个类的方法中将另一个类的对象作为其局部变量，第三种方式是在一个类的方法中调用另一个类的静态方法。图9对应的C#代码片段如下：1234567891011121314151617public class Driver&#123; public void Drive(Car car) &#123; car. Move(); &#125; ...&#125;public class Car&#123; public void Move() &#123; ... &#125; ...&#125; 3.泛化关系 泛化（Generaliation）关系也就是继承关系，用于描述父类与子类之间的关系，父类又称为基类或超类，子类又称为派生类。在UML中，泛化关系用带空心三角形的直线来表示。在用代码实现时，使用面向对象的继承机制来实现泛化关系，在C#中使用冒号“：”来实现。例如Student类和Teacher类都是Person类的子类，Student类和Teacher类继承了Person类的属性和方法，Person类的属性包含姓名（name）和年龄（age），每一个Student和Teaeher也都具有这两个属性，另外，Student类增加了属性学号（studentNo），Teacher类增加了属性教师编号（teacherNo），Person类的方法包括行走Move()和说话Say()，Studen类和Teaeher类继承了这两个方法，而且Student类还新增了方法Study()，Teaeher类还新增了方法Teach()，如图10所示。 图10 泛化关系实例 图10对应的C#代码片段如下：1234567891011121314151617181920212223242526272829303132333435363738// 父类public class Person&#123; protected string name; protected int age; public void Move() &#123; ... &#125; public void Say() &#123; ... &#125;&#125;// 子类public class Student : Person&#123; private string studentNo; public void Study() &#123; ... &#125;&#125;// 子类public class Teacher : Person&#123; private string teacherNo; public void Teach() &#123; ... &#125;&#125; 4.接口与实现关系 在很多面向对象语言中都引入了接口的概念，例如C#、Java等，在接口中通常没有属性，而且所有的操作都是抽象的，只有操作的声明，没有操作的实现。在C#中，接口中的方法默认可见性均为public，无须再使用任何可见性关键字。在UML中用与类的表示法类似的方式表示接口，如图11所示。 图11 接口的UML图示 接口之间也可以有与类之间关系类似的继承关系和依赖关系，但是接口和类之间还存在一种实现（Realization）关系，在这种关系中，类实现了接口，类中的操作实现了接口中所声明的操作。在UML中，类与接口之间的实现关系用带空心三角形的虚线来表示。例如定义了一个交通工具接口Vehicle，包含一个抽象操作Move()，在类Ship和类Car中都实现了该Move()操作，不过具体的实现细节将会不一样，如图12所示。 图12 实现关系实例 实现关系在用代码实现时，不同的面向对象语言也提供了不同的语法，在C#中使用冒号“：”来实现。图12对应的C#代码片段如下：1234567891011121314151617181920public interface Vehicle&#123; void Move();&#125;public class Ship : Vehicle&#123; public void Move() &#123; ... &#125;&#125;public class Car : Vehicle&#123; public void Move &#123; ... &#125;&#125;]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>C#设计模式（第2版）</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IOC和AOP的一些基本概念]]></title>
    <url>%2F2019%2F09%2F11%2FIOC%E5%92%8CAOP%E7%9A%84%E4%B8%80%E4%BA%9B%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是IOCIoC就是Inversion of Control，控制反转。在Java开发中，IoC意味着将你设计好的类交给系统去控制，而不是在你的类内部控制。这称为控制反转。 下面我们以几个例子来说明什么是IoC 假设我们要设计一个Girl和一个Boy类，其中Girl有kiss方法，即Girl想要Kiss一个Boy。那么，我们的问题是，Girl如何能够认识这个Boy？ 在我们中国，常见的ＭＭ与GG的认识方式有以下几种 １ 青梅竹马； ２ 亲友介绍； ３ 父母包办 那么哪一种才是最好呢？ 青梅竹马：Girl从小就知道自己的Boy。1234567public class Girl &#123; void kiss() &#123; Boy boy = new Boy(); &#125;&#125; 然而从开始就创建的Boy缺点就是无法在更换。并且要负责Boy的整个生命周期。如果我们的Girl想要换一个怎么办？（笔者严重不支持Girl经常更换Boy）亲友介绍：由中间人负责提供Boy来见面1234567public class Girl &#123; void kiss() &#123; Boy boy = BoyFactory.createBoy(); &#125;&#125; 亲友介绍，固然是好。如果不满意，尽管另外换一个好了。但是，亲友BoyFactory经常是以Singleton的形式出现，不然就是，存在于Globals，无处不在，无处不能。实在是太繁琐了一点，不够灵活。我为什么一定要这个亲友掺和进来呢？为什么一定要付给她介绍费呢？万一最好的朋友爱上了我的男朋友呢？ 父母包办：一切交给父母，自己不用费吹灰之力，只需要等着Kiss就好了。12345678public class Girl &#123; void kiss(Boy boy) &#123; // kiss boy boy.kiss(); &#125;&#125; Well，这是对Girl最好的方法，只要想办法贿赂了Girl的父母，并把Boy交给他。那么我们就可以轻松的和Girl来Kiss了。看来几千年传统的父母之命还真是有用哦。至少Boy和Girl不用自己瞎忙乎了。 这就是IOC，将对象的创建和获取提取到外部。由外部容器提供需要的组件。 我们知道好莱坞原则：“Do not call us, we will call you.” 意思就是，You, girlie, do not call the boy. We will feed you a boy。 我们还应该知道依赖倒转原则即 Dependence Inversion Princinple，DIP。 Eric Gamma说，要面向抽象编程。面向接口编程是面向对象的核心。 组件应该分为两部分，即 Service, 所提供功能的声明 Implementation, Service的实现 好处是：多实现可以任意切换，防止 “everything depends on everything” 问题．即具体依赖于具体。 所以，我们的Boy应该是实现Kissable接口。这样一旦Girl不想kiss可恶的Boy的话，还可以kiss可爱的kitten和慈祥的grandmother。 IOC的typeIoC的Type指的是Girl得到Boy的几种不同方式。我们逐一来说明。 IOC type 0：不用IOC 12345678910111213141516public class Girl implements Servicable &#123; private Kissable kissable; public Girl() &#123; kissable = new Boy(); &#125; public void kissYourKissable() &#123; kissable.kiss(); &#125;&#125; Girl自己建立自己的Boy，很难更换，很难共享给别人，只能单独使用，并负责完全的生命周期。 IOC type 1，先看代码： 1234567891011121314public class Girl implements Servicable &#123; Kissable kissable; public void service(ServiceManager mgr) &#123; kissable = (Kissable) mgr.lookup(“kissable”); &#125; public void kissYourKissable() &#123; kissable.kiss(); &#125;&#125; 这种情况出现于Avalon Framework。一个组件实现了Servicable接口，就必须实现service方法，并传入一个ServiceManager。其中会含有需要的其它组件。只需要在service方法中初始化需要的Boy。 另外，J2EE中从Context取得对象也属于type 1。 它依赖于配置文件123456&lt;Container&gt; &lt;component name=“kissable“ class=“Boy"&gt; &lt;configuration&gt; … &lt;/configuration&gt; &lt;/component&gt; &lt;component name=“girl" class=“Girl" /&gt;&lt;/container&gt; IOC type 2： 123456789101112131415public class Girl &#123; private Kissable kissable; public void setKissable(Kissable kissable) &#123; this.kissable = kissable; &#125; public void kissYourKissable() &#123; kissable.kiss(); &#125;&#125; Type 2出现于spring Framework，是通过JavaBean的set方法来将需要的Boy传递给Girl。它必须依赖于配置文件。12345678&lt;beans&gt; &lt;bean id=“boy" class=“Boy"/&gt; &lt;bean id=“girl“ class=“Girl"&gt; &lt;property name=“kissable"&gt; &lt;ref bean=“boy"/&gt; &lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; IOC type 31234567891011121314public class Girl &#123; private Kissable kissable; public Girl(Kissable kissable) &#123; this.kissable = kissable; &#125; public void kissYourKissable() &#123; kissable.kiss(); &#125;&#125; 这就是PicoContainer的组件 。通过构造函数传递Boy给Girl。 123456789PicoContainer container = new DefaultPicoContainer();container.registerComponentImplementation(Boy.class);container.registerComponentImplementation(Girl.class);Girl girl = (Girl) container.getComponentInstance(Girl.class);girl.kissYourKissable(); ================AOP 关注与主要的东西，也可以说让你只关注与业务，其他的东西就让AOP帮你完成。 我们要吃武昌鱼：1234567891011public class Dinner &#123; Customer yangyi; public void eatfish() &#123; yangyi.cookFish(); yangyi.eatFish(); yangyi.washDish(); &#125;&#125; prog 1 现在我觉得这顿饭吃的太不爽了，还要自己做,洗碗。 我想这样123456789public class Dinner &#123; ICustomer yangyi; public void eatfish() &#123; yangyi.eatFish(); &#125;&#125; prog 2 就是说我现在只用吃就行了，但是这样可以么？谁来帮我做鱼呢？这个我想就是所谓AOP吧，我只用关心我吃鱼的方面就行了，做鱼又食堂关注就行了。 现在看看谁来帮我cook fish呢，它怎么做到的呢？ 我看到上面prog 1中的Customer已经变成了prog 2中的ICustomer了，就是说如果愿意，我可以用任意的ICustomer实现来替代yangyi了，这个就是一个Customer的代理，在调用 yangyi.eatfish的时候，之前代理会帮我调用cookfish()，之后代理会帮我调用washdish()还是看看代码吧123456789101112131415161718class Customer implements ICustomer &#123; void eatfish() &#123; // haha eat, delicious &#125;&#125;class CustomerProxy implements ICustomer &#123; Customer yangyi = new Customer() //just for example. proxy is implement by dynamic proxy or other tech in real world void eatfish() &#123; cookfish(); yangyi.eatfish(); washdish(); &#125;&#125; 基本上就是说proxy会在调用我的Customer代码之前和之后做一些工作，ok, 这就是AOP，不知道我讲清楚了没有。在spring中，proxy是用java的动态代理做的，在运行的时候自动生成CustomerProxy这个东西，然后用这个Proxy替代我的Customer。 为什么老把IOC和AOP放在一起讲呢，想想我们的Customer是怎么来的吧 如果在某个时候我们说yangyi = new Customer()，那这样Proxy怎么替代这个Customer啊。所以IoC说，你要用Customer么，你直接说我要用，声明他，告诉我怎么样能够设置这个Customer，用的时候我会来调用你的(don’t call me, but I call you) 所以真正的代码应该是这样的1234567891011121314public class Dinner &#123; ICustomer yangyi; public void eatfish() &#123; yangyi.eatFish(); &#125; public void setYangyi(ICustomer customer) &#123; this.yangyi = customer; &#125;&#125; 我提供一个SetYangyi的方法，IoC会在运行时把yangyi设置成CustomerProxy，然后，我的代码就只用尽情的享受武昌鱼的美味了。其它的，留给ioc了。 BTW,烦死JDBC的connection.close()了吧，呵呵，IOC＋AOP应该最适合这方面了。 这两个概念基本上是一个设计层的概念，主要讲的就是怎么去分离关注，用面向对象的话说，就是怎么把职责进行分离。而这两个模式，我个人认为都有一个共同点，就是变以前的主动为被动，而我认为，这种改变可能也是将来面向对象发展的一个趋势。 首先说说什么叫主动。写过面向对象程序的人都知道，面向对象与面向过程的区别就是，面向对象是由一大堆对象组成的，对象通过协作完成面向过程中的任务。假设现在有对象A和B，那么当A需要使用B中的方法时，那么在A内部，就会有有一个对B方法的调用，这种调用就称为主动调用。代码大概会如下：123456789public class A&#123; B b; public void methodA() &#123; b.methodB(); &#125;&#125; 这里为了下文解释方便，我增加了一个调用点的定义，调用点就是调用发生的地方。也就是上面 b.methodB()中的b。 理解了什么叫主动之后，我想就先介绍什么叫IoC。IoC的全称这里就不说了，他的字面意思就是控制反转。在上面的代码当中，由于A调用了B的方法，因此就形成了一个A对B的依赖，这本身并没有什么问题。但是OO的思想是希望我们基于接口编程，而不是基于实现编程。因此，系统设计将不止是原有的A，B，而需要变成IA，IB，A，B，其中IA，IB是接口，A，B是对应的实现类，然后为了使得A中现在对B的实现依赖变成对接口的依赖，代码应该变成这样。123456789public class A implements IA&#123; IB b; public void methodA() &#123; b.methodB(); &#125;&#125; 这里虽然我们是基于接口编程了，但大家知道，在这中间，我们需要有一个步骤把b指向一个IB的实现类B，这个怎么做，就是IoC要做的事情，这里就不细说了。但简单来说，没有IoC，我们可能需要在A中通过某种方法去获取一个B的实例，但有了IoC，她就能在A不参与的情况下，给我们一个B的实例，所以，IoC要做的就是在调用点上从原来的主动生成一个调用点，变成被动的接受一个调用点。 接着就是AOP，全称也不说了，字面意思就是面向方面编程。举一个最普遍的例子，就是如果我们代码需要做日志的话，那么在没有AOP的时候，我们的代码可能就是这样：12345678public class A&#123; public void methodA() &#123; do log; b.methodB(); &#125;&#125; 这里methodA()中的做日志并不是方法本身的逻辑功能，而是一个附属功能，因此，我们需要把它分离出去。怎么分离，就是AOP要做的事情，简单来说，就是系统在调用者不知情的情况下，为我们的类A增加了一个代理类，她把我们的类A包装了起来，像这样：12345678910111213141516171819public class AP extends A&#123; A a; public void methodA() &#123; do log; a.methodA(): &#125;&#125;public class A&#123; public void methodA() &#123; b.methodB(); &#125;&#125; 于是，当我们以为自己在调用A的methodA()方法时，实际调用的将是AP中的methodA()，于是就可以把做日志的功能从原有的methodA()中分离了出去。所以，AOP要做的就是在用户不知道的情况下，将我们的调用点包裹了起来，从而把原来的功能进行了分离。]]></content>
  </entry>
  <entry>
    <title><![CDATA[职责链模式]]></title>
    <url>%2F2019%2F08%2F23%2F%E8%81%8C%E8%B4%A3%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 职责链设计模式的好处是，任何对象都可以向处理请求的对象发送请求，而且处理请求的对象可以改变，从而可以结合更多或不同的对象来处理请求。怎么理解？ 本章涵盖： 推卸责任职责链设计模式将请求的发送者与接收者分开，这样可以避免请求者与接收者的耦合。另外，这个模式允许将请求沿着一个链传递到多个不同的对象，使这些对象都有机会处理请求。发送者并不需要知道哪一个对象处理这个请求，而对象也不需要知道是谁发送了这个请求。在这二者之间不存在耦合。 职责链设计模式的好处是，任何对象都可以向处理请求的对象发送请求，而且处理请求的对象可以改变，从而可以结合更多或不同的对象来处理请求。所以请求者和请求处理器都可以改变，而不必担心对更大的系统带来破坏。图1显示了这个职责链设计模式的类图。 图1：职责链设计模式类图 注意，Client是这个程序中不可缺少的一部分。实际上，在这个结构中，它要完成很重要的工作，因为Client不仅要启动请求，可能还需要启动具体处理器中实现的后继。为此，一种方法是在Handler接口中建立后继方法，并在具体处理器中实现。当Client发出一个请求时，它可以同时建立这个链，并确定后继的顺序。 看到职责链模式时，有些人可能会认为“这只不过是一个大的switch语句而已”。从某种程度上看似乎如此，不过实际上并不是这样。它确实会检查一个请求，确定它是否与某个case条件匹配。不过， switch语句是固定的，而职责链会由各个具体处理器定义其后继。基于这种组织，可以把任意多个响应存储在一个MySQL数据库表中，这样一来，多个不同的“咨询台”可以使用相同的表以及相同的PHP职责链。由于每个具体处理器都包含一个方法来指定它自己的后继， Client通过具体处理器对象指定后继时也就定义了顺序。 另外，由于Client要启动请求链，它可以在开发人员指定的任何位置开始。假设具体请求处理器4、10、15和30可以作为你希望的新咨询台，就可以指定处理器4作为链中的第一个处理器，然后指定处理器10作为它的后继，再指定15为10的后继，而30作为15的后继。所以，职责链具有switch语句所没有的灵活性。 MySQL咨询台中的职责链职责链的第一个实现是一个咨询台，用户可以从一系列帮助主题中选择一个要询问的主题。不论是作为PHP设计模式，还是使用MySQL作为一个文本数据存储系统，这都是一个简单的实现。基本说来，在这个实现中，用户将从一组单选钮中选择一个查询，发出请求，然后通过一个响应链搜索。找到正确的响应时，对象从一个MySQL表获取响应，并在屏幕上显示。 构建和加载响应表首先要构建一个表，在其中存储文本响应。这一章中的MySQL连接同样使用第11章中的连接类和接口。为便于查看，这里再次给出这些类和接口。首先来看接口：12345678910&lt;?php// 文件名： IConnectInfo.phpinterface IConnectInfo&#123; const HOST = "localhost"; const UNAME = "phpWorker"; const PW = "easyWay"; const DBNAME = "dpPatt"; public function doConnect（）;&#125; 当然，你要使用你自己的连接信息。现在来看实现这个接口的连接类：12 这一章需要的每一个MySQL连接都会使用这个连接接口和类。 响应表只需要一个ID、一个指示链对象的字段，以及一个文本字段（提供咨询台中的“帮助”文本）：12 这里增加了自动id字段，因为将来有可能对表进行编辑，这算是一种预备措施，不过如果你愿意也可以将其忽略。另外，这里首先删除一个表，然后再创建一个表，这种做法在开发中很常用。这样可以加速这个过程，并确保在继续处理之前先将原来的表删除。完成表的调试之后，可以使用MySQL命令来创建表（去掉之前首先删除表的那些代码）：123```要让这个表真正发挥作用，需要在表中填入对应查询的响应，所以需要一个数据输入模块，包括一个PHP类和一个HTML表单。另外还必须更新咨询素材，所以除了数据输入外，还需要一个数据更新模块。先来看HTML：```html InsertData和UpdateData类获得HTML表单发送的数据，将数据存储在helpdesk表中。 InsertData.php&lt;/span&gt; 12 UpdateData.php&lt;/span&gt; 12 对于这个职责链咨询台，要在数据库表中输入或更新数据，这需要一个简单的表单。图2显示了这个数据输入/更新管理工具的外观。 图2：输入响应数据 只有应用管理员才能输入帮助数据，用户无权访问这个数据输入表单。图2中的查询链值（Query Chain Value）是用户搜寻的请求或帮助的一个标识符。这个特定的程序是这样组织的：请求用一个值来标识查询（q1到q（查询数））。在这个例子中，“咨询台”只有5个查询，所以是q1到q5。不过，完全可以有更多的查询。另外，一旦完成这个程序，如果想增加更多查询，可以使用咨询台数据输入模块（Help Desk Data EntryModule）来增加。接下来只需增加更多具体处理器，构成职责链模式。利用更新模块，咨询台就有了一个微型的内容管理系统（content management system， CMS）。 咨询台职责链一旦输入请求的响应数据，可以使用职责链来提供一个程序，不仅获取信息，还可以对链序列排序。图3显示了这个咨询台应用的类图。 图3：咨询台类图 在职责链的这个实现中，Client使用一个辅助类（Request）首先发起一个请求，将这个请求发送到第一个具体处理器。Client会以所需的方式设置这个链序列。这里有5个具体处理器类（从Q1到05），调用其中第一个具体处理器之后，这个具体处理器负责其余的工作，可能会处理查询，也可能将请求继续传递到下一个处理器类。 HTML数据输入、客户和请求参与者&lt;/span&gt; 数据输入表单是一个HTML文档，包含5个单选钮，分别对应不同的“帮助”请求。每个单选钮用一个值标识（表示相应的问题），从q1到q5：12 css样式表提供了一种“公司”风格（当然，你可以建立你喜欢的任何样式）。将这个文件保存为help.css：12 这里的想法是提供一种便捷的方法，允许用户选择，另外允许开发人员创建一个请求（将进入一个职责链流）。图4显示了这个用户界面，用户可以在这里选择要咨询的问题。 图4：数据输入用户界面 Client类处理从HTML表单发出的请求。它从一个$POST变量接受请求，将请求保存在一个变量squeryNow中。然后Client实例化链中各个具体响应（处理器）的实例。实例化这些对象变量后，Client再使用setSuccessor()方法为各个具体处理器建立后继。所以，现在就会以序列顺序“加载”这个链：12 一旦实例化具体处理器，并分别指定了一个后继（但链上最后一个具体处理器除外，它没有后继）， Client就可以做出请求了。为了帮助做出请求，Client使用了一个辅助类Request：12 处理器接口和具体处理器&lt;/span&gt; 职责链的接口是一个抽象类。在这个实现中，它包括两个抽象方法，另外还包含多个属性（将由具体处理器使用）：12 这些具体处理器分别提供了方法来处理请求和设置后继。这个例子中，处理请求方法非常简单.handleRequest()方法传递请求（将请求作为参数）。（由Client首先发起请求，启动这个链—就像是点燃导火索。）如果$handle变量与Client通过Request辅助类传递的$request匹配，就会由这个具体处理器来处理这个查询。否则，它会将请求继续传递给链中的后继：12 按照这个职责链的设计，用户只可有5个帮助请求，所以链尾的处理器后继为NULL-也就是说， Client没有为它定义后继。这样可以确保所有请求都有相应的处理器，不会有请求无法得到处理。 自动职责链和工厂方法下面这个例子显示了职责链模式如何与工厂方法模式结合使用。这里不再由一个UI（用户界面）做出请求，职责链使用了一个日期函数作为“请求”。由此可以说明职责链的灵活性。接下来，程序中的具体处理器调用一个工厂方法应用，加载所请求的文本和图像。图5显示了这个应用中两个设计模式之间的关系。 图5：职责链通过工厂方法模式处理请求 实际中，很多开发人员都可能根据应用的需要组合使用多个设计模式。工厂方法模式就经常与其他模式结合使用，以建立产品请求。 这个应用是针对学生每周要完成的一项加分作业设计的，这些学生们在研究全球饥荒情况。首先有一个地图，其中包括城市、河流、海洋和其他标志性地点，另外还要为页面增加一个照片和一个文本说明。学生们要找出正确的国家，明确饥荒情况、文明情况和性别差异，最后返回答案来得到学分。 职责链和日期驱动请求链接到这个应用的地址后，会通过一个index.php文件自动启动Client， Client再把当前日期放在一个变量$queryNow中，这个变量将传递到一个Request辅助类。沿着职责链，查询会查找第一个合适的具体处理器作为工厂方法的客户，由它创建和显示图像和文字素材。 日期函数为什么改变：时间巴别塔如果你用PHP创建过需要在世界范围使用的区分日期的应用，可能会注意到，可能要应用一些奇怪的时区规则（也可能不应用） 。使用PHP 5.4时， 日期对象要求你在php.net/manuallenltimezones.php中查找时区码，把它作为一个字符串直接量放在一个变量中来设置默认时区。例如，Client中使用下面的代码设置请求变量：123$tz = 'America/New_York';date_default_timezone_set（$tz）;$this-&gt;queryNow-getdate(); 这里设置了美国东海岸的时区。有些国家，比如印度，时间与UTC相差半小时。中国西部的喀什与东部的北京相差一个时区，二者距离约3400 km（2100英里）按这个距离，在美国很可能跨4个时区。要把时区从”Europe/Minsk”设置为”Australia/Tasmania” ，需要查看时区标识符（如果你住在印第安纳州，可能会查找8个时间标识符一”America/Indiana/Knox”-以及”America/ndianaIndianapolis” 和”America/Indianapolis” ） 。该学学地理了。 首先，要建立一个自动启动，下面的“触发器”文件会启动Client，并保存为index.php：12 除了由一个日期创建请求外，Client还负责建立后继列表：12 这里相继建立了类D1到D15，它们是对应不同日期的具体处理器。如果第一个处理器（D1）与请求日期不匹配，则会继续查找下一个，直到找到正确的日期。这里的Request类与第一个职责链例子中相同，用作为Client辅助类：12 处理器参与者同样是一个抽象类，作为一个接口。其中包含同样的方法，不过针对日期请求还增加了一些属性：12 接下来，实现请求处理的具体处理器包含有日期范围，用来确定这个具体处理器是否适合完成当前任务：12 通过使用一个布尔变量（$handleNow）和布尔表达式，处理器首先查询shandleNow，如果为true，则指向一个工厂方法，由它加载必要的素材。从这个角度来看，职责链具体处理器（D1到D15）是一个客户，将从工厂方法做出一个请求。图6显示了这两个模式如何协作。 链接点的代码就包含在具体处理器对象（DI到D15）中。请求代码与所有其他客户请求并没有不同：12$this-&gt;hungerFactory = new HungerFactory();echo $this-&gt;hungerFactory-&gt;feedFactory(new C1()); 下一节将分析职责链具体处理器调用的工厂方法设计模式的作用。 工厂方法完成任务工厂方法模式的工作与第5章中的一个例子类似（见图5-6） ，只是稍有区别。请求由具体处理器发出，而不是从”Client”类发出，不过这一点不会带来任何差异。如图6所示，handleRequest()方法相当于一个客户。 Creator和HungerFactory&lt;/span&gt; 标识客户来源之后，第一步构造Creator抽象类，这要作为工厂方法设计的接口：12 factoryMethod()函数和feedFactory()方法使用了类型提示，以确保参数包含Product接口。不过，由于feedFactory()函数不是抽象方法，Creator的所有具体实现都会自动包含这个方法。 正如第5章中看到的，一些工厂方法模式实现会为不同的产品使用不同的工厂（具体创建者）。不过，如果产品类似，具体创建者可以处理任意多个不同的具体产品：123456789&lt;?php// HungerFactory-phpclass HungerFactory extends Creator&#123; private $country; protected function factoryMethod(Product $product) $this-&gt;country=$product return($this-&gt;country-&gt;getProperties());&#125; factoryMethod()实现包含一个参数，以便接收具体产品实例。在具体处理器中（即工厂的客户），这个参数在职责链中确定，并发送到工厂方法。各具体产品将满足通过职责链发送的原始请求 产品和不同国家&lt;/span&gt; 最终结果显示了一个web页面，其中包含一个照片、一个地图和一段简短的文字说明。学生们使用这个应用研究全球饥荒情况，必须找出国家名、婴儿死亡率和不同文化程度的性别差异。 Product接口有一个方法getProperties()，HungerFactory使用这个方法得到所请求的产品。具体的产品类（C1到C15）显示了所需的各个部分：12 集成产品之后，将返回给客户，在这里客户就是职责链中的具体处理器。图7显示了最后得到的产品。 图片和文字部分放在单独的文件夹中。 辅助类、资源和样式&lt;/span&gt; 具体产品对象使用了外部样式表，另外有单独的文件夹提供文本和图片文件，还有一个辅助类来完成格式化。图8显示了整个应用的总布局。 图8：资源 主资源文件夹名为hunger。其中包含文件夹c01到c15，这些文件夹中分别包含3个文件：clue.txt、map.gif和pic.jpg，我们可以改变任何文件的内容，而不用担心破坏程序。不过需要指出一个诀窍，如果图片的大小改变，相应的具体产品大小也必须改变，以与之匹配。 FormatHelper类可以减少创建输出所使用的HTML：12 最后，需要利用外部样式表（products.css）把最终产品集成在一起，以便清楚地表达信息：12 对于所有这些部分，合理的组织至关重要，从长期来看，为这个应用增加新素材以及做出修改都极其容易。 易于更新设计模式最重要的特性是：基于设计模式，开发人员可以顺利地做出改变以及增加新素材，而不会让整个应用像一摞纸牌一样坍塌。一般来讲，开发人员很可能为了达到一些短期目标而选择走捷径，以节省编程时间，但是从长远来看，这种做法有一个严重的后果：最后即使只做简单的修改也必须重构整个程序。 上一节介绍的饥荒应用就是一个很好的例子，对于这样一个应用，重用和改变非常重要。由于这个应用是区分日期的，所以每个学期都需要改变，不过这很容易，因为所有日期查询都在D系列处理器（D1到D15）类中完成，这些处理器都作为职责链模式的一部分。同样，具体产品很容易修改，因为只要图片大小保持不变，所要修改的就只有新图像。名字是不变的（例如，clue.txt、map.gin），而且这样一来，开发人员不必操心程序在给定的文件夹中查找什么。如果增加了新素材，对应新增加的每个素材会增加一个新类，另外对于新增的资源还会增加一个新的文件夹。 出于某种原因，开发人员可能决定职责链采用一种不同的顺序。这很容易，只需要改变原客户的后继，其他所有内容都不用改变。不论如何计划，使用设计模式完成修改都会比尽可能缩减代码要容易得多。有些做法尽管短期奏效，但长期来看可能并不合适。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[策略模式的灵活性]]></title>
    <url>%2F2019%2F08%2F23%2F%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%81%B5%E6%B4%BB%E6%80%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 封装算法结合MySQL使用PHP时，要完成的任务之一是需要编写算法来处理对MySQL应用做出的不同类型的请求。一般的请求包括创建表，或者输入、选择、修改和删除数据。对于这些不同的请求，算法可能很简单，也可能很复杂，这取决于请求以及表的复杂性。 设计模式的主要原则之一是封装变化的内容。对于发送到PHP类的不同类型的请求，分别有不同的算法来处理这些MySQL请求，变化的显然是算法。这些变化可能很小，也可能是显著的变化，不过通过使用策略（Strategy）设计模式，我们可以大大简化这个过程。 一般来讲，使用设计模式时，首先要考虑“什么会导致重新设计”？然后要避免那些导致重新设计的因素。不过，有没有一种方法既能做出改变又无需重新设计呢？通过封装那些变化的内容，程序员应首先确定程序中哪些会变化，然后封装这些特性。这样一来，一个设计需要改变时，可以改变封装的元素，而不会影响系统的其余部分。由于不同的MySQL任务需要不同的算法，可以封装这些算法（任务），所以策略设计模式非常适用。 区分策略和状态设计模式首先来看图1，它是策略设计模式的类图。 图1：策略设计模式类图 再回到第10章，看看图1，其中模式参与者的组织与图1中非常相似。在两个设计中，Context参与者都与一个接口有一个聚合关系。在状态模式中，接口为State，在策略模式中则是Strategy接口。除此以外，它们看起来是一样的。 要了解二者的差别，需要了解两个Context参与者与Strategy和State接口及其具体实现的关系有什么不同。表1对这些差别做了一个总结。 表1：状态和策略设计模式中上下文和变化的差别 模式 什么会变化？ 上下文 状态 状态 维护子类当前状态的一个实例（定义了当前状态） 策略 算法 配置为具体策略对象，这是一个封装的算法。 在第10章可以看到， Context包含一个变量，保存了当前的具体状态。这个具体状态提供了一些方法，可以从Context变量中记录的当前状态变迁到另一个状态。 不过，策略模式中的Context参与者并没有记录当前使用的策略。它没有理由这么做，这是因为，与不断改变的状态不同，一般来讲，改变的算法并不依赖于当前正在使用的算法。显然，有些情况下，执行一个算法之前可能首先要使用另一个算法，如试图访问一个表中的数据之前，需要先在表中插入数据。不过，这并不妨碍使用算法尝试从一个空表获取数据。但在状态模式中很容易出现这样一种情况：即一个状态只能进入某些状态，而不能转移到另外一些状态。在第10章中的三路灯泡例子中，如果灯泡处于第二个on状态，就不能进入第一个on状态，也不能进入off状态。它只能转移到第3个on状态。（见第10章中的图5）大多数算法都不是这样。 请不要加条件语句状态和策略设计模式有很多共同的特性，其中之一是Context参与者要避免使用条件语句。如果查看第10章中的例子，你会注意到，这些例子都没有条件语句。第10章的“何时使用状态模式？ ”一节中提供了一些伪代码，指出使用条件语句从一个单元格到下一个单元格难度很大。（不过不用担心，要在一组已有的状态中增加新状态，或者要改变已有的状态，这些都很容易！） 设计模式并不是要求永远不要使用条件或case语句，不过在一些模式中（如状态和策略设计模式），使用条件语句可能会导致维护相当困难。如果要改变一个策略（封装的算法），而且需要改变一大堆条件或case语句，那么引入错误的可能性会更大。另外需要说明，使用这两个模式时，客户参与者中引入条件或case语句是可以接受的，因为客户所要做的就是做出请求。另外，在封装的算法中（具体策略），完成某个任务可能需要一个条件或case语句。类似地，在使用mysqli实现数据输出和错误检查时，往往都会有条件语句。利用策略，不再需要条件语句来选择所需的行为。不同的任务由不同的具体策略来处理，因为客户通过上下文请求具体策略，它必须知道有哪些可用的策略。这并不是说客户选择过程中不能使用条件语句，而是说条件语句不是上下文的一部分。 算法族GoF的《设计模式》中，有些元素的介绍不太详细，其中就包括“算法族”（family of algorithms）的概念。开发人员需要定义一个算法族，但GoF并没有指定设计模式上下文中“族”（family）一词的确切含义。不过，在《Head First Design Patterns》一书中，提出了一个很简单但很有用的概念——行为集（a set of behaviors）。任何依赖于一组特定行为的项目都可以转换为一种策略设计模式，将那些行为封装为策略。也就是说，需要某种算法才能实现这些行为。通过将它们封装为具体的策略，就能使用、重用和完成修改。 这一章中的“族”由使用MySQL表通常所需的行为组成。一般需要输入、修改、获取和删除数据。这些涉及数据操作的行为就构成了一个“族” ，每个族成员可以转换为一个策略。实现这些策略需要不同的算法，还要结合使用MySQL命令和PHP mysqli类。把这些操作放在不同的具体类中（所有具体类实现一个公共接口） ，就成为了策略设计模式的一部分。 最简单的策略模式为了查看使用MySQL连接的一般模式，第一个例子中并没有使用表，而是建立了一个一般模式，以便以后加入各个策略中的细节。由于HTML表单不能把选择的参数传递给PHP类或文件，这个例子会使用多个短小的PHP触发器脚本。这些触发器脚本调用客户的不同方法，客户再通过上下文调用所请求的具体策略。 图2显示了这个实现的文件图。对于每个策略，HTML文件中分别包含相应的表单，表单数据通过一个PHP触发器脚本传递到Client中的方法。Client再通过Context进一步将请求传递到一个具体策略。连接辅助类包括一个接口和类，可以用来连接一个MySQL数据库。 有些开发人员在处理MySQL数据库方面有着丰富的经验，对他们来说，图2看起来可能有些“过度设计”。不过，设计模式的目的是为了便于修改和重用对象。每个具体策略会得到封装，因此只要保持所实现的接口不变，对具体策略的任何修改都不会破坏系统。即使从这个最小策略的角度来看，也很容易看出具体策略中的行为是开放的，允许各种不同的实现。 客户和触发器脚本Client类通过Context做出请求，来创建一个具体策略。这里利用了一组方法来完成对不同策略的请求。请求的关键是下面这两行代码：12$context = new Context(new ConcreteStrategy());$context-&gt;algorithm(); 每个Client方法提供了要实现的具体策略的名，algorithm()是具体策略中实现的一个Context方法。这个过程可以展示多态（polymorphism）是如何工作的。Client通过一个Context实例发出请求，来请求具体方法的算法，所以所有算法请求看起来都很像，都是$context-&gt;algorithm()。不过， Client要实例化Context，并提供一个具体策略作为参数。通过实现具体策略的algorithm()方法，这个参数允许Context使用所请求的具体策略。这样一来，通过采用策略模式，算法就可以独立变化，而不影响使用该算法的客户。在下面的例子中，没有使用多个不同的Client类，而是利用多个不同的触发器脚本来使用相同的客户： 为了触发不同具体策略（封装的算法）的方法，HTML会调用以下的一个PHP触发器脚本：12 HTML文档中的表单分别调用各个不同的PHP触发器。触发器脚本发出的请求传递到客户，客户再针对各个请求使用相应的一个方法。在策略设计模式中，客户通常会创建一个具体对象并传递到上下文。不过，最初的请求是由HTML文档发出：12 在这个设计中，比较困难的一点是要保护$_POST数据，为此可以使用mysqli-&gt;realescape-string()方法抽取由HTML文档发送的数据值。可以在提交的所有数据中包含-个额外的变量，指示客户将要使用一个具体策略请求方法，这样就能做出选择而无需使用大量触发器脚本。可以在客户中建立MySQL连接，取出数据、关闭连接，然后把请求继续传递到具体策略，在这里打开第二个连接，通过适当的策略处理这个请求。不过，这个例子的重点是设计模式，而不是解决所有安全问题。所以这里分别提供不同的触发器脚本来完成各个请求。 Context类和Strategy接口在状态模式设计中，Context类相当于一个“跟踪者”（track keeper），它会跟踪当前的状态。在策略模式设计中， Context则有完全不同的功能，用于将请求与具体策略分离，使策略和请求可以独立地工作。这体现了请求与后果之间的另外一种松绑定。与此同时，它还有利于从Client发出请求。 Context不是一个接口（既不是抽象类也不是接口），不过它与Strategy接口有聚合关系。“四人帮”指定了以下特征： 用一个具体策略对象来配置（参见“客户与触发器脚本”一节中Client类如何实例化Context） 维护Strategy对象的一个引用 可以定义一个接口，允许strategy访问其数据。 在下面的代码清单中，可以看到ConText类的上述特征：12 对于以上的3个特性，第一，构造函数希望有一个Istrategy实现作为参数。第二，通过-个封装的属性$strategy（可见性为私有）来维护strategy对象的一个引用。$strategy属性从构造函数参数接收strategy对象实例，这将成为一个具体策略实例。第三，algorithm()方法实现了Istrategy的algorithm()方法，实现为通过Client选择的具体策略。由于Context和Istrategy构成一个聚合关系，所以Context具有抽象类或接口的某些特性。实际上，最好通过聚合来理解Context。查看策略接口Istrategy时，可以看到要实现的方法是algorithm()：12345&lt;?phpinterface IStrategy&#123; public function algorithm();&#125; 各个具体策略可以采用所需的方式实现这个方法。 具体策略构成具体策略的封装算法族提供了所有可能的策略。对于这个最简单的例子，关键是要了解策略设计模式中不同的参与者如何协同工作。在这一节中，你会看到一个完全实现的例子。 5个具体策略包括以下类： DataEntry DisplayData SearchData UpdateData DeleteData 这些具体策略分别表示结合使用PHP和MySQL的典型算法。 DataEntry 第一个策略表示向一个表中输入数据：12 DisplayData 在这个例子中并没有使用$_POST[‘data’]，因为这个算法只显示字符串”Here’s all thedata!”，它作为一个字符串直接量赋给变量$test：12 SearchData 搜索项在$_POST[‘data’]中，将传递到$test变量：12 UpdateData “新”数据在$_PoST[‘data’]中，并传递到$test变量。在实际的实现中，还可能包含字段名： DeleteRecord 最后，会有一个唯一标识符传入$-POST[‘data’]并存储在stest中，通过使用这个唯一标识符，可以从表中删除一个记录：12 连接接口和类 所有具体策略都实现相同的连接对象（与其他章中一样）。下面的接口包含了实际程序使用的名：12 通过使用一个连接类和单独的接口，可以更容易地重用和修改。这里只会修改接口中的常量值。 增加数据安全性和参数化算法来扩展策略模式在上一节给出的最简单的例子中，可以看到结合使用MySQL数据库时PHP策略设计模式的所有基本元素。为了构建一个更健壮的例子，下面这个例子会为不同策略增加功能。这里还增加了一个辅助类，来处理数据从HTML客户到MySQL数据库的安全移动。这说明，客户可以使用通过mysqli-&gt;real_escapestring($_POST[‘data’])函数传递的数据做出安全的请求。Client类可以自己处理安全性，不过这样一来，除了做出请求外，会为Client类增加额外的责任。 数据安全性辅助类通过使用mysqli-&gt;real_escape_string($_POST[‘data’])函数，在HTML表单和PHP类之间安全地传递数据，需要有一个MySQL连接，不过一旦打开连接并安全地传递了数据，可以再关闭这个连接，释放连接占用的资源。 考虑到会有不同的具体策略，这个辅助类对于保证各个具体策略的数据安全性分别提供了不同的方法。一个方法是向Client传回一个数组，其中包含该请求所需的数据。图3通过图示表示了辅助类与Strategy的关系。 图3：增加一个辅助类处理数据安全性 图3中没有显示策略模式中Context类后面的部分，不过它仍然遵循图1所示的标准类图。另外，前面使用了MySQL辅助类处理数据库请求，SecureData类同样使用这个辅助类来创建MySQL连接。 对于每一个依赖于HTML表单数据的具体策略， SecureData类中分别提供了相应的方法。DisplayA11具体策略请求显示所有数据，所以它不需要由HTML表单传递的特殊数据：12 除了setEntry()之外，所有方法都生成一个名为dataPack的数组。setEntry()方法会返回这个dataPack数组的当前内容。取决于具体的请求， SecureData类生成将置于数组中的值，这会传回到Client，并通过algorithm()方法作为请求的一部分发送到一个具体策略。 为算法方法增加参数第二个要增加的特性是修改Strategy算法方法。我们将增加一个数组作为函数的一个参数，这样可以增加灵活性，处理更多的内容。每个算法函数调用都包含一个数组，其中包含从HTML表单传递的数据：123456&lt;?phpinterface IStrategy&#123; const TABLENOW ="survey"; public function algorithm(Array $dataPack);&#125; 同样，还要为接口增加一个常量TABLENON，由于这个实现中各个具体策略都使用相同的表，而且PHP能够通过接口传递常量，因此可以建立一个松耦合而且可重用的代码。显然，如果不同的具体策略要使用不同的表，就必须在各个具体策略中指定表引用。参数中的类型提示指示要将数组用作为一个实参。 调查表下面的脚本用于创建一个调查表（数据库表） 。策略设计模式中可以使用更大或更小的表，为此只需要调整具体策略中所用数组的大小：12 这个特定的类用于创建数据库表，仅在开发和调试阶段使用。一旦建立了所要的表，而且希望安装在不同的系统上，可以删除下面这段代码：123456$drop = "DROP TABLE IF EXISTS sthis-tableMaster";if(sthis-&gt;hookup-&gt;query($drop) = true)&#123; printf("Old table %s has been dropped.&lt;br/&gt;"，$this-&gt;tableMaster);&#125; 并将以下代码：1$sql = "CREATE TABLE Sthis-tableMaster （ 修改为：1$sql= "CREATE TABLE IF NOT EXISTS sthis-&gt;tableMaster （ 这样一来，如果原来的表中已经存储有数据，就不会被CreateTable类删除。本章中所有其他的MySQL连接都会使用同样的UniversalConnect类。 数据输入模块利用SecureData辅助类和修改后的IStrategy接口（可以为algorithm()方法包含一个参数），对于不同的HTML表单请求，Client可以根据相应的方法更容易地做出请求。在继续学习下面的内容之前，先来看看HTML表单中发出的请求。这里使用了两个表单：一个允许用户输入调查数据，另一个用于查看存储在MySQL表中的数据。两个表单都非常简单，是很通用的HTML表单。两个表单使用同一个CSS文件：12 CSS只是用来稍做区分。 首先，调查表单只有一个简单的文本输入，另外可以利用单选钮做一些选择：12 图4显示了在一个平板设备上打开的调查表单。 第二个HTML文档提供了一个管理工具，可以用来检查数据库中的表。同样的，这个HTML表单也很简单，通过策略设计模式将数据从其来源（数据库表）放入HTML表单中：12 这两个用户界面（UI）都使用了移动布局，只有一列，可以调整这个布局以便在支持互联网功能的移动手机上查看。 两个HTML文档中的按钮分别表示不同的表单。每个表单调用一个触发器文件，再实例化Client类，并调用所需的方法来完成所请求的任务。 客户请求帮助Client没有构造函数，不过有多个方法，可以做不同的请求。这些方法与最简单的例子类似，不过在前面讨论的SecureData辅助类（见“数据安全性辅助类”一节）的帮助下，这些方法可以做更多工作。 首先请回顾SecureData类的工作，然后再来分析Client：12 除了showAll()方法外，Client中的所有方法都会首先实例化SecureData类、然后使用具体方法作为参数来创建一个上下文对象。接下来，SecureData对象调用具体策略的相应方法创建所需的数组。最后Client方法调用Context-&gt;algorithm（），并使用SecureData类返回$secure-&gt;setEntry（）数组作为参数。数组的内容取决于HTML表单发送的用户输入以及所请求的策略类型。 “四人帮”指出，不论是否使用，所有具体策略类都有一个共同的接口。因此，所有具体策略类都必须实现Strategy接口的方法（Istrategy中的algorithm()方法）。不过，并不是所有具体策略都需要这个算法，当然实现方式也不完全相同。 可以看到，从某种程度上讲，Client类中的showAll()方法就不需要这个算法。这个方法没有使用SecureData类返回的一个数组，而是创建了一个dummy数组，并把它用作为Context-&gt;algorithm()的参数。这是为了满足IStrategy接口的需求，接口要求这个方法必须包含一个数组作为参数。 Context类重要的小改变与这一章第一部分中最简单的例子相比，Context类几乎没有改动，只是为algorithm()方法增加了一个参数，这是更新后的Istrategy接口提出的要求。由于context类和IStrategy之间有一种聚合关系，Context类必须包含Istrategy的一个引用。类似于前面最简单的例子，同样要用一个具体策略对象创建Context，这一部分未做任何改变。不过，它还包含一个方法，将实例化具体策略的algorithm()方法实现：12 注意：Context类方法的名字也是”algorithm” ，它要求有一个数组参数。两个方法都命名为algorithm，其目的是为了强调上下文和策略参与者之间的聚合关系。如果觉得有些混淆，可以把这个方法重命名为contextAlgorithm，使它与IStrategy的algorithm()方法有所区别。 Context还有另外一个属性$dataPack，反映了通过Context algorithm()方法传递的数组的名字。然后再传递到具体策略的algorithm()方法。 具体策略通过一个数组向具体策略传递数据的根本目的是允许不同的策略对不同的请求做出响应。这样可以为设计提供灵活性，因为利用数组可以传递大量数据。在下面的具体策略类中可以看到，每个策略类都实现了IStrategy algorithm()方法，其中使用了通过方法数组参数传递的数据。 最简单的策略例子中使用了一个UniversalConnect类，这里的所有具体类同样使用了这个类。表名作为一个常量（TABLENOw）存储在IStrategy接口中。 DataEntry 在所有具体策略中，DataEntry类使用的数组最大。这是因为它必须插入HTML调查表提交的所有数据：12 这里只是标准MySQL语句中使用了条件语句。作为这个类的核心，通用算法没有使用任何条件语句。 DisplayAll将为这个类传递一个dummy数组。可以看到，它只是使用一个通用算法从数据库表向屏幕发送数据：12 表格可以更好地显示数据，不过它可不是最优的实现。实际上，由于我们的重点是实现设计模式，所以这个格式要尽可能简单。图6显示了这个输出。 SearchData 搜索算法将从一个指定字段选择一个指定值。字段名和搜索值通过数组作为一个参数传入algorithm（）方法。如果匹配，则会显示匹配的记录，如果没有找到匹配，就不显示任何结果：12 也可以替换一个更精巧的算法和显示设计，这很容易。如果需要更多数据，可以修改HTML文档中生成的数据，并把它们放在SecureData类中的一个数组中，这很简单，很容易做到，而且不会影响程序的任何其他组件，对于所有设计模式来说，这都是必不可少的一个要素。图7显示了在Designer/Developer字段中搜索”designer”的结果。 图7：输出显示”designer”的所有匹配结果 UpdateData 要改变当前字段中的值，这个实现只需要三个要素：字段名、原来的值和新值。这个算法很灵活，与所有其他具体策略一样，可以修改算法来反映具体的需求：12 这个输出通知用户已经完成了一个修改。 DeleteRecord 最后一个具体策略将删除一条记录，为此只需要数组中的一个元素来传递要删除的记录号。由于创建表时采用的是一种自动编号机制，标识号是一个整数：12 这个类和相应的具体策略很简单，如果想增加一个更健壮的算法，也很容易做到，而不会破坏程序的其余部分。 灵活的策略模式策略模式很灵活，改变算法时可以只改变一个实现，不仅如此，模式本身还可以有多个实现。一方面，这一章展示了一个最简单的策略设计模式，它可以调用不同的算法，这些算法独立于具体策略之外的数据;另一方面，第二个例子使用了参数，可以向具体策略传递安全的数据。 “四人帮”指出，一种做法是由Context通过参数向Strategy操作传递数据。这正是第二个例子采用的做法。这种方法可以得到提交给策略的数据，同时保证Context与Strategy解耦合，但也可能向Strategy传递它不需要的数据。对于这个问题，可以使用一个数组来解决，利用这个数组（这也包括一个空数组），为Strategy传递数据时会有更大的灵活性。 特定的策略模式实现依赖于特定算法的需求以及它具体需要些什么。一些策略模式实现会存储其上下文的一个引用，因此没有必要传递数据。不过，这样一来， Context和Strategy会更紧密地耦合。 还有一个问题需要考虑：即策略模式所生成的对象（具体策略）个数。在这一章的例子中可以看到，它们都构建了大量的对象（类）来处理一个简单MysQL调查（由PHP驱动）的不同请求。还有可能构建更多对象。不过，相对于重用性以及改变模式所带来的好处，这可能不算太大的问题。构建设计模式是为了提高管理一个应用的速度，而不是为了提高执行代码的速度。如果采用了良构的策略模式，开发人员可以很容易地优化和重新优化封装的算法，而不会搞得一团乱麻。所以速度表现在重用和修改时间上，而且额外对象的开销很小。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模板方法模式]]></title>
    <url>%2F2019%2F08%2F23%2F%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 什么是模板方法模式首先，要区别两个概念，模板方法（Template Method）设计模式中使用了一个类方法templateMethod()，要知道这二者是不同的。templateMethod()是抽象类中的一个具体方法。这个方法的作用是对抽象方法序列排序，具体实现留给具体类来完成。关键在于，模板方法模式定义了操作中算法的“骨架”，而由具体类来实现。 关于模板方法模式，值得高兴的是它相当简短，实现很容易。只需要一个抽象类和一个具体类，如图1所示。 图1：模板方法类图 可以把抽象类中的模板方法操作看做是“基本操作的组织者”。后面提到模板方法设计模式时，我会将首字母大写（Template Method），谈到模板方法操作时，则会用小写（template method operation）。就像考虑婚礼司仪，她要按某种顺序安排仪式中的一系列事件（操作），包括宴会、切蛋糕、第一支舞、发表感言以及仪式中可能的所有事件。婚礼司仪会遵循一个模板，按一种给定的顺序合理地组织事件，不过她会让新娘的家人具体决定希望如何执行这些事件。例如，宴会可能是一个正式宴会，也可以是一个户外的烧烤晚会，舞蹈可能选择华尔兹也可能是街舞（hip-hop），乐队可以是整个乐团，也可以只请一位手风琴师。事件发生的顺序都是一样的，不过它们的实现有所不同。 何时使用模板方法如果已经明确算法中的一些步骤，不过这些步骤可以采用多种不同的方法实现，就可以使用模板方法模式。“四人帮”指出，如果算法中的步骤不变，可以把这些步骤留给子类具体实现。在这种情况下，可以使用这种设计模式来组织抽象类中的基本操作（函数/方法）。然后由子类实现应用所需的这些操作。 还有一种用法稍微复杂一些，可能需要把子类共同的行为放在一个类中，以避免代码重复。“四人帮”援引了Opdyke和Johnson的“重构为一般性”（refactoring togeneralize），以此描述将重复的代码组织到模板方法模式中的过程。如果使用多个类来解决同一个大型问题，可能很快就会出现重复代码。 最后一点，还可以使用模板方法模式控制子类扩展。这里涉及一个“钩子”操作，将在“模板方法设计模式中的钩子”一节中讨论。可以利用“钩子”控制扩展：只在钩子操作所在的某些位置允许扩展。 最简单的例子：对图像和图题使用模板方法模式在PHP编程中，可能经常会遇到一个问题：要建立带图题的图像。这个算法相当简单，无非是显示图像，然后在图像下面显示文本。 由于模板方法设计中只涉及两个参与者，所以这是最容易理解的模式之一，同时也非常有用。抽象类建立templateMethod()（具体的方法），并由具体类实现这个方法。 抽象类抽象类是这里的关键，因为它同时包含具体和抽象方法。模板方法（这里是指方法本身）往往是具体方法，其操作是抽象的。 要加载一个图片，只需要一个操作使用HTML包装器调用图像URL，要得到文本作为图题并把它放在图像下面，这个操作也同样很简单。 两个抽象方法分别是addPix($pix)和addCaption($cap)。这两个操作都包含一个参数，分别表示图像的URL信息和图题字符串。templateMethod()函数中设置了这两个属性，属性可见性为保护（protected），以提供封装：12 在模板方法函数中增加这两个参数，以便接收实参，再将接收到的实参进一步传递到保护属性。 具体类要使用模板方法的具体类扩展这个抽象类，并实现基本操作addPix()和addCaption()。算法要求提供相应的代码，可以用来显示图像和适当的图题：12 这里并没有返回一个对象，而是由这两个操作使用echo语句将结果发送到屏幕。这样做是为了尽可能简化这个例子。现在客户可以使用addPix()和addCaption()方法了。 客户“四人帮”讨论这种设计模式时并没有提到客户，不过类似于客户作为其他设计模式中的一部分，在这里客户就相当于UI连接的基础。所以，可能需要模板方法模式的任何上下文中，都可以考虑这样一个简单的Client类：12 注意，$mo变量实例化了ConcretecClass，但是它调用templateMethod()，这是从父类继承的一个具体操作。父类（AbstractClass）通过templateMethod()调用子类的操作。图2显示了相应的输出。 图2：模板方法建立的图片-图题序列 实际上，客户只需要提供图像URL和图题文本串。 好莱坞原则“反向控制结构”概念另外也称为“好莱坞原则”（the Hollywood Principle）。这个原则是指父类调用子类的操作，而子类不调用父类的操作。（就像试镜之后，导演告诉年轻的演员，“如果你拿到这个角色，我们会通知你。不要打电话来询问；我们会打电话给你的”。正因如此，这种反向控制结构被称为好莱坞原则。） 与好莱坞原则关联最紧密的模式就是模板方法模式，因为它在父类中实现。除了templateMethod()，父类中的其他操作（方法）都是抽象和保护方法。所以，尽管客户实例化一个具体类，但它调用了父类中实现的方法。图3可以帮助你更清楚地理解这种反向控制结构。 图3：好莱坞原则 不过，我们真正想问的是：为什么好莱坞原则对于OOP和设计模式很重要？从某些方面来讲，这个问题和答案的关键在于与顺序和过程编程思维划定界限。在过程编程中，关键问题是控制流（flow of control），在OOP中，关键问题则是对象职责（object responsibility）。由于过程编程的重点在于控制流，一些解释会使用“控制反向”（inversion of control）来解释好莱坞原则。控制反向从过程编程的角度来讲很有意义，不过在OOP中，大多数控制流都会通过对象职责和协作抽取出来。也就是说，并不是考虑控制流，而应考虑哪些对象将处理某些职责，另外对象如何协作来完成任务。 要在OOP上下文中准确地理解好莱坞原则，最简单的方法就是从框架以及框架中可能的改变来考虑[这里我使用“框架”（framework）这个词来表示程序中的小结构，而不是第3章中与设计模式相区别的那些更大的结构]。模板方法定义了框架，子类可以扩展或重新实现算法的可变部分，不过它们不能改变模板方法的控制流。从子类发出“调用”是重新实现父类的方法，这是好莱坞原则不允许的一种“调用”。只有父类可以做出“调用”来建立或改变框架（操作的执行顺序）。 要理解好菜坞原则，更好的办法可能是按幼儿园里老师和学生之间的关系来考虑，也就是幼儿园原则（Kindergarten Principle）。老师建立一些项目，让孩子们按某种顺序完成，比如数数、认时间，背单词。老师设定好顺序，但是孩子们具体如何完成或者如何实现则由孩子们自己决定。不过，孩子们不能改变老师定好的这个顺序。换句话说，孩子在数数练习中间不能说“我现在想背单词”。这个结构是有序的： 1.数数2.认时间3.背单词 老师说，“抱歉，Elmo，我们现在要数数。过一会再背单词吧”。对孩子们来说，这个顺序是不可变的。所以只能由老师来掌控，没有其他可能。在这种情况下，控制反向是不合适的：由父类建立顺序，子类按自己特有的方式完成这些操作。直观看来这并不是“反向”。所以，如果讨论好莱坞原则时谈到控制反向，要记住这个“反向”只在过程编程的控制流上下文中才有意义。 结合其他设计模式使用模板方法模式设计模式并不是孤立存在的，它们存在于编码对象的大环境中，其中一些对象可能是其他设计模式。为了说明这一点，下面结合工厂方法模式来实现第一个例子，我们可以得到相同的结果，即显示一个有图题的图片。由于这个例子只使用了一个图像和图题，看起来有点像高射炮打蚊子——大材小用了，不过，关键是要知道这两个设计模式如何合作。如果你理解了模式之间的交互，就能结合使用更多的模式。模板方法模式将建立算法的顺序，以给定的顺序来显示图像和图题，工厂方法模式则具体创建对象。图4给出了相应的文件图，两个不同模式分别用灰边框区分。 图4：有关联关系的模板方法和工厂方法文件图 结合使用这两个模式是因为它们分别承担不同的角色。模板方法模式建立算法的顺序（首先是图像，然后是图题），工厂方法模式则创建图像和图题。看到这个，你可能认为客户不得不做出请求；不过，情况正好相反。 客户工作负担减轻客户的请求会通过模板方法模式做出。模板方法模式负责组织操作，从而能按适当的顺序自动地传递请求：12 在这里，Client类主要是错误检查和加载必要的类。只有两行代码与请求有关：12$mo = new TmFac();$mo-&gt;templateMethod(); 连接两个不同的设计模式之后，Client的工作居然会减少，这看起来有些讽刺，不过利用模式很容易做到。模板方法模式将建立算法的顺序，这些算法再调用工厂来创建图像和图题。所以，Client所请求的只是将接收请求的方法。 模板方法参与者与之前最简单的例子相比，创建模板方法模式的两个类稍有改变。在某些方面， TmFac类相当于一个客户，因为它会向工厂方法模式中的工厂发出请求：12 templateMethod()操作指定TmFac类中方法的顺序，调用templateMethod()后会按指定的顺序来调用工厂。 工厂方法参与者Client类与工厂方法模式之间没有任何通信。最初的请求由模板方法操作传递，不过它们没有留下任何“足迹”（暂且这么说）。工厂方法参与者所响应的是来自TmFac对象的请求：12 图5与图2几乎完全相同，只是图题的样式不同。从templateMethod()向工厂做出请求后，由工厂实现的产品会生成图题的样式。 图5：按照templateMethod()中的步骤生成的图像和图题 图5的重点是，由于设计模式力求所有参与者（类和相应的对象）松耦合但相互连接，所以程序很灵活，完全可以通过所有类和接口来返回图像和图题。对于一个简单的图像和图题，可能注意不到这个好处。不过，对于更复杂的算法，如果有更多的步骤，模板方法模式可以提供一个可重用的顺序来组织职责集。产品以及产品中的变化都将通过同样的接口来处理。 模板方法设计模式中的钩子有时模板方法函数中可能有一个你不想要的步骤，某些特定情况下你可能不希望执行这个步骤。例如，假设有一个模板方法，可以累加一个订单的总费用，另外加上税和运费，然后显示交易总金额。不过，顾客告诉你，如果买家购买需要送货的商品超过200美元，可以免运费。这里就可以用到模板方法钩子。 在模板方法设计模式中，利用钩子可以将一个方法作为模板方法的一部分，不过不一定会用到这个方法。换句话说，它是方法的一部分，不过它包含一个钩子，可以处理例外情况。子类可以为算法增加一个可选元素，这样一来，尽管仍按模板方法建立的顺序执行，但有可能并不完成模板方法期望的动作。对于上面这种运费可选的情况，钩子就是解决这个问题最理想的工具。 你可能认为，这与好莱坞原则有冲突（子类没有遵循父类设置的顺序），这样想也没错。好莱坞原则要求只有父类能够改变框架。钩子很特殊，因为尽管它实现了模板方法中的方法，但实现的方法有一个“后门”，也就是说，它会处理例外情况。 要了解钩子是如何工作的，来看一个简单的例子。一家公司销售GPS设备和地图，为顾客沿赞比西河徒步旅行提供帮助。它还提供租船业务。公司老板决定，如果买家购买的需要送货的商品超过200美元，可以免收运费。不过，这不包括租船的费用。所以，他需要这样一个程序，可以累加送货商品的费用，确定是否增加运费，然后加上租船的费用，最后显示总金额。图6显示了这个程序的用户界面。 UI HTML代码使用了一个表单，以便数据输入，表单中使用了单选钮和复选框。单选钮和复选框都有一个值，分别表示产品或服务的价格。下面的HTML代码清单中包括一个HTML数组，用来提供地图选择：12 一旦用户单击“Send order”（发送订单）按钮，PHP Client类就会启动。不过，先来看这里采用的模板方法模式。 建立钩子在模板方法接口中建立钩子方法看起来很有意思，尽管子类可以改变钩子的行为，但仍然要遵循模板方法中定义的顺序：12 这里有3个抽象方法——addTax()、addShippingHook()和displayCost()，抽象类IHook实现的templateMethod()中确定了它们的顺序。在这里，钩子方法放在中间，实际上模板方法指定的顺序中，钩子可以放在任意位置。模板方法需要两个参数：一个是总花费，另外还需要一个变量用来确定顾客是否免收运费。这些值必须由Client类提供，Client类则从HTML文档接收原始数据。 实现钩子一旦抽象类中建立了这些抽象方法，并指定了它们执行的顺序，子类将实现所有这3个方法：12 addTax()和displayCost()方法都是标准方法，只有一个实现。不过，addShippingHook()的实现有所不同，其中有一个条件来确定是否增加运费。这就是钩子。 客户以及捕获钩子由于可以使用二进制字符，开发人员通常会忽视布尔变量的重要性。不过，实际上处理布尔变量很简洁，速度也很快，我发现它们对于捕获钩子尤其适合。在所有钩子操作中，必须有人警告控制流：将有不同的情况发生，而不是正常地执行模板方法中指定的那些默认操作。 用比较操作符设置布尔值 不必使用条件语句来建立一个布尔状态，使用比较操作符会更容易，也更简洁。客户中包含以下代码行，可以为前面的模板方法例子中的钩子设置布尔值。1$this-&gt;special = （$this-&gt;buyTotal &gt;= 200）; 这会为布尔变量$this-&gt;special赋一个状态true或false，Zambezi Trading Post为货运商品超过200美元的所有订单提供了免收运费的特殊优惠。 接下来看Client类，可以看到模板方法设计模式中的请求如何访问钩子。 Client类 Client类根据从HTML表单接收的数据做出一个请求。它必须将租船的费用与购买设备的费用区分开，只根据设备购买费用来计算特殊折扣。将special设置为true或false后，再累加总金额，还要加上税费。由于变量$special是一个布尔变量，不会把它增加到总金额。实际上，$special会作为一个参数传递到templateMethod()方法：12 首先，利用从单选钮传入$gpsNow变量的值来确定设备的总费用，然后通过一个循环将所有传入复选框数组（$mapNow）的值累加起来，如上一节所述，此时已经建立了布尔变量$special；最后，加上通过一个单选钮传入的$boatNow值。设置$special之后，程序将$boatNow值与$buyTotal值相加。现在可以把这两个变量中的值发送到主程序，主程序将在$templateMethod()参数中使用这两个值。 这个例子很简单，用户的数据输入也很容易，最重要的是，只需要重写Client，就可以很容易地重用这个设计。换句话说，这个设计是可改变而且可重用的。这个例子中使用直接量来表示运费和税费，不过，它们同样也可以修改为不同的值取代直接量。完全可以用客户传入的值，甚至可以使用可计算的费用，而不是直接量。 短小精悍的模板方法模式学习设计模式很不容易，并不适合那些心存畏惧的人，不过模板方法模式不仅很简单，还有很多经验可以借鉴。首先，要解释好莱坞原则，采用模板方法模式是最适合的。这个原则中的“调用”概念实际上是指“遵循某个顺序”。父类（抽象类）建立操作，并设置它们的顺序，而子类具体实现这些操作。“不要打电话来询问，我们会打电话给你的”可以改写为：“我们会建立面试、试镜和才艺测试；你要按我们建立的顺序完成这些测试，但是可以采用你喜欢的任何方式。只是不要改变这个顺序！” 模板方法模式还有一个重要的方面，要记住这是一个设计模式，可以与其他设计模式结合使用。你已经看到，它能与工厂方法模式很好地合作，同样地，这个模式还能与抽象工厂模式协作（而且这样更有帮助）。模板方法模式很简短，所以可以作为其他模式的一部分，也可以作为一个辅助类在很多其他模式中使用。 关于模板方法模式，最好的一点是它很容易学习，而且有重要的经验可以借鉴。不错，模板方法模式有很多应用，这也很重要，不过概念和思想才是设计模式中最重要的部分。作为一个很容易掌握和学习的模式，尽管它很短小，但确实很有意义。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[装饰器模式1]]></title>
    <url>%2F2019%2F08%2F23%2F%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F1%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 什么是装饰器模式作为一种结构型模式，装饰器（Decorator）模式就是对一个已有的结构增加“装饰”。对于适配器模式，为现有结构增加的是一个适配器类，用来处理不兼容的接口。装饰器模式会向现有对象增加对象。装饰器也称为包装器（类似于适配器），Decorator参与者用具体组件包装Component参与者。图1显示了这个类图，不过在详细介绍这个类图之前，需要先考虑几个细节问题。 图1：装饰器类图[隐含Client] 首先，有些设计模式包含一个抽象类，而且该抽象类还继承了另一个抽象类，这种设计模式为数不多，而装饰器模式就是其中之一。从图1可以看到，通过一个环状聚合将Decorator连接到Component参与者。（“四人帮”给出的类图中使用的是直线，与直线相比，这里的环线看起来更像“包装”。）可以称为Decorator装饰器“包装”了Component。 这个设计既要创建要装饰的组件，还要创建装饰器。可以把Component参与者想成是一个要装修的空房间，要配上家具和地毯——家具和地毯就是具体装饰器。还要注意，所有参与者通过Component共享一个公共的接口。 这个图中包含有Client，不过它实际上并不是这个模式的一部分——甚至连隐含包含都不算是。基于这种松耦合，可以直接请求任何具体组件或装饰器。不过，使用装饰器模式时，Cient包含有Component接口的一个引用。 何时使用装饰器模式“四人帮”指出了使用装饰器的一般原则。基本说来，如果想为现有对象增加新功能而不想影响其他对象，就可以使用装饰器模式。如果你好不容易为客户创建了一个网站格式，主要组件的工作都很完美，客户请求新功能时，你肯定不希望推翻重来，再重新创建网站。例如，假设你已经构建了客户原先请求的所有组件，之后客户又有了新的需求，希望在网站中包含视频功能。你不用重写原先的组件，只需要“装饰”现有组件，为它们增加视频功能。这样一来，既可以保持原来的功能，还可以增加新功能。 有些项目可能有时需要装饰，而有时不希望装饰，这些项目体现了装饰器设计模式的另一个重要特性。假设你的基本网站开发模型可以满足大多数客户的要求。不过，有些客户还希望有一些特定的功能来满足他们的特殊需求。并不是所有人都希望或需要这些额外的功能。作为开发人员，你希望你创建的网站能满足客户的业务目标，所以需要提供“本地化”（customerization）特性，即针对特定业务提供的特性。利用装饰器模式，不仅能提供核心功能，还可以用客户要求的特有功能“装饰”这些核心功能。 由于Web和互联网日新月异（其范围更是飞速扩张），装饰器模式可能是你的开发工具包中的一个宝贵财富。使用装饰器模式就相当于你可以吃到蛋糕，或者至少可以装饰一些“糖霜”。 最简单的装饰器例子第一个例子先考虑最简单的装饰器模式，这里只包含最基本的参与者，不过完全可以清楚地展示一个PHP应用。这个例子描述了一个web开发企业，企业计划建立一个基本网站，并提供一些增强功能。不过，web开发人员知道，尽管这个基本计划适用于大多数客户，但客户以后很可能还希望进一步提升。 从这个最简单的装饰器例子还可以看出，利用装饰器模式，可以很容易地增加多个具体装饰器。除了这个例子中提供的3个装饰器之外，看看你能不能增加更多的装饰器。实际上这很容易。 另外由于你能选择要增加的装饰器，所以企业不仅能控制功能，还可以控制项目的成本。装饰器模式很容易使用，不仅能选择装饰中增加什么，还能选择哪些不用增加。 Component接口Component参与者是一个接口，在这里，它是一个抽象类IComponent。这个抽象类只有一个属性$site，另外有两个抽象方法getSite()和getPrice()。Component参与者为具体组件和Decorator参与者抽象类建立了接口：12 在PHP中，抽象方法只有一个很简短的签名，所以尽管getSite()和getPrice()会有期望的返回结果，但抽象方法声明中没有提供更多信息来指示应当生成何种类型的返回结果。 Decorator接口这个例子中的装饰器接口可能会让你感到惊讶。这是一个抽象类，而且它扩展了另一个抽象类！这个类的作用就是维护组件接口（IComponent）的一个引用，这是通过扩展IComponent完成的：12 与所有其他抽象类一样，你也可以实现方法和增加属性。不过，在这个最简单的例子中，Decorator类的主要作用就是维护组件接口的一个链接（引用）。 讨论具体组件参与者之前，下面来看这个装饰器模式实现的类图，如图2所示。 图2：最简单的装饰器模式实现的类图 所有这些参与者都有相同的接口。在所有装饰器模式实现中，你会发现，具体组件和装饰器都有相同的接口。它们的实现可能不同，另外除了基本接口的属性和方法外，组件和装饰器可能还会有额外的属性和方法。不过，从第一个例子我们可以得出，所有具体组件和装饰器都有共同的接口。 具体组件这个例子中只有一个具体组件，它生成一个网站名，另外生成一个基本网站报价（$1200）： 12 两个抽象方法都使用直接量赋值来实现（“Basic Site”和1200），不过灵活性并不体现在如何改变设置的值。实际上，要通过增加装饰器值来改变“Basic Site”值。下一小节会介绍这是如何做到的。 具体装饰器这个例子中的具体装饰器与具体组件有相同的接口。实际上，它们是从Decorator抽象类（而不是IComponent类）继承了这个接口。不过，要记住，Decorator所做的就是继承IComponent接口。 Maintenance 12 查看这个具体构造函数，你会发现，它看起来与装饰器几乎完全相同。不过，每个具体装饰器在它包装的具体组件价格上还会增加它自己的一个价格。另外两个具体装饰器与Maintenance装饰器也类似。 Video 12 Database 12 测试这个应用时，可以看到，在基本价格之上还会增加各个装饰器的价格。另外还指定了装饰器名的格式，增加了两个空格，使之缩进。 装饰器实现中最重要的元素之一就是构造函数，要为构造函数提供一个组件类型。由于这里只有一个具体组件，所有装饰器的实例化都会使用这个组件。使用多个组件时，装饰器可以包装应用中的一部分或全部组件，也可以不包装任何组件。 客户Client类并不是这个设计模式的一部分，甚至连隐含包含都不算是，尽管如此，正确使用Client类至关重要。每个装饰器必须在实例化时“包装”组件，这在上一节已经看到。不过，首先必须创建一个要包装的BasicSite类实例：12 一旦Client实例化BasicSite，会有一个wrapComponent()方法检查这个实例，以确保参数有正确的数据类型（IComponent），然后分别实例化3个装饰器。（在装饰器设计模式的典型用法中，只会包含所选择的装饰器；可以注释掉两个装饰器，看看不同的组合会对总价有什么影响。） wrapComponent()方法返回组件时（$this-&gt;basicSite），组件已经改变，现在已经包含了增加的装饰。由输出可以看到，具体组件实例现在由3个装饰器包装，不过，要记住，这里给出的是最简单的输出：12 也可以把wrapComponent()方法中的语句写在构造函数中，这样不用wrapComponent()方法Client也可以包装装饰器。不过，我们还是增加了wrapComponent()方法，这样就能把注意力更多地放在模式中的包装过程上。 关于包装器适配器和装饰器模式都有另外一个名字“包装器”（wrapper）。实际上，在一些定义中，就把包装器描述为适配器。如果你还不太明确包装器的定义，可以先停一下，来看看如何编写一般的包装器，另外如何编写PHP包装器。 包装器包装基本类型要了解包装器，最好的办法就是查看如何包装基本类型。下面的代码显示了如何将一个整数包装在一个对象中，以及如何获取这个整数：12 如果需要将一个基本类型包装在对象中，如PrimitiveWrap，有些语言允许用内置的包装器来包装基本类型，相比之下，PHP中则要困难一些。一些语言（如Java）对于每一个基本类型都有相应的包装器类，所以在这些语言中，无需再构建新的包装器类。 PHP中的内置包装器尽管PHP没有为所有基本类型都提供包装器，不过它确实有自己的包装器。例如，在第5章中就用到过一个包装器的例子，即file_get_contents()包装器。它将一个指定资源（如一个文件名，或者一个文件名的URL）绑定到一个流。下面的例子使用一首诗来说明这一点。首先，将这首诗保存为一个文本文件（haha.txt）：123456&lt;strong&gt;真正的粉丝&lt;/strong&gt;&lt;p&gt;苟利国家生死以，&lt;br/&gt;岂因祸福避趋之。&lt;br/&gt;&lt;/p&gt;--林则徐&lt;br/&gt; file_get_contents()包装器打开haha.txt，以便PHP程序输出。下面显示了这个包装器如何工作：12 这段代码生成以下输出：12 文件名（haha.txt）“包装”在内置的file_get_contents()包装器中。 设计模式包装器在第7章中，你已经看到对象适配器模式中的适配器（Adapter）参与者如何“包装”被适配者（Adaptee）。采用这种做法，就能创建一个与Adaptee兼容的接口。同样，从以上最简单的装饰器模式例子中可以看到，装饰器（Decorator）参与者可以“包装”一个组件对象，这样就能为这个已有的组件增加职责，而无须对它做任何修改。下面的代码展示了Client如何将组件对象（$component）包装在装饰器（Maintenance）中：1$component = new Maintenance（$component）; 类似于“接口”，在计算机编程中用到“包装器”时，不同的上下文中会有不同的用法和含义。一般来讲，在设计模式中使用“包装器”是为了处理接口的不兼容，或者希望表示用来减少不兼容性的策略。 包装多个组件的装饰器尽管以上最简单的装饰器模式例子中只使用了一个具体组件，不过使用多个组件的情况也很常见。例如，图3显示了一个包含多个具体组件的类图。 图3：装饰器模式中使用多个具体组件 Male和Female类表示IComponent抽象类的具体实现。装饰器采用数组方式增加属性。在这一节后面，我们会分别详细介绍这些属性。 多个具体组件对于实现或装饰来说，包含多个具体组件并不成问题。只要这些具体组件与传入装饰器的组件有相同的接口，就可以在具体装饰器中包装任何组件，就像包含一个组件的程序或系统一样。 包含多个状态和值的具体装饰器在图3中，继承IComponent抽象类接口的装饰器实现了一些方法。有几个问题需要说明。首先，装饰器（Decorator）实现了设置装饰状态时所有没有用到的方法。实际上，装饰器可以识别出组件中某些元素在装饰中不会改变（如组件的年龄和名字）。如果组件对应的方法只是在Decorator中实现，就不必在具体装饰器中重新实现这些方法。其次，在图1中可以看到，装饰器类图指示它至少要实现Component的一些接口。方法Operation()没有用斜体显示，这表示这个方法已经实例化。getAge()和setAge($a)方法已经实现，但是没有使用。如果它们未在Decorator中实现，就必须在各个具体装饰器中实现，因为继承的所有抽象方法都必须在子类中实现。 开发人员约会服务为了说明如何实现一个包装多个组件的装饰器，下面给出一个例子，它为软件开发人员建立了一个约会服务。这里有两个组件，分别是Male和Female，可以分别为这两个组件装饰不同的约会关注点。可以用相同或不同的具体装饰采用任意组合来装饰这些组件。 基本说来，每个组件都有一个名字和指定的年龄。我们假设年龄不是装饰。具体装饰会有不同的状态。各个装饰可以增加到具体组件，不仅如此，与第一个例子中一样，每个具体装饰可以有不同的状态。 组件接口 组件接口包括3个属性和5个方法。$date属性用来标识这是一个“约会”，而不是普通的日/月/年形式的日期对象。$ageGroup是该组件所属的组，$feature是由某个具体装饰提供的特性：12 所以的方法都是抽象的，另外所有属性都是保护属性。 具体组件 两个具体组件实现为Male和Female，它们分别有一个构造函数，将$date值（ID）设置为“Male”或“Female”。另外获取方法/设置方法设置了年龄和其他可能增加的装饰：12 基于两个具体组件设置的初始特性，基本描述了男性（male）和女性（female）的特点：12 可以使用$setFeature()方法为这两个组件增加其他特性作为装饰。可以把$setFeature()看作是一个组件增强器，而不只是一个组件设置方法。 包含组件方法的装饰器 装饰器接口扩展了组件接口。不过，如前所述，它还实现了年龄属性的获取方法和设置方法：12 如果想增加一个else语句来捕获错误，这很容易做到。不过，目前采用了一种“安静失败”的做法，即不会传递对象。 具体装饰器 这个例子中的具体装饰器与前面最简单例子中的具体装饰器有很大不同。并不是只有一个状态，这些具体装饰器都包含数组，其中有多个属性值。除了使用一个包含4种不同语言的具体装饰器作为具体装饰，也可以有4个不同的具体装饰，分别表示一种不同的计算机语言。不过，将相同的选择结合到一个数组中可以达到同样的目标，还可以保持松耦合：12 所有具体装饰器都有相同的格式。首先使用getFeature()为一个输出变量赋值，设置为所选择的元素，然后在这个输出变量后面加上格式化标记和一般的具体组件信息，共同作为输出：12 通过使用关联数组（即字符串元素作为键的数组），选择装饰属性时会更为容易一些。 对于每一个特性，所有具体装饰器都有类似的数组：12 客户应当能很容易地访问具体装饰，所以所有获取方法和设置方法都有public可见性。 不过，不同属性（数组）中设置的值为private，这样可以增加组件装饰过程的封装性。 Client 最后，Client类请求一个组件和具体装饰。首先通过实例化选择一个具体组件，然后Client设置感兴趣的年龄组。Client将4个年龄组分别设置为字符串“Age Group N”，其中“N”是1-4之间的一个字符串值：12 实例化这两个具体组件之一之后，Client将它们包装在某个具体装饰器中来完成装饰。整个过程都在wrapComponent()方法中完成。创建各个实例时，setFeature()方法利用参数（由一个关联数组键构成）来完成组件的装饰。客户会生成以下输出：123456FemaleAge Group 4Grrrl programmer features: Preferred programming language:PHP Current Hardware: Linux Favorite food: Veggies 可以看到，装饰器就是具体装饰器类中关联数组的元素。 HTML用户界面到目前为止，这本书还没有介绍HTML用户界面（UI）。在第5部分中，所有应用都包括一个HTML用户界面。之所以目前还没有增加HTML用户界面，原因在于我们现在重点强调的是不同设计模式的基本原理。PHP并未嵌在一个HTML包装器中，所生成的HTML也只用于一般的格式化。 下面要用HTML UI来显示如何通过Client类（对象）连接到一个PHP设计模式。使用“开发人员约会服务”一节中的例子，可以看到，HTML与PHP之间的通信与其他项目中任何其他HTML-&gt;PHP程序中的通信是一样的。在PHP中，唯一有改变的是允许从HTML表单向Client类传递值。模式中的所有其他参与者都保持不变。 首先，来看我们完成的HTML UI，如图4所示。可以看到，页面使用单选钮来提供所有数据输入。 图4：装饰器的数据输入 数据输入很简单，只需要提供这个页面的标准HTML/CSS文件。首先，页面使用了以下CSS文件：12 这个页面是针对移动设备的垂直布局建立的，不过也可以很好地用在平板电脑或桌面系统上。接下来给出页面的HTML，如以下代码所示。它调用了一个页面（ClientH.php）。类和文件名中的H表示它将接收HTML数据（可能需要为HTML或PHP脚本增加验证代码；如果某一组单选钮均未选择，就会抛出错误！）：12 基本上，这个页面会把数据传递到一个PHP页面，就像通过PHP从一个HTML页面向一个MySQL数据库发送数据一样。所以，尽管数据发送到一个装饰器设计模式中的Client类，在传递数据方面，与以往向PHP文件传递其他数据并没有不同。 Client类传递HTML数据前面已经指出，从HTML向一个PHP Client类发送数据与向一个数据库表发送数据是类似的。查看ClientH类，可以看到它类似于Client类，只不过使用了DeveloperDating.html文件的数据：12 通过使用$_POST关联数组，可以把单选钮变量和值传递到PHP变量。性别（gender）和年龄（age）变量通过构造函数传递，而组件变量（$hotDate）和3个装饰器变量（$proLang、$hardware和$food）都声明为私有变量，取代在原来Client类中使用相应直接量。 从变量名到对象实例要实例化一个对象实例，一般做法是为类实例指定一个命名变量。在这本书中，约定所有类名首字母大写，变量类实例名都使用小写，如下：1$someInstance = new Someclass(); 只要知道类名，这种格式会很合适。不过，如果需要通过一个从HTML页面传递的变量来声明多个组件，类名必须来自这个变量的值。利用PHP，这个过程极其容易，尤其是与使用某个eval函数的方法相比（使用eval函数也可以达到这个目的，不过烦琐得多）。 在第6章已经看到，通过一个变量命名和实例化一个类时，一般过程就是将类名赋至一个变量，然后用这个变量实例化这个类。例如，假设有一个类名为Nature；可以通过一个变量动态地实例化一个类实例：12$quack = "Nature";$myNature = new $quack(); 这样一来，$myNature是Nature类的一个实例。在类ClientH中，可以看到$hotDate变量必须实例化Female或Male组件类。用户要选择男性或女性，需要在两个单选钮中做出选择（两个单选钮都命名为gender） 。两个值分别为类名Female和Male，所以，这些值传递到PHP变量$gender时，就会实例化相应的具体组件类。下面这行代码完成实例化：1$this-&gt;hotDate = new $gender(); 需要说明，这个表达式包含new关键字，另外变量$gender后面有开始和结束小括号。 增加装饰你可能希望最好包含一个查询来了解用户喜欢哪一类电影，以此衡量约会双方的契合度。例如，动作片、爱情片、科幻片和音乐片都可能是用户喜欢的电影类型。可以考察一下你对装饰器设计模式的理解程度，自己动手增加一个具体装饰器类，由用户喜欢的电影类型来装饰所选择的具体组件。 这很简单。实际上，可以复制粘贴现有的某个具体组件，把它重命名为Films，然后改变类别选项，使用Client类中的直接量值测试。如果一切正常，再更新HTML UI，加入电影选择，并修改ClientH类向程序传递这个请求。 程序越庞大，OOP编程和结构型设计模式就越有用。这是因为，第3部分中讨论的所有模式都可以用来改变现有结构的功能，而不必重写原来的结构。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[适配器模式]]></title>
    <url>%2F2019%2F08%2F23%2F%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么组合优先于继承？ 本章涵盖： 什么是适配器模式 何时使用适配器模式 使用继承的适配器模式 使用组合的适配器模式 从桌面环境转向移动环境 适配器和变化 能生存下来的物种，不是最强壮的，也不是最聪明的，而是能因应环境变化的物种。——查尔斯·达尔文 智力的详测要看其变革能力。——阿尔伯特·爱因斯坦 什么是适配器模式这一章会同时介绍对象适配器和类适配器。其中最有意思的是查看使用继承和使用组合的差别。类适配器设计模式使用继承，如图1中的类图所示。 图1：使用继承的适配器类图 从这个类图可以看到，这个模式实现中一个类有双重继承。要知道，双重继承在PHP（C#）中是不允许的，不过实现双重继承有一些替代方法，可以结合继承和实现来正确地实现这种模式。 设计模式有一个重要格言：组合优先于继承。再来看第二个适配器模式（图2），Adapter参与者使用组合来包含Adaptee的一个引用，这里没有使用继承。 图2：使用组合的适配器类图 一般来说，组合要优先于继承，因为参与者之间的绑定更宽松，在重用、结构和修改等方面有很多优点，这与使用继承不同，继承具体类或者所继承的类中包含已实现的方法时，存在一种紧密绑定，使用组合就没有这种紧密绑定的缺点。 何时使用适配器模式适配器很容易理解，我们一直都在使用适配器。大多数家庭都有手机转接器，用来为移动电话充电，这就是一种适配器。如果只有USB连接头，就无法将移动电话插到标准插座上。实际上，必须使用一个适配器，一端接USB插头，另一端接插座。图3显示了为移动电话或电脑充电的一个典型的适配器。 图3：适配器在电气领域很常见 如果有人问：“什么时候使用适配器模式？”从某种程度上讲，这个问题与“什么时候使用某种适配器”是一样的，会得到类似的答案。例如，如果有人问如何为移动电话充电，你可能会告诉他：需要用到一个适配器，使USB连接头和墙上插座相互兼容。 分解这个问题可以得到： USB连接头——不变 标准墙上插座——不变 当然，你可以拿出你的电气工具，改装USB连接头，或者重新安装墙上插座，不过这样会带来很多额外的工作，而且可能会把连接头或插座弄坏（甚至两个都弄坏）。或者，你也可以找一个适配器。最可取的做法就是找一个适配器。软件开发也是如此。 假设你和你的同事已经开发了一个PHP程序，可以很容易地为客户创建定制的桌面web设计。这个系统可以处理所有工作，包括网站的外观以及一个MySQL数据库的处理。对于笔记本电脑和台式机的屏幕来说，很适合采用一种多栏设计以及相应的用户体验设计（User experience design，UX）。实际上，这样得到的系统非常类似于用PHP创建的一个桌面CMS（Content Management System）。 某一天，一些客户要求你为这个网站增加一个移动版本。设计人员告诉你移动平台更适合采用水平设计，所以你必须重新设计外观。相应地，整个用户体验设计也必须修改。设计人员开发出一个移动模块后，你发现这个模块与你原先的桌面模块并不兼容。图4描述了这个问题。 图4：与移动电话适配器一样，适配器设计模式也遵循同样的原则 我们不想改变web开发模块（这个系统原本工作得很好，其中包含链接web页面和数据库的所有类和操作），也不想改变新开发的移动模块，那么你该怎么做呢？答案很简单，就像为手机充电一样，可以使用一个适配器。在“使用组合的适配器模式”一节中，你会找到这样一个例子，从中可以了解如何使用适配器设计模式更新系统来包含一个新模块。 适配器模式还有很多其他的应用。很多专业的web开发人员可能会使用开发商提供的一些特殊的加速器、UI或其他增强模块，为了与现有软件一同使用，他们通常需要某种适配器。类似地，如果两个不同的开发小组开发了不兼容的模块，也可以使用一个适配器，与要求某个小组重新开发模块相比，使用适配器通常更节省时间。 使用继承的适配器模式类适配器设计模式很简单，不过与对象适配器模式相比，类适配器模式的灵活性稍弱。类适配器模式更简单的原因在于，适配器（Adapter）会从被适配者（Adaptee）继承功能，所以适配器模式中需要重新编写的代码比较少。当然，由于给定了一个将由适配器（Adapter）继承的具体被适配者（Adaptee），这种绑定很紧密，所以使用类适配器模式创建应用时，必须非常清楚将在哪里发生适配。 由于类适配器包含双重继承，如图1中所示，下面的PHP例子首先用了一点技巧。实际上，PHP并不支持双重继承。你会发现很多设计精巧的例子都展示了PHP可以模拟双重继承，不过最重要的是，PHP本身可以很好地处理接口实现和类继承的组合。下面的语句展示了一个正确的结构，这里不仅继承了一个类，同时还实现了一个接口：1class ChildClass extends ParentClass implements ISomeInterface 所以，实现类适配器模式时，参与者必须包括一个PHP接口。 最简单的类适配器例子：货币兑换 假设有一个企业网站在同时销售软件服务和软件产品，目前，所有交易都在美国进行，所以完全可以用美元来完成所有计算。现在开发人员希望能有一个转换器能处理美元与欧元的兑换，而不要改变原来按美元计算交易金额的类。通过增加一个适配器，现在程序既可以用美元计算也可以用欧元计算。 首先，假设有一个很好的类DollarCalc，它能累加所购买服务和产品的价格，然后返回总金额：1234567891011121314151617181920212223&lt;?php// DollarCalc.phpclass DollarCalc&#123; private $dollar; private $product; private $service; public $rate = 1; public function requestCalc($productNow, $serviceNow) &#123; $this-&gt;product = $productNow; $this-&gt;service = $serviceNow; $this-&gt;dollar = $this-&gt;product + $this-&gt;service; return $this-&gt;requestTotal(); &#125; public function requestTotal() &#123; $this-&gt;dollar *= $this-&gt;rate; return $this-&gt;dollar; &#125;&#125; 查看这个类，可以看到其中有一个属性$rate，requestTotal()方法使用$rate来计算一次交易的金额。在这个版本中，这个值设置为1，另外将两个参数变量的值乘以1，实际上总金额无需再乘以兑换率。不过，如果要为客户提供折扣或者要增加额外服务或产品的附加费，$rate变量会很方便。这个类并不是类适配器模式的一部分，不过这是一个起点。 加入欧元 客户宣布她的公司决定向欧洲拓展，所以需要开发一个应用，能够用欧元完成同样的计算。你希望这个欧元计算能像DollarCalc一样，所要做的就是改变变量名。1234567891011121314151617181920212223&lt;?php// EuroCalc.phpclass DollarCalc&#123; private $euro; private $product; private $service; public $rate = 1; public function requestCalc($productNow, $serviceNow) &#123; $this-&gt;product = $productNow; $this-&gt;service = $serviceNow; $this-&gt;euro = $this-&gt;product + $this-&gt;service; return $this-&gt;requestTotal(); &#125; public function requestTotal() &#123; $this-&gt;euro *= $this-&gt;rate; return $this-&gt;euro; &#125;&#125; 接下来，再把应用的其余部分插入到EuroCalc类中，你已经做好了准备。不过，你知道客户的所有数据都是按美元计算的。换句话说，如果不重新开发整个程序，就无法在系统中“插入”这个欧元计算。但你不想这么做。为了加入EuroCalc，你需要一个适配器。 创建一个欧元适配器 我们先停一下，理一理思路。图5显示了一个类图，这里使用了这个类适配器模式实现中的类名。 图5：使用继承实现的适配器类图 就像找一个适配器来适应欧洲的插座一样，可以创建一个适配器，使你的系统能够使用欧元。幸运的是，类适配器模式正是为这种情况设计的。首先需要创建一个接口。在这个类图中，这个接口名为ITarget。它只有一个方法requester()。requester()是一个抽象方法，要由接口的具体实现来实现这个方法：123456&lt;?php// ITarget.phpinterface ITarget &#123; function requester();&#125; 现在开发人员可以实现requester()方法，请求欧元而不是美元。 在使用继承的适配器设计模式中，适配器（Adapter）参与者既实现ITarget接口，还实现了具体类EuroCalc。创建EuroAdapter不需要做太多工作。大部分工作已经在EuroCalc类中完成，这是一个具体类。现在要做的就是实现requester()方法，使它能把美元值转换为欧元值：12345678910111213141516171819&lt;?php// EuroAdapter.php// Adapterinclude_once('EuroCalc.php');include_once('ITarget.php');class EuroAdapter extends EuroCalc implements ITarget&#123; function __construct() &#123; $this-&gt;requester(); &#125; function requester() &#123; $this-&gt;rate = 0.8111; return $this-&gt;rate; &#125;&#125; 类适配器模式中，一个具体类会继承另一个具体类，有这种结构的设计模式很少见。大多数设计模式中，几乎都是继承一个抽象类，并由具体类根据需要实现其抽象方法和属性。换句话说， 一般谈到继承时，都是具体类继承抽象类。 由于既实现了一个接口又扩展了一个类，所以EuroAdapter类同时拥有该接口和具体类的接口。通过使用requester()方法，EuroAdapter类可以设置rate值（兑换率），从而能使用被适配者的功能，而无需做任何改变。 下面来看具体是如何工作的，Client类从EuroAdapter和DollarCalc类发出请求。可以看到，原来的DollarCalc仍能很好地工作，不过它没有ITarget接口。EuroAdapter类同时实现了接口和具体类，通过使用类型提示，可以保证与其接口一致：1234567891011121314151617181920212223242526272829303132&lt;?php// Client.php// Clientinclude_once('EuroAdapter.php');include_once('DollarCalc.php');class Client&#123; private $requestNow; private $dollarRequest; public function __construct() &#123; $this-&gt;requestNow = new EuroAdapter(); $this-&gt;dollarRequest = new DollarCalc(); echo "Euros: €".$this-&gt;makeAdapterRequest($this-&gt;requestNow)."&lt;br/&gt;"; echo "Dollars: $".$this-&gt;makeDollarRequest($this-&gt;dollarRequest); &#125; private function makeAdapterRequest(ITarget $req) &#123; return $req-&gt;requestCalc(40, 50); &#125; private function makeDollarRequest(DollarCalc $req) &#123; return $req-&gt;requestCalc(40, 50); &#125;&#125;$worker = new Client(); 由输出可以看到，现在美元或欧元都可以处理，这要归功于适配器模式：12Euros: €72.999Dollars: $90 这个计算很简单，不过对于更为复杂的计算，继承要提供建立类适配器的Target接口的必要接口和具体实现。 使用组合的适配器模式&lt;/span&gt;对象适配器模式使用组合而不是继承，不过它也会完成同样的目标。通过比较这两个版本的适配器模式，可以看出它们各自的优缺点。采用类适配器模式时，适配器可以继承它需要的大多数功能，只是通过接口稍做调整。在对象适配器模式中，适配器（Adapter）参与者使用被适配者（Adaptee），并实现Target接口。在类适配器模式中，适配器（Adapter）则是一个被适配者（Adaptee），并实现Target接口。 从桌面环境转向移动环境PHP程序员经常会遇到这样一个问题：需要适应移动环境而做出调整。不久之前，你可能只需要考虑提供一个网站来适应多种不同的桌面环境。大多数桌面环境都使用一个布局，再由设计人员让它更美观。对于移动设备，设计人员和开发人员不仅需要重新考虑桌面和移动环境中页面显示的设计元素，还要考虑如何从一个环境切换到另一个环境。 这个例子使用了对象适配器模式，首先给出一个简单的PHP类，它提供一个简单的页面，其中包含文本和图片。对于文本，这个例子使用了一个占位文本（“loremipsum”）作为填充内容（存储在一个文本文件中）。CSS也很简单，使用一个很基本的两栏设计，文本图片关系为左边显示文本，右边显示图片。CSS存储为一个单独的CSS文件。 桌面 要了解组合适配器，首先来看原来的类（它将需要一个适配器）。这个类使用了一个简单但很宽松的接口：12 它支持多个CSS和图片选择，不过其中一个方法指示一种水平布局，我们知道，这种布局并不适用于小的移动设备。这个接口的实现相当简单，下面给出这个接口实现（Desktop）类：12 这个类中的大多数代码都是在完成HTML页面的格式化，以便浏览。文本、图像以及页眉都是最简单的例子。CSS提供了一个样式表，用来设置调色板、体文本、页眉、“第二列”（以便将图像放在文本右边）以及图像周围的边距：12 这个CSS保存在一个名为desktop.css的文件中，通过PHP生成的HTML \标记来调用。 图6：简单的两栏桌面设计 在图6中可以看到，这个布局对于小的移动设备来说太宽了。所以我们的目标是仍采用同样的内容，但调整为一种移动设计。 调整为移动设计。首先来看图7，这里显示了创建移动网站时要使用的具体类名和操作。我增加了Mobile类原来的接口（IMobileFormat），不过，由于使用了MobileAdapter，它要实现IFormat接口。 图7：对象适配器类图中的MobileAdapter 查看IMobileFormat和IFormat接口时，可以看到它们是不兼容的：一个包含方法horizontalLayout()，而另一个包含verticalLayout()方法。不过，通过使用MobileAdapter（适配器），它继承了Desktop类原来使用的IFormat（Target），现在Mobile（Adaptee）类可以以兼容的方式与IFormat接口的其他实现交互。 适配器模式也称为包装器模式，这一点并不奇怪。适配器（MobileAdapter）参与者“包装了”被适配者（Mobile）参与者，使被适配者可以使用同样的接口。要看包装过程是如何工作的，首先来看IMobileFormat接口和Mobile类，Mobile类与Desktop类几乎完全相同，只不过它有一个不同的接口：12 要记住，这个过程的目的是让两个不兼容的接口合作。它们的差别很小，不过你要知道，从桌面设计转换到移动设计时，最主要的区别是：桌面设计可以采用水平的多栏布局，而移动设计要使用垂直布局。下面的Mobile类实现了IMobileFormat（它看起来与Desktop类几乎完全相同）：12 前面已经提到，它与Desktop类非常相似，不过图片的设置不同，而且提供了一个不同的图片。它还调用了另一个不同的CSS文件。这个CSS文件包含一个@media语句，提供了不同的分辨率选择：12 尽管这个CSS看起来很重要，但在这里它只用于对移动设计的页面外观完成格式化。设计人员还可以做更多工作。重要的是，不论是桌面设计还是移动设计，负责页面外观的不同的类（Desktop类和Mobile类）要协同工作。下面来看关键的适配器（Adapter）参与者，它将Desktop类和Mobile类结合在一起：12 可以看到，MobileAdapter实例化时要提供一个Mobile对象实例。还要注意，类型提示中使用了IMobileFormat，来确保参数是一个Mobile对象。有意思的是，Adapter参与者通过实现horizontalLayout()方法来包含Mobile对象的verticalLayout()方法。实际上，所有MobileAdapter方法都包装了一个Mobile方法。碰巧的是，适配器参与者中的一个方法并不在适配器接口中（verticalLayout()）。它们可能完全不同，适配器只是把它们包装在适配器接口（IFormat）的某一个方法中。 Client类作为参与者 最后一步是使用MobileAdapter类启动应用。要记住，Client类是这个设计模式中不可缺少的一部分，尽管它只是做出请求，但其请求方式要与适配器模式的目标和设计相一致：12 适配器模式中的Client类必须包装Adaptee（Mobile）的一个实例，以便集成到Adapter本身。实例化Adapter时，Client使用Adaptee作为参数来完成Adapter的实例化。所以客户必须首先创建一个Adaptee对象（new Mobile()），然后创建一个Adapter实例（(new MobileAdapter（$this-&gt;mobile)）。 Client类的大多数请求都通过MobileAdapter实例发出。不过，在这个代码的最后，它使用了Mobile类的实例。由于应用不需要特殊的closeHTML()方法实现，Client直接调用了Mobile实例的这个方法。 图8显示了为一个移动设备配置相同内容时得到的结果。在这个例子中，所使用的移动设备是一个iPhone。 图8：为移动设备调整为单栏布局 关于如何设计和配置移动web应用，有很多相关的书和资料，这些设计都可以采用适配器模式。关键在于，适配器模式能够以一个桌面设计为起点，选择并使用适合移动设备的不同设计，而不会破坏原来的桌面设计实现。 适配器和变化PHP程序员要时刻面对变化。不同版本的PHP会有变化，可能增加新的功能，另外还可能取消一些功能。而且，随着PHP的大大小小的变化，MySQL也在改变。例如，mysql扩展包升级为mysqli，PHP开发人员需要相应调整，要改为使用mysqli中的新API，这里适合采用适配器模式吗？可能不适合。适配器可能适用，也可能不适用，这取决于你的程序如何配置。当然可以重写所有连接和交互代码，不过这可不是适配器模式的本意。这就像是重新安装USB连接头，想把它插进标准的墙上插座一样。不过，如果所有原来的mysql代码都在模块中，你可以修改这个模块（类），换入一个有相同接口的新模块，只是要使用mysqli而不是mysql。我不认为交换等同于适配器，不过道理是一样的。在适配器模式中，原来的代码没有任何改变。有变化的只是适配器。 如果需要结合使用两个不兼容的接口，这种情况下，适配器模式最适用。适配器可以完成接口的“联姻”。可以把适配器看作是一个婚姻顾问：通过创建一个公共接口来克服双方的差异。利用这种设计模式，可以促成二者的合作，而避免完全重写某一部分。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式的分类]]></title>
    <url>%2F2019%2F08%2F23%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%88%86%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 设计模式分为哪三类？为什么这么分？各举几个例子。 本章涵盖： 创建型设计模式 结构型设计模式 行为型设计模式 创建型设计模式创建型设计模式强调的是实例化过程。设计这些模式的目的是隐藏实例的创建过程，并封装对象使用的知识。5个创建型设计模式包括： 单例（Singleton） 工厂方法（Factory Method） 抽象工厂（Abstract Factory） 建造者（Builder） 原型（Prototype） 工厂方法模式是这5个设计模式中唯一的一种类设计模式。原型模式属于对象类模式，可以使用PHP _clone()方法实现。首先基于原型实例化（创建）一个对象，然后由这个实例化对象进一步克隆其他对象。你会发现这种模式很容易使用，相当方便。 使用创建型模式时，最有意思的是，程序和系统越来越依赖于对象组合而不是依赖于类继承时，创建型模式就会很重要——确切地说是至关重要。程序变成由对象构成的系统，而对象又由其他对象组合而成，所以任何单个对象的创建都不应该依赖于创建者。换句话说，对象不应与创建对象的过程紧密绑定。这样一来，就不会由于请求对象的特定特性而影响对象组合。此类设计模式会告诉你如何以最优的方式实现创建过程。图1概要描述了创建型模式如何工作。 图1：创建型模式结构 结构型设计模式结构型设计模式研究的是如何组合对象和类来构成更大的结构。在类结构型设计中，要通过多个接口来创建新结构。一个类可能继承多个父类来创建一个新的结构。更常见的是对象结构结合不同的对象来形成新的结构。下面7种模式称为结构型模式。 适配器模式（Adapter）（类和对象） 桥接模式（Bridge） 组合模式（Composite） 装饰器模式（Decorator） 外观模式（Pacade） 享元模式（Flyweight） 代理模式（Proxy） 如果需要通过适配（使用多重继承或组合）来结合两个不兼容的系统，适配器就非常重要。但有一个棘手的问题需要处理：PHP不支持多重继承，不过可以看到，PHP提供了一种变通方法来实现类适配器模式。另外，组合不仅适用于对象适配器模式，也适用于装饰器模式。图2提供了结构型设计模式的一个可视化表示。 图2：结构型模式强调由现有结构创建新结构 结构型设计模式的重点是创建新结构而不破坏原有的结构。在这个基础上，结构型模式可以保持并提升松耦合标准以实现重用和灵活改变。 行为型设计模式“四人帮”所提供的设计模式中，行为型设计模式占了绝大部分。这一部分将介绍一个类设计模式（模板方法模式）和一个对象设计模式（状态模式）。有11个行为型模式: 职责链模式（Chain of Responsibility） 命令模式（Command） 解释器模式（Interpreter）（类设计模式） 迭代器模式（Iterator） 中介者模式（Mediator） 备忘录模式（Memento） 观察者模式（Observer） 状态模式（State） 策略模式（Strategy） 模板方法模式（Template Method）（类设计模式） 访问者模式（Visitor） 理解行为型设计模式的关键是通信。对于这些模式，重点不再是构成一个设计模式的对象和类，而应转变为对象和类之间的通信。实际上，最好考虑对象如何相互合作来完成任务，从这个角度来理解行为型设计模式。 图3：行为型模式强调模式参与者之间的通信 要重点考虑构成模式的元素之间的交互，这一点非常重要，有些模式的类图看起来是一样的，如状态模式和策略模式。不过，由于参与者通信的方式不同，另外它们处理职责的方式也不同，所以这些模式实际上有很大不同。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象设计原则 (2)]]></title>
    <url>%2F2019%2F07%2F24%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99%20(2)%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是依赖倒转原则？和依赖注入和控制反转有什么不同？ 依赖倒置的“细节”可以理解为实现类。接口类和实现类是什么，是什么关系？ 什么是里氏替换原则？ 单一职责原则1就一个类而言，应该仅有一个引起它变化的原因。 我们在做编程的时候，很自然地就会给一个类加各种各样的功能，比如我们写一个窗体应用程序，一般都会生成一个Form1这样的类，于是我们就把各种各样的代码，像某种商业运算的算法呀，像数据库访问的SQL语句呀什么的都写到这样的类当中，这就意味着，无论任何需求要来，你都需要更改这个窗体类，这其实是很糟糕的，维护麻烦，复用不可能，也缺乏灵活性。 方块游戏的设计拿手机里的俄罗斯方块游戏为例。要是让你开发这个小游戏，你如何考虑？ 首先它方块下落动画的原理是画四个小方块，擦掉，然后再在下一行画四个方块。不断地绘出和擦掉就形成了动画，所以应该要有画和擦方块的代码。然后左右键实现左移和右移，下键实现加速，上键实现旋转，这其实都应该是函数，当然左右移动需要考虑碰撞的问题，下移需要考虑堆积和消层的问题。 如果就用WinForm的方式开发，打算怎么开发呢？ 那当然是先建立一个窗体Form，然后加一个用于游戏框的控件，比如Panel或者PictureBox，一个按钮Button来控制‘开始’，最后再放一个Timer控件用于分时动画的编程。写代码当然就是编写Timer_Tick事件来绘出和擦除方块，并做出堆积和消层的判断。再编写控件的键盘事件，按了左箭头则左移，右箭头则右移等等。对了，还需要用到些GDI+技术的方法来画方块和擦方块。 你能不能就这些代码划分一下类呢？ 分类？这里好像关键在于各种事件代码如何写吧，这里有什么类可言呢？ 看来你的面向过程开发已经根深蒂固了。你把所有的代码都写在了Form1.cs这个类里，你觉得这合理吗？ 打个比方，如果现在要你写的是手机版的俄罗斯方块程序，即Pocket PC或者Windows CE上运行的程序，它们可以安装.NET框架的精简版，运行C#语言编写的应用程序，但PC上的普通WinForm界面的程序不能使用。那你现在这个代码有什么可以复用的吗？ 这当中，有些东西是始终没变的。 下落、旋转、碰撞判断、移动、堆积这些都是和游戏有关的逻辑，和界面如何表示没有什么关系，为什么要写在一个类里面呢？如果一个类承担的职责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱或者抑制这个类完成其他职责的能力。这种耦合会导致脆弱的设计，当变化发生时，设计会遭受到意想不到的破坏。事实上，你完全可以找出哪些是界面，哪些是游戏逻辑，然后进行分离。 方块的可移动的游戏区域，可以设计为一个二维整型数组用来表示坐标，宽10，高20，比如‘int[，] arraySquare=new int[10，20];’，那么整个方块的移动其实就是数组的下标变化，比如原方块在arraySquare [3，5]上，则下移时变成arraySquare [3，6]，如果下移同时还按了左键，则是arraySquare [2，6]。每个数组的值就是是否存在方块的标志，存在为1，不存在时缺省为0。这下你该明白，所谓的碰撞判断，是否能左移，就是判断arraySquare[x，y]中的x–1是否小于0，否则就撞墙了。或者arraySquare[x–1，y]是否等于1，否则就说明左侧有堆积的方块。所谓堆积，不过是判断arraySquare[x，y+1]是否等于1的过程，如果是，则将自己arraySquare [x，y]的值改1。那么消层，其实就是arraySquare [x，y]中循环x由0到9，判断arraySquare [x，y]是否都等于1，是则此行数据清零，并将其上方的数组值遍历下移一位。” 所谓游戏逻辑，不过就是数组的每一项值变化的问题，下落、旋转、碰撞判断、移动、堆积这些都是在做数组具体项的值的变化。而界面表示逻辑，不过是根据数组的数据进行绘出和擦除，或者根据键盘命令调用数组的相应方法进行改变。因此，至少应该考虑将此程序分为两个类，一个是游戏逻辑的类，一个是WinForm窗体的类。当有一天要改变界面，或者换界面时，不过是窗体类的变化，和游戏逻辑无关，以此达到复用的目的。 软件设计真正要做的许多内容，就是发现职责并把那些职责相互分离。其实要去判断是否应该分离出类来，也不难，那就是如果你能够想到多于一个的动机去改变一个类，那么这个类就具有多于一个的职责，就应该考虑类的职责分离。 界面的变化是和游戏本身没有关系的，界面是容易变化的，而游戏逻辑是不太容易变化的，将它们分离开有利于界面的改动。 编程时，要在类的职责分离上多思考，做到单一职责，这样代码才是真正的易维护、易扩展、易复用、灵活多样。 开放-封闭原则在软件设计模式中，不能修改，但可以扩展的思想是最重要的一种设计原则，它就是开放-封闭原则（The Open-Closeed Principle，简称OCP）或叫开-闭原则。” 这个原则其实是有两个特征，一个是说‘对于扩展是开放的（Open for extension）’，另一个是说‘对于更改是封闭的（Closed for modification）’。 在做任何系统的时候，都不要指望系统一开始时需求确定，就再也不会变化，这是不现实也不科学的想法，而既然需求是一定会变化的，那么如何在面对需求的变化时，设计的软件可以相对容易修改，不至于说，新需求一来，就要把整个程序推倒重来。怎样的设计才能面对需求的改变却可以保持相对稳定，从而使得系统可以在第一个版本以后不断推出新的版本呢？，开放-封闭给我们答案。 设计软件要容易维护又不容易出问题的最好的办法，就是多扩展，少修改？ 何时应对变化开放-封闭原则的意思是说，你设计的时候，时刻要考虑，尽量让这个类是足够好，写好了就不要去修改了，如果新需求来，我们增加一些类就完事了，原来的代码能不动则不动。 绝对的对修改关闭是不可能的。无论模块是多么的‘封闭’，都会存在一些无法对之封闭的变化。既然不可能完全封闭，设计人员必须对于他设计的模块应该对哪种变化封闭做出选择。他必须先猜测出最有可能发生的变化种类，然后构造抽象来隔离那些变化。 我们很难预先猜测，但我们却可以在发生小变化时，就及早去想办法应对发生更大变化的可能。也就是说，等到变化发生时立即采取行动。正所谓，同一地方，摔第一跤不是你的错，再次在此摔跤就是你的不对了。 在我们最初编写代码时，假设变化不会发生。当变化发生时，我们就创建抽象来隔离以后发生的同类变化[ASD]。比如，我之前让你写的加法程序，你很快在一个client类中就完成，此时变化还没有发生。然后我让你加一个减法功能，你发现，增加功能需要修改原来这个类，这就违背了今天讲到的‘开放-封闭原则’，于是你就该考虑重构程序，增加一个抽象的运算类，通过一些面向对象的手段，如继承，多态等来隔离具体加法、减法与client耦合，需求依然可以满足，还能应对变化。这时我又要你再加乘除法功能，你就不需要再去更改client以及加法减法的类了，而是增加乘法和除法子类就可。即面对需求，对程序的改动是通过增加新代码进行的，而不是更改现有的代码[ASD]。这就是‘开放-封闭原则’的精神所在。（样例代码见第1章） 当然，并不是什么时候应对变化都是容易的。我们希望的是在开发工作展开不久就知道可能发生的变化。查明可能发生的变化所等待的时间越长，要创建正确的抽象就越困难。” 如果加减运算都在很多地方应用了，再考虑抽象、考虑分离，就很困难。 开放-封闭原则是面向对象设计的核心所在。遵循这个原则可以带来面向对象技术所声称的巨大好处，也就是可维护、可扩展、可复用、灵活性好。开发人员应该仅对程序中呈现出频繁变化的那些部分做出抽象，然而，对于应用程序中的每个部分都刻意地进行抽象同样不是一个好主意。拒绝不成熟的抽象和抽象本身一样重要。切记，切记。 我还以为尽量地抽象是好事呢，看来过犹不及呀。 依赖倒转原则依赖倒转和依赖注入，控制反转是不一样的东西。 面向对象的四个好处是： 可维护 可扩展 可复用 灵活性好 电脑好修而收音机不好修的原因是电脑是模块化的，而收音机不是，各组件紧密结合。 可以把PC电脑理解成是大的软件系统，任何部件如CPU、内存、硬盘、显卡等都可以理解为程序中封装的类或程序集，由于PC易插拔的方式，那么不管哪一个出问题，都可以在不影响别的部件的前提下进行修改或替换。 面向对象里把这种关系叫强内聚、松耦合吧，即高内聚，低耦合。 面向对象的几大设计原则 单一职责原则，对象各自的职责是明确的。开放-封闭原则，对扩展开放，对修改关闭 依赖倒转原则，原话解释是抽象不应该依赖细节，细节应该依赖于抽象，就是要针对接口类编程，不要对实现类编程。通过接口声明对象，通过具体对象来调用。 依赖倒转原则 A.高层模块不应该依赖低层模块。两个都应该依赖抽象。B.抽象不应该依赖细节。细节应该依赖抽象。 为什么要叫倒转呢? 面向过程的开发时，为了使得常用代码可以复用，一般都会把这些常用代码写成许许多多函数的程序库，这样我们在做新项目时，去调用这些低层的函数就可以了。比如我们做的项目大多要访问数据库，所以我们就把访问数据库的代码写成了函数，每次做新项目时就去调用这些函数。这也就叫做高层模块依赖低层模块。 我们要做新项目时，发现业务逻辑的高层模块都是一样的，但客户却希望使用不同的数据库或存储信息方式，这时就出现麻烦了。我们希望能再次利用这些高层模块，但高层模块都是与低层的访问数据库绑定在一起的，没办法复用这些高层模块，这就非常糟糕了。就像刚才说的，PC里如果CPU、内存、硬盘都需要依赖具体的主板，主板一坏，所有的部件就都没用了，这显然不合理。反过来，如果内存坏了，也不应该造成其他部件不能用才对。而如果不管高层模块还是低层模块，它们都依赖于抽象，具体一点就是接口或抽象类，只要接口是稳定的，那么任何一个的更改都不用担心其他受到影响，这就使得无论高层模块还是低层模块都可以很容易地被复用。这才是最好的办法。 为什么依赖了抽象的接口或抽象类，就不怕更改呢? 原因就是里氏代换原则。 里氏替换原则里氏代换原则是在1988年发表的，它的白话翻译就是一个软件实体如果使用的是一个父类的话，那么一定适用于其子类，而且它察觉不出父类对象和子类对象的区别。也就是说，在软件里面，把父类都替换成它的子类，程序的行为没有变化，简单地说，子类型必须能够替换掉它们的父类型[ASD]. 里氏代换原则1子类型必须能够替换掉它们的父类型。 子类继承了父类，所以子类可以以父类的身份出现。如果在面向对象设计时，一个是鸟类，一个是企鹅类，如果鸟是可以飞的，企鹅不会飞，那么企鹅是鸟吗?企鹅可以继承鸟这个类吗” 企鹅是一种特殊的鸟，尽管不能飞，但它也是鸟呀，当然可以继承。 子类拥有父类所有非private的行为和属性。鸟会飞，而企鹅不会飞。尽管在生物学分类上，企鹅是一种鸟，但在编程世界里，企鹅不能以父类—鸟的身份出现，因为前提说所有鸟都能飞，而企鹅飞不了，所以，企鹅不能继承鸟类。 也正因为有了这个原则，使得继承复用成为了可能，只有当子类可以替换掉父类，软件单位的功能不受到影响时，父类才能真正被复用，而子类也能够在父类的基础上增加新的行为。比方说，猫是线承动物类的，以动物的身份拥有吃、喝、跑、叫等行为，可当某一天，我们需要狗、牛、羊也拥有类似的行为，由于它们都是继承于动物，所以除了更改实例化的地方，程序其他处不需要改变。 收音机就是典型的耦合过度，只要收音机出故障，不管是没有声音、不能调频，还是有杂音，反正都很难修理，不懂的人根本没法修，因为任何问题都可能涉及其他部件，各个部件相互依赖，难以维护。非常复杂的PC电脑可以修，反而相对简单的收音机不能修，这其实就说明了很大的问题。当然，电脑的所谓修也就是更换配件， CPU或内存要是坏了，老百姓是没法修的。现在在软件世界里，收音机式的强耦合开发还是太多了，比如前段时间某银行出问题，需要服务器停机大半天的排查修整，这要损失多少钱。如果完全面向对象的设计，或许问题的查找和修改就容易得多。依赖倒转其实可以说是面向对象设计的标志，用哪种语言来编写程序不重要，如果编写时考虑的都是如何针对抽象编程而不是针对细节编程，即程序中所有的依赖关系都是终止于抽象类或者接口，那就是面向对象的设计，反之那就是过程化的设计了。 用子类对象实例化父类对象 注意： 只能调用到子类对象里面的父类对象 如果父类成员方法被子类重写了，那么就调用子类里面重写的方法 里氏替换原则有三种表现形式： 1、用子类对象实例化父类对象。 2、父类作为参数，传入子类对象。 3、父类作为返回值，可以返回子类对象。 使用场景： 游戏中的宠物商店123456789101112131415static Animal GetAnimal(string name)&#123; if (name == "Cat") &#123; return new Cat(); &#125; else if (name == "Dog") &#123; return new Dog(); &#125; else &#123; return null; &#125; &#125; 单例模式两个作用1、主要是让内存中只有一个对象，保证数据的正确性。2、节省内存 自己的总结并不是写一个继承就能自动满足里氏替换原则的。比如鸟类，写了一个会飞的方法，然后鸵鸟继承了这个类，某处调用了父类鸟飞的方法，然后就满足不了里氏替换原则了。 不能用鸵鸟替换掉鸟类，因为鸵鸟不会飞，所以这个父类设计错误。 再比如设计一个宠物类，宠物的属性有重量、价格、颜色，返回值是宠物类，然后根据传参返回具体的宠物。然后直接使用宠物类Pets.climbTree()肯定不行，因为狗不会上树。 所以设计父类的时候一定要拿到所有的共同点。 迪米特法则哪怕两个人，也应该有管理才好。 迪米特法则（LoD）也叫最少知识原则。 迪米特法则首先强调的前提是在类的结构设计上，每一个类都应当尽量降低成员的访问权限，也就是说，一个类包装好自己的private状态，不需要让别的类知道的字段或行为就不要公开。 需要公开的字段，通常就用属性来体现了。这就是封装的思想。 面向对象的设计原则和面向对象的三大特性本就不是矛盾的。迪米特法则其根本思想，是强调了类之间的松耦合。 我们在程序设计时，类之间的耦合越弱，越有利于复用，一个处在弱耦合的类被修改，不会对有关系的类造成波及。也就是说，信息的隐藏促进了软件的复用。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>大话设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[命令模式]]></title>
    <url>%2F2019%2F07%2F23%2F%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 命令模式的应用场景是什么？命令模式必须使用吗？命令模式属于哪种设计模式？ 先使用继承自抽象命令类的具体命令类对厨师类（Receiver）进行引用和方法封装。最后再引入服务员类（Invoker）对命令进行管理。怎么理解？ 命令模式的缺点是什么？ 不使用命令模式做不到对请求的排队和撤销。为什么？ 第1版：紧耦合设计 代码结构图 路边烤羊肉串的实现 123456789101112131415// 烤肉串者public class Barbecuer&#123; // 烤羊肉 public void BakeMutton() &#123; Console.WriteLine("烤羊肉串!"); &#125; // 烤鸡翅 public void BakeChickenWing() &#123; Console.WriteLine("烤鸡翅!"); &#125;&#125; 客户端调用 123456789101112131415161718class Program&#123; static void Main(string[] args) &#123; Barbecuer maimaiti = new Barbecuer(); // 客户端程序与“烤肉串者”紧耦合，尽管简单，但却极为僵化，有许许多多的隐患 maimaiti.BakeMutton(); maimaiti.BakeMutton(); maimaiti.BakeMutton(); maimaiti.BakeChickenWing(); maimaiti.BakeMutton(); maimaiti.BakeMutton(); maimaiti.BakeChickenWing(); Console.Read(); &#125;&#125; 这就是‘行为请求者’与‘行为实现者’的紧耦合，对请求排队或记录请求日志，以及支持可撤销的操作等行为时，‘行为请求者’与‘行为实现者’的紧耦合是不太适合的。 第二版：松耦合设计 代码结构图 抽象命令类 123456789101112// 抽象命令类，只需要确定“烤肉串者”是谁。public abstract class Command&#123; protected Barbecuer receiver; public Command(Barbecuer receiver) &#123; this.receiver = receiver; &#125; abstract public void ExecuteCommand();&#125; 具体命令类 12345678910111213141516171819202122class BakeMuttonCommand : Command&#123; public BakeMuttonCommand(Barbecuer receiver) : base(receiver) &#123;&#125; // 执行命令 public override void ExecuteCommand() &#123; receiver.BakeMutton(); &#125;&#125;class BakeChickenWingCommand : Command&#123; public BakeChickenWingCommand(Barbecuer receiver) : base(receiver) &#123;&#125; public override void ExecuteCommand() &#123; receiver.BakeChickenWing(); &#125;&#125; 服务员类 1234567891011121314151617// 服务员类，不用管用户想要什么烤肉，反正都是‘命令’，只管记录订单，然后通知‘烤肉串者’执行即可public class Waiter&#123; private Command command; // 设置订单 public void SetOrder(Command command) &#123; this.command = command; &#125; // 通知执行 public void Notify() &#123; command.ExecuteCommand(); &#125;&#125; 烤肉串者类与之前相同，略。 客户端实现 12345678910111213141516171819202122232425class Program&#123; static void Main(string[] args) &#123; // 烧烤店事先就找好了烤肉厨师、服务员和烤肉菜单，就等客户上门 Barbecuer tangniu = new Barbecuer(); Command bakeMuttonCommand1 = new BakeMuttonCommand(tangniu); Command bakeMuttonCommand2 = new BakeMuttonCommand(tangniu); Command bakeChickenWingCommand1 = new BakeChickenWingCommand(tangniu); Waiter girl = new Waiter(); // 开门营业 // 服务员根据用户要求，通知厨房开始制作 girl.SetOrder(bakeMuttonCommand1); girl.Notify(); girl.SetOrder(bakeMuttonCommand2); girl.Notify(); girl.SetOrder(bakeChickenWingCommand1); girl.Notify(); Console.Read(); &#125;&#125; 这样写有几个问题： 第一，真实的情况其实并不是用户点一个菜，服务员就通知厨房去做一个，那样不科学，应该是点完烧烤后，服务员一次通知制作； 第二，如果此时鸡翅没了，不应该是客户来判断是否还有，客户哪知道有没有呀，应该是服务员或烤肉串者来否决这个请求； 第三，客户到底点了哪些烧烤或饮料，这是需要记录日志的，以备收费，也包括后期的统计； 第四，客户完全有可能因为点的肉串太多而考虑取消一些还没有制作的肉串。这些问题都需要得到解决。 第三版：松耦合后 服务员类 1234567891011121314151617181920212223242526272829303132333435// 服务员public class Waiter&#123; private IList&lt;Command&gt; orders = new List&lt;Command&gt;(); // 设置订单 public void SetOrder(Command command) &#123; if (command.ToString() == "命令模式.BakeChickenWingCommand") &#123; Console.WriteLine("服务员：鸡翅没有了，请点别的烧烤。"); &#125; else &#123; orders.Add(command); Console.WriteLine("增加订单：" + command.ToString() + " 时间：" + DateTime.Now.ToString()); &#125; &#125; // 取消订单 public void CancelOrder(Command command) &#123; orders.Remove(command); Console.WriteLine("取消订单：" + command.ToString() + " 时间：" + DateTime.Now.ToString()); &#125; // 通知全部执行 public void Notify() &#123; foreach (Command cmd in orders) &#123; cmd.ExcuteCommand(); &#125; &#125;&#125; 客户端代码实现 12345678910111213141516171819202122class Program&#123; static void Main(string[] args) &#123; //开店前的准备 Barbecuer boy = new Barbecuer(); Command bakeMuttonCommand1 = new BakeMuttonCommand(boy); Command bakeMuttonCommand2 = new BakeMuttonCommand(boy); Command bakeChickenWingCommand1 = new BakeChickenWingCommand(boy); Waiter girl = new Waiter(); //开门营业 顾客点菜 girl.SetOrder(bakeMuttonCommand1); girl.SetOrder(bakeMuttonCommand2); girl.SetOrder(bakeChickenWingCommand1); //点菜完闭，通知厨房 girl.Notify(); Console.Read(); &#125;&#125; 执行结果： 12345日志：命令模式.烤羊肉串 时间：200x-xx-xx xx:xx:xx 日志：命令模式.烤羊肉串 时间：200x-xx-xx xx:xx:xx 服务员：鸡翅没有了，请点别的烧烤。烤羊肉串！烤羊肉串！ 命令模式1命令模式（Command）：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。 命令模式（Command）结构图 Command类，用来声明执行操作的接口。 1234567891011abstract class Command&#123; protected Receiver receiver; public Command(Receiver receiver) &#123; this.receiver = receiver; &#125; abstract public void Execute();&#125; ConcreteCommand类，将一个接收者对象绑定于一个动作，调用接收者相应的操作，以实现Execute。 12345678910class ConcreteCommand : Command&#123; public ConcreteCommand(Receiver receiver) : base(receiver) &#123; &#125; public override void Execute() &#123; receiver.Action(); &#125;&#125; Invoker类，要求该命令执行这个请求。 1234567891011121314class Invoker&#123; private Command command; public void SetCommand(Command command) &#123; this.command = command; &#125; public void ExecuteCommand() &#123; command.Execute(); &#125;&#125; Receiver类，知道如何实施与执行一个与请求相关的操作，任何类都可能作为一个接收者。 1234567class Receiver&#123; public void Action() &#123; Console.WriteLine("执行请求！"); &#125;&#125; 客户端代码，创建一个具体命令对象并设定它的接收者。 123456789101112131415161718static void Main(string[] args)&#123; // 本来的代码执行是这样 // Receiver r = new Receiver(); // r.Action()直接执行 Receiver r = new Receiver(); // r.action已经变成了c对象的一个方法。 Command c = new ConcreteCommand(r); Invoker i = new Invoker(); i.SetCommand(c); // 这个地方就是定义里说的可用不同的请求对客户进行参数化 // 这里是排队，记录，撤销操作 i.ExecuteCommand(); Console.Read();&#125; 命令模式作用命令模式的优点： 1.它能较容易地设计一个命令队列； 2.在需要的情况下，可以较容易地将命令记入日志； 3.允许接收请求的一方决定是否要否决请求。 4.可以容易地实现对请求的撤销和重做； 5.由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类很容易。 其实还有最关键的优点就是命令模式把请求一个操作的对象与知道怎么执行一个操作的对象分割开。 但是否是碰到类似情况就一定要实现命令模式呢？ 这就不一定了，比如命令模式支持撤销/恢复操作功能，但你还不清楚是否需要这个功能时，你要不要实现命令模式？ 要，万一以后需要就不好办了。 其实应该是不要实现。敏捷开发原则告诉我们，不要为代码添加基于猜测的、实际不需要的功能。如果不清楚一个系统是否需要命令模式，一般就不要着急去实现它，事实上，在需要的时候通过重构实现这个模式并不困难，只有在真正需要如撤销/恢复操作等功能时，把原来的代码重构为命令模式才有意义。 学习设计模式的时候，要抛弃所有的可以直接通过函数执行的想法，所有的功能都必须通过类来完成。 命令模式的缺点： 可能产生大量具体命令类。因为针对每一个具体操作都需要设计一个具体命令类，这将增加系统的复杂性。 某个方法需要完成某一个功能，完成这个功能的大部分步骤已经确定了，但可能有少量具体步骤无法确定，必须等到执行该方法时才可以确定。具体一点：假设有个方法需要遍历某个数组的数组元素，但无法确定在遍历数组元素时如何处理这些元素，需要在调用该方法时指定具体的处理行为。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>大话设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[［设计模式］唠唠依赖注入]]></title>
    <url>%2F2019%2F07%2F17%2F%EF%BC%BB%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%EF%BC%BD%E5%94%A0%E5%94%A0%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 啥是依赖注入(Dependency injection)？ 直接上例子： 这不是依赖注入！123456789101112131415161718192021//这不是依赖注入！！！class Bar&#123;&#125;class Foo&#123; protected $bar; public function __construct() &#123; $this-&gt;bar = new Bar(); &#125; public function getBar() &#123; return $this-&gt;bar; &#125;&#125;$foo = new Foo(); 这就是依赖注入12345678910111213141516171819202122//这就是依赖注入。。。class Bar&#123;&#125;class Foo&#123; protected $bar; public function __construct(Bar $bar) &#123; $this-&gt;bar = $bar; &#125; public function getBar() &#123; return $this-&gt;bar; &#125;&#125;$bar = new Bar();$foo = new Foo($bar); 这也是依赖注入123456789101112131415161718192021222324252627//这也是依赖注入。。。class Bar&#123;&#125;class Foo&#123; protected $bar; public function __construct() &#123; &#125; public function setBar(Bar $bar) &#123; $this-&gt;bar = $bar; &#125; public function getBar() &#123; return $this-&gt;bar; &#125;&#125;$bar = new Bar();$foo = new Foo();$foo-&gt;setBar($bar); 依赖注入就是new好了依赖的对象注入进去，而不是在类中显式的new一个依赖的对象。其实，就是这么简单。。。 为啥要用依赖注入？虽然思想简单，但是在降低耦合度方面作用巨大。 依赖注入都可以怎么用下面举个例子说明（just for demonstration）： 比如我们做了个小游戏，里面的男人可以亲自己的妻子。123456789101112131415161718192021222324abstract class Human&#123;&#125;class Woman extends Human&#123;&#125;class Man extends Human&#123; protected $wife; public function __construct() &#123; $this-&gt;wife = new Woman(); &#125; public function kissWife() &#123; echo "the man kissed his wife"; &#125;&#125;$man = new Man();$man-&gt;kissWife(); 玩的人越来也多，新需求随之而来。。。 产品经理（腐腐）：妻子改成可以是男的吧，好多用户有这个需求，这样玩我们游戏的肯定更多。 程序员（猿猿）心里：擦，Wife又可以是Man，又可以是Woman，这可咋整。 这个时候，依赖注入就可以闪亮登场了。123456789101112131415161718192021222324252627282930abstract class Human&#123;&#125;class Woman extends Human&#123;&#125;class Man extends Human&#123; protected $wife; public function setWife(Human $human) &#123; $this-&gt;wife = $human; &#125; public function kissWife() &#123; echo "the man kissed his wife"; &#125;&#125;$man = new Man();$man-&gt;setWife(new Woman());$man-&gt;kissWife();$anotherMan = new Man();$anotherMan-&gt;setWife(new Man());$anotherMan-&gt;kissWife(); 这里我们看到，依赖注入的可以是继承依赖类的任何类，所以现在Man的Wife既可以是Woman也可以是Man。 玩的人越来也多，新需求随之而来。。。 产品经理（宅宅）：把妻子改成伴侣吧，伴侣里面除了Man和Woman再加个Cat，好多用户有这个需求，这样玩我们游戏的肯定更多。 程序员（猿猿）心里：擦，又是Man又是Woman还有Cat，幸好我会依赖注入。123456789101112131415161718192021222324252627282930313233343536373839404142abstract class Human&#123;&#125;interface canBePartner&#123;&#125;class Cat implements canBePartner&#123;&#125;class Woman extends Human implements canBePartner&#123;&#125;class Man extends Human implements canBePartner&#123; protected $partner; public function setPartner(canBePartner $partner) &#123; $this-&gt;partner = $partner; &#125; public function kissPartner() &#123; echo "the man kissed his partner"; &#125;&#125;$man = new Man();$man-&gt;setPartner(new Woman());$man-&gt;kissPartner();$man2 = new Man();$man2-&gt;setPartner(new Man());$man2-&gt;kissPartner();$man3 = new Man();$man3-&gt;setPartner(new Cat());$man3-&gt;kissPartner(); 这里我们看到，依赖注入不但可以是继承依赖类的所有子类，也可以是实现依赖接口的所有类。 所以如果我们在伴侣中再加入一个Dog，只需要让它实现canBePartner接口就可以了：12345class Dog implements canBePartner&#123;&#125;$man = new Man();$man-&gt;setPartner(new Dog()); 实际应用依赖注入虽然降低了耦合度，但是也有缺点，就是需要我们自己管理注入的对象。 所以，在实际应用中，我们通常需要实现一个容器去管理和实现依赖对象的注入。实际上，PHP的常用Web框架中都是这么做的。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Cluster]]></title>
    <url>%2F2019%2F07%2F06%2FMySQL-Cluster%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： MySQL Cluster也称为MySQL集群或者MySQL簇，是一种允许在无共享架构（SNA，share nothing architecture）系统中部署“内存”数据库集群的技术。通过无共享架构，可以使系统使用廉价的硬件获取持续的高可用性。本章首先介绍了MySQL集群的基础知识，重点介绍了MySQL集群的环境搭建方法。 MySQL Cluster简介MySQL Cluster是一个高性能、可扩展、集群化的数据库技术。MySQL集群是一种分布式架构，通常由一组计算机构成，每台计算机运行至少一个MySQL集群进程，每个MySQL集群进程对应一个“节点”（node）。通过节点间的切换，可以确保集群出现节点故障或者网络故障时的持续高可用性。 说明在很多情况下，一个“节点”对应一台计算机。但在讨论MySQL集群时，一个“节点”表示的是一个“集群进程”。如果在单台计算机开启了多个集群进程，那么这台计算机上存在了多个节点。 MySQL集群的组成MySQL集群由4类节点组成：SQL节点、数据节点、管理节点以及客户机节点。 1．客户机节点 为了实现MySQL集群中数据的增、删、改、查，需要通过MySQL客户机编辑、提交SQL语句（这里将MySQL客户机简称为客户机节点）。MySQL集群中最简单的客户机节点是打开CMD命令提示符窗口，然后输入“mysql -h localhost -u root -p”命令，接着连接MySQL 服务器。 2．SQL节点 SQL节点主要用于提供MySQL服务，提供了访问MySQL集群中数据节点中数据的“接口”。在MySQL集群体系中，客户机节点通过SQL节点访问数据节点中的数据，任意一个数据节点都是连接到所有的SQL节点的。当任意一个SQL节点出现故障时，客户机节点都可以将请求转移到其他SQL节点。当然，数据库开发人员应该提供一种当一个SQL节点出现故障时，客户机节点能够自行切换到其他SQL节点的机制。 事实上，MySQL集群主要是通过将NDB Cluster内存集群存储引擎与MySQL服务器集成实现的，因此SQL节点的MySQL服务必须支持NDB存储引擎才能实现MySQL集群。而传统的MySQL服务默认情况下仅支持8种存储引擎（不支持NDB Cluster存储引擎），为了实现MySQL集群，需下载、安装支持MySQL集群的MySQL服务软件。 通常，SQL节点使用命令“mysqld–ndbcluster”启动，或在my.ini配置文件的[mysqld]选项组中添加“ndbcluster”参数，使得SQL节点支持NDB Cluster 存储引擎。每个SQL节点对应一个mysqld.exe进程。 说明NDB是网络数据库（network database）的缩写。NDB存储引擎支持所有通常的MySQL数据类型和SQL语句，该存储引擎还提供了完整的事务支持，而且是ACID兼容的。 3．数据节点 数据节点用于存储所有属于MySQL集群的数据，这些数据在数据节点之间被复制，以保证在一个或多个数据节点出现故障时，MySQL集群仍然持续可用。可以这样理解：在MySQL集群体系中，客户机节点通过SQL节点访问数据节点中的数据，任意一个SQL节点都是连接到所有的数据节点的，当任意一个数据节点出现故障时，SQL节点都可以将请求转移到另一个数据节点。 数据节点是通过命令“ndbd”启动的，每个数据节点对应一个ndbd.exe进程。 MySQL集群中的事务安全是由数据节点保证的，任意一个事务产生的数据变化会同时反映到所有数据节点中；某个事务在执行过程中，某个数据节点数据更新的失败会导致整个事务的回滚。说明 每个数据节点中都有两个检查点，即本地检查点以及全局检查点。本地检查点的目的是将内存中的数据和硬盘上的数据进行同步。全局检查点是在各节点中进行通信，以保证事务的一致性。 4．管理节点 管理节点用于控制MySQL集群启动时的初始配置，管理MySQL集群内的其他节点。管理节点的初始配置由集群配置文件决定，集群配置文件默认的文件名为config.ini，该配置文件提供了数据节点和SQL节点的全局配置信息，包括数据、索引所占用内存大小、各个节点的IP地址信息、数据存放的目录信息等。 MySQL集群期间，管理节点会获取其他节点的状态和错误信息，并将这些信息写入集群日志，反馈给集群中的其他所有节点。例如，当数据节点出现新的事件时，数据节点将关于该事件的信息传输到管理节点，然后由管理节点将事件信息写入集群日志，并反馈给其他节点。由于管理节点担任了集群中各个节点的沟通工作，因此在启动其他节点之前，应该首先启动管理节点。管理节点是通过命令“ndb_mgmd”启动的，每个管理节点对应一个ndb_mgmd.exe进程。 说明管理节点只在集群启动和发生配置变化的时候起作用，集群正常运行期间停止管理节点，整个集群都将保持在线和可用状态。通常只需配置一个管理节点，然而为了排除单点故障需要，可能需要增加管理节点的数量。 MySQL集群架构可以看出：MySQL集群架构可以简单地分为4个区域，客户机节点、SQL节点、数据节点、管理节点，如图1所示。 图1 MySQL集群架构 MySQL集群中的数据保存在NDB存储引擎的表中（数据节点中），MySQL集群中的表结构保存在MySQL服务器中（SQL节点中）。数据库用户通过客户机节点连接SQL节点访问集群数据，为了保证每个数据节点中的数据均匀分布，在进行数据插入时，SQL节点采用分片的策略将数据均匀分配到不同的数据节点上。管理节点通过管理工具（ndb_mgmd）管理数据节点与SQL节点，MySQL Cluster所有的这些节点构成一个完整的MySQL集群体系。 MySQL Cluster环境搭建目前支持MySQL Cluster的操作系统有Linux、Mac OS X和Solaris，最新版本的MySQL Cluster支持更多的操作系统，包括Windows操作系统。本章以Windows操作系统为例，讲解MySQL Cluster配置的最简单方法。 准备工作MySQL集群的准备工作包括下载MySQL集群软件、准备主机以及网络环境。 主机：对于实验目的的MySQL集群主机而言，MySQL集群可以在一台单独的计算机上成功部署，每个数据节点、SQL节点设置不同的目录以及端口号，即可进行MySQL集群实验。为了让读者更好地理解MySQL集群，本书以5台主机为例部署MySQL集群环境。 网络环境：集群内的主机必须可以通过IP地址相互通信（读者可以通过ping命令判断集群内的主机是否连通）。为了提升MySQL集群的性能以及高可用性，MySQL集群通常在单独的子网中部署（不建议跨越公网部署MySQL集群）。除此之外，还要确保集群内所有主机的防火墙关闭，否者可能导致SQL节点与管理节点无法连接。 MySQL集群软件：所需的MySQL集群软件可以在 MySQL Cluster 官网免费下载，最新的MySQL集群软件提供了两种安装程序：图形化安装包msi与zip免安装压缩文件。本章以最新版本的免安装压缩文件mysql-cluster-gpl-7.3.2-win32.zip为例，讲解MySQL集群的配置过程（对于64 位Windows操作系统而言，读者可以下载mysql- cluster-gpl-7.3.2- winx64.zip）。 说明为了便于学习，读者也可以到本书指定的网址下载MySQL集群软件mysql-cluster-gpl-7.3.2-win32.zip。 假设当前的网络环境存在M、S1、S2、D1、D2五台主机，五台主机的IP 地址如表15-1所示，这些主机可以通过IP地址相互通信，并且它们的防火墙已经关闭。五台主机中，M主机是管理节点，D1和D2主机是数据节点，S1和S2是SQL节点。 表1 MySQL集群环境 对于免安装压缩文件mysql-cluster-gpl-7.3.2-win32.zip，将该文件分别拷贝到M、S1、S2、D1 与D2 五台主机的C盘，接着解压缩至当前文件夹，然后重命名为mysql-cluster，如图2所示。 为了便于启动管理节点、数据节点以及 SQL 节点，将图 15-2 中 bin 目录所在的路径（即C：\mysql-cluster\bin）添加到Path系统环境变量中（方法为：鼠标右键单击我的电脑高级环境变量系统变量Path），如图3所示。 图3 配置MySQL Cluster环境变量说明 如果当前主机存在其他MySQL服务，并且这些MySQL服务bin目录所在的路径已经配置到了 PATH 环境变量，建议删除这些环境变量的配置，或者将图2中bin目录所在的路径配置到Path环境变量最开始处。 数据节点的配置数据节点的配置较为简单，分别将D1与D2主机中mysql-cluster目录中的my-default.ini配置文件重命名为my.ini，然后分别在两个my.ini配置文件中添加[mysql_cluster]选项组，并在该选项组中添加下列参数信息，如下所示。12[mysql_cluster]ndb-connectstring = 192.168.4.15 说明[mysql_cluster]选项组的 ndb-connectstring 参数用于指定当前的数据节点连接哪一台管理节点主机（IP地址为192.168.4.15的M主机提供了管理节点服务）。至此，MySQL集群中的数据节点已经配置完毕。接下来讲解管理节点的配置方法。 SQL节点的配置步骤1：在S1、S2主机上注册MySQL服务。为了方便管理MySQL服务，便于启动、停止SQL节点，分别在S1、S2主机的CMD命令提示符窗口中运行下列命令，注册MySQL服务，执行结果如图15-4所示。cd C：\mysql-cluster\binmysqld.exe -install mysqlcluster▲图15-4 安装MySQL服务说明同一台主机的服务名不能重名，否则将提示如图15-4所示的“The service already exists！”错误信息。出现重名问题后，如果不想修改服务名，可以在CMD命令提示符窗口中运行“sc delete mysqlcluster”命令，删除指定的服务（如果该服务正在运行，删除服务时将失败）。成功注册MySQL服务后，右键单击“我的电脑”，在弹出的菜单中单击“管理”，在弹出的“计算机管理”窗口中双击“服务和应用程序”，然后单击“服务”选项，即可找到刚刚注册的MySQL服务（服务名为“mysqlcluster”），如图15-5所示（建议将MySQL服务的启动类型由自动修改为手动，再进行其他配置工作）。由于名字为“mysqlcluster”的MySQL服务缺失my.ini配置文件，mysqlcluster服务尚不能启动。 步骤2：启动MySQL服务。分别将S1与S2主机中mysql-cluster目录中的my-default.ini配置文件重命名为“my.ini”，然后单击图15-5 中的“启动”链接，或者在CMD 命令提示符窗口输入命令“net start mysqlcluster”启动MySQL服务，接着在CMD命令提示符窗口输入下面的命令，开启MySQL客户机，并连接MySQL服务器，如图15-6所示（默认情况下，初始密码为空字符串）。mysql -h localhost -u root -p▲图15-6 启动MySQL服务执行MySQL命令“show engines;”，执行结果如图15-7所示。从图15-7中可以看到，当前的MySQL服务默认的存储引擎为InnoDB，并且不支持NDB存储引擎。▲图15-7 查看MySQL服务存储引擎 ▲图15-7 查看MySQL服务存储引擎步骤3：开启S1、S2 主机MySQL服务的NDB Cluster 存储引擎支持。单击图15-8中的“停止”链接，或者在CMD命令提示符窗口输入命令“net stop mysqlcluster”，停止S1与S2主机的MySQL服务。分别在S1与S2主机my.ini配置文件的[mysqld]选项组中添加下列参数信息，该参数用于开启MySQL 服务的NDB Cluster 存储引擎支持。ndbcluster步骤4：指定管理节点。分别在S1与S2主机my.ini配置文件的[mysqld]选项组中添加下列参数信息，该参数用于指定当前的SQL节点连接哪一台管理节点主机（IP地址为192.168.4.15的A主机提供了管理节点服务）。ndb-connectstring = 192.168.4.15至此，MySQL集群中的数据节点以及SQL节点已经配置完毕，接下来讲解管理节点的配置方法。由于MySQL集群中SQL节点、数据节点以及管理节点的启动顺序有特殊要求，配置管理节点前，暂且不能启动数据节点与SQL节点。▲图15-8 MySQL服务管理 管理节点的配置管理节点负责管理MySQL集群内所有其他节点，管理节点的配置比较复杂。管理节点的初始配置由集群配置文件决定，该文件配置了所有管理节点、所有数据节点以及所有SQL节点的基本信息。这里将IP地址为192.168.4.15的M主机作为“管理节点”，在M主机C盘根目录创建conf目录，在该目录下创建config.ini文件作为集群配置文件，并输入如下内容：12345678910111213141516[NDBD DEFAULT]NoOfReplicas=2DataDir=C：/data[NDB_MGMD]HostName=192.168.4.15DataDir=C：/logs#数据节点[NDBD]HostName=192.168.4.11[NDBD]HostName=192.168.4.12#SQL节点[MYSQLD]HostName=192.168.4.13[MYSQLD]HostName=192.168.4.14 接着在M主机的C盘创建logs目录，在D1与D2主机的C盘创建data目录。需要注意的是：创建config.ini文件时，一定不能隐藏已知文件类型的扩展名。说明集群配置文件 config.ini 中共有 6 种选项组，分别是[NDB_MGMD DEFAULT]、[NDB_MGMD]、[MYSQLD DEFAULT]、[MYSQLD]、[NDBD DEFAULT]以及[NDBD]。其中，名字中包含有“DEFAULT”的选项组最多出现一次，分别用于配置管理节点、SQL 节点以及数据节点参数的默认值。[NDB_MGMD]、[MYSQLD]以及[NDBD]选项组分别用于单个管理节点、单个 SQL 节点以及单个数据节点的个性化配置。例如，[NDBD DEFAULT]选项组的 DataDir 参数定义了所有数据节点日志信息默认存放的路径；[NDB_MGMD]选项组的 DataDir 参数定义了当前管理节点日志信息存放的路径。每个节点都有各自的个性化配置，例如，每个节点的主机 IP 地址需要使用 HostName参数进行单独的配置。说明NoOfReplicas=2：表示在集群环境中，定义两个数据节点为一个节点组，同组存储的数据是相同的，继而避免了单点故障。可以看出，该参数定义了相同数据的份数，即数据的冗余次数。NoOfReplicas参数只能设置在[NDBDDEFAULT]选项组中，该参数对所有数据节点有效。NoOfReplicas参数的默认值为2，原因在于：假设当前MySQL集群环境存在两个数据节点D1和D2，需要存储两个数据A和B。如果将NoOfReplicas的值设为1，则数据A存储在节点D1上，数据B存储在节点D2上，此时，节点D1与节点D2中只要有一个节点宕机，数据将不再完整。但如果将NoOfReplicas的值设为2，则数据A存储在节点D1上，数据A的“副本”也将存储在节点D2上；数据B存储在节点D2上，数据B的“副本”也将存储在节点D1上，此时，即便节点D1与节点D2中有一个节点宕机，数据依然完整。 MySQL集群的启动MySQL集群的启动包括管理节点的启动、数据节点的启动以及SQL节点的启动，启动顺序依次是：先启动管理节点，接着是数据节点，最后是SQL节点。 步骤1：启动管理节点。 在M主机的CMD命令行窗口中运行如下命令，即可启动管理节点，如图15-9所示。ndb_mgmd ——configdir=c：/conf -f c：/conf/config.ini - initial▲图15-9 管理节点的启动管理节点成功启动后，M主机的C：/logs目录中将自动创建ndb_1.pid文件、ndb_1_cluster.log文件以及ndb_1_out.log文件，如图15-10所示。其中，ndb_1_cluster.log文件以及ndb_1_out.log文件用于记录管理节点的日志信息，ndb_1.pid用于记录管理节点的进程ID。 ▲图15-10 管理节点的日志同时，M主机的C：/conf目录中将自动创建ndb_1_config.bin.1文件，如图15-11所示。该文件是config.ini 集群配置文件的二进制缓存文件“副本”，以后每次重新启动管理节点时，管理节点将直接加载二进制缓存文件ndb_1_config.bin.1的配置信息。如果config.ini集群配置文件的内容发生了变动，需要删除ndb_1_config.bin.1文件后，再启动管理节点。步骤2：查看管理节点的状态。管理节点一旦启动，即可通过管理节点客户机了解管理节点当前的状态信息。打开 M 主机新的CMD命令行窗口，输入ndb_mgm命令，接着输入show命令，即可查看管理节点当前的状态信息，如图15-12所示。▲图15-11 管理节点的二进制缓存文件▲图15-12 查看管理节点的状态图15-12中状态信息的含义依次如下：① 连接本地主机的管理节点，管理节点默认情况下占用的端口号为1186。② 管理节点的配置如下：[ndbd(NDB)] 2 node(s)：两个数据节点。③ id=2 的数据节点主机 IP 地址为 192.168.4.11，该数据节点没有连接管理节点。集群中的每个节点都有唯一的标识。④ id=3的数据节点主机IP 地址为192.168.4.12，该数据节点没有连接管理节点。⑤ [ndb_mgmd(MGM)] 1 node(s)：一个管理节点。⑥ id=1的管理节点主机IP 地址为192.168.4.15。⑦ [mysqld(API)] 2 node(s)：两个SQL节点。⑦ [mysqld(API)] 2 node(s)：两个SQL节点。⑧ id=4的SQL 节点主机IP 地址为192.168.4.13，该SQL节点没有连接管理节点。⑨ id=5的SQL 节点主机IP 地址为192.168.4.14，该SQL节点没有连接管理节点。步骤3：启动D1、D2主机的数据节点。在D1主机的CMD命令行窗口中运行如下命令，执行结果如图15-13所示，此时D1主机的数据节点服务成功启动。从图15-13中可以看出，管理节点默认情况下占用的是1186端口号。Ndbd – initial▲图15-13 启动D1主机的数据节点D1主机的数据节点服务成功启动后，D1主机的C：/data目录中将自动创建如图15-14所示的文件（或者目录）。▲图15-14 D1数据节点的文件在D2主机的CMD命令行窗口中运行如下命令，执行结果如图15-15所示，此时D2主机的数据节点服务成功启动。Ndbd – initial▲图15-15 启动D2主机的数据节点D2主机的数据节点服务成功启动后，D2主机的C：/data目录中将自动创建如图15-16所示的文件（或者目录）。▲图15-16 D2数据节点的文件说明第一次启动数据节点时，或者config.ini配置文件改动后，在ndbd命令后建议添加“– initial”参数，以便进行数据节点的初始化工作。以后再次启动数据节点时，无需添加该参数，否则该参数将会使数据节点删除由早期ndbd进程创建的、用于恢复的任何文件，包括恢复用途的日志文件。 步骤4：启动S1、S2主机的MySQL服务。 重新启动S1、S2主机的MySQL服务，重新执行MySQL命令“show engines;”， 重新启动 S1、S2 主机的MySQL服务，重新执行MySQL命令“show engines;”，执行结果如图15-17所示。从图15-17中可以看到，当前的MySQL 服务已经支持NDB Cluster存储引擎。 步骤5：查看管理节点的状态。 打开M主机新的CMD命令行窗口，输入“ndb_mgm”命令，接着输入“show”命令，查看管理节点当前的状态信息，如图15-18所示。从图15-18可以看出：MySQL集群的所有节点已经成功启动。▲图15-17 查看S1、S2主机的存储引擎▲图15-18 查看管理节点的状态15.2.6 集群测试在S1 主机上打开CMD 命令提示符窗口，并输入“mysql -h localhost -u root -p”命令连接S1 主机的MySQL服务。接着依次输入下面的SQL语句，执行结果如图15-19所示。1234create database student;use student;create table teacher(teacher_no int primary key) engine=ndb;insert into teacher values(1); ▲图15-19 添加测试数据由于 teacher 表的存储引擎是 NDB Cluster，teacher 表对应的表结构文件存放在 S1 主机C：\mysql-clusterdata\student目录下，如图15-20所示。▲图15-20 NDB存储引擎的表结构文件在另一台S2主机上打开CMD 命令提示符窗口，并输入“mysql -h localhost -u root -p”命令连接S2主机的MySQL服务。接着依次输入下面的SQL语句，执行结果如图15-21所示。123show databases;use student;select * from teacher; ▲图15-21 集群测试 可以看到：针对S1主机NDB Cluster存储引擎teacher表的数据更新同步到了S2主机。至此MySQL集群的环境搭建工作已经完毕。鉴于目前MySQL Cluster的成熟案例并不太多，为了便于读者快速地部署 MySQL Cluster 环境，上述 MySQL Cluster 环境搭建方法仅仅是集群的最简化配置方法。有关MySQL Cluster 的复杂配置，读者可以登录MySQL Cluster官网查看具体资料。 说明SQL节点和数据节点在启动的时候需要连接到管理节点读取MySQL集群的配置信息，SQL节点和数据节点启动完成后，管理节点是可以停止工作的。因此MySQL集群过程中，即便管理节点宕机，也不会影响整个集群服务，所以管理节点一般只需要一台主机即可满足应用要求。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SQL语句优化]]></title>
    <url>%2F2019%2F07%2F06%2FSQL%E8%AF%AD%E5%8F%A5%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： SQL语句优化的首要任务是了解SQL语句的频率，分析当前的应用是查询操作频繁还是更新操作频繁。一条频繁执行但是性能糟糕的SQL语句可能对整个应用产生严重的负面影响，例如消耗过多的服务器内存资源，消耗过多的网络带宽。 如果当前的应用更新操作较为频繁，需要解决更新操作带来的并发问题，例如锁等待、死锁问题。可以采用InnoDB存储引擎引入行级锁缩小锁的粒度，解决更新操作的并发问题。读者可以参考事务与锁机制章节的内容，这里不再赘述。 如果当前的应用查询操作较为频繁，此时需要借助explain命令分析select语句，了解select语句的执行情况，分析select语句的性能瓶颈，进而对select语句进行重新设计或者对表结构进行重新设计（例如添加索引或者拆分表），让查询优化器能够更好地工作，提升查询性能，这是本节着重讲解的内容。 了解SQL的执行频率单个数据库用户对数据库中的少量数据进行操作，无法挖掘数据库的瓶颈。只有数据库服务器长时间运行，并且有批量用户进行频繁操作的时候，数据库服务器的性能瓶颈才会体现出来。 1．每秒查询率QPS每秒查询率QPS（query per second）是指MySQL每秒执行的查询总量，在MySQL 5.1.30及以下版本可以通过Questions状态值每秒内的变化量来近似表示，而从MySQL 5.1.31开始，可以通过Queries状态值每秒内的变化量来近似表示。引入Queries的目的是解决Questions状态变量没有记录存储程序中执行的Query的问题。执行MySQL命令“show status like ‘questions’;”以及“show status like ‘queries’;”可以查看两个状态值，如图1所示。 图1 Queries与Questions Questions：MySQL服务执行的MySQL语句数量，仅仅包含MySQL客户机发送到MySQL服务器的MySQL语句，存储程序中的MySQL语句不包含在内。该状态变量不统计com_ping、com_statistics、com_stmt_prepare、com_stmt_close以及com_stmt_reset命令。 Queries：MySQL服务执行的MySQL语句数量，包括存储程序中的MySQL语句。该状态变量不统计com_ping以及com_statistics命令。 使用MySQL命令“show global status like ‘Com_％’;”可以查看当前MySQL服务实例执行各种SQL语句的次数。由于该命令的统计信息比较多，这里不再一一罗列，下面仅列出几种典型的统计信息。 Com_select：记录了执行select操作的次数。 Com_insert：记录了执行insert操作的次数，对于批量插入的insert操作，只累加一次。 Com_update：记录了执行update操作的次数。 Com_delete：记录了执行delete操作的次数。 通过查看上面的统计信息，可以计算得出当前应用中数据更新语句与查询语句的大致比例，从而了解当前应用偏向于OLTP还是OLAP，以便对存储引擎进行适当调整。针对InnoDB表的更新操作，可以通过Com_commit和Com_rollback得到事务提交的次数以及回滚的次数，如果回滚频繁，就说明应用程序存在某些问题。 说明Com_xxx计数器状态变量表示xxx类型语句执行的次数。 2．数据处理状态信息执行了删除语句，删除语句影响的行数可能为0，使用MySQL命令“show status like ‘handler％’;”可以查看表数据的处理情况。 Handler_delete：表示记录从表中删除的次数。Handler_delete与Com_delete不一样，只要执行delete操作，Com_delete状态值就会增加；只有从表中删除了记录的时候，Handler_delete状态值才会增加。 Handler_commit：表示提交SQL语句数。 Handler_rollback：表示rollback语句的执行次数。 Handler_update：更新表的行数。 Handler_write：向表插入记录的行数。Handler_savepoint：在事务中放置保护点的次数。 Handler_savepoint_rollback：在事务中回滚到保护点的次数。 3．索引使用情况 Handler_read_first：表示索引中第一个键值被读的次数。值如果较高，说明执行了大量的全索引扫描select语句。例如select column_name from table，假设column_name列上有索引。 Handler_read_key：表示根据索引读一行记录的请求数。值如果较高，说明 select 语句正在使用索引进行查询操作。 Handler_read_next：表示按照索引的顺序读下一行记录的请求数，按索引的顺序读取数据。 Handler_read_prev：表示按照索引的顺序读前一行记录的请求数，按索引的倒序读取数据，主要用于优化order by …… desc子句。 说明Handler_xxx计数器状态变量表示xxx类型语句执行的次数或者对记录影响的行数。从MySQL5.6开始，新增了下面的数据处理状态信息。 Handler_read_last：表示索引中最后一个键值被读的次数。对索引字段使用order by 子句时，首先发起第一个索引值的请求，然后是下一个索引值的请求。对索引字段使用order by…desc子句时，首先发起最后一个索引值的请求，然后是前一个索引值的请求。 Handler_read_rnd：表示根据固定位置读一行记录的请求数。如果执行了大量需要对结果进行排序的查询，该值较高。该值较高，通常意味着很多查询扫描了整个表，或者表中没有创建合适的索引。 Handler_read_rnd_next：表示读取数据文件中下一行记录的请求数。如果进行了大量的全表扫描，该值较高。该值较高，通常意味着表中没有创建合适的索引或者查询没有利用好已有的索引。 另外，使用MySQL 命令“show status like ‘Innodb_rows％’;”可以查看InnoDB表记录的查询、更新行数。 Innodb_rows_read：从InnoDB表中读取的记录行数。 Innodb_rows_inserted：向InnoDB表插入的记录行数。 Innodb_rows_updated：更新InnoDB表的记录行数。 Innodb_rows_deleted：从InnoDB表中删除的记录行数。 定位执行效率较低的SQL语句分析Select_scan、Select_full_join、Select_full_range_join、Select_range_check、Handler_read_rnd以及Handler_read_rnd_next等状态信息，可以查看当前MySQL服务实例中select语句没有使用索引的次数。开启慢查询日志，可以在慢查询日志中找出超过某一个时间阈值（该值由 long_query_time参数设置）或者没有使用索引的SQL语句。如果这些SQL语句频繁执行，则可能对MySQL的性能造成负面影响。 慢查询日志只包含成功执行过的SQL语句，在查询语句执行期间，当系统性能出现问题时，使用慢查询日志并不能定位问题，可以使用MySQL命令“show processlist;”查看当前MySQL服务实例正在执行询日志并不能定位问题，可以使用MySQL命令“show processlist;”查看当前MySQL服务实例正在执行的线程，包括线程的状态（例如是否出现表锁现象等）。这样就可以实时地查看MySQL服务实例的执行情况，同时可以对一些表级锁操作进行适当优化。状态信息出现在Command列，一条查询从开始运行到运行结束，它的状态变化多次（共有12个状态）。这里仅罗列其中几个，如表1所示。 表1 线程的常用状态 另外，还可以使用MySQL命令“show status like ‘uptime’;”查询当前MySQL服务实例的工作时间，使用MySQL命令“show status like ‘slow_queries’;”查询当前MySQL服务实例执行的慢查询的次数等信息。 分析select语句有的应用对select语句的性能要求较高，此时单纯依靠开发者的直觉设计select语句，可能导致“理想”与“现实”出现偏差。可以使用explain命令或desc命令分析select语句的执行计划，从而了解select语句的执行情况，进而分析select语句的性能瓶颈，然后对select语句进行重新设计或者对表结构进行重新设计（例如添加索引或者拆分表），让查询优化器能够更好地工作，提升查询性能。explain的语法格式非常简单（desc语法格式与explain的语法格式相同），如下所示： explain select语句 说明desc命令通常用于获取表结构的相关信息。而explain命令通常用于获取查询的执行计划，例如，多个表进行 join 连接运算时，这些表如何连接、连接顺序如何等信息都可以通过explain命令获取。在MySQL 5.7中，使用explain命令还可以获取select、delete、insert、replace以及update等语句的执行计划。然而，一般而言，由于select语句对MySQL的性能影响较大，通常使用explain命令获取select语句的执行计划。explain命令返回了一行或者多行记录，包括了select语句中用到的各个表的信息。 例如，查询姓“张”学生的信息，可以使用下面的SQL语句。使用explain对该SQL语句进行分析，如图2所示。1explain select * from student where student_name like '张_'\G 图2 分析select语句 explain命令的返回信息说明如下。 id：查询的序列号。 select_type：查询语句的类型，可以为以下任何一种。 simple：简单查询语句（不使用union或子查询的查询）。 primary：主查询语句。 union：union中的第二个或后面的select语句。 dependent union：相关子查询中的union语句，union中的第二个或后面的select语句。 union result：union 的合并结果。 subquery：非相关子查询中的第一个select语句。 uncacheable subquery：结果集无法缓存的子查询。 dependent subquery：相关子查询中的第一个select语句。 derived：派生表的select语句。 table：执行该查询时所访问的数据库表。 type：表数据的访问类型。下面给出各种访问类型，按照性能从最佳类型到最坏类型进行排序。 system：结果集中仅有一条记录。这是const连接类型的一个特例。 const：表中有多条记录，但结果集只包含一条记录。例如比较运算符中含有主键字段或者唯一性约束字段，只查询出表的一条记录。 eq_ref：最多只会有一条匹配结果。两个表进行连接运算时，一个表使用主键字段或者唯一性约束字段与另一个表连接，查询出若干条记录。除了const类型，是比较好的连接类型。 ref：两个表进行连接运算时，一个表使用普通索引与另一个表连接，查询出若干条记录。 ref_or_null：两个表进行连接运算时，一个表使用普通索引与另一个表连接（这与ref类似），不同之处在于，检索时额外搜索包含null值的记录。 index_merge：查询中同时使用两个（或更多）索引，然后对索引结果进行merge之后再读取表数据。在这种情况下，key字段表示使用了哪个索引，key_len字段表示使用索引时关键字的最长长度（字节数）。 unique_subquery：使用了子查询，且子查询的返回结果包括主键字段或者唯一性约束字段。 index_subquery：使用了子查询，且子查询使用了普通索引（不是主索引或唯一索引）。 range：使用索引字段，检索给定范围的记录。在这种情况下，key字段表示使用了哪个索引。key_len字段表示使用索引时关键字的最长长度（字节数）。在该类型中，ref字段值为NULL。 index：从第一个关键字开始，对索引进行顺序扫描。即便如此，index通常比ALL快，因为索引文件比数据文件小。 all：对表进行全表扫描。说明检索数据时MySQL可能没有使用索引，效率会受到重大影响，应尽可能地优化select语句或者添加索引以避免此类情况的发生。 fulltext：全文索引。说明从全表扫描（full table scan）、索引扫描（index scans）、范围扫描(range scans)、唯一索引查找（unique index lookups）到常量（constants）扫描，访问速度依次递增，访问的数据越来越少。 possible_keys：检索数据时可能使用到的索引，这就意味着possible_keys里面所包含的索引可能在 select 语句实际运行过程中根本没有用到。如果这个字段的值是 null，就表示没有索引被用到。这种情况下，可以检查where子句中哪些字段适合增加索引以提高查询的性能。 key：实际使用的索引。当没有任何索引被用到的时候，这个字段的值就是NULL。想让MySQL强行使用或者忽略在possible_keys 字段中的索引列表，可以在select 语句中使用关键字force index，use index或ignore index。 key_len：使用的索引关键字的长度（字节数）。当key字段的值为NULL时，索引的长度就是NULL。 ref：显示了哪些字段或者常量被用来和索引关键字匹配以从表中查询记录。 rows：返回MySQL认为在查询中应该检索的记录数。 extra：显示了查询中MySQL的附加信息。以下是这个字段的几个不同值的解释。 distinct：当MySQL找到第一个匹配记录后，就不再搜索其他记录了。 not exists：MySQL 能够对查询进行left join 优化，当在当前表中找到一条记录符合left join匹配标准时，就不再搜索更多的记录了。 range checked for each record (index map：#)：MySQL 没找到合适的可用的索引，但是发现来自前面表的字段值已知，部分索引可以使用。 using filesort：当查询中包含order by子句，而且无法利用索引完成排序操作的时候，MySQL查询优化器不得不选择相应的排序算法，在内存或者硬盘上进行排序。应尽可能地优化select语句或者添加索引以避免此类情况的发生。 using index：直接从索引中取得信息，不需要从表中获取数据。这就意味着查询时的字段是索引的关键字。 using temporary：MySQL需要创建临时表存储结果集以完成查询。在group by以及order by查询中比较常见。 using where：如果查询不是读取表的所有数据，也不是仅仅通过索引就可以获取所有需要的数据，则会出现using where信息。 using sort_union(……), using union(……), using intersect(……)：说明如何为index_merge连接类型合并索引扫描。 using index for group-by：类似于访问表的using index 方式，using index for group-by表示在进行group by或distinct查询时，分组字段也在索引中。 Full scan on NULL key：子查询中的一种优化方式，主要在遇到无法通过索引访问NULL 值的时候使用。Impossible WHERE noticed after reading const tables：MySQL 查询优化器通过收集到的统计信息判断出不可能存在的结果。No tables：查询语句中使用不包含任何FROM的子句。Select tables optimized away：当使用某些聚合函数来访问某个索引字段的时候，MySQL 查询优化器会通过索引直接一次定位到所需的数据行，完成整个查询。当然，前提是在查询语句中不能有group by操作。使用下面的SQL语句在student表的student_name字段创建两个普通索引，其中name_index1索引仅仅对学生的“姓”创建了索引。然后重新使用explain命令分析两条select语句，如图14-69所示。1234create index name_index on student (student_name);create index name_index1 on student (student_name(1));explain select * from student where student_name like '张％'\Gexplain select * from student use index (name_index1) where student_name like '张％'\G 图14-69 分析select语句从图中可以分析，第一条select语句执行时使用了name_index索引检索了student表，第二条select语句由于指定使用索引name_index1，执行时使用了name_index1索引检索了student表（注意两个索引的长度key_len的值不相同）。 索引与select语句有时数据库表即使存在了合理的索引，不良的select语句也可能导致索引无法使用，对于InnoDB表而言，这样不仅会降低检索性能，还会导致行级锁升级为表级锁。因此，为了提升select语句的性能，合理的select语句与良好的索引结构缺一不可。（1）对索引关键字字段使用了函数将导致索引无法使用。下面的SQL语句同样实现了查询姓“张”学生的信息，使用explain或desc对该SQL语句进行分析，如图14-70所示。可以看到：由于type为ALL，并且rows的值为6（总共有6条学生信息），可以得知该select语句进行的是全表扫描，当学生表中的记录非常多时，该select语句会导致MySQL的性能瓶颈。事实上，where条件语句后的索引字段加上了函数处理的话，将不能使用索引。1explain select * from student where substring(student_name,1,1)='张'\G ▲图14-70 索引与select语句（1）（2）对索引字段进行模糊查询时，模式的第一个字符是通配符时，将导致索引无法使用。下面的SQL语句实现了查询姓名中含有“张”的学生信息，使用explain或desc对该SQL语句进行分析，如图14-71所示。同样，该select语句会导致MySQL的性能瓶颈。事实上,模糊查询时，查询模式的第一个字符是通配符时，将不能使用索引。 1explain select * from student where student_name like '％张％'\G ▲图14-71 索引与select语句（2）3）违反最左前缀原则的select语句，将导致索引无法使用。例如，下面的SQL语句首先在teacher表的（teacher_name、teacher_contact）组合字段创建一个组合索引name_contact，然后查询teacher_contact值为“11000000000”的教师信息，执行结果如图14-72所示。12create index name_contact on teacher (teacher_name,teacher_contact);explain select * from teacher where teacher_contact='11000000000'\G 上面的select语句并没有使用组合索引name_contact，原因是该select语句违反了最左前缀原则。下面的select语句适用于最左前缀原则，因此使用了组合索引name_contact，执行结果如图14-73所示。explain select * from teacher where teacher_name=’张老师’\G4）使用不等于（not操作符、！=或者&lt;&gt;）作为查询条件，将导致索引无法使用。例如查询不是姓“张”学生的信息，可以使用下面的SQL语句。使用explain或desc对该SQL语句进行分析，执行结果如图14-74所示。1desc select * from student where student_name not like '张_'\G 图14-72 索引与select语句（3）▲图14-73 索引与select语句（4）5）检索值的数据类型与索引字段不同，虽然MySQL能够进行数据类型转换，但却不会使用索引。例如，下面的两条select语句从student表中检索出学号为“2012001”的学生信息，使用explain或desc对这两条select语句进行分析，第二条select语句没有使用索引，如图14-75所示。12desc select * from student where student_no='2012001'\Gdesc select * from student where student_no=2012001\G ▲图14-74 索引与select语句(5) 图14-75 索引与select语句（6） 分页与select对于MySQL而言，只需要指定select语句limit关键字start与length的值，就可以轻松地实现分页功能。但是如果考虑性能因素，当start的值比较大的时候，MySQL的分页性能会明显下降。下面的操作步骤意在说明start的取值与MySQL分页性能之间的关系。步骤1：准备海量测试数据。假设某个新闻发布系统存在新闻表news，主键是news_id，创建news 表的create table 语句如下所示。title表示新闻的标题，content表示新闻的内容，publish_time表示新闻的发布时间。123456create table news(news_id int auto_increment primary key,title char(100) not null,content text,publish_time datetime); 下面的MySQL语句负责创建存储过程insert_n()，该存储过程的功能是向news表中插入n条新闻信息。12345678910111213delimiter $$create procedure insert_n(n int)modifies sql databegindeclare start int default 0;while start&lt;n doset start = start + 1;insert into news values(start,'title','content',now());end while;end;$$delimiter ; 下面的MySQL语句负责调用存储过程insert_n()，向news表插入百万级别的新闻信息。1call insert_n(1000000); 主机执行该存储过程共用了将近 30 分钟的时间，如图14-76所示。▲图14-76 批量插入百万条数据所需要的时间步骤2：数据库用户需要分页浏览其中的10条新闻信息。假设数据库用户分页浏览新闻内容时，每一页最多容纳 10 条新闻信息，当前页的第一条新闻的news_id是900001，最后一条新闻的news_id应该是900010。对于该应用，数据库开发人员可能使用下列方法实现。 方法一：1select * from news limit 900000,10; 方法二：1select * from news order by news_id limit 900000,10; 方法三：1select * from news where news_id&gt;900000 order by news_id limit 10; 或者1select * from news where news_id&gt;900000 limit 10; 比较这3种方法的执行时间，如图14-77、图14-78、图14-79所示。第三种方法耗费的时间最短，大概是0.05秒；前面的两个方法执行时间大致相当，耗时最长，大概是4秒多钟的时间（耗费的时间是第三种方法的80倍）。如果多个数据库用户同时分页浏览新闻信息，第三种方法的性能优势更加明显。 图14-77 方法一的执行时间▲图14-78 方法二的执行时间▲图14-79 方法三的执行时间 分析：limit 900000,10的意思是扫描满足条件的900010行记录，扔掉前面的900000行记录，返回最后的10行记录。对于方法一的select语句而言，实际上执行的是全表扫描，如图14-80所示；对于方法二的select语句而言，使用聚簇索引（或者主键索引）扫描前900010行记录；对于方法三的select语句而言，使用聚簇索引（或者主键索引）进行范围扫描，扫描201394行记录。可以看出：方法三的分页性能更加优越。结论：在进行分页时，如果使用聚簇索引（或者主键索引）进行范围扫描，性能更加优越。 扩展：同样的道理，假设数据库用户分页浏览新闻内容时，每一页最多容纳 10 条新闻信息，当前页的第一条新闻的news_id是900001，最后一条新闻的news_id是900010。那么当前页的下一页可以使用下面的select语句实现。1select * from news where news_id&gt;900010 limit 10; 或者1select * from news where news_id&gt;900010 order by news_id limit 10; 当前页的上一页可以使用下面的select语句实现。1select * from news where news_id&lt;900000 order by news_id desc limit 10; SQL语句其他注意事项SQL语句的编写是一门艺术，在编写SQL语句时，首先应该确保SQL语句能够正确地执行，除此以外，还要考虑SQL语句的效率。下面介绍几点在编写SQL语句时应该注意的问题。 1）获取了不需要的字段。如果应用程序并不需要表的所有字段，避免使用“*”可以减轻MySQL服务器内存压力以及网络带宽压力。2）同一功能的SQL语句，书写格式尽量保持统一。例如查询学生的所有信息，如果A、B程序员分别写为：12select * from student;select * from student;（中间多了空格） 上面两个select语句功能完全相同，并且它们产生的结果以及执行的时间是一样的。但是如果考虑到缓存因素（例如查询缓存Query Cache 开启时），功能相同的两条select语句可能导致查询缓存失效。原因在于：查询缓存匹配的过程是一个区分大小写的hash查找，在缓存中两个相似的查询哪怕是一个单字节不一样，也不会匹配。 3）使用存储程序。存储程序在解析时，自动检查语法错误、权限以及所有对象的依赖性。而等到执行的时候，会直接执行，而不会进行上述检查，这也是存储程序执行效率高的主要原因。当存储程序所依赖的对象发生了变化，MySQL会自动将存储程序的状态设置为INVALID，而存储程序的状态如果是INVALID，则会在下次执行的时候尝试重新解析。4）使用预处理prepared statement。使用预处理prepared statement可以提升SQL语句的性能，原因在于预处理中的SQL语句只需要解析一次，之后执行SQL语句时，就不需要再进行解析操作。如果需要多次执行同一个SQL语句，可以使用预处理prepared statement提升SQL语句的性能。5）根据齿轮原则，多个表进行join连接运算时，使用小结果集启动大结果集。6）当查询结果集只有一行数据时使用limit 1，可以提前终止查询语句的执行。 7）使用连接（join）来代替子查询连接（join）之所以更有效率一些，是因为连接（join）不需要在内存中使用临时表，而子查询需要在内存中创建临时表来完成，逻辑上需要两个步骤的查询工作。14.6.7 profiling性能分析工具通过慢查询日志可以得知哪些SQL语句执行效率低下，通过explain命令可以得知SQL语句的执行计划、索引使用等信息。如果这些信息还不够详细，可以通过profiling性能分析工具得到更准确的SQL执行消耗系统资源的信息。profiling是另一个常用的性能分析工具，profiling能够显示SQL语句执行过程中消耗各种系统资源的信息。通过分析这些信息可以及时发现不良的SQL语句，从而对其进行调优。例如，通过profiling工具可以查看SQL语句的执行时间、System lock 以及Table lock花费的时间等信息，这对定位一条I/O或CPU消耗严重的SQL语句非常重要。默认情况下，profiling是关闭的。 1）使用下面的set命令开启profiling1set profiling=1; 2）使用下面的SQL语句查询姓“张”学生的信息。1select * from student where student_name like '张％'; 3）使用MySQL命令“show profiles;”查看所有SQL语句的执行时间（Duration 的单位为秒），执行结果如图14-81所示。 4）使用MySQL命令“show profile for query 1;”查询Query_ID 值为1 的SQL语句的具体执行时间，如图14-82所示。 ▲图14-82 profiling性能分析工具 5）测试完毕以后，关闭profiling。1set profiling=0;]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[锁资源的优化]]></title>
    <url>%2F2019%2F07%2F04%2F%E9%94%81%E8%B5%84%E6%BA%90%E7%9A%84%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 锁是数据库实现数据并发访问最为重要的资源。不合适的锁粒度，不适当的加锁时机、解锁时机，不恰当的锁作用范围等都会导致锁资源的争用现象，继而出现锁等待问题，甚至是死锁问题。 表级锁资源竞争对于表级锁而言，读锁与写锁是相互排斥的锁，可以简单地理解为：使用表级锁时，对同一个表的查询操作与对同一个表的更新操作是完全串行化的，不能并发地执行，否则将出现锁等待现象。数据库管理员可以使用MySQL命令“show status like ‘table_locks％’;”，通过查看表级锁状态变量的值，分析当前MySQL服务实例上表级锁资源竞争的情况，如图1所示。这两个状态变量的解释如下。 图1 表级锁资源竞争 Table_locks_immediate：使用表级锁后立即释放表级锁的次数，从MySQL服务启动后开始记录。 Table_locks_waited：出现表级锁争用而发生的锁等待次数，从MySQL服务启动后开始记录。如果 Table_locks_waited 的值较大，说明表级锁争用严重，存在严重的并发瓶颈（表级锁不存在死锁问题）。 表级锁资源竞争的解决方案表级锁允许多个线程同时从一个表中进行读取操作，但如果一个线程想要对表进行更新操作，它必须首先获得独占访问。更新期间，所有其他想要访问该表的线程必须等待直到更新完成。通常认为表更新比表检索更重要，因此通常给更新操作赋予更高的优先级，确保了更新操作不被“饿死”，即使该表有很繁重的检索操作。 然而这种设计会导致读操作被“饿死”，假设MySQL客户机A针对MyISAM表执行长时间的select语句A，期间，MySQL客户机B对该表进行更新操作B，MySQL客户机B必须等待直到select语句A完成；MySQL客户机C对该表执行另一个select语句C，由于更新操作B比select语句C优先级高，select语句C等待更新操作B完成，并且等待select语句A完成。MySQL允许改变语句调度的优先级，使得多个MySQL客户机的查询更好地协作，确保特定类型的查询被更早地处理。 ● 使用“-low-priority-updates”选项启动mysqld。此时所有更新操作的优先级比select语句的优先级低。在这种情况下，select语句C将在更新操作B前执行，而不需要等候select语句A完成。● 使用MySQL命令“set low_priority_updates=1;”指定某一个会话中的更新操作使用低优先级。● 向特定的insert、delete、update、replace或者load data语句添加low_priority选项，降低这些操作的优先级。● 向特定的select语句添加high_priority选项，提高检索操作的优先级。● 为max_write_lock_count系统变量指定一个低值启动mysqld，强制MySQL在具体数量的插入完成后临时提高所有等待执行的select语句的优先级。这样允许在一定数量的写锁后存在读锁。● 使用延迟插入。● 对SELECT语句使用sql_buffer_result可以使表锁定时间变短。● 对同一个表混合使用select和delete语句出现问题时，在delete语句中添加limit选项指定删除的记录行数。● 启用并发插入。 MyISAM表上有一个读锁时，原则上其他MySQL客户机不能对该表进行插入操作。但启用并发插入后，MyISAM表支持查询和插入的并发操作，可以在一定程度上缓解表级锁争用问题。全局系统变量concurrent_insert专门用以控制并发插入的行为。该参数值可以使用MySQL命令“show variables like ‘concurrent％’;”进行获取，如图14-84 所示。 图2 concurrent_insert系统变量 ● 当concurrent_insert设置为0时，不允许并发插入。● 当concurrent_insert设置为1时，如果MyISAM表中没有空洞（即表的中间没有被删除的行），在一个MySQL客户机读表的同时，MyISAM允许另一个MySQL客户机从表尾插入记录。这也是MySQL的默认设置。● 当concurrent_insert设置为2时，无论MyISAM表中有没有空洞，都允许在表尾并发插入记录。注意：并发插入对隐式表级锁有效，对显式表级锁无效。使用InnoDB替换MyISAM存储引擎是表级锁资源竞争的最有效解决方案。 行级锁的资源竞争数据库管理员可以使用MySQL命令“show status like ‘innodb_row_lock％’;”，通过检查行级锁状态变量的值，分析当前MySQL服务实例上行级锁资源竞争的情况，如图14-85所示。这5个状态变量的解释如下。 ▲图14-85 行级锁的资源竞争 ● Innodb_row_lock_current_waits：当前锁等待的数量，从MySQL服务启动后开始记录。● Innodb_row_lock_time：锁等待的总时间，从 MySQL 服务启动后开始记录。● Innodb_row_lock_time_avg：锁等待的平均时间，从MySQL服务启动后开始记录。该值较大时，说明锁冲突大。● Innodb_row_lock_time_max：最长的一次锁等待时间，从MySQL服务启动后开始记录。● Innodb_row_lock_waits：锁等待的次数，从MySQL服务启动后开始记录。如果Innodb_row_lock_waits以及Innodb_row_lock_time_avg的值较大，说明行级锁争用严重，影响了其他MySQL线程的正常处理，存在严重的并发瓶颈，需要查找出原因并解决。 行级锁资源竞争的解决方案如果行级锁争用严重，可以采取如下方案解决行级锁的并发瓶颈。 ● 尽量缩短锁的生命周期。例如在事务中避免使用长事务，可以将长事务拆分成若干个短事务。在事务中避免使用循环语句。● InnoDB 默认的事务隔离级别是 repeatable read，而 repeatable read 隔离级别使用间隙锁实现InnoDB的行级锁。优化索引，优化SQL语句，避免行级锁升级为表级锁。● 优化表结构，优化SQL语句，尽量缩小锁的作用范围。例如可以将大表拆分成小表，从而缩小锁的作用范围。● 优化表结构，优化SQL语句，尽量缩小锁的作用范围。例如可以将大表拆分成小表，从而缩小锁的作用范围。● 对于InnoDB行级锁而言，设置锁等待超时参数为合理范围，编写锁等待超时异常处理程序，解决发生的锁等待问题（甚至死锁）。● 为避免死锁，一个事务对多条记录进行更新操作时，获得所有记录的排他锁后，再进行更新操作。● 为避免死锁，一个事务对多个表进行更新操作时，获得所有表的排他锁后，再进行更新操作。● 为避免死锁，确保所有关联事务均以相同的顺序访问表和记录。● 必要时，使用表级锁来避免死锁。● 必要时，可以开启全局系统变量innodb_print_all_deadlocks。死锁发生后，死锁所有的相关信息将记录到MySQL错误日志中。 禁用InnoDB间隙锁在事务与锁机制章节曾经提到：利用间隙锁的特点，对查询结果集施加共享锁（lock in share mode）或者排他锁（for update）可以避免幻读现象。然而有时事务中如果存在太多的间隙锁，反而会影响事务之间的并发性能。可以使用下面两种办法禁用InnoDB间隙锁。方法一：把事务隔离级别修改为READ COMMITTED。方法二：将全局变量innodb_locks_unsafe_for_binlog设置为ON（或者1），禁用间隙锁。 事务监控与锁监控新版本的InnoDB存储引擎中，在information_schema数据库中添加了INNODB_TRX、INNODB_LOCKS、InnoDB_LOCK_WAITS三张表。通过这三张表，可以更简单地新版本的 InnoDB 存储引擎中，在 information_schema 数据库中添加了 INNODB_TRX、INNODB_LOCKS、InnoDB_LOCK_WAITS三张表。通过这三张表，可以更简单地监控当前的事务并分析可能存在的锁的问题。例如读者在演示间隙锁与死锁章节的代码时，可以通过查看这三张表的记录信息，监控当前的事务并分析可能存在的锁问题。 INNODB_TRX表包含了当前InnoDB执行的每一条事务信息，其中包括事务的开始时间、事务正在执行的SQL语句等信息，这些内容存储在INNODB_TRX表的24个字段中，限于篇幅这里仅介绍常用的几个字段，如表14-4所示。 表14-4 INNODB_TRX表的常用字段INNODB_LOCKS表包含了当前InnoDB的锁信息（但不包括元数据锁信息，有关元数据锁的相关知识稍后进行介绍），其中包括锁住的事务ID、锁的模式等信息。这些内容存储在INNODB_LOCKS表的10个字段中，如表14-5所示。 INNODB_LOCK_WAITS表包含了当前InnoDB的锁资源信息及被锁住的事务信息，该表由4个字段组成，如表14-6所示。 表14-6 INNODB_LOCK_WAITS表的常用字段 元数据锁metadata locks从MySQL 5.5.3 开始，任何已经开始的事务将一直持有InnoDB表的元数据锁，直到事务提交。除此之外，使用alter table语句对InnoDB表的表结构进行修改时，alter table语句也会持有InnoDB表的元数据锁，直到alter table语句执行结束。下面的操作步骤意在说明元数据锁的存在。 步骤1：打开MySQL客户机A，输入如下命令，将account表的存储引擎修改为InnoDB。alter table account engine=InnoDB; 步骤2：在MySQL客户机A中输入如下命令，首先开启事务，然后查询account表中的所有记录，执行结果如图14-86所示。12start transaction;select * from account; 步骤3：打开MySQL客户机B，输入如下命令，首先开启事务，然后查询account表中的所有记录，执行结果如图14-87所示。12start transaction;select * from account; 步骤4：打开MySQL客户机C，输入如下alter table语句，修改account表结构，向该表增加address字段（默认值为beijing），alter table语句被阻塞，执行结果如图14-88 所示。1alter table account add column address char(32) default 'beijing';]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git分支管理策略]]></title>
    <url>%2F2019%2F06%2F06%2FGit%E5%88%86%E6%94%AF%E7%AE%A1%E7%90%86%E7%AD%96%E7%95%A5%2F</url>
    <content type="text"><![CDATA[通常，合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。 这句话的说明如下：此时master分支没有做任何代码的改动。切换到master分支合并有代码改动的dev，此时默认使用Fast forward模式，git log不会有合并的信息。12345678910$ git checkout -b cb_dev （此时在master分支）$ vim 1.txt （此时在cb_dev分支）$ git commit -am 'test'$ git checkout master$ git merge cb_dev$ git log * e429856 test* 121be0f 更新 xiaoxiaole.json* 649f161 更新 README.md* 3d02ba4 更新消消乐web版为手机预览版本 如果再把分支删了，则分支信息一点都没有了 而如果master也有改动，则是会有分支的信息的。 如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。 下面我们实战一下—no-ff方式的git merge：首先，仍然创建并切换dev分支：$ git checkout -b devSwitched to a new branch ‘dev’ 修改readme.txt文件，并提交一个新的commit：$ git add readme.txt$ git commit -m “add merge”[dev f52c633] add merge 1 file changed, 1 insertion(+) 现在，我们切换回master：$ git checkout masterSwitched to branch ‘master’ 准备合并dev分支，请注意—no-ff参数，表示禁用Fast forward：$ git merge —no-ff -m “merge with no-ff” devMerge made by the ‘recursive’ strategy. readme.txt | 1 + 1 file changed, 1 insertion(+) 因为本次合并要创建一个新的commit，所以加上-m参数，把commit描述写进去。合并后，我们用git log看看分支历史：$ git log —graph（图表） —pretty（pretty）=oneline —abbrev（缩写）-commit e1e9c68 merge with no-ff|\| * f52c633 add merge|/ cf810e4 conflict fixed… 可以看到，不使用Fast forward模式，merge后就像这样： 在实际开发中，我们应该按照几个基本原则进行分支管理： 首先，master分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活； 那在哪干活呢？干活都在dev分支上，也就是说，dev分支是不稳定的，到某个时候，比如1.0版本发布时，再把dev分支合并到master上，在master分支发布1.0版本； 你和你的小伙伴们每个人都在dev分支上干活，每个人都有自己的分支，时不时地往dev分支上合并就可以了。所以，团队合作的分支看起来就像这样：]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git标签管理]]></title>
    <url>%2F2019%2F06%2F06%2FGit%E6%A0%87%E7%AD%BE%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。 快照 关于指定数据集合的一个完全可用拷贝，该拷贝包括相应数据在某个时间点（拷贝开始的时间点）的映像。快照可以是其所表示的数据的一个副本，也可以是数据的一个复制品。快照的作用主要是能够进行在线数据备份与恢复。1、当存储设备发生应用故障或者文件损坏时可以进行快速的数据恢复，将数据恢复某个可用的时间点的状态。2、快照的另一个作用是为存储用户提供了另外一个数据访问通道，当原数据进行在线应用处理时，用户可以访问快照数据，还可以利用快照进行测试等工作。所有存储系统，不论高中低端，只要应用于在线系统，那么快照就成为一个不可或缺的功能。好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。那个存盘就是快照，存储了那个时间点的状态。 标签可以针对某一时间点的版本做标记，常用于版本发布。主要用来发布版本的。 标签就是跟某个commit关联起来，便于发布和查找。 步骤1、切换到某个分支上。12345$ git branch* dev master$ git checkout masterSwitched to branch 'master' 2、然后，敲命令git tag 就可以打一个新标签：打在了最近的那一次commit上1$ git tag v1.0 添加标签说明1$ git tag -a v0.1 -m "version 0.1 released" 如果想打之前的commit，找历史然后再打就行了12$ git log --pretty=oneline --abbrev-commit$ git tag v0.9 6224937 3、推送到远程1git push origin &lt;tagname&gt; 命令git push origin —tags可以推送全部未推送过的本地标签； 4、切换到标签与切换分支命令相同，用git checkout [tagname] 5、删除标签先从本地删除：1$ git tag -d v0.9 然后，从远程删除。删除命令也是push，但是格式如下：1$ git push origin :refs/tags/v0.9 6、查看标签查看所有标签：123$ git taggit show &lt;tagname&gt;查看标签信息$ git tag -l 'v1.4.2.*' 没有不同分支下tag这个概念，也就是说tag不是属于某个分支的，而是全局的tag,是对于commit编号的一个别称。 标签是为了打上版本号信息，不能乱叫，通常用：v1.0, v1.1, v2.0 …或者按发布日期：build-20150702, build-20150910 … 一般来说都是在master分支commit后打标签。 TortoiseGit]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git忽略文件权限和设置大小写敏感]]></title>
    <url>%2F2019%2F06%2F05%2FGit%E5%BF%BD%E7%95%A5%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E5%92%8C%E8%AE%BE%E7%BD%AE%E5%A4%A7%E5%B0%8F%E5%86%99%E6%95%8F%E6%84%9F%2F</url>
    <content type="text"><![CDATA[在发布项目到线上时，很多时候需要修改文件的权限，如果是使用git来发布的话，那么下次更新线上文件的时候就会提示文件冲突。明明文件没有修改，为什么会冲突呢？原来git把文件权限也算作文件差异的一部分。下面笔者自己做了个简单的例子来演示这种情况。 忽略文件权限修改版本库的文件的权限，然后使用diff查看下改变。12$ chmod 777 pack.php$ git diff pack.php 可以看到git把文件权限也列入了版本管理。 git中可以加入忽略文件权限的配置，具体如下：1$ git config core.filemode false 这样就设置了忽略文件权限。查看下配置：1$ cat .git/config git忽略文件权限的配置这时候再更新代码就OK了。 文件所有者和所有组的修改不列入版本管理。 对文件名大小写敏感当你创建一个文件后,叫 readme.md 写入内容后 提交到线上代码仓库.然后你在本地修改文件名为 Readme.md 接着你去提交,发现代码没有变化.控制台输入git status 也不显示任何信息 那么就配置git 使其对文件名大小写敏感git config core.ignorecase false]]></content>
      <categories>
        <category>工具</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL乐观锁与悲观锁]]></title>
    <url>%2F2019%2F05%2F23%2FMySQL%E4%B9%90%E8%A7%82%E9%94%81%E4%B8%8E%E6%82%B2%E8%A7%82%E9%94%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 悲观并发控制实际上是“先取锁再访问”的保守策略，但影响效率。怎么理解？ 来源：漫话：如何给女朋友解释什么是乐观锁与悲观锁 为什么加购物车的时候还有，但是付款的时候提示没有了呢？是因为下单减库存是用了乐观锁，属于并发控制的一种方式。 并发控制当程序中可能出现并发的情况时，我们就需要通过一定的手段来保证在并发情况下数据的准确性，通过这种手段保证了当用户和其他用户一起操作时，所得到的结果和他单独操作时得到的结果是一样的。 这种手段就叫做并发控制。并发控制的目的是保证一个用户的工作不会对另一个用户的工作产生不合理的影响。 没有做好并发控制，就可能导致脏读、幻读和不可重复读等问题。 我们常说的并发控制，一般都和数据库管理系统（DBMS）有关，在DBMS中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 实现并发控制的主要手段大致可以分为乐观并发控制和悲观并发控制两种。 在开始介绍之前要明确一下：无论是悲观锁还是乐观锁，都是人们定义出来的概念，可以认为是一种思想。其实不仅仅是关系型数据库系统中有乐观锁和悲观锁的概念，像memcache、hibernate、tair等都有类似的概念。所以，不应该拿乐观锁、悲观锁和其他的数据库锁等进行对比。 悲观锁当我们要对一个数据库中的一条数据进行修改的时候，为了避免同时被其他人修改，最好的办法就是直接对该数据进行加锁以防止并发。 这种借助数据库锁机制在修改数据之前先锁定，再修改的方式被称之为悲观并发控制（又名“悲观锁”，Pessimistic Concurrency Control，缩写“PCC”）。 之所以叫做悲观锁，是因为这是一种对数据的修改抱有悲观态度的并发控制方式。我们一般认为数据被并发修改的概率比较大，所以需要在修改之前先加锁。 悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。 但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，还会降低并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数据。 乐观锁乐观锁（ Optimistic Locking ） 是相对悲观锁而言的，乐观锁假设数据一般情况下不会造成冲突，所以在数据进行提交更新的时候，才会正式对数据的冲突与否进行检测，如果发现冲突了，则让返回用户错误的信息，让用户决定如何去做。 相对于悲观锁，在对数据库进行处理的时候，乐观锁并不会使用数据库提供的锁机制。一般的实现乐观锁的方式就是记录数据版本。 乐观并发控制相信事务之间的数据竞争(data race)的概率是比较小的，因此尽可能直接做下去，直到提交的时候才去锁定，所以不会产生任何锁和死锁。 悲观锁实现方式悲观锁的实现，往往依靠数据库提供的锁机制。在数据库中，悲观锁的流程如下： 在对记录进行修改前，先尝试为该记录加上排他锁（exclusive locking）。 如果加锁失败，说明该记录正在被修改，那么当前查询可能要等待或者抛出异常。具体响应方式由开发者根据实际需要决定。 如果成功加锁，那么就可以对记录做修改，事务完成后就会解锁了。 其间如果有其他对该记录做修改或加排他锁的操作，都会等待我们解锁或直接抛出异常。 我们拿比较常用的MySql Innodb引擎举例，来说明一下在SQL中如何使用悲观锁。 要使用悲观锁，我们必须关闭mysql数据库的自动提交属性，因为MySQL默认使用autocommit模式，也就是说，当你执行一个更新操作后，MySQL会立刻将结果进行提交。set autocommit=0; 我们举一个简单的例子，如淘宝下单过程中扣减库存的需求说明一下如何使用悲观锁：12345678//0.开始事务begin; //1.查询出商品库存信息select quantity from items where id=1 for update;//2.修改商品库存为2update items set quantity=2 where id = 1;//3.提交事务commit; 以上，在对id = 1的记录修改前，先通过for update的方式进行加锁，然后再进行修改。这就是比较典型的悲观锁策略。 如果以上修改库存的代码发生并发，同一时间只有一个线程可以开启事务并获得id=1的锁，其它的事务必须等本次事务提交之后才能执行。这样我们可以保证当前的数据不会被其它事务修改。 上面我们提到，使用select…for update会把数据给锁住，不过我们需要注意一些锁的级别，MySQL InnoDB默认行级锁。行级锁都是基于索引的，如果一条SQL语句用不到索引是不会使用行级锁的，会使用表级锁把整张表锁住，这点需要注意。 乐观锁实现方式使用乐观锁就不需要借助数据库的锁机制了。 乐观锁的概念中其实已经阐述了他的具体实现细节：主要就是两个步骤：冲突检测和数据更新。其实现方式有一种比较典型的就是Compare and Swap(CAS)。 CAS是项乐观锁技术，当多个线程尝试使用CAS同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。 比如前面的扣减库存问题，通过乐观锁可以实现如下：1234//查询出商品库存信息，quantity = 3select quantity from items where id=1//修改商品库存为2update items set quantity=2 where id=1 and quantity = 3; 以上，我们在更新之前，先查询一下库存表中当前库存数（quantity），然后在做update的时候，以库存数作为一个修改条件。当我们提交更新的时候，判断数据库表对应记录的当前库存数与第一次取出来的库存数进行比对，如果数据库表当前库存数与第一次取出来的库存数相等，则予以更新，否则认为是过期数据。 以上更新语句存在一个比较重要的问题，即传说中的ABA问题。 比如说一个线程one从数据库中取出库存数3，这时候另一个线程two也从数据库中库存数3，并且two进行了一些操作变成了2，然后two又将库存数变成3，这时候线程one进行CAS操作发现数据库中仍然是3，然后one操作成功。尽管线程one的CAS操作成功，但是不代表这个过程就是没有问题的。 有一个比较好的办法可以解决ABA问题，那就是通过一个单独的可以顺序递增的version字段。改为以下方式即可：1234//查询出商品信息，version = 1select version from items where id=1//修改商品库存为2update items set quantity=2,version = 3 where id=1 and version = 2; 乐观锁每次在执行数据的修改操作时，都会带上一个版本号，一旦版本号和数据的版本号一致就可以执行修改操作并对版本号执行+1操作，否则就执行失败。因为每次操作的版本号都会随之增加，所以不会出现ABA问题，因为版本号只会增加不会减少。 除了version以外，还可以使用时间戳，因为时间戳天然具有顺序递增性。 以上SQL其实还是有一定的问题的，就是一旦发上高并发的时候，就只有一个线程可以修改成功，那么就会存在大量的失败。 对于像淘宝这样的电商网站，高并发是常有的事，总让用户感知到失败显然是不合理的。所以，还是要想办法减少乐观锁的粒度的。 有一条比较好的建议，可以减小乐观锁力度，最大程度的提升吞吐率，提高并发能力！如下：1234//修改商品库存update item set quantity=quantity - 1 where id = 1 and quantity - 1 &gt; 0 以上SQL语句中，如果用户下单数为1，则通过quantity - 1 &gt; 0的方式进行乐观锁控制。 以上update语句，在执行过程中，会在一次原子操作中自己查询一遍quantity的值，并将其扣减掉1。 高并发环境下锁粒度把控是一门重要的学问，选择一个好的锁，在保证数据安全的情况下，可以大大提升吞吐率，进而提升性能。 如何选择在乐观锁与悲观锁的选择上面，主要看下两者的区别以及适用场景就可以了。 1、乐观锁并未真正加锁，效率高。一旦锁的粒度掌握不好，更新失败的概率就会比较高，容易发生业务失败。 2、悲观锁依赖数据库锁，效率低。更新失败的概率比较低。 随着互联网三高架构（高并发、高性能、高可用）的提出，悲观锁已经越来越少的被使用到生产环境中了。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL脏读、不可重复读和幻读]]></title>
    <url>%2F2019%2F05%2F23%2FMySQL%E8%84%8F%E8%AF%BB%E3%80%81%E4%B8%8D%E5%8F%AF%E9%87%8D%E5%A4%8D%E8%AF%BB%E5%92%8C%E5%B9%BB%E8%AF%BB%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是脏读？ 什么是不可重复读？ 什么是幻读？ “读现象”是多个事务并发执行时，在读取数据方面可能碰到的状况。了解它们有助于理解各隔离级别的含义。其中包括脏读、不可重复读和幻读。 事务隔离级别在数据库中，事务是要满足ACID的，即满足原子性、一致性、持久性以及隔离性。 在数据库事务的ACID四个属性中，隔离性是一个最常放松的一个。可以在数据操作过程中利用数据库的锁机制或者多版本并发控制机制获取更高的隔离等级。 但是，随着数据库隔离级别的提高，数据的并发能力也会有所下降。所以，如何在并发性和隔离性之间做一个很好的权衡就成了一个至关重要的问题。 具体的隔离级别和读现象有什么关系呢？ 不同的隔离级别会导致和解决不同的读现象，我先给你介绍下都有哪些读现象吧。 脏读脏读，就是读到了脏数据，即无效数据。 脏读。是指当一个事务正在访问数据，并且对数据进行了修改，而这种修改还没有提交（commit）到数据库中，这时，另外一个事务也访问这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是脏数据，依据脏数据所做的操作可能是不正确的。 打个比方，什么情况下会出现脏读呢，就是我在我的本地修改了AbstractPayExecutor这个类的代码，我还没提交。 为了更快的知道这个类被我改成了什么样，你跑到我的电脑前面阅读了我修改后的代码。这就是脏读了。因为我没有提交代码，说明我随时可能撤销刚刚的修改，这时你之前读取到的数据就是脏数据了。 这种情况下，多个开发者之间的并发性很高，几乎没有任何阻塞。师妹想知道代码最新的是什么样，她就读到了最新代码。但是，这个代码我还没有提交，这就是个脏数据。我们之间的隔离性很差。 这显然不是我们想要看到的现象，我们不希望代码在未提交的状态下被别人读到，所以我们需要提高一点隔离性。 不可重复读为了解决脏读问题，我们决定提高一点隔离性，我在修改代码的时候，不允许她跑到我的电脑前面读代码。她只能读取到我提交后的代码。 当我需要修改AbstractPayExecutor这个类的时候，我需要告诉师妹让她等一下，等我提交完代码她再读。这就有效的解决了脏读，因为师妹读到的代码全部都是我已经提交的代码。 但是，提高了我们之间的隔离性，并发性就降低了一些。因为她要等我提交代码后才能阅读。 脏读没有了，但是还会存在不可重复读问题。 不可重复读，就是开始我说的那种AbstractPayExecutor中常量被删除的现象吗。 差不多吧。 我们已经提高了一点隔离级别，使得脏读现象没有了。但是并没有办法避免以下现象： 师妹在阅读AbstractPayExecutor的代码，代码中定义了一个LOGGER常量。然后我修改了代码，把这个常量删除了，并提交。师妹更新了代码继续阅读，但是她却发现LOGGER这个常量没有了。 两次读取，得到的文件内容不一样。严重了影响了她的学习进度。这就是不可重复读现象。 不可重复读。是指在数据库访问中，一个事务范围内两个相同的查询却返回了不同数据。这是由于查询时系统中其他事务修改的提交而引起的。比如事务T1读取某一数据，事务T2读取并修改了该数据，T1为了对读取值进行检验而再次读取该数据，便得到了不同的结果。 那么有没有可能我在读某个类的代码的时候，你先不要修改这个类呢？这就是进一步提升了隔离性了。 幻读为了让师妹可以更好的学习代码。我们约定好，当她阅读某个类的代码的时候，她通知我一下，然后我就不修改这个类的代码。避免出现不可重复读的情况。 这样，我们之间的并发性就又降低了一些。不仅仅她阅读哪个类有了一些限制，我修改哪个类也有了要求了。 就这样相安无事了一段时间，师妹又来找我了。 师兄呀，你又新增了几个类了么，刚刚我看的时候只有20几个类呀。 嗯嗯，是的呀，我又增加了2个枚举类和1个Java类。 好吧，那我只能继续阅读这几个新增的类了。 在提升了隔离性之后，虽然我不会修改师妹正在阅读的类，师妹也不会阅读我正在修改的类。但是我可能会增加或者删除几个类。这时候和师妹之前读取到的类的总个数就有了变化。也就是说，她之前读到的数据就不准确了。这就是幻读。 幻读。指同一个事务内多次查询返回的结果集不一样（比如增加了或者减少了行记录）。比如同一个事务A内第一次查询时候有n条记录，但是第二次同等条件下查询却有n+1条记录，这就好像产生了幻觉。 幻读是不可重复读的一种特殊场景。 幻读的情况其实也是可以解决的，就是我读代码的时候你不要做任何修改。 如果想要解决幻读问题，那么就只能在师妹阅读代码的时候，我什么也不做了。这样我们之间的隔离性最高，但是并发性就最低了。 要想解决脏读、不可重复读、幻读等读现象，那么就需要提高事务的隔离级别。但与此同时，事务的隔离级别越高，并发能力也就越低。所以，还需要读者根据业务需要进行权衡。 总结事务的隔离性上，从低到高可能产生的读现象分别是：脏读、不可重复读、幻读。 脏读指读到了未提交的数据。 不可重复读指一次事务内的多次相同查询，读取到了不同的结果。 幻读是不可重复读的特殊场景。一次事务内的多次范围查询得到了不同的结果。 通过在写的时候加锁，可以解决脏读。 通过在读的时候加锁，可以解决不可重复读。 通过串行化，可以解决幻读。 以上这几种解决方案其实是数据库的几种隔离级别。 背景数据库的锁是在多线程高并发的情况下用来保证数据稳定性和一致性的一种机制。MySQL根据底层存储引擎的不同，锁的支持粒度和实现机制也不同。MyISAM只支持表锁，InnoDB支持行锁和表锁。目前MySQL默认的存储引擎是InnoDB，这里主要介绍InnoDB的锁。 InnoDB存储引擎使用InnoDB的两大优点：一是支持事务；二是支持行锁。 MySQL的事务在高并发的情况下事务的并发处理会带来几个问题 1、脏读：指在事务A处理过程里读取到了事务B未提交的事务中的数据。比如在转账的例子中：小A开了一个事务给小B转了1000块，还没提交事务的时候就跟小B说，钱已经到账了。这个时候小B去看了一下余额，发现果真到账了（然后就开开心心刷抖音去了），这个时候小A回滚了事务，把1000块又搞回去了。小B刷完抖音再去看下余额，发现钱又不见了。 2、不可重复读：指在一个事务执行的过程中多次查询某一数据的时候结果不一致的现象，由于在执行的过程中被另一个事务修改了这个数据并提交了事务。比如：事务A第一次读小明的年龄是18岁，此时事务B将小明的年龄改成了20并提交了，这个时候事务A再次读取小明的年龄发现是20，这就是同一条数据不可重复读。 3、幻读：幻读通常指的是对一批数据的操作完成后，有其他事务又插入了满足条件的数据导致的现象。比如：事务A将数据库性别为男的状态都改成1表示有钱人，这个时候事务B又插入了一条状态为0没钱人的记录，这个时候，用户再查看刚刚修改的数据时就会发现还有一行没有修改，这就出现了幻读。幻读往往针对insert操作，脏读和不可重复读针对select操作。 由于高并发事务带来这几个问题，所以就产生了事务的隔离级别。 Read uncommitted（读未提交）：最低级别，任何情况都无法保证。 Read committed（读已提交）：可避免脏读的发生。 Repeatable read（可重复读）：可避免脏读、不可重复读的发生。 Serializable（串行化）：可避免脏读、不可重复读、幻读的发生。 InnoDB 常见的几种锁机制1、共享锁和独占锁（Shared and Exclusive Locks），InnoDB通过共享锁和独占所两种方式实现了标准的行锁。共享锁（S锁）：允许事务获得锁后去读数据，独占锁（X锁）：允许事务获得锁后去更新或删除数据。一个事务获取的共享锁S后，允许其他事务获取S锁，此时两个事务都持有共享锁 S，但是不允许其他事务获取X锁。如果一个事务获取的独占锁（X），则不允许其他事务获取S或者X锁，必须等到该事务释放锁后才可以获取到。大家可以通过下面的SQL感受下。 123456789101112131415161718# T1START TRANSACTION WITH CONSISTENT SNAPSHOT;SELECT * FROM category WHERE category_no = 2 lock in SHARE mode; #共享锁SELECT * FROM category WHERE category_no = 2 for UPDATE; #独占锁COMMIT;# T2START TRANSACTION WITH CONSISTENT SNAPSHOT;SELECT * FROM category WHERE category_no = 2 lock in SHARE mode; #共享锁UPDATE category set category_name = '动漫' WHERE category_no = 2; #独占锁COMMIT; 意向锁（Intention Locks），上面说过InnoDB支持行锁和表锁，意向锁是一种表级锁，用来指示接下来的一个事务将要获取的是什么类型的锁（共享还是独占）。意向锁分为意向共享锁（IS）和意向独占锁（IX），依次表示接下来一个事务将会获得共享锁或者独占锁。意向锁不需要显示的获取，在我们获取共享锁或者独占锁的时候会自动的获取，意思也就是说，如果要获取共享锁或者独占锁，则一定是先获取到了意向共享锁或者意向独占锁。 意向锁不会锁住任何东西，除非有进行全表请求的操作，否则不会锁住任何数据。存在的意义只是用来表示有事务正在锁某一行的数据，或者将要锁某一行的数据。原文：Intention locks are table-level locks that indicate which type of lock （shared or exclusive） a transaction requires later for a row in a table. 记录锁（record Locks），锁住某一行，如果表存在索引，那么记录锁是锁在索引上的，如果表没有索引，那么InnoDB会创建一个隐藏的聚簇索引加锁。所以我们在进行查询的时候尽量采用索引进行查询，这样可以降低锁的冲突。 间隙锁（Gap Locks），间隙锁是一种记录行与记录行之间存在空隙或在第一行记录之前或最后一行记录之后产生的锁。间隙锁可能占据的单行，多行或者是空记录。通常的情况是我们采用范围查找的时候，比如在学生成绩管理系统中，如果此时有学生成绩60，72，80，95，一个老师要查下成绩大于72的所有同学的信息，采用的语句是select * from student where grade &gt; 72 for update，这个时候InnoDB锁住的不仅是80，95，而是所有在72-80，80-95，以及95以上的所有记录。为什么会这样呢？实际上是因为如果不锁住这些行，那么如果另一个事务在此时插入了一条分数大于72的记录，那会导致第一次的事务两次查询的结果不一样，出现了幻读。所以为了在满足事务隔离级别的情况下需要锁住所有满足条件的行。 Next-Key Locks，NK 是一种记录锁和间隙锁的组合锁。是2和3的组合形式，既锁住行也锁住间隙。并且采用的左开右闭的原则。InnoDB对于查询都是采用这种锁的。 举个例子 123456789101112131415161718192021222324252627282930313233343536CREATE TABLE `a` ( `id` int(10) unsigned NOT NULL AUTO_INCREMENT, `uid` int(10) unsigned DEFAULT NULL, PRIMARY KEY (`id`), KEY `idx_uid` (`uid`) USING BTREE) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8;INSERT INTO `a`(uid) VALUES (1);INSERT INTO `a`(uid) VALUES (2);INSERT INTO `a`(uid) VALUES (3);INSERT INTO `a`(uid) VALUES (6);INSERT INTO `a`(uid) VALUES (10);# T1START TRANSACTION WITH CONSISTENT SNAPSHOT; //1SELECT * FROM a WHERE uid = 6 for UPDATE; //2COMMIT; //5# T2START TRANSACTION WITH CONSISTENT SNAPSHOT; //3INSERT INto a(uid) VALUES(11);INSERT INto a(uid) VALUES(5); //4INSERT INto a(uid) VALUES(7);INSERT INto a(uid) VALUES(8);INSERT INto a(uid) VALUES(9);SELECT * FROM a WHERE uid = 6 for UPDATE;COMMIT;ROLLBACK; 按照上面 1，2，3，4的顺序执行会发现第4步被阻塞了，必须执行完第 5 步后才能插入成功。这里我们会很奇怪明明锁住的是uid=6的这一行，为什么不能插入 5 呢？原因就是这里采用了next-key的算法，锁住的是（3,10）整个区间。感兴趣的可以试一下。]]></content>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Force Index]]></title>
    <url>%2F2019%2F05%2F23%2FMySQL-Force-Index%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 以下的文章主要介绍的是MySQL Force Index强制索引，以及其他的强制操作其优先操作的具体操作步骤如下：我们以MySQL中常用的hint来进行详细的解析。 强制索引MySQL FORCE INDEX1SELECT * FROM TABLE1 FORCE INDEX (FIELD1) … 以上的SQL语句只使用建立在FIELD1上的索引，而不使用其它字段上的索引。 忽略索引 IGNORE INDEX1SELECT * FROM TABLE1 IGNORE INDEX (FIELD1, FIELD2) … 在上面的SQL语句中，TABLE1表中FIELD1和FIELD2上的索引不被使用。 关闭查询缓冲 SQL_NO_CACHE SELECT SQL_NO_CACHE field1, field2 FROM TABLE1;有一些SQL语句需要实时地查询数据，或者并不经常使用（可能一天就执行一两次）,这样就需要把缓冲关了,不管这条SQL语句是否被执行过，服务器都不会在缓冲区中查找，每次都会执行它。 MySQL force Index 强制索引：强制查询缓冲 SQL_CACHE1SELECT SQL_CALHE * FROM TABLE1; 如果在my.ini中的query_cache_type设成2，这样只有在使用了SQL_CACHE后，才使用查询缓冲。 优先操作 HIGH_PRIORITY HIGH_PRIORITY可以使用在select和insert操作中，让MySQL知道，这个操作优先进行。1SELECT HIGH_PRIORITY * FROM TABLE1; 滞后操作 LOW_PRIORITY LOW_PRIORITY可以使用在insert和update操作中，让MySQL知道，这个操作滞后。1update LOW_PRIORITY table1 set field1= where field1= … 延时插入 INSERT DELAYED1INSERT DELAYED INTO table1 set field1= … INSERT DELAYED INTO，是客户端提交数据给MySQL，MySQL返回OK状态给客户端。而这是并不是已经将数据插入表，而是存储在内存里面等待排队。当MySQL有空余时，再插入。另一个重要的好处是，来自许多客户端的插入被集中在一起，并被编写入一个块。这比执行许多独立的插入要快很多。坏处是，不能返回自动递增的ID，以及系统崩溃时，MySQL还没有来得及插入数据的话，这些数据将会丢失。 强制连接顺序 STRAIGHT_JOIN1SELECT TABLE1.FIELD1, TABLE2.FIELD2 FROM TABLE1 STRAIGHT_JOIN TABLE2 WHERE … 由上面的SQL语句可知，通过STRAIGHT_JOIN强迫MySQL按TABLE1、TABLE2的顺序连接表。如果你认为按自己的顺序比MySQL推荐的顺序进行连接的效率高的话，就可以通过STRAIGHT_JOIN来确定连接顺序。 MySQL force Index 强制索引:强制使用临时表 SQL_BUFFER_RESULT SELECT SQL_BUFFER_RESULT * FROM TABLE1 WHERE …当我们查询的结果集中的数据比较多时，可以通过SQL_BUFFER_RESULT.选项强制将结果集放到临时表中，这样就可以很快地释放MySQL的表锁（这样其它的SQL语句就可以对这些记录进行查询了），并且可以长时间地为客户端提供大记录集。 分组使用临时表 SQL_BIG_RESULT和SQL_SMALL_RESULT1SELECT SQL_BUFFER_RESULT FIELD1, COUNT(\*) FROM TABLE1 GROUP BY FIELD1; 一般用于分组或DISTINCT关键字，这个选项通知MySQL，如果有必要，就将查询结果放到临时表中，甚至在临时表中进行排序。SQL_SMALL_RESULT比起SQL_BIG_RESULT差不多，很少使用。 创建索引索引的创建可以在CREATE TABLE语句中进行，也可以单独用CREATE INDEX或ALTER TABLE来给表增加索引。以下命令语句分别展示了如何创建主键索引（PRIMARY KEY），唯一索引（UNIQUE）和普通索引（INDEX）的方法。 12345678910111213mysql&gt;ALTER TABLE `表名` ADD INDEX `索引名` (column list); mysql&gt;ALTER TABLE `表名` ADD UNIQUE `索引名` (column list); mysql&gt;ALTER TABLE `表名` ADD PRIMARY KEY `索引名` (column list); mysql&gt;CREATE INDEX `索引名` ON `表名` (column_list); mysql&gt;CREATE UNIQUE INDEX `索引名` ON `索引名` (column_list); mysql&gt;ALTER TABLE `表名` ADD INDEX (`id`,`order_id`);给article表增加id索引，order_id索引 mysql&gt;ALTER TABLE `表名` ADD INDEX `id`;//给article表增加id索引 2、重建索引 重建索引在常规的数据库维护操作中经常使用。在数据库运行了较长时间后，索引都有损坏的可能，这时就需要重建。对数据重建索引可以起到提高检索效率。 Sql代码 收藏代码mysql&gt; REPAIR TABLE table_name QUICK; 3、查询数据表索引1mysql&gt; SHOW INDEX FROM `table_name`; 4、删除索引 删除索引可以使用ALTER TABLE或DROP INDEX语句来实现。DROP INDEX可以在ALTER TABLE内部作为一条语句处理，其格式如下： 1234567mysql&gt;DROP index `index_name` ON `table_name` (column list); mysql&gt;ALTER TABLE `table_name` DROP INDEX `index_name` (column list); mysql&gt;ALTER TABLE `table_name` DROP UNIQUE `index_name` (column list); mysql&gt;ALTER TABLE `table_name` DROP PRIMARY KEY `index_name` (column list); 在前面的三条语句中，都删除了table_name中的索引index_name。而在最后一条语句中，只在删除PRIMARY KEY索引中使用，因为一个表只可能有一个PRIMARY KEY索引，因此也可不指定索引名。如果没有创建PRIMARY KEY索引，但表具有一个或多个UNIQUE索引，则MySQL将删除第一个UNIQUE索引。如果从表中删除某列，则索引会受影响。对于多列组合的索引，如果删除其中的某列，则该列也会从索引中删除。如果删除组成索引的所有列，则整个索引将被删除。 5、强制使用索引 1mysql&gt;SELECT * FROM TABLE1 FORCE INDEX (索引名或PRIMARY) ; 6、联合索引 1mysql&gt;alter table test add key id_a_b(a,b) ; 对于联合索引当条件为 a=1 and b=1 则使用索引 ，当a=1 时也使用索引 当单独使用b=1时则不使用索引。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Apache Rewrite with Htaccess理解与技巧]]></title>
    <url>%2F2019%2F05%2F15%2FApache-Rewrite-with-Htaccess-%E7%90%86%E8%A7%A3%E4%B8%8E%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： .htaccess文件是做什么用的？ 一、开启Rewrite功能进行以下操作开启Rewrite模块（CentOS7编译安装）。 找到apache的配置文件httpd.conf并寻找下面这行：1LoadModule rewrite_module modules/mod_rewrite.so 将前面“#”去掉，如果不存在则添加此句。 确认是否已经开启模块了： 123$ cd /usr/local/apache/bin$ sudo apachectl -M | grep rewriterewrite_module (shared) 接着就可以开始在Site Config里面编写所需的RewriteRule了。 在理解Rewrite的过程中，常常会出现与之搭配的.htaccess文件。.htaccess称作「Hypertext Access」，以一个文件夹为单位改变Apache设定的配置（Override Config），简单来说就是可以根据每个文件夹Override原本Site Config，可以针对一个文件夹改写网址，所以RewriteRule并非就只能写在.htaccess当中哦！ 但本篇文章还是会以使用.htaccess作为范例，若要打开Override的功能，只要修改Site Config，加入AllowOverride All就可以了（例如/usr/local/apache/conf/vhost/example.conf）123&lt;Directory "/var/www/html"&gt; AllowOverride All&lt;/Directory&gt; All、FlieInfo都可以让.htaccess使用Rewrite功能，详情可以参考官方设定值的意义。 二、Rewrite Rule基本用法 就是改写网址条件的规则，它的写法结构如下：1RewriteRule [match_uri] [rewrite_uri] [flags] match_uri：符合Pattern的URI rewrite_uri：将被改写的URI 这两个也都可以使用正则表达式来写，一个Rule范例长这样：1Rewrite ^match\.html$ rewrite.html [NC,L] 意义等同于以下Pseudo Code：1234567// 假设输入网址：http://domain.com/a/b/c.htmluri = a/b/c.htmlif (uri.match("match.html") &#123; url = "rewrite.html"&#125; RewriteRule的Flag 最后面的flags代表设定Rule的行为，可用逗号代表多个Flag，中间不能有空格，介绍以下常用的： [L]：Last，代表成功执行这个Rule后就会停止，不继续往下执行。 [NC]：Non Case-sensitive，代表match_uri不比对大小写差异。 [QSA]：Query String Append，代表保留网址尾端带的GET参数，没使用flag的默认是会把参数去掉的。 [QSD]：Query String Discard（丢弃），与QSA相反的作用，apache v2.4才有。 [R]: Redirect，代表用转址的方式转到新的网址，默认是302 Status Code，如：[R=301]，也可以回传400、200、404等的Status Code，通常会跟[L]一起代表结束，也是排错常用的Flag [DPI]: 不要再接续的Rule中结尾中加上PathInfo，会在「五、一些小特性」的段落说明。 [F]: Forbidden 就是不给看啦！ 范例 接着来举例多个Rules加上Flag的功用，假设网站文件夹结构如下：123456root/ ├ match.html ├ rewrite.html ├ .htaccess └ secret/ └ database_password.json 而范例的.htaccess的內容为：123456789101112131415161718# 前面有井字号是注释### 开启RewriteRewriteEngine On### 设定Rewrite前面会加上的path，默认会是DocumentRoot(如：/var/www/html）RewriteBase /# Rules 将会由上往下依序执行# 直到最后一行或遇到有符合且有 L flag 的 Rule 就会停止### Rule 1. 输入 domain.com/match.html 将会显示 rewrite.html 的內容RewriteRule ^match\.html$ rewrite.html [NC,L]### Rule 2. 输入 domain.com/redirect.html 将会被导至 domain.com/rewrite.htmlRewriteRule ^redirect\.html$ rewrite.html [NC,R=302,L]### Rule 3. 如果输入 domain.com/secret/… 这样格式的网址，则去掉 secret/ 后，转回 root 并加上 .html### $1 是正则表达式的 group capture，就是 $1=(.*) 取得括号內的值RewriteRule ^secret/(.*)$ $1.html [NC,L] 在浏览器上输入match.html或redirect.html均会显示rewrite.html的內容，明显是Rule 2将网址改变了，而Rule 1没有，因为就是302 Status Code的关系。 在此建议可以使用POSTMAN或是cURL命令列或Request擷取等工具观察整个Response的差異，将会非常容易除错，详细原因将在「四、如何除错」段落中解释，以下使用cURL示范： 1.Request：http://localhost/match.html12$ curl &apos;http://localhost/match.html&apos;I’m rewrite.html 2.Request： http://localhost/redirect.html1234567891011$ curl &apos;http://localhost/redirect.html&apos;&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Found&lt;/h1&gt;&lt;p&gt;The document has moved &lt;a href=&quot;http://localhost/rewrite.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7 Server at localhost Port 80&lt;/address&gt;&lt;/body&gt;&lt;/html&gt; 与浏览器不同的是，这里的Response会指出网址被转移至另外一个新网址http://localhost/rewrite.html，浏览器自动帮忙处理转址的工作，根据上面回传的网址，再发出另一个Request取得网页內容，让使用者仅感觉到网址与页面改变而已。 这时候读者可试着把RewriteBase这行注释，将会发现回传结果出错了，Rewrite结果与Domain之间被加上DocumentRoot预设的路径。 1234567891011$ curl &apos;http://localhost/redirect.html&apos;&lt;!DOCTYPE HTML PUBLIC &quot;-//IETF//DTD HTML 2.0//EN&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Found&lt;/h1&gt;&lt;p&gt;The document has moved &lt;a href=&quot;http://localhost/var/www/html/rewrite.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7 Server at localhost Port 80&lt;/address&gt;&lt;/body&gt;&lt;/html&gt; 前面两个Rule仅是一个基本的示范，平常应用当然会难上许多，来继续看第三个Rule吧 1234### Rule 3. 如果输入domain.com/secret/…这样格式的网址，则去掉 secret/后，转回root并加上.html### $1是正则表达式的group capture，就是取得那个满足括号内的值RewriteRule ^secret/(.*)$ $1.html [NC,L] 第三个Rule是禁止使用者访问敏感的secret文件夹，来试着访问database_password.json看能不能得到结果： 123456789$ curl &apos;http://localhost/secret/database_password.json&apos;HTTP/1.1 404 Not FoundDate: Sun, 07 Oct 2018 13:39:11 GMTServer: Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7Vary: accept-language,accept-charsetAccept-Ranges: bytesContent-Type: text/html; charset=utf-8Content-Language: en 不管网址改成任何http://localhost/secret/...，都会回传404找不到页面，是理想中的状况，非常棒！但是访问 http://localhost/secret/反而变成403禁止访问了耶，咦？123456789$ curl &apos;http://localhost/secret/&apos;HTTP/1.1 403 ForbiddenDate: Sun, 07 Oct 2018 13:43:08 GMTServer: Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7Vary: accept-language,accept-charsetAccept-Ranges: bytesContent-Type: text/html; charset=utf-8Content-Language: en 这时候不知出了什么错的话，可以将Rule的Flag加上R=302，检查最后改写的结果出了什么状况：1234567891011$ curl &apos;http://localhost/secret/&apos;&lt;!DOCTYPE HTML PUBLIC “-//IETF//DTD HTML 2.0//EN”&gt;&lt;html&gt;&lt;head&gt;&lt;title&gt;302 Found&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;Found&lt;/h1&gt;&lt;p&gt;The document has moved &lt;a href=”http://localhost/.html&quot;&gt;here&lt;/a&gt;.&lt;/p&gt;&lt;hr&gt;&lt;address&gt;Apache/2.4.33 (Win32) OpenSSL/1.1.0h PHP/7.2.7 Server at localhost Port 80&lt;/address&gt;&lt;/body&gt;&lt;/html&gt; 发现 $1没有抓到任何字串，所以没有任何檔名加上 .html，就变成 403 的结果，所以只要在 Rule 3 之前加上以下新的 Rule 就可以！1RewriteRule ^secret/$ / [R=302,NC,L] 以上就是RewriteRule与简单的Debug方法，只要再加上看得懂正则表达式就能懂一般常见的Rules！继续看更难一点的RewriteCond吧～ 三、RewriteCondRewriteRule仅仅只能判断Request URI是否匹配而改写URI，但有很多需求是希望根据一些Request Header（Host、User-agent）与Apache的环境变量做改写，先满足某些条件后，再次Rewrite URI，因此有了RewriteCond的出现，它的写法结构如下：12RewriteCond [test_string] [match_string] [flags]RewriteRule … test_string：要比对的条件 match_string：符合的条件 以上这两个都可以使用正则表达式撰写，而且RewriteCond结束一定会接着一个RewriteRule，真正的范例会长这样：12RewriteCond %&#123;HTTP_USER_AGENT&#125; (facebookexternalhit)RewriteRule ^blog/(.*)$ fb-bot.html?path=$1&amp;type=%1 [L] 以上意义等同于以下Pseudo Code：1234567if ($HTTP_USER_AGENT == 'facebookexternalhit') &#123; if (url.match('^blog/(.*)$')) &#123; url = 'fb-bot.html?path=$1&amp;type=facebookexternalhit'; &#125;&#125; 前面说到$1是Group Capture的用法，而RewriteCond则是用%1表示 RewriteCond可使用的变量 ${HTTP_USER_AGENT}是RewriteCond可使用的变量，有以下常见的变量：123456789%&#123;REQUEST_URI&#125;：Domain后面完整的URI Path，Rule其实会拿到不完整的URI，详情可以参考「五、一些小特性」段落%&#123;QUERY_STRING&#125;：后面GET带的参数%&#123;HTTP_HOST&#125;：Domain 例：163.com%&#123;HTTP_COOKIE&#125;：Cookie%&#123;HTTPS&#125;：判断是否用https或http，如果是https就等于「on」，否则为“off”%&#123;HTTP_USER_AGENT&#125;：User Agent%&#123;REQUEST_FILENAME&#125;：访问的文件名称其实变量也可以放在RewriteRule的rewrite url当中 以及判断文件时，很常见搭配这两个match用法：12-d：directory. 代表如果有这个文件夹-f：regular file. 代表如果有这个文件 搭配起来写法就像以下范例，代表着如果没有这个文件就转到首页：12RewriteCond %&#123;REQUEST_FILENAME&#125; !-fRewriteRule ^(.*)$ index.html 其实还有不同的match写法，可以参考Apache官网的 RewriteCond 。 RewriteCond的Flag用法 12NC：Non case-sensitiveOR：就是OR条件，下面会说明 RewriteCond也有OR跟AND的条件，先前提到RewriteCond后面一定会接一个RewriteRule，有个特性是它只吃接续的第一个rule，来看下面的范例：123456789101112131415161718192021222324252627282930### 范例 ARewriteCond 1RewriteRule 1RewriteRule 2// 等同于if (Cond1) &#123; Rule1&#125;Rule 2### 范例 BRewriteCond 1RewriteCond 2RewriteRule 1// 等同于if (Cond1 &amp;&amp; Cond2) &#123; Rule1&#125;### 范例 CRewriteCond 1 [OR]RewriteCond 2RewriteRule 1// 等同于if (Cond1 || Cond2) &#123; Rule1&#125; 了解RewriteCond跟RewriteRule的用法与每一行执行下来的逻辑，就可以更轻易的改写网络上別人写好的规则。 四、如何排错先前在RewriteRule的段落有稍微简单展示Debug的流程，这里仅使用文字讲解一些小秘诀。 1.该使用什么Debug工具 使用POSTMAN、cURL等的工具，浏览器除了有Cache外，也会帮忙转址，此时就没办法观察第一次转址的网址內容，譬如：最常见就是浏览器直接显示转址太多次的错误，但使用工具的话，就可以看到Response回传的转址结果。 2.如何知道撰写的Regular Expression是否正确？ 把RewriteRule的Flag加上[R=302]，302 Status Code代表Moved Temporarily，浏览器并不会Cache302的转址结果，但301会，可以确定Rule无误后再拿掉或改为原本301就好，像这样观察转址的结果：1RewriteRule ^(.*)$ =$1 [L,R=302] 3.非得要修改正在运行中的网站怎么办？ 可以用一些识別的Header，加上RewriteCond来测试撰写的RewriteRule，譬如自定义一个User-agent，每次Reuqest都用这个User-agent即可。 4.浏览器有Cache 前面提到浏览器cache的问题，若认为写的没问题，但访问网站仍是旧有结果的话，就开启私密浏览访问看看，最后仍没办法只好重开Apache看看。 五、关于一些小特性1.RewriteRule在嵌套.htaccess当中不会取得完整URI Path 直接看范例，假设文件夹结構如下：123456root/ ├ a/ ├ b.html └ .htaccess ├ c.html └ .htaccess 12### 两个.htaccess都只有这一行內容RewriteRule ^(.*)$ $1 [L] 1.Request：c.html 使用root/.htaccessRule结果：c.html 2.Request： a/b.html 使用root/a/.htaccessRule结果： b.html没错，发生了不会拿到 a/ 的路径的情况。 Apache会自动选择最接近的.htaccess文件（详情会在下一段落说明） 3.如果拿掉root/a/.htaccess文件，重新Request： a/b.html 使用root/.htaccessRule结果：a/b.html这样的结果又正常了，如果真的想确保拿到完整的 URI Path，可以使用 %{REQUEST_URL}变量来取得 URI ！12RewriteCond %&#123;REQUEST_URI&#125; ^(.*)$RewriteRule ^ %1 [L] 2.RewriteRule自动附加在结尾的PATH_INFO 有时候会希望遇到Rule1改写之后，再传递至下一个Rule2判断与改写，可是会遇到后面莫名多了先前的URI，来看一个简单的示范例子：123RewriteRule ^(.*)$ web/$1 [NC]RewriteRule ^(.*)$ sec======$1====== [NC,R=301]Request： a/b/c.html 经过第一个Rule变成：web/a/b/c.html最后到第二个Rule变成：sec======web/a/b/c.html/b/c.html====== 发现它在Rule1的结果末端多了一个不需要的/b/c.html，这是因为PATH_INFO的缘故，若不需要后面Path的话，可以在Rule 1加上DPI Flag移除它，由于一些php的CMS或是Framework会使用到PATH_INFO的功能，所以是否关掉PATH_INFO的作用还是要注意一下！ 3.重新寻找.htaccess文件 有时候要的Rule很纯，就只是将所有Request都转到web/文件夹下：12RewriteBase /RewriteRule ^(.*)$ web/$1 [QSA,L] 但在Apache 2.4后就会遇到出现Redirect Loop的错误，原因是第一次Request URI被改写后成web/xxxx，它会根据新URI找对应最近的.htaccess并再重跑一次RewriteRule。 此时有两种解法，第一种是在web/ 文件夹下放一个空的.htaccess ，第二种是可以参考下一点停止Redirect Loop的写法，放在RewriteRule前面。 4.停止Redirect Loop的情况 有时候会遇到无穷Loop 的问题：1Request exceeded the limit of 10 internal redirects due to probable configuration error. Use &apos;LimitInternalRecursion&apos; to increase the limit if necessary. Use &apos;LogLevel debug&apos; to get a backtrace. 可以在所有RewriteRule之前加上判断，若Redirect Status是200的话，就停止Loop：12RewriteCond %&#123;ENV:REDIRECT_STATUS&#125; 200RewriteRule ^ - [L] 不过建议还是检查RewriteRule=哪边有写错的，毕竟这解不太算是万灵药。 六、使用Htaccess的缺点使用Override很方便，只要将.htaccess放到文件夹下面就有效果，但官方其实不推荐开启Override的功能，它会降低效能，主要是有以下缺点： 1.每次Request的嵌套搜寻 每一次Request都会使得Apache透过嵌套递归的方式搜寻.htaccess文件，导致Apache缓慢，譬如送出这个Request： Request： /example/sub/index.html Apache 则会根据路径寻找以下 .htaccess文件123/var/www/.htaccess/var/www/example/.htaccess/var/www/example/sub/.htaccess 最后Apache选择离文件最近的/var/www/example/sub/.htaccess 2.重复Compile RewirteRule 由于每次Request都会嵌套搜寻.htaccess，所以再遇到RewriteRule 都会重新Compile一次，不像Site Config只会Compile一次后做 cache，所以RewriteRule非常多的话，也会导致apache缓慢。 笔者使用Apache Benchmark做了一个小型的压力测试，连续访问10000次，同时1000个连线，取其三次执行ab指令的平均值，分别比较是否有打开Override功能，和Rewrite数量多寡是否有影响，Rewrite的状况都是以跑到倒数第三行结束为主，且每行RewriteRule跟RewriteCond不重复。 有开启Override功能比没开启花的时间多了一些，而行数的多寡也会影响到花費的时间，但筆者还是有点疑惑，差0.1秒好像也没什么关系吶。 官方认为.htaccess主要还是给无法编辑Site Config的情况下使用，像是一台主机上有多站共用，但真的想用.htaccess效果又不想开启Override的话怎么办呢？也是有一个取得中间值的做法。 在Site Config中预先指定.htaccess文件路径，把Override功能关掉，并使用Include指定引入的.htaccess，如下写法：123456DocumentRoot /var/www/&lt;Directory /var/www/&gt; AllowOverride None Include /var/www/.htaccess …&lt;/Directory&gt; 但这方法也是有个小缺点：每次更新.htaccess都必须重新启动Apache重新读取设定。 如果主机流量不大的话，效能问题并没这么严重，最后还是得依据主机上的网站与情况，衡量哪种做法比较好哦！]]></content>
      <categories>
        <category>Apache</category>
      </categories>
      <tags>
        <tag>Apache</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何设计高性能的索引？]]></title>
    <url>%2F2019%2F04%2F30%2F%E5%A6%82%E4%BD%95%E8%AE%BE%E8%AE%A1%E9%AB%98%E6%80%A7%E8%83%BD%E7%9A%84%E7%B4%A2%E5%BC%95%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 回表就是通过辅助索引拿到主键id之后，要再去遍历聚集索引的B+树，这个过程就叫做回表。怎么理解？ 上回我们主要研究了为什么使用索引，以及索引的数据结构。今天带你了解如何设计高性能的索引。 其中，有这么一个点，说的是InnoDB引擎中使用的是聚簇索引，其主索引的实现树中的叶子结点存储的是完整的数据记录，而辅助索引中存储的则只是辅助键和主键的值。 这样在用辅助索引进行查询时，会先查出主键的值，然后再去主索引中根据主键的值查询目标值。 比如，假想一个表如下图存储了4行数据。其中Id作为主索引，Name作为辅助索引。 Id Name Company 5 Gates Microsoft 7 Bezos Amazon 11 Jobs Apple 14 Ellison Oracle 对于聚簇索引，若使用主键索引进行查询，select * from tab where id = 14;这样的条件查找主键，则按照B+树的检索算法即可查找到对应的叶节点，之后获得行数据。 若使用辅助索引进行查询，对Name列进行条件搜索，则需要两个步骤： 1、第一步在辅助索引B+树中检索Name，到达其叶子节点获取对应的主键值。 2、第二步根据主键值在主索引B+树中再执行一次B+树检索操作，最终到达叶子节点即可获取整行数据。 上面这个过程称为回表。 回表：在数据中，当查询数据的时候，在索引中查找索引后，获得该行的rowid，根据rowid再查询表中数据，就是回表。 显然，使用辅助索引出现了回表操作，这势必会影响查询性能，那有什么办法能够减少回表吗？ 覆盖索引上面，我们查询的是select *，如果是根据Name查询Id呢？即select Id from tab where Name=’Jobs’。 很明显，由于辅助索引Name上已经存储了Id的值，所以这时，查询便不会再次回表查询。 如果索引已经包含了所有满足查询需要的数据，这时我们称之为覆盖索引（Covering Index），这时就不再需要回表操作。 覆盖索引是一种非常强大的工具，能大大提高查询性能，只需要读取索引而不用读取数据有以下一些优点： 1、索引条目通常远小于数据行大小，只需要读取索引，则 MySQL 会极大地减少数据访问量。 2、因为索引是按照列值顺序存储的，所以对于IO密集的范围查找会比随机从磁盘读取每一行数据的IO少很多。 3、覆盖索引对 InnoDB 表特别有用。因为 InnoDB 的辅助索引在叶子节点中保存了行的主键值，所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询； 由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。 联合索引/最左匹配原则又名复合索引，由两个或多个列的索引。 它规定了MySQL从左到右地使用索引字段，对字段的顺序有一定要求。 另外，一个查询可以只使用索引中的一部分，更准确地说是最左侧部分（最左优先），这就是传说中的最左匹配原则。 即最左优先，如： 如果有一个2列的索引(col1,col2)，则相当于已经对(col1)、(col1,col2)上建立了索引； 如果有一个3列索引(col1,col2,col3)，则相当于已经对(col1)、(col1,col2)、(col1,col2,col3) 上建立了索引； 但是(col2,col3)上并没有。 假定数据表有一个包含2列的联合索引（a, b），则索引的B+树结构可能如下： 键值都是排序的，通过叶子节点可以逻辑上顺序的读出所有数据。 数据（1,1）（1,2）（2,1）（2,4）（3,1）（3,2）是按照（a，b）先比较a再比较b的顺序排列。 所以从全局看，a是全局有序的，而b则不是。 基于上面的结构，对于以下查询显然是可以使用（a，b）这个联合索引的：123select * from table where a=xxx and b=xxx ;select * from table where a=xxx; 但是对于下面的sql是不能使用这个联合索引的，因为叶子节点的b值，1,2,1,4,1,2显然不是排序的。1select * from table where b=xxx 只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。 注意 1、主键字段其实跟所有非主键索引建立了联合索引，只是说如果主键字段没有在联合索引中明确声明，只会在其他索引中处于最右边； 2、最左前缀匹配原则，MySQL会一直向右匹配直到遇到范围查询（&gt;、&lt;、between、like）就停止匹配。 比如a = 1 and b = 2 and c &gt; 3 and d = 4如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引，则都可以用到，a,b,d的顺序可以任意调整。 3、= 和 in 的条件可以乱序 MySQL的查询优化器会帮你优化成索引可以识别的形式。MySQL查询优化器会判断纠正SQL语句该以什么样的顺序执行效率最高，最后才生成真正的执行计划。 为什么要使用联合索引？1、减少开销 “一个顶三个”。建一个联合索引(col1,col2,col3)，实际相当于建了(col1),(col1,col2),(col1,col2,col3) 三个索引。 每多一个索引，都会增加写操作的开销和磁盘空间的开销。对于大量数据的表，使用联合索引会大大的减少开销！ 2、覆盖索引 对联合索引(col1,col2,col3)，如果有如下的sql: select col1,col2,col3 from test where col1=1 and col2=2。那么MySQL可以直接通过遍历索引取得数据，而无需回表，这减少了很多的随机IO操作。 减少IO操作，特别的随机IO其实是DBA主要的优化策略。所以，在真正的实际应用中，覆盖索引是主要的提升性能的优化手段之一。 3、效率高 索引列越多，通过索引筛选出的数据越少。 有1000W条数据的表，有如下sql: select col1,col2,col3 from table where col1=1 and col2=2 and col3=3，假设假设每个条件可以筛选出10%的数据。 如果只有单值索引，那么通过该索引能筛选出1000W_10%=100w条数据，然后再回表从100w条数据中找到符合col2=2 and col3= 3的数据，然后再排序，再分页； 如果是联合索引，通过索引筛选出1000w_10% * 10% * 10%=1w，效率提升可想而知！ 索引下推索引条件下推（ICP：index condition pushdown）是MySQL中一个常用的优化，尤其是当MySQL需要从一张表里检索数据时。 ICP（index condition pushdown）是MySQL利用索引（二级索引）元组和筛字段在索引中的WHERE条件从表中提取数据记录的一种优化操作。 ICP的思想是：存储引擎在访问索引的时候检查筛选字段在索引中的where条件，如果索引元组中的数据不满足推送的索引条件，那么就过滤掉该条数据记录。 ICP（优化器）尽可能的把index condition的处理从server层下推到存储引擎层。 存储引擎使用索引过滤不相关的数据，仅返回符合index condition条件的数据给server层。也是说数据过滤尽可能存储引擎层进行，而不是返回所有数据给server层，然后后再根据where条件进行过滤。 下推过程优化器没有使用ICP时，数据访问和提取的过程如下： ①：MySQL Server发出读取数据的命令，调用存储引擎的索引读或全表表读。此处进行的是索引读。 ②、③：进入存储引擎，读取索引树，在索引树上查找，把满足条件的（红色的）从表记录中读出（步骤④，通常有IO）。 ⑤：从存储引擎返回标识的结果。 以上，不仅要在索引行进行索引读取（通常是内存中，速度快。步骤③），还要进行进行步骤④，通常有IO。 ⑥：从存储引擎返回查找到的多条数据给MySQL Server，MySQL Server在⑦得到较多的元组。 ⑦—⑧：依据WHERE子句条件进行过滤，得到满足条件的数据。 注意在MySQL Server层得到较多数据，然后才过滤，最终得到的是少量的、符合条件的数据。 在不支持ICP的系统下，索引仅仅作为data access使用。 优化器使用ICP时： ①：MySQL Server发出读取数据的命令，过程同图一。 ②、③：进入存储引擎，读取索引树，在索引树上查找，把满足已经下推的条件的（红色的）从表记录中读出（步骤 ④，通常有 IO）； ⑤：从存储引擎返回标识的结果。 此处，不仅要在索引行进行索引读取（通常是内存中，速度快。步骤③），还要在③这个阶段依据下推的条件进行进行判断，不满足条件的，不去读取表中的数据，直接在索引树上进行下一个索引项的判断，直到有满足条件的，才进行步骤④，这样，较没有ICP的方式，IO量减少。 ⑥：从存储引擎返回查找到的少量数据给MySQL Server，MySQL Server在⑦得到少量的数据。 因此比较图一无ICP的方式，返回给MySQL Server层的即是少量的、 符合条件的数据。 在ICP优化开启时，在存储引擎端首先用索引过滤可以过滤的where条件，然后再用索引做data access，被index condition过滤掉的数据不必读取，也不会返回server端。 举例 比如：1SELECT * FROM employees WHERE first_name='Mary' AND last_name LIKE '%man'; 在没有ICP时，首先通过索引前缀从存储引擎中读出所有first_name为Mary的记录，然后在server端用where筛选last_name的like条件； 而启用ICP后，由于last_name的like筛选可以通过索引字段进行，那么存储引擎内部通过索引与where条件的对比来筛选掉不符合where条件的记录，这个过程不需要读出整条记录，同时只返回给server筛选后条记录，因此提高了查询性能。 注意事项 有几个关于ICP的事情要注意： ICP只能用于二级索引，不能用于主索引； 也不是全部where条件都可以用ICP筛选，如果某where条件的字段不在索引中，当然还是要读取整条记录做筛选，在这种情况下，仍然要到server端做where筛选； ICP的加速效果取决于在存储引擎内通过ICP筛选掉的数据的比例； 总结建索引的几大原则1、最左前缀匹配原则，非常重要的原则，MySQL 会一直向右匹配直到遇到范围查询 （&gt;、&lt;、between、like）就停止匹配； 2、=和in的条件可以乱序； 3、尽量选择区分度高的列作为索引，区分度表示字段不重复的比例，比例越大我们扫描的记录数越少； 4、索引列不能参与计算，保持列「干净」。原因很简单，B+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。 5、尽量的扩展索引，不要新建索引。 索引是最好的解决方案吗？ 索引不是最好的，但已经是相当好的了。 当表非常小时，没必要使用索引，直接全表查询好了； 当表是中大型时，比较适合使用索引，来快速定位目标数据； 当表是超大型时，创建和维护索引都是不小的代价，需要专业的DBA来分析，这种情况下可以尝试使用分表技术；]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[在PHP中使用yield来做内存优化]]></title>
    <url>%2F2018%2F12%2F05%2F%E5%9C%A8PHP%E4%B8%AD%E4%BD%BF%E7%94%A8yield%E6%9D%A5%E5%81%9A%E5%86%85%E5%AD%98%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是yield？ yield&amp;return的区别？ 什么是yield生成器函数看上去就像一个普通函数，除了不是返回一个值之外，生成器会根据需求产生更多的值。 来看以下的例子：123456function getValues() &#123; yield 'value';&#125;// 输出字符串 "value"echo getValues(); 当然，这不是他生效的方式，前面的例子会给你一个致命的错误： 类生成器的对象不能被转换成字符串， 让我们清楚的说明： yield&amp;return的区别前面的错误意味着getValues()方法不会如预期返回一个字符串，让我们检查一下他的类型：123456789function getValues() &#123; return 'value';&#125;var_dump(getValues()); // string(5) "value"function getValues() &#123; yield 'value';&#125;var_dump(getValues()); // class Generator#1 (0) &#123;&#125; 生成器类实现了迭代器接口，这意味着你必须遍历getValue()方法来取值：123456789foreach (getValues() as $value) &#123; echo $value;&#125;// 使用变量也是好的$values = getValues();foreach ($values as $value) &#123; echo $value;&#125; 但这不是唯一的不同！ 一个生成器允许你使用循环来迭代一组数据，而不需要在内存中创建是一个数组，这可能会导致你超出内存限制。 在下面的例子里我们创建一个有800,000元素的数字同时从getValues()方法中返回他，同时在此期间，我们将使用函数memory_get_usage()来获取分配给次脚本的内存，我们将会每增加200,000个元素来获取一下内存使用量，这意味着我们将会提出四个检查点：12345678910111213141516171819202122&lt;?phpfunction getValues() &#123; $valuesArray = []; // 获取初始内存使用量 echo round(memory_get_usage() / 1024 / 1024, 2) . ' MB' . PHP_EOL; for ($i = 1; $i &lt; 800000; $i++) &#123; $valuesArray[] = $i; // 为了让我们能进行分析，所以我们测量一下内存使用量 if (($i % 200000) == 0) &#123; // 来 MB 为单位获取内存使用量 echo round(memory_get_usage() / 1024 / 1024, 2) . ' MB'. PHP_EOL; &#125; &#125; return $valuesArray;&#125;$myValues = getValues(); // 一旦我们调用函数将会在这里创建数组foreach ($myValues as $value) &#123;&#125; 前面例子发生的情况是这个脚本的内存消耗和输出：12340.34 MB8.35 MB16.35 MB32.35 MB 这意味着我们的几行脚本消耗了超过30MB的内存，每次你你添加一个元素到$valuesArray数组中，都会增加他在内存中的大小。 让我们使用yield同样的例子:12345678910111213141516171819&lt;?phpfunction getValues() &#123; // 获取内存使用数据 echo round(memory_get_usage() / 1024 / 1024, 2) . ' MB' . PHP_EOL; for ($i = 1; $i &lt; 800000; $i++) &#123; yield $i; // 做性能分析，因此可测量内存使用率 if (($i % 200000) == 0) &#123; // 内存使用以 MB 为单位 echo round(memory_get_usage() / 1024 / 1024, 2) . ' MB'. PHP_EOL; &#125; &#125;&#125;$myValues = getValues(); // 在循环之前都不会有动作foreach ($myValues as $value) &#123;&#125; // 开始生成数据 这个脚本的输出令人惊讶：12340.34 MB0.34 MB0.34 MB0.34 MB 这不意味着你从return表达式迁移到yield，但如果你在应用中创建会导致服务器上内存出问题的巨大数组，则yield更加适合你的情况。 什么是”yield”选项这里有很多yield的选项，我将强调他们中的几个： a. 使用yield，你也可以使用return。1234567891011function getValues() &#123; yield 'value'; return 'returnValue';&#125;$values = getValues();foreach ($values as $value) &#123;&#125;echo $values-&gt;getReturn(); // 'returnValue' b. 返回键值对： 1234567function getValues() &#123; yield 'key' =&gt; 'value';&#125;$values = getValues();foreach ($values as $key =&gt; $value) &#123; echo $key . ' =&gt; ' . $value;&#125; 使用情景http://www.php100.com/9/20/19693.html laravel ORM中的cursor游标cursor方法允许你使用游标遍历数据库，它只执行一次查询。处理大量的数据时,可以大大减少内存的使用量通过对比cursor与get方法，查找到了其中的一点不同，get方法是直接fetchAll返回所有数据，cursor方法是使用yield构建了一个生成器，逐步返回fetch的数据PDO mysql中的查询一般查询如下：12345$sql = "select * from `user` limit 100000000";$stat = $pdo-&gt;query($sql);$data = $stat-&gt;fetchAll(); //mysql buffered直接全部返回给phpvar_dump($data); 使用yield如下：1234567891011function get()&#123; $sql = "select * from `user` limit 100000000"; $stat = $pdo-&gt;query($sql); while ($row = $stat-&gt;fetch()) &#123; //一个一个地返回给php yield $row; &#125;&#125;foreach (get() as $row) &#123; var_dump($row);&#125; PDO参数 这个PDO参数，侧面说明了，如果这个参数为ture,MySQL驱动程序将使用MySQL API的缓冲版本。 注意，这个参数只对Mysql起作用，如果要编写可移植的sql代码，请使用fetchAll 查看php手册MYSQL_ATTR_USE_BUFFERED_QUERY 在使用了yield的情况下，内存使用量的确减少了，但是在逐渐使用yield中，内存会逐渐增大，这样的情况与以下函数不一致，下面这个函数的内存使用量将会不变12345function getNum() &#123; for($i=0; $i &lt; 100000000; $i++) &#123; yield $i; &#125;&#125; 结论在使用fetch、fetchAll之前，查找数据结果集还存在于mysql的缓冲区内，而每次yield和fetch配合，才取回一条结果存入内存，这就能解释，为什么内存使用量会逐步增大。 而上面的这个getNum函数之所以内存使用量不变，是因为，每次只返回一个数字。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL优化表]]></title>
    <url>%2F2018%2F11%2F29%2FMySQL%E4%BC%98%E5%8C%96%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： MySQL主要支持4种模式的分区，分别是range（范围）分区、list（预定义列表）分区、hash（哈希）分区以及key（键值）分区。有什么区别？ 优化表同样可以提升数据库性能，其中包括优化表结构、表的拆分、分区、表的分析与检查等内容。 优化表结构1）尽量将字段定义为NOT NULL约束。这是由于：在MySQL中，含有空值的列很难进行查询优化，NULL值会使索引、索引的统计信息以及比较运算变得更加复杂。推荐使用0、一个特殊的值或者一个空字符串代替NULL值。 2）考虑使用enum、set等复合数据类型。对于一个只包含有限数目的特定值的字段，可以考虑将其设计为enum、set等复合数据类型。enum、set等复合数据类型的值可以更快地处理，因为它们在内部是以数值表示的。 3）虽然MySQL支持blob类型，可以存储二进制数据，但是设计数据库表时，图片、音频、视频等二进制数据不要使用数据库存储，毕竟处理这些二进制数据并不是数据库的强项。 4）数值型（例如整型）字段的比较比字符串的比较效率高很多，这也符合一项优化原则：字段类型尽量使用最小、最简单的数据类型，典型的例子是IP地址的存储。当前还有很多应用使用char(15)存储IP地址，然而使用无符号整数存储IP地址效率会更高，MySQL提供了inet_aton()和inet_ntoa()函数来解决IP地址与整数之间的转换。 表的拆分表的拆分是指将某个表按照某个（或一些）条件拆分成两个或多个独立表。表的拆分分为垂直拆分与水平拆分。 1．垂直拆分垂直拆分按照字段（或者列）进行拆分，其实就是把组成一行的多个列分开，放到不同的表中。这些表具有不同的结构，拆分后的表含有更少的列，例如可以将频繁访问的列置于一张表中，不经常访问的列（例如长文本信息）置于另一张表中，然后在这两张表的记录与记录之间创建1∶1关系。举例来说，对于一张用户表而言，不仅包含账号、账户名、密码、性别等基本信息，还包括兴趣爱好（不经常使用的信息）、自我介绍（长文本信息）等扩展信息。设计用户表时，可以将用户表拆分成两个表user1表与user2表，其中user1表中包含账号、账户名、密码、性别等基本信息，user2表中包含兴趣爱好、自我介绍等扩展信息。由于user1表中的记录与user2表中的记录存在1∶1关系，此时还需要在user2表中增加user1表的主键字段user1_no作为外键，并将外键设置为唯一性约束。user1表为父表，user2表为子表。12user1（user1_no，account_name，password，sex）user2（user2_no，interest，introduction，user1_no） 使用垂直拆分的优点在于：垂直拆分可以使得列数据变小，一个数据块（Block）就可以存放更多行的记录，对频繁访问的字段执行select语句，硬盘I/O次数也会相应减少。另外，垂直拆分表可以达到最大化利用Cache的目的。 使用垂直拆分的缺点在于：由于拆分出来的两张表的记录与记录之间存在1∶1关系，这种1∶1关系需要使用冗余字段进行维护。另外，一旦访问不经常使用的字段，会引起表之间的join连接操作，额外增加了CPU的负担。 2．水平拆分水平拆分按照记录（或者行）进行拆分，其实就是把一个表分成几个表，这些表具有相同的列，但是存放更少的数据。拆分的原则通常是按照日期时间维度、地区维度或者特殊的业务维度进行表的拆分。 案例1：某个公司销售记录数据量非常大，可以对销售记录按月进行水平拆分，每个月的销售记录拆分成一张独立表，共拆分成12张独立表。 案例2：某个集团在各个地区都有分公司，该集团的订单数据量非常大，可以按分公司所在的地区进行水平拆分。 案例3：某电信公司的话单按月份、地市水平拆分后，发现数据量依然很大，可以按号码段进行3次水平拆分。 使用水平拆分的优点在于：将维度作为查询条件执行select语句时，如果维度范围很小（例如查询12月份的销售记录），可以有效降低需要扫描的数据和索引的数据块数，加快查询速度。 使用水平拆分的缺点在于：水平拆分会给应用增加复杂度，它通常在查询时需要多个表名。查询所有数据需要union操作，有时，这种复杂度会超过它带来的优点。例如，将维度作为查询条件执行select语句时，如果维度范围很大（例如查询1月份到12月份的销售记录），此时需要进行11个union操作，硬盘I/O次数也会增加。 分区分区是按照指定的规则，跨文件系统分配单个表的多个部分。对于海量数据库或者OLAP的应用而言，对表进行适当的分区可以提升数据库性能。MySQL主要支持4种模式的分区，分别是range（范围）分区、list（预定义列表）分区、hash（哈希）分区以及key（键值）分区。无论使用哪一种分区模式，它们都是对表进行“水平分区”。并且，如果表中存在主键或者唯一性约束字段，要求分区字段必须是主键字段或唯一性约束字段的一部分。分区的原则是按照日期时间维度、地区维度或者特殊的业务维度进行分区，这与水平拆分的原则相同，分区与水平拆分的不同之处如表1所示。 表1 水平拆分与分区的比较 range（范围）分区：这种分区模式允许数据库管理员将数据划分不同范围。例如，数据库管理员可以将销售记录表按照销售年度对该表划分分区。 list（预定义列表）分区：这种分区模式允许系统通过数据库管理员定义的离散值列表进行分区。例如：数据库管理员建立了一个横跨3个分区的表，分别根据2011年、2012年和2013年所对应的数据进行分区。 hash（哈希）分区：这种分区模式允许数据库管理员通过对表的一个或多个列的hash值进行计算，最后通过这个hash码不同数值对应的数据区域进行分区。例如数据库管理员可以建立一个对表主键hash值进行分区的表。 key（键值）分区：hash分区的一种延伸，这里的key由MySQL自动生成。 上述4种模式的分区中，range（范围）分区最为常用。下面以range分区为例讲解MySQL表分区的方法。下面的SQL语句首先创建一个sale销售记录表，然后再向该表添加销售年度分区（注意sale表的存储引擎为MyISAM）。12345678910create table sale( sale_id int not null, sale_date datetime, money int)engine=myisam;alter table sale partition by range columns (sale_date) ( partition p01 values less than ('2011-1-1'), partition p02 values less than ('2012-1-1')); MyISAM的sale表经过分区后，产生分区定义文件sale.par、分区索引文件（sale#P#p01.MYI与sale#P#p02.MYI）以及分区数据文件（sale#P#p01.MYD与sale#P#p02.MYD），如图1所示。 图1 MyISAM表分区的物理文件 说明如果sale表的存储引擎为InnoDB，则sale表经过分区后，仅仅产生分区定义文件sale.par。如果sale表的存储引擎为InnoDB，并且使用的是独享表空间（ibd）文件，则sale表经过分区后，除了产生分区定义文件sale.par外，还会产生分区独享表空间文件sale#P#p01.ibd与sale#P#p02.ibd，如图2所示。 图2 InnoDB独享表空间分区的物理文件 接着使用下面的SQL语句向sale表插入记录信息，运行结果如图3所示。12insert into sale values(1, '2011-1-2',100);insert into sale values(1, '2012-1-2',100); 图3 向sale表插入记录信息 注意：第二条记录插入失败，原因在于插入的值‘2012-1-2’不在sale表的两个分区范围之内。对于此类问题，可以向sale表添加一个maxvalue（无穷大值）分区。这样，第二条记录就可以成功插入p03分区中，执行结果如图4所示。1alter table sale add partition(partition p03 values less than maxvalue); 图4 maxvalue分区 查询2011年的销售记录可以使用下面的SQL语句，如图5所示。1explain partitions select * from sale where sale_date&lt;='2011-12-31' and sale_date&gt;='2011-1-1'\G 图5 分区select语句的分析 通过explain partitions命令可以发现，查询优化器只需要搜索p02 分区，查询范围的缩小可以有效提升检索性能。 如果要删除2011年度的数据，只需要删除p02分区即可，可以使用下面的SQL语句。此时对应分区的物理文件也随之删除。1alter table sale drop partition p02; 表分析与表检查表结构一旦确定，随着向表插入记录、更新记录以及删除记录，索引文件和数据文件之间的链接可能会发生错误，或者表空间中数据文件可能存在碎片，这时需要使用一些MySQL命令对表进行分析或者检查，从而提升数据库性能。 1．analyze table在执行select语句时，MySQL查询优化器需要收集一些相关信息，进而优化select语句，其中就包括索引字段的cardinality（离散度），它表示某个索引字段中包含多少个不同的值。如果索引字段cardinality的值远远小于索引字段实际的离散度，那么索引就基本失效了。通过使用show index 命令可以查看某个表所有索引字段的离散度，索引字段实际的离散度可以通过“select count(distinct(字段名))from表名;”获取。 MySQL查询优化器是基于成本的，并且最主要的成本因素就是这个查询要访问多少数据。如果这个统计信息没有生成，或者如果统计信息已经过期，优化器可能就会有个比较差的决定。analyze table命令负责对表进行分析，获得索引字段的分布情况，分析的结果可以使MySQL查询优化器得到准确的统计信息，使得SQL能够生成正确的执行计划。 举例来说：当索引字段的离散度远远小于字段实际的离散度时，可以使用MySQL命令“analyze table表名”修复某个表的索引，提高索引字段的离散度，进而为MySQL查询优化器优化select语句提供依据。例如，优化student表的索引离散度可以使用MySQL命令“analyze table student;”，执行结果如图6所示。 图6 对表进行分析说明 如果开启了二进制文件，那么analyze table的结果会写入二进制文件，可以在analyze和table之间添加关键字local以取消写入。 analyze table命令是通过执行全索引扫描来计算统计信息的，这个过程对表是锁定的。因此，对于数据基本没有发生变化的表，是不需要经常进行表分析的。但是如果表的数据量变化很明显，且实际的执行计划和预期的执行计划不同的时候，执行一次表分析可能有助于产生预期的执行计划。 2．optimize table如果某个数据库表不断地执行delete、insert或者update等更新语句，那么表的内部结构就会出现很多碎片以及未利用的空间，使用MySQL命令“optimize table表名”可以整理MyISAM以及InnoDB表的碎片，从而提升系统性能。例如，整理student表的碎片可以使用MySQL命令“optimize table student\G”，执行结果如图7所示。需要注意的是，该MySQL命令整理student表碎片失败。 图7 对表进行优化1 在启动MySQL服务前，在my.ini配置文件[mysqld]选项组中加入skip-new或者safe-mode选项，然后重启MySQL服务，此时MySQL才支持optimize table功能。重新运行MySQL命令“optimize table student\G”，执行结果如图8所示。 图8 对表进行优化2说明 如果开启了二进制日志，那么optimize table的结果会写入二进制日志，可以在optimize和table之间添加关键字local，取消写入。 3．check table所有存储引擎的表都会因为硬件问题、MySQL内部BUG或者操作系统的原因导致索引的损坏，索引没有同步更新。损坏的索引会导致诸多问题，例如，查询返回不正确的结果；当没有重复值出现时却抛出重复键值的错误；查询死锁以及宕机。 可以使用check table命令检查表、索引是否损坏，检测MyISAM和InnoDB表的健康程度。check table还可以指定下面一些选项。 quick：速度最快的选项，在检查各列的数据时，不会检查索引文件和数据文件之间链接的正确与否。如果没有遇到什么问题，可以使用这个选项。 fast：只检查没有正常关闭的表，如果在系统掉电之后没有遇到严重问题，可以使用这个选项。 changed：只检查上次检查时间之后更改的表以及没有正常关闭的表。 medium：默认的选项，会删除索引文件和数据文件之间错误的链接。 extended：最慢的选项，对索引所有关键字进行一个全面的检查。 check table也可以检查视图是否有错误，比如在视图定义中被引用的表已不存在。例如，下面的SQL语句首先创建了名字为“view1”的视图，该视图从student表中获取信息。12345create view view1 as select student_no,student_name,student_contact from student;``` 然后使用check table命令检查该视图。```sqlcheck table view1; 接着使用下面的SQL语句删除student表中的student_contact字段。1alter table student drop student_contact; 最后再次使用check table命令检查该视图，将出现如图9所示的错误信息。1check table view1; 图9 对表进行检查 4．repair table如果一个表或索引已经损坏，遇到如下错误时：1Incorrect key file for table：&apos; &apos;．Try to repair it. 可以使用MySQL命令repair table尝试修复它，该命令只对MyISAM和ARCHIVE表有效。repair table命令同样可以指定下面一些选项。 quick：最快的选项，只修复索引树。 extended：最慢的选项，需要逐行重建索引。 use_frm：只有当MYI索引文件丢失时才使用这个选项，全面重建整个索引。 与analyze table一样，repair table也可以使用local来取消写入二进制日志。 说明修复MyISAM和ARCHIVE存储引擎的表前，建议首先备份数据。 5．checksum tableMySQL主从复制环境中，从表出现写入操作或者主表执行了具备不确定性的查询指令，或者主从数据在网络传输过程中发生了数据变化，这些情况都会导致从属数据未能与主体数据正确同步，继而出现主从数据不一致问题。 对于复制环境中的每一对主从表，可以使用checksum table语句计算主从表的checksum（校验值），从而确定主从数据是否一致。通常情况下，对于每一对主从表而言，如果两个表存储的数据相同、表结构相同（字段数据类型相同以及字段的顺序相同），那么主从表的checksum校验值是相同的。 在执行checksumtable时，可以在命令的最后指定选项quick或是extended。quick 表示返回存储的checksum（校验值），而extended会重新计算checksum（校验值），如果没有指定选项，则默认使用extended。 说明创建MyISAM存储引擎的表时，如果在create table语句后加上“CHECKSUM=1”选项，那么MyISAM存储引擎的表会把checksum存储起来，称为live checksum，当数据发生变化时，checksum会相应变化。 NULL值对统计信息的影响使用analyze table命令统计索引字段的分布情况时，如果索引字段包括NULL值，MySQL如何统计该字段的cardinality（离散度）？对于MyISAM而言，myisam_stats_method参数用于控制MySQL如何处理NULL值；对于InnoDB而言，innodb_stats_method参数用于控制MySQL如何处理NULL值。这两个参数用于控制MySQL如何统计、处理NULL值，共有如下3种取值。 nulls_equal：所有的NULL值被看成相等的一个值。 nulls_unequal：每个NULL值被看成单独的一个值。 nulls_igored：NULL值被忽略。 使用MySQL命令“show variables like ‘％stats_method％’;”可以查看这两个参数的相关信息，如图10所示。innodb_stats_method的默认值为“nulls_equal”，如果此时InnoDB表的某个索引字段的NULL值较多，那么该索引字段的离散度较小，这就意味着该索引基本失效。myisam_stats_method的默认值为“nulls_unequal”，如果此时MyISAM表的某个索引字段的NULL值较多，那么该索引字段的离散度依然较大，这样就会让查询优化器处理查询语句的时候使用该索引的倾向性更高。如果索引字段的NULL值本身就很少，此时不管使用nulls_unequal还是nulls_equal，对查询优化器选择执行计划的影响很小。 图10 NULL值对统计信息的影响 记录的格式使用MySQL命令“show table status;”可以查看某个数据库的所有表或者视图（不包括临时表）的状态信息。如果需要查看某一个表的状态信息，可以使用“show table status like ‘表名’;”。例如，下面的命令负责查看account表的状态信息（注意，该表的存储引擎目前为MyISAM），如图11所示。1show table status like 'account'\G 图11 查看MyISAM表的状态信息 使用下面的命令将account表的存储引擎修改为InnoDB，然后查看account表的状态信息，如图12所示。12alter table account engine=innodb;show table status like 'account'\G 图12 查看InnoDB表的状态信息 show table status显示了表的大量信息，如表2所示。 表2 表的状态信息 说明对于MyISAM表，记录的格式有3种：Dynamic，Fixed或Compressed。Dynamic记录格式是指表的每一行记录长度是可变的。Fixed记录格式是指表的每一行记录使用固定大小的空间。Compressed记录格式仅仅用在compressed tables中。使用create table或alter table创建或者修改表结构时，可以使用row_format选项强制表的记录格式为fixed固定格式或dynamic动态格式，这会导致char和varchar列因fixed格式变成char，或因dynamic格式变成varchar。如果表的row_format是fixed，该表是静态表，静态表每条记录所占用的字节空间系统，静态表的优点是读取速度快，缺点是浪费存储空间。如果表的row_format是dynamic，该表是动态表，动态表的每条记录所占用的字节空间是动态的，动态表的优点是节省储存空间，缺点是读取速度较慢。 说明对于InnoDB表而言，记录的格式有两种：Compact以及Redundant。MySQL5.0.3之前的版本仅支持Redundant，MySQL5.0.3以及MySQL5.0.3 之后的版本，默认的row_format是Compact。 与Redundant相比，Compact以牺牲CPU使用为代价，节省大约20％的行储存空间。如果当前应用系统的负荷受限于缓存命中率以及硬盘的速度，推荐使用 Compact。如果当前应用系统的负荷受限于CPU的速度，推荐使用Redundant。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务的ACID特性]]></title>
    <url>%2F2018%2F11%2F27%2FMySQL%E4%BA%8B%E5%8A%A1%E7%9A%84ACID%E7%89%B9%E6%80%A7%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 事务的隔离性通过事务的隔离级别实现，而事务的隔离级别则是通过锁机制实现。有哪些事务隔离级别？ 为什么使用间隙锁能避免幻读现象？ 事务的首要任务是保证一系列更新语句的原子性，锁的首要任务是解决多用户并发访问可能导致的数据不一致问题。如果事务与事务之间存在并发操作，此时可以通过事务之间的隔离级别实现事务的隔离性，从而实现事务间数据的并发访问。 事务的ACID特性事务的ACID特性由原子性（atomicity）、一致性（consistency）、隔离性（isolation）和持久性（durabilily）4个英文单词的首字母组成（如图1所示）。 图1 事务的ACID特性 1．原子性（atomicity） 原子性用于标识事务是否完全地完成。一个事务的任何更新都要在系统上完全完成，如果由于某种原因出错，事务不能完成它的全部任务，那么系统将返回到事务开始前的状态。回顾银行转账业务，如果在转帐的过程中出现错误，那么整个事务将被回滚。只有事务中的所有修改操作成功执行，事务的更新才被写入外存（例如硬盘），并使更新永久化。 2．一致性（consistency） 事务的一致性保证了事务完成后，数据库能够处于一致性状态。如果事务执行过程中出现错误，那么数据库中的所有变化将自动地回滚，回滚到另一种一致性状态。回顾银行转账业务，在转账前，两个账户处于某个初始状态（一致性状态），如果转账成功，则两个账户处于新的一致性状态。如果转账失败，那么事务将被回滚到初始状态（一致性状态）。 3．隔离性（isolation） 同一时刻执行多个事务时，一个事务的执行不能被其他事务干扰。事务的隔离性确保多个事务并发访问数据时，各个事务不能相互干扰，好像只有自己在访问数据。事务的隔离性通过事务的隔离级别实现，而事务的隔离级别则是通过锁机制实现。不同种类的事务隔离级别使用的锁机制也不相同，可以这样认为，事务是对一系列更新操作的封装（保证了多个更新操作的原子性），事务的隔离级别是对锁机制的封装（保证了多个事务可以并发地访问数据）。 4．持久性（durabilily） 持久性意味着事务一旦成功执行，在系统中产生的所有变化将是永久的。回顾银行转账业务，无论转账成功还是失败，资金的转移将永久地保存在数据库的服务器硬盘中。 事务的隔离级别与并发问题事务的隔离级别是事务并发控制的整体解决方案，是综合利用各种类型的锁机制解决并发问题的整体解决方案。SQL标准定义了4种隔离级别：read uncommitted（读取未提交的数据）、read committed（读取提交的数据）、repeatable read（可重复读）以及serializable（串行化）。4种隔离级别逐渐增强，其中，read uncommitted的隔离级别最低，serializable的隔离级别最高。 1．read uncommitted（读取未提交的数据） 在该隔离级别，所有事务都可以看到其他未提交事务的执行结果。该隔离级别很少用于实际应用，并且它的性能也不比其他隔离级别好多少。 2．read committed（读取提交的数据） 这是大多数数据库系统的默认隔离级别（但不是MySQL默认的）。它满足了隔离的简单定义：一个事务只能看见已提交事务所做的改变。 3．repeatable read（可重复读） 这是MySQL默认的事务隔离级别，它确保在同一事务内相同的查询语句的执行结果一致。 4．serializable（串行化） 这是最高的隔离级别，它通过强制事务排序，使之不可能相互冲突。换言之，它会在每条select语句后自动加上lock in share mode，为每个查询数据施加一个共享锁。该级别可能会导致大量的锁等待现象。该隔离级别主要用于InnoDB存储引擎的分布式事务。 低级别的事务隔离可以提高事务的并发访问性能，却可能导致较多的并发问题（例如脏读、不可重复读、幻读等并发问题）；高级别的事务隔离可以有效避免并发问题，但会降低事务的并发访问性能，可能导致出现大量的锁等待，甚至死锁现象。如表1所示，read uncommitted隔离级别可能导致脏读、不可重复读、幻读等并发问题；而read committed隔离级别解决了脏读问题，却无法解决不可重复读、幻读等并发问题；repeatable read隔离级别可以解决脏读、不可重复读问题，却无法解决幻读问题；serializable隔离级别可以解决脏读、不可重复读、幻读等并发问题，却可能导致大量的锁等待现象。4种隔离级别逐渐增强，每种隔离级别解决一个并发问题。 表1 事务的隔离级别与并发问题 脏读（dirty read）：一个事务可以读到另一个事务未提交的数据，脏读问题显然违背了事务的隔离性原则。 不可重复读（non-repeatable read）：同一个事务内，两条相同的查询语句的查询结果不一致。 幻读（phantom read）：同一个事务内，两条相同的查询语句的查询结果应该相同。但是，如果另一个事务同时提交了新数据，当本事务再更新时，就会“惊奇地”发现这些新数据，貌似之前读到的数据是“鬼影”一样的幻觉。 查看当前MySQL会话的事务隔离级别可以使用MySQL命令“select @@session.tx_isolation;”。查看MySQL服务实例全局的事务隔离级别可以使用MySQL命令“select @@global.tx_isolation;”。执行结果如图2所示，从图中可以看出，MySQL默认的事务隔离级别为repeatable read（可重复读）。 图2 查看MySQL的事务隔离级别 设置事务的隔离级别InnoDB支持4种事务隔离级别，在InnoDB存储引擎中，可以使用以下命令设置事务的隔离级别。123set &#123; global | session &#125; transaction isolation level &#123; read uncommitted | read committed | repeatable read | serializable&#125; 合理地设置事务的隔离级别，可以有效避免脏读、不可重复读、幻读等并发问题。 场景描述1：脏读现象。 将事务的隔离级别设置为read uncommitted可能出现脏读、不可重复读以及幻读等问题，以脏读现象为例。 步骤1：打开MySQL客户机A，执行下面的SQL语句，首先将account表的存储引擎设置为InnoDB，然后将当前MySQL会话的事务隔离级别设置为read uncommitted，接着开启事务，查询account表中的所有记录，执行结果如图3所示。123456alter table account engine=InnoDB;set session transaction isolation level read uncommitted;select @@tx_isolation;start transaction;select * from account; 图3 将事务的隔离级别设置为read uncommitted 步骤2：打开MySQL客户机B，执行下面的SQL语句，首先将当前MySQL会话的事务隔离级别设置为read uncommitted，然后开启事务，接着将account表中account_no=1的账户增加1000元钱。123set session transaction isolation level read uncommitted;start transaction;update account set balance=balance+1000 where account_no=1; 步骤3：在MySQL客户机A上执行下面的SQL语句，查询account表中的所有记录，执行结果如图4所示。从图中可以看出，MySQL客户机A看到了MySQL客户机B尚未提交的更新结果，造成脏读现象。1select * from account; 图4 read uncommitted隔离级别可能造成脏读问题 步骤4：关闭MySQL客户机A与MySQL客户机B，由于MySQL客户机A与MySQL客户机B的事务没有提交，因此，account表中的数据没有发生变化，“甲”账户的余额依然是200元。 场景描述2：不可重复读现象。 将事务的隔离级别设置为read committed可以避免脏读现象，但可能出现不可重复读以及幻读等现象，以不可重复读现象为例。 步骤1：打开MySQL客户机A，执行下面的SQL语句，首先将account表的存储引擎设置为InnoDB，然后将当前MySQL会话的事务隔离级别设置为read committed，接着开启事务，查询account表中的所有记录，执行结果如图5所示。123456alter table account engine=InnoDB;set session transaction isolation level read committed;select @@tx_isolation;start transaction;select * from account; 图5 将事务的隔离级别设置为read committed 步骤2：打开MySQL客户机B，执行下面的SQL语句，首先将当前MySQL会话的事务隔离级别设置为read committed，然后开启事务，接着将account表中account_no=1的账户增加1000元钱，最后提交事务。1234set session transaction isolation level read committed;start transaction;update account set balance=balance+1000 where account_no=1;commit; 步骤3：在MySQL客户机A上执行下面的SQL语句，查询account表中的所有记录，执行结果如图6所示。两次查询结果对比可以看出，MySQL客户机A在同一个事务中两次执行“select * from account;”的结果不相同，造成不可重复读现象。1select * from account; 图6 read committed隔离级别可能造成不可重复读 说明不可重复读现象与脏读现象的区别在于，脏读现象是读取了其他事务未提交的数据；而不可重复读现象读到的是其他事务已经提交（commit）的数据。 步骤4：关闭MySQL客户机A与MySQL客户机B，由于MySQL客户机B的事务已经提交，因此，account表中“甲”账户的余额从200元增加到1200元。 场景描述3：幻读现象。 将事务的隔离级别设置为repeatable read可以避免脏读以及不可重复读现象，但可能出现幻读现象。 步骤1：打开MySQL客户机A，执行下面的SQL语句，首先将account表的存储引擎设置为InnoDB，然后将当前MySQL会话的事务隔离级别设置为repeatable read，接着开启事务，查询account表中是否存在account_no=100的账户信息，执行结果如图7所示。 12345alter table account engine=InnoDB;set session transaction isolation level repeatable read;select @@tx_isolation;start transaction;select * from account where account_no=100; 图7 事务的隔离级别设置为repeatable read 步骤2：打开MySQL客户机B，执行下面的SQL语句，首先将当前MySQL会话的事务隔离级别设置为repeatable read，接着开启事务，然后向account表中添加一条“己”账户信息，并将account_no赋值为100，最后提交事务，执行结果如图8所示。1234set session transaction isolation level repeatable read;start transaction;insert into account values(100,'己',5000);commit; 图8 向account表中添加一条“己”账户信息 步骤3：接着在MySQL客户机A上执行下面的SQL语句，查询account表中是否存在account_no=100的账户信息，执行结果如图9所示。从图中可以看出，account 表中不存在account_no=100的账户信息。1select * from account where account_no=100; 图9 查询account表中是否存在account_no=100的账户信息 步骤4：由于MySQL客户机A检测到account表中不存在account_no=100的账户信息，因此MySQL客户机A就可以向account表中插入一条account_no=100的账户信息。在MySQL客户机A上执行下面的insert语句，向account表中添加一条“庚”的账户信息，并将account_no赋值为100，执行结果如图10所示。1insert into account values(100,'庚',5000); 图10 repeatable read隔离级别可能造成幻读问题 从运行结果可以看出，account表中确实存在account_no=100的账户信息，但由于repeatable read（可重复读）隔离级别使用了“障眼法”，使得MySQL客户机A无法查询到account_no=100的账户信息，这种现象称为幻读现象。 说明幻读现象与不可重复读现象不同之处在于，幻读现象读不到其他事务已经提交（commit）的数据，而不可重复读现象读到的是其他事务已经提交（commit）的数据。 场景描述4：并发访问性能问题 避免幻读现象的方法有两个。 方法一：保持事务的隔离级别repeatable read不变，利用间隙锁的特点，对查询结果集施加共享锁（lock in share mode）或者排他锁（for update）。这种方法要求数据库开发人员了解间隙锁的特点。 方法二：将事务的隔离级别设置为serializable，可以避免幻读现象，这种方法最为简单，先以方法二为例。 步骤1：打开MySQL客户机A，执行下面的SQL语句，首先将account表的存储引擎设置为InnoDB，然后将当前MySQL会话的事务隔离级别设置为serializable，接着开启事务，查询account表中是否存在account_no=200的账户信息，执行结果如图11所示。12345alter table account engine=InnoDB;set session transaction isolation level serializable;select @@tx_isolation;start transaction;select * from account where account_no=200; 图11 将事务的隔离级别设置为serializable 步骤2：打开MySQL客户机B，执行下面的SQL语句，首先将当前MySQL会话的事务隔离级别设置为serializable，然后开启事务，接着向account表中添加一条“庚”的账户信息，并将account_no赋值为200，执行结果如图12所示。从图中可以看出，MySQL客户机B发生锁等待现象，降低了事务间的并发访问性能（虽然解决了幻读问题）。1234set session transaction isolation level serializable;start transaction;insert into account values(200,'庚',5000); 图12 serializable隔离级别可以防止幻读问题说明 由于InnoDB存储引擎发生了锁等待超时引发的错误异常，InnoDB存储引擎回滚引发了该错误异常的事务，因此，“庚”的账户信息并没有添加到account表中。 将事务隔离级别设置为serializable，可以有效避免幻读现象。然而，serializable隔离级别会降低MySQL的并发访问性能，因此，不建议将事务的隔离级别设置为serializable。 使用间隙锁避免幻读现象MySQL默认的事务隔离级别为repeatable read。为了保持事务的隔离级别repeatable read不变，利用间隙锁的特点对查询结果集施加共享锁（lock in share mode）或者排他锁（for update），同样可以避免幻读现象，同时也不至于降低MySQL的并发访问性能。当然这种方法首先要求数据库开发人员了解InnoDB间隙锁的特点。 场景描述5：将事务的隔离级别设置为repeatable read，可以避免脏读以及不可重复读现象，但可能出现幻读现象。通过引入间隙锁，可以避免幻读现象。 步骤1：打开MySQL客户机A，执行下面的SQL语句，首先将account表的存储引擎设置为InnoDB，然后将当前MySQL会话的事务隔离级别设置为repeatable read，接着开启事务，查询account表中是否存在account_no=200的账户信息，执行结果如图13所示。 12345alter table account engine=InnoDB;set session transaction isolation level repeatable read;select @@tx_isolation;start transaction;select * from account where account_no=200 lock in share mode; 图13 将事务的隔离级别设置为repeatable read 说明虽然account表中不存在account_no=200的账户信息，但最后一条 select语句为account_no=200的账户信息施加了间隙锁（共享锁）。 步骤2：打开MySQL客户机B，执行下面的SQL语句，首先将当前MySQL会话的事务隔离级别设置为repeatable read，接着开启事务，然后向account表中添加一条“庚”的账户信息，并将account_no赋值为200。insert语句将被阻塞，执行结果如图14所示。 123set session transaction isolation level repeatable read;start transaction;insert into account values(200,'庚',5000); 图14 使用间隙锁锁定account_no=200的账户，insert语句被阻塞 步骤3：接着在MySQL客户机A上执行下面的SQL语句，查询account表中是否存在account_no=200的账户信息，执行结果如图15所示。从图中可以看出，account表中不存在account_no=200的账户信息。 1select * from account where account_no=200;lock in share mode 图15 查询account表中是否存在account_no=200的账户信息 步骤4：由于MySQL客户机A检测到account表中不存在account_no=200的账户信息，因此MySQL客户机A就可以向account表中插入一条account_no=200的账户信息。在MySQL客户机A上执行下面的insert语句，向account表中添加一条“庚”的账户信息，并将account_no赋值为200，执行结果如图16所示。1insert into account values(200,'庚',5000); 图16 成功添加account_no=200的账户信息 从运行结果可以看出，当MySQL的事务隔离级别是repeatable read时，数据库开发人员可以利用间隙锁的特点，避免幻读现象。 事务与锁机制注意事项使用事务与锁机制还应该注意以下内容。 锁的粒度越小，应用系统的并发性能就越高。由于InnoDB支持行级锁，如果需要提高应用系统的并发性能，建议选用InnoDB存储引擎。 如果事务的隔离级别无法解决事务的并发问题，数据库开发人员只有在完全了解锁机制的情况下，才能在SQL语句中手动设置锁，否则应该使用事务的隔离级别。 使用事务时，尽量避免在一个事务中使用不同存储引擎的表。 尽量缩短锁的生命周期。例如，在事务中避免使用长事务，可以将长事务拆分成若干个短事务。在事务中避免使用循环语句。 优化表结构，优化SQL语句，尽量缩小锁的作用范围。例如，可以将大表拆分成小表，从而缩小锁的作用范围。 InnoDB 默认的事务隔离级别是 repeatable read，而 repeatable read 隔离级别使用间隙锁实现InnoDB的行级锁。不合理的索引可能导致行级锁升级为表级锁，从而引发严重的锁等待问题。 对于InnoDB行级锁而言，设置锁等待超时参数为合理范围，编写锁等待超时异常处理程序，解决发生锁等待问题（甚至死锁）。 为避免死锁，一个事务对多条记录进行更新操作时，当获得所有记录的排他锁后，再进行更新操作。 为避免死锁，一个事务对多个表进行更新操作时，当获得所有表的排他锁后，再进行更新操作。 为避免死锁，确保所有关联事务均以相同的顺序访问表和记录。 必要时，使用表级锁来避免死锁。 避免在一个单独事务中混合使用存储引擎。在服务器级别，MySQL不能管理事务，事务是由存储引擎实现的，尽量避免在一个单独事务中混合使用存储引擎。如果在一个单独事务中混合了事务表和非事务表，若一切正常，这个事务就没有问题；但是如果执行回滚操作，非事务表改变的数据并不会回滚。若数据库的一致性遭到了破坏，则很难恢复和呈现完整的事务。 习题1．请简单描述事务的必要性。 2．关闭MySQL自动提交的方法有哪些？您推荐数据库开发人员使用哪一种方法？ 3．关闭MySQL自动提交后，提交更新语句的方法有哪些？您推荐数据库开发人员使用哪一种方法？ 4．请简单描述典型的事务处理使用方法。 5．请简单描述典型的事务保存点使用方法。您是如何理解保存点是“临时状态”这句话的？ 6．请简单描述锁机制的必要性。 7．为MyISAM表施加表级锁的语法格式是什么？ 8．为MyISAM表施加表级锁时，read local与read选项有什么区别？ 9．您是如何理解锁的粒度、隐式锁与显式锁、锁的类型、锁的钥匙以及锁的生命周期等概念的？ 10．您如何理解锁的粒度、锁的生命周期与数据库的并发性能之间的关系？ 11．您如何理解锁的粒度、锁的生命周期与服务器资源之间的关系？ 12．“选课系统”应该使用哪种粒度的锁机制？为什么？ 13．为InnoDB表施加行级锁的语法格式是什么？ 14．请列举现实生活中的“资源竞争”问题，如何使用锁机制解决此类“资源竞争”问题？ 15．完成调课功能的replace_course_proc()存储过程以及完成选课功能choose_proc()存储过程使用了行级锁解决了“资源竞争”问题，能不能将存储过程中下面的select语句写在“start transaction;”语句之前，以便缩短行级锁的生命周期？1select state into status from course where course_no=c_no; 16．InnoDB什么时候使用间隙锁，什么时候使用记录锁？间隙锁与记录锁之间的区别是什么？ 17．锁等待与死锁之间是什么关系？ 18．请解释事务的ACID特性。 19．MySQL支持哪些事务隔离级别？默认的事务隔离级别是什么？ 20．每一种事务隔离级别可能引发什么问题？ 21．脏读现象、不可重复读现象以及幻读现象之间有什么区别？ 22．您如何理解事务、锁机制、事务的隔离级别之间的关系？]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[状态设计模式]]></title>
    <url>%2F2018%2F11%2F26%2F%E7%8A%B6%E6%80%81%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 本章涵盖： 什么是状态模式 何时使用状态模式 状态机 开灯关灯：最简单的状态设计模式 情景为王 状态 客户通过上下文做出请求 增加状态 改变接口 改变状态 更新Context类 更新客户 导航工具：更多选择和单元格 建立一个矩阵状态图 建立接口 上下文 状态 客户选择一条路径 状态模式与PHP 什么是状态模式状态（State）设计模式是GoF提出的最吸引人的模式之一，也是一种最有用的模式。游戏通常就采用状态模式，因为游戏中的对象往往会非常频繁地改变状态。状态模式的作用就是允许对象在状态改变时改变其行为。还有很多其他模拟应用（不一定是游戏）也依赖于状态模式。你会发现状态模式有很多应用。图1用类图方式显示了这种基本设计模式。 图1：状态设计模式类图 如图所示，这里没有Client类；不过，GoF指出Context是客户的主要接口。查看这个模式时，可以认为Client类通过ConText类做出请求。 何时使用状态模式如前所述，游戏开发人员通常使用状态模式来处理不同的状态。PHP中几乎每一个应用都会有一些状态改变，一个对象依赖于它的状态时，它肯定会频繁地改变，在这种情况下，状态模式就有绝对的优势。 对象中频繁的状态改变非常依赖于条件语句。就其自身来说，条件语句本身没有什么问题（如switch语句或那些带else子句的语句）。不过，如果选项太多，以至于程序开始出现混乱，或者增加或改变选项需要花费太多时间，甚至成为一种负担，这就出现了问题。 先来看模拟器或游戏的一个简单例子。假设有一个3x3的矩阵，也就是9个状态，不同的单元格（共有9个单元格）会有不同的选择。考虑图2中的矩阵。 图2：3 x 3矩阵 假设你创建了一个程序，可以上下移动和左右移动，但是不能沿对角线方向移动。如果在单元格5（见图2）上，对象可以向任何方向移动（上下和左右都可以），不过除了这个单元格以外，采用传统方式编程时，对于其他单元格都需要某个条件语句。考虑单元格4的移动，可能会有类似下面的代码:12345678910111213141516if($this-&gt;moveUp())&#123; $this-&gt;currentCell = $cell_1;&#125;elseif ($this-&gt;moveDown())&#123; $this-&gt;currentCell = $cell_7;&#125;elseif ($this-&gt;moveRight())&#123; $this-&gt;currentCell = $cell_5;&#125;elseif ($this-&gt;moveLeft())&#123; $this-&gt;currentCell = $errorMove;&#125; 在此基础上，程序必须跟踪对象在哪些单元格“中”。可以看到，条件语句的个数（或switch语句中的case个数）可能会大幅增长，使程序变得纠缠不清。 对于状态设计模式，每个状态都有自己的具体类，它们实现一个公共接口。我们不打算查看对象的控制流，而是从另一个角度来考虑，即对象的状态。下一节分析状态机，通过介绍，你将更好地理解“以状态为中心”的思路。 状态机状态机是一个模型，其重点包括不同的状态、一个状态到另一个状态的变迁，以及导致状态改变的触发器。要研究状态机，最好的起点是状态图（statechart），我们将用状态图来分析，而不是一个计算机流程图或类图。图3为一个简单的状态图，其中一个灯泡的状态从关（off）变为开（on）。 图3：显示灯泡状态的状态图 与类图相似，状态图强调的是控制流以外的东西。从图3可以看到状态模型的本质： 状态（关灯和开灯） 变迁（从关灯到开灯，以及从开灯到关灯） 触发器（灯开关） 对于打开和关上的灯，其状态、变迁和触发器都非常简单。变迁是即时的，触发器就是灯开关。不过，触发器请求一个改变之后，有些变迁可能需要渐进完成，或者要采用更复杂的方式完成。例如，天气触发树叶颜色的改变，这个变迁就是渐进完成的。不过，可以使用这个状态模型来理解从夏天状态变换到秋天状态，另外只要是通过一个触发器激活从一个状态到另一个状态的状态变迁，这种情况都可以使用这个状态模型来理解。 开灯关灯:最简单的状态设计模式尽管状态机的概念相当简单，但要知道，即使是最基本的状态设计模式也可能很有难度。考虑到这一点，这个最简单的PHP模式例子将重点考虑创建模式的步骤。有一个好消息，如果你能完成一个简单的状态设计模式，那么更大规模的模式也能轻松应对。所以我们慢慢来，先来看这个模式中的各个参与者。 情境为王所有状态模式都需要一个参与者来跟踪对象所处的状态。例如，对于前面的灯泡状态例子，就很有必要记住图2中的矩形。如果当前状态是单元格4，系统需要知道可以通过哪些变迁进入其他状态。这正是ConText类要完成的任务。要知道第一个例子只处理两个状态，即灯的状态（关或开）。Context要知道当前状态是什么。使用图3中的状态图作为指导，可以看到初始状态为关（由一个带箭头的黑色小球指示）。 作为一个参考点，首先来看ConText类。下面几小节将分析这个上下文，了解它的各个部分以及各部分的角色：1234567891011121314151617181920212223242526272829303132333435363738394041// Context.phpclass Context&#123; private $offState; private $onState; private $currentState; public function __construct() &#123; $this-&gt;offState = new OffState($this); $this-&gt;onState = new OnState($this); // 开始状态为off $this-&gt;currentState = $this-&gt;offState; &#125; // 调用状态方法触发器 public function turnOnLight() &#123; $this-&gt;currentState-&gt;turnLightOn(); &#125; public function turnOffLight() &#123; $this-&gt;currentState-&gt;turnLightOff(); &#125; // 设置当前状态 public function setState(IState $state) &#123; $this-&gt;currentState = $state; &#125; // 获得状态 public function getOnState(): &#123; return $this-&gt;onState; &#125; public function getOffState() &#123; return $this-&gt;offState; &#125;&#125; ConText类建立了3个属性，可见性均为私有(private):123$offState$onState$currentState 前两个分别是两个状态的实例，第三个属性用来跟踪给定时间系统所处的状态。 ConText类中的状态实例 在构造函数中，Context实例化IState实现的两个实例--一个对应关(off)状态，另一个对应开(on)状态:12$this-&gt;offState = new OffState($this);$this-&gt;onState = new OnState($this); 这个实例化过程用到了一种递归，称为自引用(self-referral)。构造函数参数中的实参写为$this，这是Context类自身的一个引用。状态类希望接收一个ConText类实例作为参数，为了在ConText类中实例化一个状态实例，它必须使用$this作为实参。 由于必然有某个状态作为启动时的当前状态，将$currentState属性赋为$offState值。(可以这样考虑，刚走进一个房间，当时灯是关着的。)这是offState类的一个实例。查看图3中的状态图，可以看到开始状态是off状态，所以代码只是遵循了状态图中的结构。 调用状态方法:上下文触发器方法Context类中的一些方法要调用状态类中的方法。可以把这些方法想成是触发器(triggers)。调用这些触发器，就会启动从当前状态到另外一个不同状态的变迁。举例来说，下面的方法就是一个触发器:1234public function turnOnLight()&#123; $this-&gt;currentState-&gt;turnLightOn();&#125; 注意， context方法的名字与状态方法稍有不同:这里是turnOnLight而不是turnLightOn，这些差别只是为了将Context类中的触发器方法与状态实例中的方法相区别。 设置当前状态Context类最重要的作用是跟踪当前状态，从而为系统提供一个正确的上下文或窗口。再回到图2中的矩阵，矩阵中的每一步移动都取决于当前单元格。对于单元格9，可以移到单元格8或单元格6 (不允许沿对角线方向移动)。不过，系统必须知道它的当前状态是单元格9，这样才能知道有哪些选择。 要设置一个当前状态，必须以某种方式向Context类发送信息，指定当前状态。这是通过某个状态类完成的。一旦触发一个状态，这个状态就会向Context发送一个消息，指示“我是当前状态”:1234public function setState(IState $state)&#123; $this-&gt;currentState = $state;&#125; setState()方法需要一个状态对象作为实参(由IState类型提示指示)。触发器方法触发时，它会调用一个状态和相关的方法。这个状态的方法必须向Context发送一个消息，指出现在该状态是当前状态。所以最近触发的状态会调用setState()方法，使它成为当前状态。 状态获取方法最后， context类需要有办法得到当前状态发送的消息。这个消息通过获取方法传递。对于每一个状态，context都要有相应的获取方法。由于这个例子有两个状态类，所以只需要两个获取方法。OffState的获取方法如下:.1234public function getOffState()&#123; return $this-&gt;offState;&#125; OnState的获取方法如下:1234public function getOnState()&#123; return $this-&gt;onState;&#125; 在实现的状态类中可以看到，这些方法将在设置当前状态时使用。 Context类小结Context实例化所有状态的实例，并设置默认状态。Context包含有一些方法，可以通过调用具体状态中的相应方法来触发不同的状态。设置方法会跟踪当前状态。为了帮助跟踪当前状态，对于每个状态Context还有一个获取方法，会在状态有改变调用。 状态如果了解了具体状态类如何实现Istate接口，就更能看出Context类的意义。这个接口只包含两个要实现的状态方法:123456//IState.phpinterface IState&#123; public function turnLightOn(); public function turnLightOff();&#125; 在Context类中，这两个方法都称为状态改变触发器。不过，重要的细节都在以下这两个状态类的实现中: OnState和OffState. OnState1234567891011121314151617181920// OnState.phpclass OnState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "Light is already on-&gt; take no action&lt;br/&gt;"; &#125; public function turnLightOff() &#123; echo "Lights off!&lt;br/&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getOffState()); &#125;&#125; OffState12345678910111213141516171819// OffState.phpclass OffState implements IState&#123; private $context; public function __construct(Context $contextNow) $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "Lights on! Now I can see &lt;br/&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getOnState()); &#125; public function turnLightOff() &#123; echo "Light is already off-&gt; take no action&lt;br/&gt;"; &#125;&#125; OnState和OffState类是IState的简单实现，会有文本消息指示这些状态。状态类在构造函数中包含了Context类的一个引用。应该记得，Context会实例化状态实例，并为状态构造函数类提供一个自引用。 默认状态是OffState，它必须实现IState方法turnLightOn和turnLightOff。Context调用turnLightOn方法，这会显示”Lights on! Now I can see” (开灯了，现在我能看见了)。然后它向Context方法getOnState发送一个消息，将OnState作为当前状态。不过，如果是调用OffState中的turnLightOff，就只有一个消息指示灯已经关了，不会有任何动作。它不会重置Context中的当前状态，因为这已经是当前状态。基本说来，如果请求一个状态启动它自身，就什么也不会做。类似地，如果请求触发一个无法触发的状态，同样什么也不会做。 再来看图2中9个单元格的矩阵。从单元格3可以合法地移动到单元格2或单元格6。不过，在单元格3状态中，它不能上移或右移。所以，如果它接收到一个指令，要求启动一个它无法达到的状态，对于这种不可达到的状态，通常程序员会提供一个null条件。 客户通过上下文做出请求Client的所有请求都通过Context做出。 Client与任何状态类之间都没有直接连接，包括IState接口。下面的Client显示了触发两个状态类中所有方法的请求:12345678910111213141516171819// Client.phpfunction __autoload($class_name)&#123; include $class_name . '.php';&#125;class Client&#123; private $context; public function __construct() &#123; $this-&gt;context = new Context(); $this-&gt;context-&gt;turnOnLight(); $this-&gt;context-&gt;turnOnLight(); $this-&gt;context-&gt;turnOffLight(); $this-&gt;context-&gt;turnOffLight(); &#125;&#125;$worker = new Client(); 实例化一个Context实例之后，初始请求是打开灯，因为灯的默认状态是“关”(off)状态。第二个请求是一样的，不过它只生成一个消息，指示系统目前所处的状态正是请求的这个状态，什么也不会发生。以下输出显示了这些请求的结果:1234Lights on! Now I can see!Light is already on-&gt; take no actionLights off!Light is already off-&gt; take no action OffState请求的工作类似于OnState请求。如果变迁是从一个状态到另一个状态(off-&gt;on)，就会启动这个改变。不过，如果再次请求当前状态(off-&gt;off)，只会生成一个消息，指示什么也不会发生。 增加状态对于所有设计模式来说，很重要的一个方面是:利用这些设计模式可以很容易地做出修改。与其他模式一样，状态模式同样也很易于更新和改变。对于前面最简单的例子(只包含基本的on/off状态) ，为了查看增加状态有什么影响，下面这个例子会扩展on/off状态，变成一个3路灯泡。在这个新应用中，状态将加倍，变成4个状态: 关(Off) 开(On) 更亮(Brighter) 最亮(Brightest) 图4显示了这个更新后的4态状态图。 查看这4个状态，序列有所改变。“关”(off)状态只能变到“开”(on)状态，on状态不能变到off状态。实际上，现在规则有变化，on状态只能变到“更亮”(brighter)状态和“最亮”(brightest)状态。只有brightest状态可以变到“关”(off)状态。 改变接口要改变的第一个参与者是接口IState，这个接口中必须指定相应的方法，可以用来迁移到brighter和brightest状态:12345678// IState.phpinterface IState&#123; public function turnLightOff(); public function turnLightOn(); public function turnBrighter(); public function turnBrightest();&#125; 现在所有状态类都必须包括这4个方法，它们都需要结合到Context类中。 改变状态状态设计模式中有改变时，这些新增的改变会对模式整体的其他各方面带来影响。不过，增加改变相当简单，因为状态图显示了变迁，而且在这种情况下，每个状态只有一个特定的变迁。我们不再使用文本，现在每个状态都有该状态的一个图形表示。如果变迁合法，就会显示一个特定的图像(如果变迁不合法，会显示nada.png图像) 。 OffState1234567891011121314151617181920212223242526272829// OffState.phpclass OffState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "&lt;img src='lights/on.png'&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getOnState()); &#125; public function turnBrighter() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrightest() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnLightOff() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125;&#125; OnState1234567891011121314151617181920212223242526272829// OnState.phpclass OnState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrighter() &#123; echo "&lt;img src='lights/brighter.png'&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getBrighterState()); &#125; public function turnBrightest() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnLightOff() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125;&#125; BrighterState1234567891011121314151617181920212223242526272829// BrighterState.phpclass BrighterState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrighter() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrightest() &#123; echo "&lt;img src='lights/brightest.png'&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getBrightestState()); &#125; public function turnLightOff() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125;&#125; BrightestState1234567891011121314151617181920212223242526272829// BrightestState.phpclass BrighterState implements IState&#123; private $context; public function __construct(Context $contextNow) &#123; $this-&gt;context = $contextNow; &#125; public function turnLightOn() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrighter() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnBrightest() &#123; echo "&lt;img src='lights/nada.png'&gt;"; &#125; public function turnLightOff() &#123; echo "&lt;img src='lights/off.png'&gt;"; $this-&gt;context-&gt;setState($this-&gt;context-&gt;getOffState()); &#125;&#125; 需要说明，各个状态的方法中有且仅有一个方法会建立负图像。不过，三路灯具正是采用这种方式使用三路灯泡。打开灯之后，它必须经过另外两个状态(brighter和brightest)，才会最后关掉。 更新Context类最后一步是更新Context类，增加新的触发器，并加入新状态。另外，Context还需要为每个新状态增加状态实例和获取方法:1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071&lt;?php// Context.phpclass Context&#123; private $offState; private $onState; private $brighterState; private $brightestState; private $currentState; public function __construct() &#123; $this-&gt;offState = new OffState($this); $this-&gt;onState = new OnState($this); $this-&gt;brighterState = new BrighterState($this); $this-&gt;brightestState = new BrightestState($this); // 开始状态为Off $this-&gt;currentState = $this-&gt;offState; &#125; //调用状态方法 public function turnOnLight() &#123; $this-&gt;currentState-&gt;turnLightOn(); &#125; public function turnoffLight() &#123; $this-&gt;currentState-&gt;turnLightOff(); &#125; public function turnBrighterLight() &#123; $this-&gt;currentState-&gt;turnBrighter(): &#125; public function turnBrightestLight() &#123; $this-&gt;currentState-&gt;turnBrightest(); &#125; //设置当前状态 public function setState(IState $state) &#123; $this-&gt;currentState = $state; &#125; //获得状态 public function getOnState() &#123; return $this-&gt;onState; &#125; public function getOffState() &#123; return $this-&gt;offState; &#125; public function getBrighterState() &#123; return $this-&gt;brighterState; &#125; public function getBrightestState() &#123; return $this-&gt;brightestState; &#125;&#125;?&gt; 增加的代码与之前状态的方法以及实例化是一样的。尽管Context类增加了代码，不过与原来的代码很类似，只是有更多内容。 更新客户在最初的例子中， Client可以请求两个状态on或off。增加两个状态后，Client有了更多选择，不过默认状态仍然是off，第一个请求必然是on状态。一旦建立on状态，接下来可以请求brighter状态，然后是brightest状态，之后才能再次请求off:12345678910111213141516171819202122// Client.phpfunction __autoload($class_name)&#123; include $class_name . '.php'; &#125;class Client&#123; private $context; public function __construct() &#123; $this-&gt;context = new Context(); $this-&gt;context-&gt;turnOnLight(); $this-&gt;context-&gt;turnBrighterLight(); $this-&gt;context-&gt;turnBrightestLight(); $this-&gt;context-&gt;turnOffLight(); $this-&gt;context-&gt;turnBrightestLight(); &#125;&#125;$worker = new Client(); 修改后的Client中，按正确的序列发出请求，首先变迁到on状态。不过，在经过各个不同状态回到off状态之后，Client请求返回brightest状态。此时，会出现“错误指示灯”。图5显示了请求序列得到的不同图像。 前面4个灯泡从左到右分别显示了on，brighter，brightest和off状态。不过，第5个灯泡指示请求出现错误。在典型的状态模式实现中，不会出现错误消息(或图像)。这个请求将被简单忽略。 状态这9个状态表示3 x3矩阵中的不同单元格。为了唯一地显示各个单元格,会分别显示一个图像作为标签(有不同的数字和颜色) 。这样一来,能够更清楚地看出穿过矩阵的路线。这9个状态类都包含实现IMatrix接口所需的4个方法。在前面的状态例子中,如果一种选择不合法(如三路灯泡中从on状态直接变到brightes状态) ,并不是显示一个不合法的调用,这里只提供了注释行,指示代码中有一个不合法的移动。 状态模式与PHP很多人把状态设计模式看做是实现模拟器和游戏的主要方法。总的说来,这确实是状态模式的目标,不过除此以外,状态模型(状态引擎)和状态设计模式在PHP中也有很多应用。用PHP完成更大的项目时,包括Facebook和WordPress,会有更多的新增特性和当前状态需求。Grady Booch (http:libm.colyCL6se)指出, Facebook一方面要保证网站更新,同时在以指数速度扩张时(即使有很多程序员也不能满足需要)仍要保持正常工作,要做到这一点难度越来越大。对于这种不断有改变和增长的情况,就可以采用可扩展的状态模式来管理。PHP开发人员如何创建包含多个状态的程序,将决定状态模式的使用范围。所以不仅状态机在游戏和模拟世界中有很多应用,实际上状态模型还有更多适用的领域。只要PHP程序的用户会用到一组有限的状态,开发人员就可以使用状态设计模式。]]></content>
      <categories>
        <category>设计模式</category>
      </categories>
      <tags>
        <tag>Learning PHP设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL锁机制]]></title>
    <url>%2F2018%2F11%2F26%2FMySQL%E9%94%81%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 只有通过索引字段检索数据的查询语句或者更新语句，才可能施加行级锁，否则InnoDB将使用表级锁。怎么理解？ 给MyISAM表施加表级锁不会导致死锁问题的发生，给InnoDB表施加行级锁可能导致死锁问题的发生。为什么？ MySQL为什么会存在内存中的数据与外存中的数据不同步？ for update必须写在事务吗？ InnoDB存储引擎支持行级锁和表级锁吗？ 为什么读锁也称为共享锁，写锁也称为排他锁或者独占锁？ lock tables account read;是什么意思？ 使用low_priority write选项降低写锁的优先级，以便MySQL客户机A及时取得读锁，不被饿死。怎么理解？ 在同一时刻，如果数据库仅仅为单个MySQL客户机提供服务，仅通过事务机制即可实现数据库的数据一致性。但更多时候，在同一时刻，多个并发用户往往需要同时访问（检索或者更新）数据库中的同一个数据，此时仅仅通过事务机制无法保证多用户同时访问同一数据的数据一致性，因此有必要引入另一种机制实现数据的多用户并发访问。锁机制是MySQL实现多用户并发访问的基石。 锁机制的必要性MySQL客户机A与MySQL客户机B执行同一条SQL语句“select * from account;”时产生的结果截然不同，继而产生数据不一致问题。这种数据不一致问题产生的深层次原因在于，内存中的数据与外存中的数据不同步造成的（或者说是由内存中的表记录与外存中的表记录之间存在“同步延迟”造成的）。 MySQL客户机A访问数据时，如果能够对该数据“加锁”，阻塞（或者延迟）MySQL客户机B对该数据访问，直到MySQL客户机A数据访问结束，内存与外存中的数据同步后，MySQL客户机A对该数据“解锁”，“解锁”后，被阻塞的MySQL客户机B“被唤醒”，继而可以继续访问该数据，这样就可以实现多用户下数据的并发访问，如图1所示。 图1 多用户下数据并发访问的实现原理 简言之，内存数据与外存数据之间的同步延迟，可以通过锁机制将“并发访问”延迟，进而实现数据的一致性访问以及并发访问。 当然，单条更新语句运行期间也会产生同步延迟。update语句的执行过程可以简单描述为如下步骤，如图2所示。1update account set balance = balance + 800 where account_no = 2; 图2 单条更新语句的延迟无法避免 步骤1：使用索引查询是否存在“account_no=2”的账户信息。 步骤2：若存在，将该账户信息从外存加载到内存，在内存中生成old记录。 步骤3：修改old记录中的balance字段值，在内存中生成new记录。 步骤4：将内存中的new记录写入到外存，完成update操作。 上述每一个步骤的执行都需要一定的时间间隔（虽然短暂）。单个update语句运行期间，从步骤1运行到步骤4同样会产生延迟，这种延迟根本就无法避免，数据库开发人员也无需理会这种延迟，毕竟单条SQL语句运行期间会作为一个“原子”操作运行。数据库开发人员需要考虑的问题是:如何借助锁机制，解决多用户并发访问可能引起的数据不一致问题？ MySQL锁机制的基础知识简单地说，MySQL锁机制涉及的内容包括：锁的粒度、隐式锁与显式锁、锁的类型、锁的钥匙以及锁的生命周期等。 锁的粒度锁的粒度是指锁的作用范围。就像读者有了防盗门的钥匙就可以回到“家”中，有了卧室的钥匙就可以进到卧室，有了保险柜的钥匙就可以打开保险柜，每一种“资源”存在一个与之对应“粒度”的锁，数据库亦是如此。对于MySQL而言，锁的粒度可以分为服务器级锁（server-level locking）和存储引擎级锁（storage-engine-level locking）。 服务器级锁是以服务器为单位进行加锁，它与表的存储引擎无关。在MySQL基础知识章节中讲解数据库备份时，为了保证数据备份过程中不会有新的数据写入，使用MySQL命令“flush tables with read lock;”锁定了当前MySQL服务实例，该锁是服务器级锁，并且是服务器级“读锁”。 也就是说， MySQL客户机A执行了MySQL命令“flush tables with read lock;”，锁定了当前MySQL服务实例后，MySQL客户机A针对服务器的写操作（例如insert，update，delete以及create等语句）抛出如下错误信息。1ERROR 1223（HY000）: Can't execute the query because you have a conflicting read lock 其他MySQL客户机（例如MySQL客户机B）针对服务器的写操作（例如insert，update，delete以及create等语句）被阻塞。 只有MySQL客户机A执行“unlock tables;”命令或者关闭MySQL客户机A的服务器连接，释放服务器级读锁后，才会“唤醒”MySQL客户机B的写操作，MySQL客户机B的写操作才能得以继续执行。MySQL客户机A施加的服务器级锁，只有MySQL客户机A才能解锁。 例如，在MySQL客户机A上锁定了当前MySQL服务实例后，在MySQL客户机B上创建视图test view将被阻塞，而在MySQL客户机A上创建视图test view将产生错误信息（ERROR 1223）。MySQL客户机A解锁后，MySQL客户机B才能成功创建视图test view，如图3所示（注意图中的粗体字）。从执行结果可以看出，MySQL客户机A施加服务器级锁后，该锁对MySQL客户机A的后续操作以及对MySQL客户机B的后续操作产生的效果并不相同。 图3 服务器级读锁的使用 存储引擎级锁分为表级锁以及行级锁。表级锁是以表为单位进行加锁，MyISAM与InnoDB存储引擎的表都支持表级锁。行级锁是以记录为单位进行加锁，在MyISAM与InnoDB存储引擎中，只有InnoDB存储引擎支持行级锁。 小结：服务器级锁的粒度最大，表级锁的粒度次之，行级锁的粒度最小。锁粒度越小，并发访问性能就越高，越适合做并发更新操作（InnoDB表更适合做并发更新操作）；锁粒度越大，并发访问性能就越低，越适合做并发查询操作（MyISAM表更适合做并发查询操作）。另外，锁粒度越小，完成某个功能时所需要的加锁、解锁的次数就会越多，反而会消耗较多的服务器资源，甚至会出现资源的恶性竞争，甚至发生死锁问题。 对于“选课系统”而言，系统需要为上百名学生，甚至几百名学生同时提供选课、调课、退课服务。为了提高并发性能，“选课系统”将选用行级锁，这也是“选课系统”的各个数据库表使用InnoDB存储引擎的原因（InnoDB存储引擎支持行级锁）。 隐式锁与显式锁MySQL锁分为隐式锁以及显式锁。多个MySQL客户机并发访问同一个数据时，为保证数据的一致性，数据库管理系统会自动地为该数据加锁、解锁，这种锁称为隐式锁。隐式锁无需数据库开发人员维护（包括粒度、加锁时机、解锁时机等）。 如果应用系统存在多用户并发访问数据的行为，有时单靠隐式锁无法实现数据的一致性访问要求（例如多个学生同时选修同一门课程），此时需要数据库开发人员手动地加锁、解锁，这种锁称为显式锁。对于显式锁而言，数据库开发人员不仅需要确定锁的粒度，还需要确定锁的加锁时机（何时加锁）、解锁时机（何时解锁）以及锁的类型。 锁的类型锁的类型包括读锁（read lock）和写锁（write lock），其中读锁也称为共享锁，写锁也称为排他锁或者独占锁。 读锁（read lock）：如果MySQL客户机A对某个数据施加了读锁，加锁期间允许其他MySQL客户机（例如MySQL客户机B）对该数据施加读锁，但会阻塞其他MySQL客户机（例如MySQL客户机C）对该数据施加写锁，除非MySQL客户机A释放该数据的读锁。简言之，读锁允许其他MySQL客户机对数据同时“读”，但不允许其他MySQL客户机对数据任何“写”（如图4所示）。如果“数据”是表，则该读锁是表级读锁；如果“数据”是记录，则该读锁是行级读锁。 图4 读锁的使用 写锁（write lock）：如果MySQL客户机A对某个数据施加了写锁，加锁期间会阻塞其他MySQL客户机（例如MySQL客户机B）对该数据施加读锁以及写锁，除非MySQL客户机A释放该数据的写锁。简言之，写锁不允许其他MySQL客户机对数据同时“读”，也不允许其他MySQL客户机对数据同时“写”（见图5）。如果“数据”是表，则该写锁是表级写锁；如果“数据”是记录，则该写锁是行级写锁。 图5 写锁的使用 锁的钥匙多个MySQL客户机并发访问同一个数据时，如果MySQL客户机A对该数据成功地施加了锁，那么只有MySQL客户机A拥有这把锁的“钥匙”，也就是说，只有MySQL客户机A能够对该锁进行解锁操作。 锁的生命周期锁的生命周期是指在同一个MySQL会话内，对数据加锁到解锁之间的时间间隔。锁的生命周期越长，并发访问性能就越低；锁的生命周期越短，并发访问性能就越高。另外，锁是数据库管理系统重要的数据库资源，需要耗费一定的服务器内存，锁的生命周期越长，该锁占用服务器内存的时间间隔就越长；锁的生命周期越短，该锁占用服务器内存的时间间隔就越短。因此为了节省服务器资源，数据库开发人员必须尽可能的缩短锁的生命周期，尽可能早地释放锁资源。 小结：不恰当的锁粒度、锁生命周期不仅会影响数据库的并发性能，还会造成锁资源的浪费。 MyISAM表的表级锁对MyISAM存储引擎的表进行检索（select）操作时，select语句执行期间（时间间隔虽然短暂），MyISAM存储引擎会自动地给涉及到的MyISAM表施加“隐式读锁”；select语句执行完毕后，MyISAM存储引擎会自动地为这些表进行“解锁”。因此select语句的执行时间就是“隐式读锁”的生命周期。 对MyISAM存储引擎的表进行更新（insert、update以及delete）操作时，更新语句（例如insert、update以及delete）执行期间（时间间隔虽然短暂），MyISAM存储引擎会自动地给涉及到的MyISAM表施加“隐式写锁”；更新语句执行完毕后，MyISAM存储引擎会自动地为这些表进行解锁，更新语句的执行时间就是“隐式写锁”的生命周期。 可以看到，任何针对MyISAM表的查询操作或者更新操作，都会隐式地施加表级锁。隐式锁的生命周期非常短暂，且不受数据库开发人员的控制。 有时，应用系统要求数据库开发人员延长MyISAM表级锁的生命周期，MySQL为数据库开发人员提供了显式地施加表级锁以及显式地解锁的MySQL命令，以便数据库开发人员能够控制MyISAM表级锁的生命周期，MySQL客户机A施加表级锁以及解锁的MySQL命令的语法格式如图6所示。 图6 表级锁的使用 注意事项： （1）上述语法格式主要针对MyISAM表显式地施加表级锁以及解锁，该语法格式同样适用于InnoDB表。只不过因为InnoDB表支持行级锁，在InnoDB表中表级锁的概念比较淡化。 （2）read与write选项的功能在于说明施加表级读锁还是表级写锁。对表施加读锁后，MySQL客户机A对该表的后续更新操作将出错，错误信息如上图所示；MySQL客户机B对该表的后续查询操作可以继续进行，而对该表的后续更新操作将被阻塞。出错与阻塞是两个不同的概念。 MySQL客户机A对表施加写锁后，MySQL客户机A的后续查询操作以及后续更新操作都可以继续进行；MySQL客户机B对该表的后续查询操作以及后续更新操作都将被阻塞。 MySQL客户机A为某个表加锁后，加锁期间MySQL客户机A对该表的后续操作，MySQL客户机B对该表的后续操作以及MySQL客户机B对该表加锁之间的关系如表1所示。 表1 表级锁与后续操作之间的关系 （3）MySQL客户机A使用lock tables命令可以同时为多个表施加表级锁（包括读锁或者写锁），并且加锁期间，MySQL客户机A不能对“没有锁定的表”进行更新及查询操作，否则将抛出“表未被锁定”的错误信息。例如，在MySQL客户机A上运行下面的MySQL代码，对account表施加读锁，加锁期间对book表的查询操作将抛出错误信息，如图7所示。读者可以自行分析，使用显式锁后，锁的生命周期是否延长。123456alter table account engine=MyISAM;alter table book engine=MyISAM;lock tables account read;select * from account; select * from book;unlock tables; 图7 表级锁使用的注意事项（1） （4）如果需要为同一个表同时施加读锁与写锁，那么需要为该表起两个别名，以区分读锁与写锁。 例如，下面的MySQL代码首先将account表的存储引擎设置为MyISAM。然后向account表同时施加读锁（account表的别名为a）以及写锁（account表的别名为b）。接着将account表重命名为a进行查询操作，将account表重命名为b进行查询操作。如果直接查询account表中的所有记录，则将抛出错误信息，原因是并没有为account表施加一个名字为account的锁，抛出错误信息”account表未被锁定”也在情理之中，执行结果如图8所示。读者可以自行分析，使用显式锁后，锁的生命周期是否延长。123456alter table account engine=MyISAM;lock tables account as a read，account as b write;select * from account as a;select * from account as b;select * from account; unlock tables; 图8 表级锁使用的注意事项（2） 说明为了便于理解，读者可以认为每个表的锁必须有锁名，且默认情况下锁名就是表名。当某个表既存在读锁又存在写锁时，需要为表名起多个别名，且每个别名对应一个锁名。 （5）read local与read选项之间的区别在于，如果MySQL客户机A使用read选项为某个MyISAM表施加读锁，加锁期间，MySQL客户机A以及MySQL客户机B都不能对该表进行插入操作。如果MySQL客户机A使用read local选项为某个MyISAM表施加读锁，加锁期间，MySQL客户机B可以对该表进行插入操作，前提是新记录必须插入到表的末尾。对InnoDB表施加读锁时，read local选项与read选项的功能完全相同。 场景描述1：read local与read选项之间的区别。 首先在MySQL客户机A上执行下面的MySQL命令，并为account表施加local读锁。12alter table account engine=MyISAM;lock tables account read local; 然后打开MySQL客户机B，在MySQL客户机B上执行下面的insert语句，向account表中添加一条记录，执行结果如图9所示。从执行结果可以看出，MySQL客户机A为account表施加local读锁后，MySQL客户机B可以向account表中添加记录。local关键字使得MyISAM表最大限度地支持查询和插入的并发操作。1insert into account values（null， '丁'， 1000）; 图9 read local选项的使用 最后在MySQL客户机A上执行下面的MySQL命令，为account表解锁。1unlock tables; （6）MySQL客户机A对某个表施加读锁的同时， MySQL客户机B对该表施加写锁，默认情况下会优先施加写锁，这是因为更新操作比查询操作更为重要。如果MySQL客户机C…Z对该表同时也施加了写锁，可能造成读锁“饿死”。为了避免读锁“饿死”，MySQL客户机B….Z可以使用low_priority write选项降低写锁的优先级，以便MySQL客户机A及时取得读锁，不被饿死。 （7）unlock tables用于解锁，它会解除当前MySQL服务器连接中所有MyISAM表的所有锁。 （8）lock tables与unlock tables语句会引起事务的隐式提交。 （9）MySQL客户机一旦关闭， unlock tables语句将会被隐式地执行。因此，如果要让表锁定生效就必须一直保持MySQL服务器连接。 InnoDB表的行级锁InnoDB表的锁比MyISAM表的锁更为复杂，原因在于InnoDB表既支持表级锁，又支持行级锁，又存在意向锁，再把事务掺入其中，会给初学者的学习带来不少麻烦。使用lock tables命令为InnoDB表施加表级锁与使用lock tables命令为MyISAM表施加表级锁的用法基本相同，不再赘述，这里主要讨论InnoDB行级锁以及意向锁的用法。 InnoDB提供了两种类型的行级锁，分别是共享锁（S）以及排他锁（X），其中共享锁也叫读锁，排他锁也叫写锁。InnoDB行级锁的粒度仅仅是受查询语句或者更新语句影响的那些记录。在查询（select）语句或者更新（ insert，update以及delete）语句中，为受影响的记录施加行级锁的方法也非常简单。 方法1：在查询（select）语句中，为符合查询条件的记录施加共享锁，语法格式如下所示。 select from 表 where 条件语句 *lock in share mode; 方法2：在查询（select）语句中，为符合查询条件的记录施加排他锁，语法格式如下所示。 select from 表 where 条件语句 *for update; 方法3：在更新（insert，update以及delete）语句中，InnoDB存储引擎将符合更新条件的记录自动施加排他锁（隐式锁），即InnoDB存储引擎自动地为更新语句影响的记录施加隐式排他锁。 说明方法1与方法2是显式地施加行级锁，方法3是隐式地施加行级锁。这3种方法施加的行级锁的生命周期非常短暂，为了延长行级锁的生命周期，最为通用的做法是开启事务。事务提交或者回滚后，行级锁才被释放，这样就可以延长行级锁的生命周期，此时事务的生命周期就是行级锁的生命周期。 场景描述2：通过事务延长行级锁的生命周期。 步骤1：在MySQL客户机A上执行下面的MySQL语句，开启事务，并为student表施加行级写锁。123use choose;start transaction;select * from student for update; 步骤2：打开MySQL客户机B ，在MySQL客户机B上执行下面的MySQL语句，开启事务，并为student表施加行级写锁。此时，MySQL客户机B被阻塞。123use choose;start transaction;select * from student for update; 步骤3：在MySQL客户机A上执行下面的MySQL命令，为student表解锁。此时，MySQL客户机A释放了student表的行级写锁，MySQL客户机B被“唤醒” ，得以继续执行。1commit; 可以看到，通过事务延长了MySQL客户机A针对student表的行级锁的生命周期。 结论：事务中的行级共享锁（S）以及行级排他锁（X）的生命周期从加锁开始，直到事务提交或者回滚，行级锁才会释放。 MySQL客户机A使用“select * from 表 where 条件语句 lock in share mode;”为InnoDB表中符合条件语句的记录施加共享锁后，加锁期间，MySQL客户机A可以对该表的所有记录进行查询以及更新操作。加锁期间，MySQL客户机B可以查询该表的所有记录（甚至施加共享锁），可以更新不符合条件语句的记录，然而为符合条件语句的记录施加排他锁时将被阻塞。 MySQL客户机A使用“select * from 表 where 条件语句 for update;”或者更新语句（例如insert，update以及delete）为InnoDB表中符合条件语句的记录施加排他锁后，加锁期间，MySQL客户机A可以对该表的所有记录进行查询以及更新操作。加锁期间，MySQL客户机B可以查询该表的所有记录，可以更新不符合条件语句的记录，然而为符合条件语句的记录施加共享锁或者排他锁时将被阻塞。 为了便于读者更好地理解共享锁以及排他锁之间的关系，可以参看表2所示的内容。 表2 行级锁与后续操作之间的关系 “选课系统”中的行级锁场景描述3：实现调课功能的存储过程replace_course_proc()存在功能缺陷。考虑这样的场景：张三与李四“同时”选择同一门目标课程，且目标课程就剩下一个席位（此时目标课程available的字段值为1）。张三以及李四为了实现调课功能，“同时”调用存储过程replace_course_proc()，假设两人“同时”执行存储过程中的select语句“查询目标课程available字段值”：1select available into s from course where course_no=c_after; 张三以及李四可能都读取到available的值为1（大于零），最后的结果是张三与李四都选择了目标课程，如图10所示。 图10 存储过程replace_course_proc()存在功能缺陷 可以看出，存储过程replace_course_proc()读取课程的available字段值时，有必要为张三与李四选择相同的目标课程施加排他锁，避免多名学生同时读取同一门课程的available字段值。将存储过程replace_course_proc()中的代码片段:1select available into s from course where course_no=c after; 修改为如下的代码片段：1select available into s from course where course_no=c_after for update; 说明为了延长行级排他锁的生命周期，将该select语句写在了start transaction语句后，封装到事务中。 此时，当张三、李四以及其他更多的学生同时“争夺”同一门目标课程的最后一个席位时，可以保证只有一个学生能够读取该席位，其他学生将被阻塞（如图11所示）。这样就可以防止张三与李四都选择了目标课程的最后一个席位。很多读者可能觉得：多个学生同时选择“最后一个席位”的可能性微乎其微，但如果最后的一个“席位”是春运期间某趟列车的最后一张火车票呢？现实生活中，类似的“资源竞争”问题还有很多（例如团购、秒杀等），使用锁机制可以有效解决此类“资源竞争”问题。 图11 解决存储过程replace_course_proc()的功能缺陷 同样的道理，在前面的章节中，实现选课功能的存储过程choose_proc()也需要进行相应的修改（粗体字部分为代码改动部分）。删除存储过程choose_proc()，并重建该存储过程。12345678910111213141516171819202122232425262728293031323334drop procedure choose_proc;delimiter $$create procedure choose_proc(in s_no char(11),in c_no int,out state int)modifies sql databegin declare s1 int; declare s2 int; declare s3 int; declare status char(8); set state= 0; set status='未审核'; select count(*) into s1 from choose where student_no=s_no and course_no=c_no ; if(s1&gt;=1) then set state = -1; else select count(*) into s2 from choose where student_no=s_no; if(s2&gt;=2) then set state = -2; else start transaction; select state into status from course where course_no=c_no; select available into s3 from course where course_no=c_no for update; if(s3=0 || status='未审核') then set state = -3; else insert into choose values(null,s_no,c_no,null,now()); set state = last_insert_id(); end if; commit; end if; end if;end$$delimiter ; InnoDB表的意向锁InnoDB表既支持行级锁，又支持表级锁。考虑如下场景：MySQL客户机A获得了某个InnoDB表中若干条记录的行级锁，此时，MySQL客户机B出于某种原因需要向该表显式地施加表级锁（使用lock tables命令即可），为了获得该表的表级锁，MySQL客户机B需要逐行检测表中是否存在行级锁，而这种检测需要耗费大量的服务器资源。 试想：如果MySQL客户机A获得该表若干条记录的行级锁之前，MySQL客户机A直接向该表施加一个“表级锁”（这个表级锁是隐式的，也叫意向锁），MySQL客户机B仅仅需要检测自己的表级锁与该意向锁是否兼容，无需逐行检测该表是否存在行级锁，这样就会节省不少服务器资源，如图12所示。 图12 InnoDB表的意向锁 由此可以看出，引入意向锁的目的是为了方便检测表级锁与行级锁之间是否兼容。意向锁是隐式的表级锁，数据库开发人员向InnoDB表的某些记录施加行级锁时，InnoDB存储引擎首先会自动地向该表施加意向锁，然后再施加行级锁，意向锁无需数据库开发人员维护。MySQL提供了两种意向锁：意向共享锁（IS）和意向排他锁（IX）。 意向共享锁（IS）：向InnoDB表的某些记录施加行级共享锁时，InnoDB存储引擎会自动地向该表施加意向共享锁（IS）。也就是说，执行“select * from 表 where 条件语句 lock in share mode;”后，InnoDB存储引擎在为表中符合条件语句的记录施加共享锁前，InnoDB会自动地为该表施加意向共享锁（IS）。 意向排他锁（IX）：向InnoDB表的某些记录施加行级排他锁时，InnoDB存储引擎会自动地向该表施加意向排他锁（IX）。也就是说，执行更新语句（例如insert、update或者delete语句）或者“select * from 表 where 条件语句 for update;”后，InnoDB存储引擎在为表中符合条件语句的记录施加排他锁前，InnoDB会自动地为该表施加意向排他锁（IX）。 说明意向锁虽是表级锁，但是却表示事务正在查询或更新某一行记录，而不是整个表，因此意向锁之间不会产生冲突。 每执行一条“select…lock in share mode”语句，该select语句在执行期间自动地施加意向共享锁，执行完毕后，意向共享锁会自动解锁，因此意向共享锁的生命周期非常短暂，且不受人为控制；意向排他锁也是如此。 某个InnoDB表已经存在了行级锁，此时其他MySQL客户机再向该表施加表级锁时，可能引发意向锁与表级锁之间的冲突。意向锁与意向锁之间以及意向锁与表级锁之间的关系如表3所示。 表3 意向锁与表级锁之间的关系 InnoDB行级锁与索引之间的关系InnoDB表的行级锁是通过对“索引”施加锁的方式实现的，这就意味着，只有通过索引字段检索数据的查询语句或者更新语句，才可能施加行级锁，否则InnoDB将使用表级锁，而使用表级锁势必会降低InnoDB表的并发访问性能。 场景描述4：索引设置不当，降低InnoDB表的并发访问性能。 步骤1：打开MySQL客户机A，在MySQL客户机A上执行下面的MySQL命令，首先将account账户表的存储引擎设置为InnoDB，接着关闭MySQL自动提交，最后对账户名为“甲”的记录施加行级排他锁，执行结果如图13所示。123alter table account engine=InnoDB;set autocommit=0;select * from account where account_name='甲' for update; 图13 对账户名为“甲”的记录施加行级排他锁 步骤2：打开MySQL客户机B，在MySQL客户机B上执行下面的MySQL命令，首先关闭MySQL自动提交，对账户名为“乙”的记录施加行级排他锁时被阻塞，执行结果如图14所示。从MySQL客户机B的执行结果可以看出，MySQL客户机B对“乙”账户施加排他锁时，出现了“锁等待”现象（被阻塞）。12set autocommit=0;select * from account where account_name='乙' for update; 图14 对账户名为“乙”的记录施加行级排他锁 按理MySQL客户机A仅仅对“甲”账户施加了排他锁，不会影响MySQL客户机B对“乙”账户施加排他锁，然而事实并非如此。原因在于，查询语句或者更新语句施加行级锁时，如果没有使用索引，查询语句或者更新语句会自动地对 InnoDB 表施加表级锁，最终导致出现了“锁等待”现象，降低了InnoDB表的并发访问性能。 说明使用MySQL命令“show variables like ‘innodb_lock_wait_timeout’;”可以查看锁InnoDB等待超时的时间（默认值为50秒，如图15所示）。当InnoDB锁等待的时间超过参数innodb_lock_wait_timeout的值时，将引发InnoDB锁等待超时错误异常（如图14所示）。图15 查看锁等待超时时间 步骤3：锁等待期间，在MySQL客户机A上执行MySQL命令“show full processlist\G”可以查看当前MySQL服务实例上正在运行的MySQL线程的状态信息，如图16所示。各个状态信息说明如下。 图16 查看MySQL服务实例上正在运行的MySQL线程 Id列：是一个标识，唯一标记了一个MySQL线程或者一个MySQL服务器连接。 User列：显示了当前的MySQL账户名。 Host列：显示每条SQL语句或者MySQL命令是从哪个MySQL客户机的哪个端口上发出。 db列：显示当前的MySQL线程操作的是哪一个数据库。 Command 列：显示该线程的命令类型，命令类型的取值一般是休眠（sleep）、查询（query）或者连接（connect）。例如，命令类型的取值是Sleep时，表示当前的线程正在等待MySQL客户机向它发送一条新语句。 Time列：显示了该线程执行时的持续时间，单位是秒。例如，time=48时，意味着该线程执行的持续时间为48秒。 State列：显示了该线程的状态，状态取值一般是init、update、sleep、sending data、空字符串或者waiting for锁类型lock。例如，当状态取值是Waiting for table metadata lock时，表示当前的线程正在等待MySQL客户机获得元数据锁，即发生了锁等待现象;当状态取值是sending data时，表示当前的线程正在向MySQL服务器发送数据。如果处于某种状态（例如sending data）的持续时间较长（例如48秒），可能出现了锁等待现象。 Info列：显示了SQL语句，因为长度有限，所以长的SQL语句仅仅显示一部分。 步骤4：使用MySQL命令“kill 49;”即可杀死图16中状态持续时间较长的线程49，并关闭与之对应的MySQL服务器连接。 对于数据库开发人员而言，如果不了解InnoDB行级锁是基于索引实现的这一特性，可能导致大量的锁冲突，从而影响并发性能：当“甲”账户在银行柜台前办理存款或者取款业务时，其他账户无法同时办理存款或者取款业务。 解决办法：使用下面的SQL语句为account表的account_name字段添加索引（索引名为account_name_index）。添加索引后，读者可以再次尝试：MySQL客户机A对“甲”账户施加了排他锁后，MySQL客户机B对“乙”账户施加排他锁时，是否还会产生“InnoDB锁等待”现象（被阻塞）。1alter table account add index account_name_index(account_name); 结论：InnoDB表的行级锁是通过对索引施加锁的方式实现的，了解InnoDB行级锁的实现方式后，很多问题都可以找到答案。例如，当检索条件为某个区间（例如account_no between 1 and 100）范围时，对该区间范围施加共享锁或排他锁后，满足该区间范围的记录（例如account_no=1或者account_no=2的记录）存在共享锁或排他锁；满足该区间范围，但表中不存在的记录（例如account_no=50 或者 account_no=100 的记录）也会存在共享锁或排他锁，即行级锁会锁定相邻的键（next-key locking），这种锁机制就是所谓的间隙锁（next-key锁），可以看出，间隙锁与索引密切相关。如果间隙锁使用得当，可以避免幻读现象；如果间隙锁使用不当，可能导致死锁问题，有关间隙锁的使用请参看本章后续内容。 说明当事务的隔离级别设置为repeatable read（这是MySQL默认的事务隔离级别），此时为InnoDB表施加行级锁，默认情况下使用间隙锁。当事务的隔离级别设置为read uncommitted或者read committed，此时为InnoDB表施加行级锁，默认情况下使用记录锁（record lock）。与间隙锁不同，记录锁仅仅为满足该查询范围的记录施加共享锁或排他锁。 数据库开发人员可以使用explain命令对查询语句进行分析，从而判断该查询语句是否使用了索引。虽然explain命令只能搭配select类型语句使用，如果想查看更新语句（例如update、delete语句）的索引效果，则保持更新条件不变，把更新语句替换成select即可。 即便在条件中使用了索引关键字，MySQL最终是根据执行计划决定是否使用索引。 间隙锁与死锁场景描述5：MySQL默认的事务隔离级别是repeatable read（稍后介绍），此时如果MySQL客户机A与MySQL客户机B针对“符合查询条件但不存在记录”施加了共享锁或者排他锁（此时的锁实际上是间隙锁），那么MySQL客户机A与MySQL客户机B都会加锁成功。加锁期间，如果MySQL客户机A与MySQL客户机B都试图添加一条“符合查询条件的记录”，此时会进入死锁状态。 步骤1：打开MySQL客户机A，执行下面的SQL语句，首先将account表的存储引擎设置为InnoDB，接着开启事务，查询account表中account_no=20的账户信息，并对该账户信息施加共享锁，执行结果如图17所示。从执行结果可以得知，account表中不存在account_no=20的账户信息。123alter table account engine=InnoDB;start transaction;select * from account where account_no=20 lock in share mode; 图17 对account_no=20的账户施加共享锁（1） 步骤2：打开MySQL客户机B，执行下面的SQL语句，然后开启事务，接着查询account表中account_no=20账户信息，并对该账户信息施加共享锁，执行结果如图18所示。从执行结果可以得知，account表中不存在account_no=20的账户信息。12start transaction;select * from account where account_no=20 lock in share mode; 图18 对account_no=20的账户施加共享锁（2） 步骤3：由于MySQL客户机A已经得知，account表中不存在account_no=20的账户信息，因此MySQL客户机A可以使用下面的insert语句，向account表中添加一条account_no=20的账户信息。此时该insert语句被阻塞，进入锁等待状态。1insert into account values(20,'戊',5000); 步骤4：由于MySQL客户机B已经得知，account表中不存在account_no=20的账户信息，因此，MySQL客户机B可以使用下面的insert语句，向account表中添加一条account_no=20的账户信息。但此时该insert语句导致死锁问题的发生，执行结果如图19所示。1insert into account values(20,'戊',6000); 图19 间隙锁导致死锁问题说明 默认情况下InnoDB存储引擎会自动检测死锁，通过比较参与死锁问题的事务权重，继而选择权重值最小的事务进行回滚，并释放锁，以便其他事务获得锁，继续完成事务。每个事务的权重值存储在information_schema 数据库的INNODB_TRX表的trx_weight字段中。 步骤5：如果MySQL客户机A获得锁，此时MySQL客户机A上的insert语句成功执行，如图20所示（注意观察insert语句的执行时间）。 图20 MySQL客户机A获得锁，继续完成事务 步骤6：在MySQL客户机A上执行commit命令，提交insert语句，并解锁。然后执行select语句查询account表的所有记录，执行结果如图21所示。 图21 查询account表的所有记录 死锁与锁等待给MyISAM表施加表级锁不会导致死锁问题的发生，这是由于MyISAM总是一次性地获得SQL语句的全部锁。给InnoDB表施加行级锁可能导致死锁问题的发生，这是由于执行SQL语句期间，可以继续施加行级锁。因此，这里讨论的死锁问题主要是InnoDB行级锁产生的死锁问题。 上面的死锁问题由间隙锁产生，间隙锁如果使用不当，可能导致死锁问题。不仅仅是间隙锁可以导致死锁问题，错误的加锁时机也会导致死锁问题的发生。 场景描述6：如果account账户表的存储引擎为InnoDB，“甲”在银行柜台前通过MySQL客户机A将“甲”账户（account_no=1）的部分金额（例如1000元）转账给“乙”账户的“同时”，“乙”在银行柜台前通过MySQL客户机B将“乙”账户（account_no=2）的部分金额（例如500元）转账给“甲”账户，通过MySQL客户机A以及MySQL客户机B实现转账业务时都需要调用transfer_proc()存储过程。假设甲的转账存储过程与乙的转账存储过程的执行过程如图22所示，两个transfer_proc()存储过程正在分时、并发、交替运行，请读者注意每条语句执行的先后顺序。 注意：现实生活中，这种假设存在的可能性微乎其微，但即便这样，数据库开发人员也需要应对这种低概率事件的发生。 图22 两个账户并发、互相转账 步骤3后，MySQL客户机A首先获得了“乙”账户的排他锁，如图9-39所示（注意箭头的指向）；步骤4后，MySQL客户机B获得了“甲”账户的排他锁。为了实现转账业务，MySQL客户机A接着申请“甲”账户的排他锁（步骤5），此时需要等待MySQL客户机B释放“甲”账户的排他锁，产生“锁等待”现象（被阻塞），注意：此时并没有产生死锁问题。为了实现转账业务，MySQL客户机B接着申请“乙”账户的排他锁（步骤6），当MySQL客户机B申请“乙”账户的排他锁时，形成一个“环路等待”，此时进入死锁状态。步骤6对应的update语句执行后将产生死锁问题，并抛出如下错误信息：1ERROR 1213 (40001)：Deadlock found when trying to get lock; try restarting transaction 从图23中可以看到，锁等待与死锁是两个不同的概念。锁等待是为了保证事务可以正常地并发运行，锁等待不一定导致死锁问题的发生。而死锁问题的发生一定伴随着锁等待现象。 图23 锁等待与死锁 默认情况下，InnoDB存储引擎会自动检测死锁，通过比较参与死锁问题的事务权重，继而选择权重值最小的事务进行回滚，并释放锁，以便其他事务获得锁，继续完成事务。但即便如此，对于数据库开发人员而言，显式地处理死锁异常是一个好的编程习惯。下面的MySQL代码，首先删除原有的transfer_proc()存储过程，然后重新创建transfer_proc()存储过程，并将代码修改为下面的代码（粗体字部分为代码改动部分，其他代码不变）。粗体字部分的代码主要用于处理死锁异常，发生死锁异常问题后，回滚整个事务。123456789101112131415161718192021drop procedure transfer_proc;delimiter $$create procedure transfer_proc(in from_account int,in to_account int,in money int)modifies sql databegindeclare continue handler for 1690begin rollback;end;declare continue handler for 1213begin rollback;end;start transaction;update account set balance=balance+money where account_no=to_account;update account set balance=balance-money where account_no=from_account;commit;end$$delimiter ; 说明有些时候InnoDB并不能自动检测到死锁，可以通过设置InnoDB锁等待超时参数innodb_lock_wait_timeout的值，设置合适的锁等待超时阈值。当然锁等待超时参数innodb_lock_wait_timeout 并不只用来解决死锁问题，在并发访问比较高的情况下，如果大量事务因无法立即获取所需的锁而被阻塞，会占用大量数据库服务器资源，降低数据库服务器性能，设置合适的锁等待超时阈值也可以解决锁占用时间过长等问题。 默认情况下，InnoDB存储引擎一旦出现锁等待超时异常，InnoDB存储引擎既不会提交事务，也不会回滚事务，而这是十分危险的。一旦发生锁等待超时异常，应用程序应该自定义错误处理程序，由程序开发人员选择是进一步提交事务还是回滚事务。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL事务机制]]></title>
    <url>%2F2018%2F11%2F25%2FMySQL%E4%BA%8B%E5%8A%A1%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 数据库与文件系统的最大区别在于数据库实现了数据的一致性以及并发性。对于数据库管理系统而言事务机制与锁机制是实现数据一致性与并发性的基石。 事务机制事务通常包含一系列更新操作，这些更新操作是一个不可分割的逻辑工作单元。如果事务成功执行，那么该事务中所有的更新操作都会成功执行，并将执行结果提交到数据库文件中，成为数据库永久的组成部分。如果事务中某个更新操作执行失败，那么事务中的所有更新操作均被撤销。简言之：事务中的更新操作要么都执行，要么都不执行，这个特征叫做事务的原子性。 说明更新语句或更新操作主要是update、insert以及delete等语句。 事务机制的必要性对于银行系统而言，转账业务是银行最基本、最常用的业务，有必要将转账业务封装成存储过程，银行系统调用该存储过程后即可实现两个银行账户间的转账业务。 场景描述1：假设某个银行存在两个借记卡账户（account）甲与乙，并且要求这两个借记卡账户不能用于透支，即两个账户的余额（balance）不能小于零。 步骤1：创建account账户表，并将其设置为InnoDB存储引擎。account_no字段是账户表的主键，其值由MySQL自动生成；account_name字段是账户名；balance字段是余额，由于余额不能为负数，将其定义为无符号数。12345create table account( account_no int auto_increment primary key, account_name char(10) not null, balance int unsigned) ENGINE=innodb; 步骤2：添加测试数据。下面的SQL语句向账户account表中插入了“甲”和“乙”两条账户信息，余额都是1000元。123insert into account values(null,'甲',1000);insert into account values(null,'乙',1000); 步骤3：创建存储过程。下面的MySQL代码创建了transfer_proc()存储过程，将from_account账户的money金额转账到to_account账户中，继而实现两个账户之间的转账业务。123456789101112delimiter $$ create procedure transfer_proc(in from_account int,in to_account int,in money int) modifies sql data begin update account set balance=balance+money where account_no=to_account; update account set balance=balance-money where account_no=from_account; end$$delimiter ; 步骤4：测试存储过程。下面的MySQL代码首先调用了transfer_proc()存储过程，将账户“甲”的800元转账到了“乙”账户中。然后查询了账户表中的所有账户信息，执行结果如图9-1所示，此时两个账户的余额之和为2000元。123call transfer_proc(1,2,800);select * from account; 步骤5：再次测试存储过程。再次调用transfer_proc()存储过程，将账户“甲”的800元转账到“乙”账户中。由于账户余额不能为负数，甲的账户余额200元减去800元，产生了错误代码1690对应的错误信息（稍后为该错误代码定义错误处理程序）。1234561690 - BIGINT UNSIGNED value is out of range in &apos;(`test`.`account`.`balance` - money@2``` 然后查询账户表中的所有账户信息：```sqlcall transfer_proc(1,2,800);select * from account; 执行结果如下。account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 2600 结论：甲账户的余额没有丝毫变化，但是乙账户的余额却凭空多出800元。甲、乙账户的余额之和由转账前2000元，变成了转账后的2800元，由此产生了数据不一致问题。 为了避免出现数据不一致问题，需要在存储过程中引入事务的概念，将transfer_proc()存储过程的两条update语句绑定到一起，让它们成为一个“原子性”的操作：两条update语句要么都执行，要么都不执行。 关闭MySQL自动提交默认情况下，MySQL开启了自动提交（auto_increment），这就意味着，之前编写的任意一条更新语句，一旦发送到MySQL服务器，MySQL服务实例会立即解析、执行，并将更新结果提交到数据库文件中，成为数据库永久的组成部分。 以转账存储过程transfer_proc()为例，该存储过程包含两条update语句，第一条update语句执行“加法”运算，第二条update语句执行“减法”运算。由于MySQL默认情况下开启了自动提交，因此第二条update语句无论执行成功还是失败，都不会影响第一条update语句的成功执行。如果第一条update语句成功执行，而第二条update语句执行失败，最终将导致数据不一致问题的发生。可以这样理解：产生上述数据不一致问题的根源在于MySQL开启了自动提交，并且没有引入事务的概念。 因此，对于诸如银行转账的业务逻辑而言，首要步骤是关闭MySQL自动提交，只有当所有的更新语句成功执行后，才提交（commit）所有的更新语句，否则回滚（rollback）所有的更新语句。关闭自动提交的方法有两种：一种是显式的关闭自动提交；另一种是隐式的关闭自动提交。 方法一：显式的关闭自动提交 使用MySQL命令“show variables like ‘autocommit’;”可以查看MySQL是否开启了自动提交。系统变量@@autocommit的值为ON或者1时，表示MySQL开启自动提交，默认情况下，MySQL开启了自动提交。系统变量@@autocommit 的值为OFF或者0时，表示MySQL关闭自动提交。使用MySQL命令“set autocommit=0;”可以显式的关闭MySQL自动提交。 说明 系统变量@@autocommit是会话变量，MySQL客户机A对该系统会话变量的更改，不会影响到MySQL客户机B中该系统会话变量的值。 方法二：隐式的关闭自动提交使用MySQL命令“start transaction;”可以隐式地关闭自动提交。隐式的关闭自动提交不会修改系统会话变量@@autocommit的值。 注意：对MyISAM存储引擎的表进行更新操作时，自动提交无论开启还是关闭，更新操作都将立即解析、执行，并将执行结果提交到数据库文件中，成为数据库永久的组成部分。 回滚关闭MySQL自动提交后，数据库开发人员可以根据需要回滚（也叫撤销）更新操作。 场景描述2：接场景描述1的步骤，当甲、乙账户的余额分别变为200元以及2600元后，打开MySQL客户机A，然后输入下面的MySQL命令。该MySQL命令首先关闭MySQL的自动提交，接着修改乙账户（account_no=2）的余额（加800元），然后查询所有账户的余额。1234set autocommit=0;update account set balance=balance+800 where account_no=2;select * from account; 结果为：account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 3400 从运行结果可以看到，乙账户的余额已经从2600元修改为3400元，事实果真如此？打开另一个MySQL客户机B，选择当前的数据库为choose数据库，使用select语句再次查询所有账户的余额。123use choose;select * from account; 结果为：account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 2600 从MySQL客户机B的执行结果可以看到乙的余额依然是2600元，并没有增加800元。对于这个问题，可以通过下图进行解释。从图中可以得知：MySQL客户机A的update操作影响的仅仅是内存中new记录的值，且该值并没有写入数据库文件；当MySQL客户机A执行select语句时，查询到的3400元实际上是MySQL服务器内存中new记录的字段值；MySQL客户机B执行select语句时，看到的2600元是外存数据2600在服务器内存的一个副本。 乙的最终余额究竟应该是多少元？这要取决于MySQL客户机A接下来的操作（可以分成两种情形：场景描述3与场景描述4）。 场景描述3：接场景描述2的步骤，在MySQL客户机A上执行MySQL命令“rollback;”，接着在MySQL客户机A、MySQL客户机B上执行select语句查询甲、乙账户的余额，两次执行结果相同（乙账户的余额均为2600），结果如下：account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 2600可以这样理解：MySQL客户机A关闭MySQL自动提交后，MySQL客户机A执行的所有更新操作，都会在MySQL服务器内存中产生若干条new记录。如果在MySQL客户机A上执行了rollback命令，MySQL服务器内存中，与MySQL客户机A对应的new记录将被丢弃，回滚了（也叫撤销了）MySQL客户机A执行的更新操作。 说明 insert语句产生new记录，delete语句产生old记录，update语句产生new记录以及old记录，关于这方面的知识请参看视图与触发器章节的内容。 提交MySQL自动提交一旦关闭，数据库开发人员需要“提交”更新语句，才能将更新结果提交到数据库文件中，成为数据库永久的组成部分。自动提交关闭后，MySQL的提交方式分为显式的提交与隐式的提交。显式的提交：MySQL自动提交关闭后，使用MySQL命令“commit;”可以显式的提交更新语句。 隐式的提交：MySQL自动提交关闭后，使用下面的MySQL语句，可以隐式的提交更新语句。begin、set autocommit=1、start transaction、rename table、truncate table等语句；数据定义（create、alter、drop）语句，例如create database、create table、create index、create function、create procedure、alter table、alter function、alter procedure、drop database、drop table、drop function、drop index、drop procedure等语句；权限管理和账户管理语句（例如grant、revoke、set password、create user、drop user、rename user等语句）；锁语句（lock tables、unlock tables）。举例来说，MySQL客户机A关闭MySQL自动提交后，执行了若干条更新语句。此时如果MySQL客户机A执行了“create table test_commit(a int primary key);”语句，该语句成功创建test_commit表后，还会提交之前的所有更新语句。 为了有效地提交事务，推荐数据库开发人员尽可能地使用显式的提交方式，尽量不要使用（或者避免使用）隐式的提交方式。 场景描述4：重做场景描述2中的所有操作，在MySQL客户机A上执行MySQL命令“commit;”，接着在MySQL客户机A、MySQL客户机B上执行select语句查询甲、乙账户的余额，两次执行结果相同（乙账户的余额增加了800元，变为3400）。从执行结果可以看出,MySQL客户机A执行commit命令后, MySQL服务器内存中的new记录被更新到数据库文件中,成为数据库永久的组成部分。 说明关闭MySQL的自动提交后,需要显式提交（或者隐式提交）更新语句,否则所有的更新语句影响的仅仅是MySQL服务器内存中的new记录,更新语句提交后,才会将new记录的值写入数据库文件。 无论开启自动提交,还是关闭自动提交,使用触发器时,InnoDB存储引擎都会保证触发事件与触发程序的原子性操作。 事务使用MySQL命令”start transaction;”可以开启一个事务,该命令开启事务的同时,会隐式的关闭MySQL自动提交。使用commit命令可以提交事务中的更新语句;使用rollback命令可以回滚事务中的更新语句。典型的事务处理使用方法如下图所示。 场景描述5:银行转账业务的两条update语句是一个整体,如果其中任意一条update语句执行失败,则所有的update语句应该撤销,从而确保转账前后的总额不变。使用事务机制、错误处理机制可以避免银行转账时数据不一致问题的发生 下面的MySQL代码,首先删除原有的transfer_proc()存储过程,然后重建ransfer_proc()存储过程,并将代码修改为下面的代码。其中, “declare continue handler for 1690”负责处理MysQL错误代码1690,当发生该错误时,执行回滚操作; “start transaction”负责开启事务,并隐式地关闭自动提交;”commit”负责提交事务。12345678910111213141516drop procedure transfer_proc;delimiter $$create procedure transfer_proc (in from_account int,in to_account int,in money int) modifies sql data begin declare continue handler for 1690 begin rollback; end; start transaction; update account set balance=balance+money where account_no=to_account; update account set balance=balance-money where account_no=from_account; commit;end$$delimiter ; 说明如果账户余额balance字段定义为整数(不是无符号整数) ,那存储过程transfer_proc()也可以通过判断账户余额是否小于零,继而决定是否回滚(rollback)转账业务 默认情况下, InnoDB存储引擎既不会对异常进行回滚,也不会对异常进行提交,而这是十分危险的。异常发生后,数据库开发人员需要借助错误处理程序,显式地提交事务或者显式地回滚事务。可以这样理解:事务的提交与回滚,好比if-else语句中的then子句与else子句,两者只能选其一。 在实际的数据库开发过程中,不建议使用MySQL命令”set autocommit=0;”显式地关闭MySQL自动提交,建议选用”start transaction;”命令,该命令不仅可以开启新的事务,还可以隐式地关闭MySQL自动提交,而且”start transaction;”命令不会影响@@autocommit系统会话变量的值。 保存点默认情况下,事务一旦回滚,事务内的所有更新操作都将撤销。有些时候,仅仅希望撤销事务内的一部分更新操作,保存点(也称为检查点)可以实现事务的”部分”提交或者“部分”撤销。使用MySQL命令”savepoint 保存点名;”可以在事务中设置一个保存点,使用MySQL命令”rollback to savepoint 保存点名;”可以将事务回滚到保存点状态,如下图所示。当事务回滚到保存点后,那么数据库将进入到一致性状态B。 场景描述6:为了演示保存点的使用,下面两个存储过程save_point1_proc()与save_point2_proc()都试图在同一条事务中创建两个账号相同的银行账户。由于银行账号account_no是主键,两个银行账号不能相同,因此第二条insert语句会产生MySQL错误代码1062,两个存储过程处理MySQL错误代码1062的方法截然不同。 方法一:下面的MySQL代码创建了save_point1_proc()存储过程,该存储过程撤销了所有的insert语句。12345678910111213141516delimiter $$ create procedure save_point1_proc()modifies sql data begin declare continue handler for 1062 begin rollback to B; rollback; end; start transaction; insert into account values(null,'丙', 1000); savepoint B; insert into account values(last_insert_id(),'丁', 1000); commit; end$$delimiter ; 说明 存储过程save_point1_proc()中,为了保证”丙”与”丁”两个账户的账号相同,创建”丁”账户的insert语句使用last_insert_id()函数获取了”丙”账户的账号。第二条insert语句将抛出错误信息(ERROR 1062:主键不能相同) ,第二条insert语句出错后,错误处理程序将事务回滚到B保存点(rollback to B) ,然后回滚整个事务(rollback)如上图所示。调用存储过程save_point1_proc(),然后查询账户account表的所有记录。从查询结果可以看出,两条insert语句都被撤销。12call save_point1_proc();select * from account; mysql&gt; call save_point1_proc();Query OK, 0 rows affected (0.03 sec) mysql&gt; select * from account;account_no | account_name | balance | :-: | -:1 | 甲 | 2002 | 乙 | 34002 rows in set (0.08 sec) 方法二:下面的MySQL代码创建了save_point2_proc()存储过程,该存储过程仅仅撤销第二条insert语句,但提交了第一条insert语句。12345678910111213141516delimiter $$create procedure save_point2_proc()modifies sql data begin declare continue handler for 1062 begin rollback to B; commit; end; start transaction; insert into account values(null,'丙', 1000); savepoint B; insert into account values(last_insert_id(),'丁', 1000); commit; end$$delimiter ; 存储过程save_point2_proc()中,第二条insert语句出错后,错误处理程序将事务回滚到B保存点(rollback to B),并提交事务(commit),导致第一条insert语句成功提交到数据库中,。 调用存储过程save_point2_proc(),然后查询账户account表的所有记录。从查询结果可以看出,第一条insert语句成功执行,第二条insert语句被撤销。12call save_point2_proc();select * from account; mysql&gt; call save_point2_proc();Query OK, 0 rows affected (0.02 sec) mysql&gt; select * from account;+——————+———————+————-+| account_no | account_name | balance |+——————+———————+————-+| 1 | 甲 | 200 || 2 | 乙 | 3400 || 4 | 丙 | 1000 |+——————+———————+————-+3 rows in set (0.06 sec)说明“rollback to savepoint B”仅仅是让数据库回到事务中的某个”一致性状态B” ,而”一致性状态B”仅仅是一个“临时状态”,该“临时状态”并没有将更新回滚,也没有将更新提交。事务回滚必须借助于rollback(而不是”rollback to savepoint B”) ,而事务的提交需借助于commit 使用MySQL命令”release savepoint 保存点名;”可以删除一个事务的保存点。如果该保存点不存在,则该命令将出现错误信息: ERROR 1305 (42000): SAVEPOINT does not exist。如果当前的事务中存在两个相同名字的保存点,则旧保存点将被自动丢弃。 “选课系统”中的事务“选课系统”中,最为复杂的业务逻辑莫过于”学生选课”以及“学生调课”功能的实现,之前的章节已经编写了choose proc)存储过程,实现了学生的选课功能。本章将借用事务的概念编写调课存储过程replace course-proco,实现”选课系统”的调课功能。 场景描述7:使用存储过程实现“选课系统”的调课功能,图9-13所示的程序流程图阐述了某个学生的调课流程(其中, c before表示调课前的课程, c after表示目标课程或者调课后的课程)。从程序流程图中可以看到,调课时,首先要判断调课前的课程与目标课程是否相同,如果相同,则将调课的状态值state设置为-1;接着判断目标课程是否已经审1核,是否已经报满,如果课程未审核或者课程available字段值为0 (课程报满) ,则将状态值state设置为-2;如果调课成功,则将状态值state设置为调课成功后的课程course no。由于调课涉及3条update语句,为了保证它们的原子性,必须将它们封装到事务中。 下面的SQL语句创建了名字为replace course proc)的存储过程,该存储过程接收学生学号(s no)、课程号(c before)以及课程号(c after)为输入参数,经过存储过程一系列处理,返回调课state状态值。如果输出参数state的值大于0,则说明学生调课成功;如果输出参数state的值等于-1,则意味着该生调课前后选择的课程相同;如果输出参数state的值等于-2,则意味着目标课程未审核或者已经报满。请读者注意粗体字代码。1234567delimiter $$create procedure replace course proc(in s no char(11),in c before int,in c after int,out state int)modifies sql databegindeclare s int;declare status char(8);set state =0;set status="未审核";if(c before=c after) thenset state =-1;elsestart transactionselect state into status from course where course no=c after;select available into s from course where course no-c after;if(s=0 1l status=未审核) therset state =-2:elseif(state=0) therupdate choose set course no-c after,choose time-now0) where student no=s no andcourse no=c before;update course set available-available+1 where course no-c beforeupdate course set available=available-1 where course no=c after;set state =c after;end if;commit;end if;end$:delimiter; 下面的MySQL语句负责调用replace-course-proc)存储过程,对该存储过程进行简单的测试。首先使用下面的select语句查看学号2012002的选课信息,执行结果如图9-14所示。select * from choose where student no=2012002; 接着将该生选修的课程号3,调换为课程号1,执行下面的MySQL命令,执行结果如图9-15所示。set @s no =’2012002;set @c before =3;set @c after =1;set @state =0;call replace course proc(@s no,@c before,@c after,@state);select @state最后使用下面的select语句查看学号2012002最终的选课信息,验证调课是否成功,执行结果如图9-16所示。select * from choose where student no=2012002; 说明学生选课以及学生调课是”选课系统”的核心功能。存储过程与游标章节编写的”选课存储过程” chooseproco使用了触发器维护course表的available字段值。由于InnoDB存储引擎中,触发器已经保证了触发事件与触发程序的原子性,因此choose proc)存储过程可以保证insert语句与insert触发程序的原子性。而本章编写的”调课存储过程” replace course proc)使用事务的概念,将3条update语句封装到一个事务中,同样也可以保证3条update语句的原子性操作。在真正的项目案例中,推荐使用事务实现更新语句的原子性操作,不建议使用触发器。 一般情况下,一系列关系紧密的更新语句(例如insert, delete或者update语句)都需要封装到一个事务中。由于查询语句不会导致数据发生变化,因此一般不需要封装到事务中。细心的读者会发现,在replace course proc)存储过程中,粗体字的select语句负责”查询目标课程的available字段值” ,该select语句也封装到了事务中,具体原因在”锁机制”章节中进行讲解]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL的索引]]></title>
    <url>%2F2018%2F11%2F24%2FMySQL%E7%9A%84%E7%B4%A2%E5%BC%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： MySQL数据库中，数据是如何检索的？ 什么是前缀索引？什么是复合索引？ 什么是主索引和聚簇索引？ 索引越多越好吗？ 索引与约束有什么关系？ 最左前缀原则是什么意思？ 理解索引（1）索引的本质是什么？ 本质上，索引其实是数据表中字段值的复制，该字段称为索引的关键字。 （2）MySQL数据库中，数据是如何检索的？ 简言之，MySQL在检索表中的数据时，先按照索引“关键字”的值在索引中进行查找，如果能够查到，则可以直接定位到数据所在的起始页；如果没有查到，只能全表扫描查找数据了。 （3）一个数据库表只能创建一个索引吗？ 当然不是。想象一下《现代汉语词典》，除了将汉语拼音编入“音节表”实现汉字的检索功能外，还将所有汉字的部首编入“部首检字表”实现汉字的检索功能，“部首检字表”是《现代汉语词典）的另一个“索引”。同样对于数据库表而言，一个数据库表可以创建多个索引。 （4）什么是前缀索引？ “部首检字表”的使用方法是：首先确定一个字的部首，结合笔画可以查找到该字所在的起始页。例如部首“礻”，结合“羊”的笔画是6，可以快速地在“部首检字表”中查到“祥-&gt;1488”。 “部首检字表”中的部首“礻”仅仅是汉字的一个部分（part），不是整个汉字的拷贝。同样对于数据库表而言，索引中关键字的值可以是索引“关键字”字段值的一个部分，这种索引称为“前缀索引”。例如，可以仅仅对教师姓名（例如“张老师”）中的“姓”（“张”）建立前缀索引。 （5）索引可以是字段的组合吗？ 当然可以。《现代汉语词典》中的“部首检字表”中，部首是“索引”的第一关键字（也叫主关键字），部首相同时，“笔画”未必相同，笔画是“索引”的第二关键字（也叫次关键字），同样对于数据库而言，索引可以是字段的组合。数据库表的某个索引如果由多个关键字构成，此时该索引称为“复合索引”。无论索引的关键字是一个字段，还是一个字段的组合，需要注意的是，这些字段必须来自于同一张表，并且关键字的值必须是表中相应字段值的拷贝。另外，数据库为了提高查询“索引”的效率，需要对索引的关键字进行排序。 （6）能跨表创建索引吗？ 当然不能。这个问题如同在问：是否可以在《牛津高阶英汉双解词典》创建一个“偏旁部首”索引？数据库中同一个索引允许有多个关键字，但每个关键字必须来自同一张表。 （7）索引数据需要额外的存储空间吗？ 当然需要。翻开词典后，几十页甚至上百页的内容存放的是“索引”数据（音节表、部首检字表）。对于数据库表的索引而言，索引关键字经排序后存放在外存中。对于MyISAM表而言，索引数据存放在外存MYI索引文件中。对于InnoDB数据库表而言，索引存在InnoDB表空间文件中（可能是共享表空间文件，也可能是独享表空间文件）。就像“音节表”是按照“从a到z”的升序顺序排放，部首检字表是按照笔画的升序顺序排放一样。为了提升数据的检索效率，无论MyISAM表的索引，还是InnoDB表的索引，索引关键字经排序（默认为升序排序）后存放在外存文件中。 （8）表中的哪些字段适合选作表的索引？什么是主索引？什么是聚簇索引？ 想象一下，单独的笔画能作为《现代汉语词典》的索引吗？显然不能，原因在于同一个笔画的汉字太多。反过来说，由于表的主键值不可能重复，表的主键当作索引最合适不过了。 对于MyISAM表而言，MySQL会自动地将表中所有记录主键值的“备份”及每条记录所在的起始页编入索引中，像“部首检字表”一样形成一张“索引表”，存放在外存，这种索引称为“主索引” （primary index）， MyISAM表的MYI索引文件与MYD数据文件位于两个文件，通过MYI索引文件中的“表记录指针”可以找到MYD数据文件中表记录所在的物理地址。如果teacher表是MyISAM存储引擎，teacher表的主索引如图1所示。 图1 MyISAM存储引擎teacher表的主索引以及普通索引 说明图中teacher表的记录，并没有按照教师的工号teacher_no字段进行排序，即主索引关键字的顺序与表记录主键值的顺序无需一致。 InnoDB表的“主索引”与MyISAM表的主索引不同。InnoDB表的“主索引”关键字的顺序必须与InnoDB表记录主键值的顺序一致，严格地说，这种“主索引”称为“聚簇索引”，并且每一张表只能拥有一个聚簇索引，如图2所示。假设一个汉语拼音只对应一个汉字，《现代汉语词典》中的“音节表”就变成了汉语词典的聚簇索引。 图2 InnoDB存储引擎teacher表的聚簇索引 MySQL的聚簇索引与其他数据库管理系统不同之处在于，即便是一个没有主键的MySQL表， MySQL也会为该表自动创建一个“隐式”的主键。对于InnoDB表而言，必须有聚簇索引（有且仅有一个聚簇索引） 。 前面曾经提到，由于InnoDB表记录与索引位于同一个表空间文件中，因此InnoDB表就是聚簇索引，聚簇索引就是InnoDB表。就像一本撕掉音节表、部首检字表的汉语词典一样，读者同样可以通过拼音直接在汉语词典中查找汉字，原因在于，撕掉音节表、部首检字表后的汉语词典本身就是聚簇索引。 对于InnoDB表而言，MySQL的非聚簇索引统称为“辅助索引”（secondary index），辅助索引的“表记录指针”称为“书签”（bookmark），实际上是主键值，如图3所示，可以看到，所有的辅助索引都包含主键列，所有的InnoDB表都是通过主键来聚簇的。 图3 InnoDB存储引擎teacher表的聚簇索引与辅助索引 说明 这里为了更直观地描述索引，图中将表的索引制作成了一个表格。事实上，表的索引往往通过更为复杂的数据结构（例如双向链表、B+树btree、hash等数据结构）实现，从而可以大幅提升数据的检索效率。 MyISAM存储引擎的表支持主索引，并且还可以采用压缩机制（Packed：Packed的说明如下表所示）存储索引的关键字，比如第一个关键字的值为“her”，第二关键字的值为“here”，那么第二关键字会被存储为“3, e”。 InnoDB存储引擎的表支持聚簇索引。由于创建聚簇索引时需要对“索引”中的数据以及表中的数据进行排序，为了避免更新数据（例如插入数据）耗费过多的时间，建议将InnoDB表的主键设置为自增型字段。 （9）索引与数据结构是什么关系？ 数据库中的索引关键字在索引文件中的存储规则远比词典中的“音节表”复杂得多。为了有效提升数据检索效率，索引通常使用平衡树（btree）或者哈希表等复杂的数据结构进行“编排”。当然在操作数据库的过程中，数据库用户并不会感觉到这些数据结构的存在，原因在于SQL语句（例如select语句等）已经实现了复杂数据结构的“封装”，在执行这些SQL语句时，其底层操作实际上执行的是复杂数据结构的操作。 （10）索引非常重要，同一个表中，表的索引越多越好吗？ 如果没有索引， MySQL必须从第1条记录开始，甚至读完整个表才能找出相关的记录，表越大，花费的时间越多。有了索引，索引就可以帮助数据库用户快速地找出相关的记录，并且索引由MySQL自动维护，但这不意味着表的索引越多越好。 索引确实可以提高检索效率，但要记住，索引是冗余数据，冗余数据不仅需要额外的存储空间，而且还需要额外的维护（虽然不需要人为的维护） 。 如果索引过多，在更新数据（添加、修改或者删除）时，除了需要修改表中的数据外，还需要对该表的所有索引进行维护，以维持表字段值和索引关键字值之间的一致性，反而降低了数据的更新速度。实践表明，当修改表记录的操作特别频繁时，过多的索引会导致硬盘I/O次数明显增加，反而会显著地降低服务器性能，甚至可能会导致服务器宕机。不恰当的索引不但于事无补，反而会降低系统性能。因此，索引是把双刃剑，并不是越多越好，哪些字段（或字段组合）更适合选作索引的关键字？ 索引关键字的选取原则索引的设计往往需要一定的技巧，掌握了这些技巧，可以确保索引能够大幅地提升数据的检索效率，弥补索引在数据更新方面带来的缺陷。 原则1：表的某个字段值的离散度越高，该字段越适合选作索引的关键字。 考虑现实生活中的场景：学生甲到别的学校找学生乙，但甲只知道乙的性别，那么学生甲要想找到乙，无异于“大海捞针”。原因很简单，性别字段的值要么是男，要么是女，取值离散度较低（Cardinality的值最多为2），因此，性别字段就没有必要选作索引的关键字了。 如果甲知道的是乙的学号，情况就比较乐观了，因为对于一个学校而言，有多少名学生，就会有多少个学号与之相对应。学号的取值特别离散，因此，比较适合选作学生表索引的关键字。 主键字段以及唯一性约束字段适合选作索引的关键字，原因就是这些字段的值非常离散。尤其是在主键字段创建索引时， Cardinality的值就等于该表的行数。MySQL在处理主键约束以及唯一性约束时，考虑得比较周全。数据库用户创建主键约束的同时，MySQL会自动创建主索引（primary index），且索引名称为PRIMARY；数据库用户创建唯一性约束的同时，MySQL会自动地创建唯一性索引（unique index），默认情况下，索引名为唯一性约束的字段名。 原则2：占用储存空间少的字段更适合选作索引的关键字。 如果索引中关键字的值占用的存储空间较多，那么检索效率势必会造成影响。例如，与字符串字段相比，整数字段占用的存储空间较少，因此，较为适合选作索引的关键字。 原则3：储存空间固定的字段更适合选作索引的关键字。 与text类型的字段相比，char类型的字段较为适合选作索引的关键字。 原则4：where子句中经常使用的字段应该创建索引，分组字段或者排序字段应该创建索引，两个表的连接字段应该创建索引。 引入索引的目的是提高数据的检索效率，因此索引关键字的选择与select语句息息相关。这句话有两个方面的含义：select语句的设计可以决定索引的设计；索引的设计也同样影响着select语句的设计。例如原则1与原则2，可以影响select语句的设计；而select语句中的where子句、group by子句以及order by子句，又可以影响索引的设计。两个表的连接字段应该创建索引，外键约束一经创建，MySQL会自动地创建与外键相对应的索引，这是由于外键字段通常是两个表的连接字段。 原则5：更新频繁的字段不适合创建索引，不会出现在where子句中的字段不应该创建索引。 原则6：最左前缀原则。 复合索引还有另外一个优点，它通过被称为“最左前缀”（leftmost prefixing）的概念体现出来。假设向一个表的多个字段（例如firstname、lastname、address）创建复合索引（索引名为fname_lname_address）。当where查询条件是以下各种字段的组合时，MySQL将使用fname_lname_address索引。其他情况将无法使用fname_lname_address索引。 firstname， lastname， addressfirstname， lastnamefirstname 可以这样理解：一个复合索引（firstname、lastname、address）等效于（firstname、lastname、age）、（firstname、lastname）以及（firstname）三个索引。 基于最左前缀原则，应该尽量避免创建重复的索引，例如创建了fname_lname_address索引后，就无需在first_name字段上单独创建一个索引。 原则7：尽量使用前缀索引。 例如，仅仅在姓名（例如“张三”）中的姓氏部分（“张”）创建索引，从而可以节省索引的存储空间，提高检索效率。 当然，索引的设计技巧还有很多，而且不是千篇一律的，更不是照本宣料的，没有索引的表同样可以完成数据检索任务。索引的设计没有对错之分，只有合适与不合适之分。与数据库的设计一样，索引的设计同样需要数据库开发人员经验的积累以及智慧的沉淀，同时需要依据系统各自的特点设计出更好的索引，在“加快检索效率”与“降低更新速度”之间做好平衡，从而大幅提升数据库的整体性能。 索引与约束MySQL中表的索引与约束之间存在怎样的关系？约束分为主键约束、唯一性约束、默认值约束、检查约束、非空约束以及外键约束。其中，主键约束、唯一性约束以及外键约束与索引的联系较为紧密。 约束主要用于保证业务逻辑操作数据库时数据的完整性；而索引则是将关键字数据以某种数据结构的方式存储到外存，用于提升数据的检索性能。约束是逻辑层面的概念；而索引既有逻辑上的概念，更是一种物理存储方式，且事实存在，需要耗费一定的存储空间。 对于一个MySQL数据库表而言，主键约束、唯一性约束以及外键约束是基于索引实现的。因此，创建主键约束的同时，会自动创建一个主索引，且主索引名与主键约束名相同（PRIMARY）；创建唯一性约束的同时，会自动创建一个唯一性索引，且唯一性索引名与唯一性约束名相同；创建外键约束的同时，会自动创建一个普通索引，且索引名与外键约束名相同。 在MySQL数据库中，删除了唯一性索引，对应的唯一性约束也将自动删除。若不考虑存储空间方面的因素，唯一性索引就是唯一性约束。]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL核心技术与最佳实践</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP的依赖注入(DI)和控制反转(IoC)]]></title>
    <url>%2F2018%2F07%2F17%2FPHP%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5-DI-%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC-IoC%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 这两种模式的目的是什么？ 整个过程中参与者都有谁？ 依赖：谁依赖于谁？为什么会产生依赖？ 注入：谁注入于谁？到底注入了什么？ 控制反转：谁控制谁？控制什么？为何叫反转（有反转就应该有正转了，正转是什么呢？） 依赖注入和控制反转是同一概念吗？ A类不再主动去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中。怎么理解？ 应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC/DI容器来创建并注入它所需要的资源了。怎么理解？ 简介 IoC - Inversion of Control 控制反转 DI - Dependency Injection 依赖注入 依赖注入和控制反转说的实际上是同一个东西，它们是一种设计模式，这种设计模式用来减少程序间的耦合。 **优势（为什么使用）** 使用依赖注入，最重要的一点好处就是有效的分离了对象和它所需要的外部资源，使得它们松散耦合，有利于功能复用，更重要的是使得程序的整个体系结构变得非常灵活。 **概念** 依赖注入和控制反转是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。 依赖注入是从应用程序的角度在描述，可以把依赖注入，即：应用程序依赖容器创建并注入它所需要的外部资源； 而控制反转是从容器的角度在描述，即：容器控制应用程序，由容器反向的向应用程序注入应用程序所需要的外部资源。 问答对于一个菜鸟，如果你看了上面的概念还是一头雾水的话，那么恭喜你，你和我一样不是天才，那么下面就让我们借助于几个问答来搞清楚这个概念的意思吧。 整个过程中参与者都有谁？ 一般有三方参与者，一个是某个对象；一个是IoC/DI的容器；另一个是某个对象的外部资源。 某个对象指的就是任意的、普通的PHP对象。 IoC/DI的容器简单点说就是指用来实现IoC/DI功能的一个框架程序。 对象的外部资源指的就是对象需要的，但是是从对象外部获取的，都统称资源，比如：对象需要的其它对象、或者是对象需要的文件资源等等。 谁依赖于谁： 当然是某个对象依赖于IoC/DI的容器。 为什么需要依赖： 对象需要IoC/DI的容器来提供对象需要的外部资源。 谁注入于谁： 是IoC/DI的容器注入某个对象。 到底注入什么： 就是注入某个对象所需要的外部资源。 谁控制谁： 当然是IoC/DI的容器来控制对象了。 控制什么： 主要是控制对象实例的创建。 为何叫反转： 反转是相对于正向而言的，那么什么算是正向的呢？ 考虑一下常规情况下的应用程序，如果要在A里面使用C，你会怎么做呢？当然是直接去创建C的对象，也就是说，是在A类中主动去获取所需要的外部资源C（$c = new C();），这种情况被称为正向的。那么什么是反向呢？就是A类不再主动去获取C，而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中。 用图例来说明一下，先看没有IoC/DI的时候，常规的A类使用C类的示意图，如下图所示： 代码示意：1234567891011121314151617181920212223242526272829303132333435&lt;?php/** * 没有IoC/DI的时候，常规的A类使用C类的示例 *//** * Class c */class C&#123; public function say() &#123; echo 'hello'; &#125;&#125;/** * Class A */class A&#123; private $c; public function __construct() &#123; $this-&gt;c = new C(); // 实例化创建C类 &#125; public function sayC() &#123; echo $this-&gt;c-&gt;say(); // 调用C类中的方法 &#125;&#125;$a = new A();$a-&gt;sayC(); 当有了IoC/DI的容器后，A类不再主动去创建C了，如下图所示： 而是被动等待，等待IoC/DI的容器获取一个C的实例，然后反向的注入到A类中，如下图所示： 代码示意：1234567891011121314151617181920212223242526272829303132333435363738&lt;?php/** * 当有了IoC/DI的容器后，A类依赖C类实例注入的示例 *//** * Class C */class C&#123; public function say() &#123; echo 'hello'; &#125;&#125;/** * Class A */class A&#123; private $c; public function setC(C $c) &#123; $this-&gt;c = $c; // 实例化创建C类 &#125; public function sayC() &#123; echo $this-&gt;c-&gt;say(); // 调用C类中的方法 &#125;&#125;$c = new C();$a = new A();$a-&gt;setC($c); // 先set，$c作为C类的实例不是在A类里创建的。$a-&gt;sayC(); 什么是正转？ 正转就是按照普通的，在类中直接创建对象实例，如$c = new C(); 依赖注入和控制反转是同一概念吗？ 根据上面的讲述，我们不难出来，“依赖注入”和“控制反转”确实是对同一件事情的不同描述，从某个方面讲，就是它们描述的角度不同。 总结其实IoC/DI对编程带来的最大改变不是从代码上，而是从思想上，发生了“主从换位”的变化。应用程序原本是老大，要获取什么资源都是主动出击，但是在IoC/DI思想中，应用程序就变成被动的了，被动的等待IoC/DI容器来创建并注入它所需要的资源了。 注意我们上面说了，这是一种“设计模式”，就像“工厂模式”和“单例模式”等是一样的，它是一种面向对象中的编程“思想”，自然它也不仅限于PHP，而是所有面向对象的语言基本都是可以适用的。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>依赖注入</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第14章-对付空间限制]]></title>
    <url>%2F2018%2F07%2F15%2F%E7%AC%AC14%E7%AB%A0-%E5%AF%B9%E4%BB%98%E7%A9%BA%E9%97%B4%E9%99%90%E5%88%B6%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是空间复杂度？ 本章涵盖： 描述空间复杂度的大O记法 时间和空间之间的权衡 本书至此，在分析各种算法的效率时，我们只关注了它们的时间复杂度。换句话说，就是它们运行得有多快。但有些时候，我们还得以另一种名为空间复杂度的度量方式，去估计它们会消耗多少内存。 当内存有限时，空间复杂度便会成为选择算法的一个重要的参考因素。比如说，在给小内存的小型设备写程序时，或是处理一些会迅速占满大内存的大数据时都会考虑空间复杂度。 既省时又省内存的算法当然是最理想的。但有些情况下我们却只能二者选其一，这时要想做出正确选择，就得仔细分析了。 描述空间复杂度的大O记法有趣的是，计算机科学家还是用描述时间复杂度的大O记法来描述空间复杂度。 至今我们一直这样用大O记法来描述一个算法的速度：当所处理的数据有N个元素时，该算法所需的步数相对于元素数量是多少。例如，O(N)算法就是处理N个元素需要N步的算法。O(N2)算法就是处理N个元素需要N2步的算法。 类似地，我们也可以用大O来描述一个算法需要多少空间：当所处理的数据有N个元素时，该算法还需额外消耗多少元素大小的内存空间。让我们看一个简单的例子。 假设要写一个JavaScript函数，它接收一个字符串数组，并返回一个含有那些字符串的大写形式的数组。如果接收的数组是[“amy”, “bob”, “cindy”, “derek”] ，那么返回的就是[“AMY”, “BOB”, “CINDY”, “DEREK”] 。以下是该函数的一种写法。123456789function makeUpperCase(array) &#123; var newArray = []; for(var i = 0; i &lt; array.length; i++) &#123; newArray[i] = array[i].toUpperCase(); &#125; return newArray;&#125; makeUpperCase函数接收一个数组作为参数array。然后它创建了一个全新的数组，名为newArray，并将原数组array里的字符串的大写形式填进去。 等到该函数结束的时候，内存里会存在两个数组，一个是array，它里面是[“amy”, “bob”,”cindy”, “derek”]；另一个是newArray ，它里面是[“AMY”, “BOB”, “CINDY”, “DEREK”] 。 分析该函数的话，你会发现它接收一个N元素的数组，就会产生另一个新的N元素数组。 因此，我们会说这个makeUpperCase函数的空间效率是O(N)。 这种复杂度的图应该很熟悉了。 注意它的画法跟前面章节的O(N)是一样的，只是这次的纵坐标不是代表速度，而是代表内存。 我们再写一个更高效利用内存的makeUpperCase。12345678function makeUpperCase(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; array[i] = array[i].toUpperCase(); &#125; return array;&#125; 在这第二个版本里，我们没有创建任何新的变量或新的数组，也确实没有消耗额外的内存空间。我们只是变动了原array里的每个字符串，将它们逐一换成大写。最后返回这个修改过的array。 因为该函数并不消耗额外的内存空间，所以我们把它的空间复杂度描述为O(1)。记住，时间复杂度的O(1)意味着一个算法无论处理多少数据，其速度恒定。相似地，空间复杂度的O(1)则意味着一个算法无论处理多少数据，其消耗的内存恒定。 刚才的例子中，无论传入的array包含4个元素还是100个元素，该算法所需的额外的空间都一样（为零）。因此，我们认为新版的makeUpperCase的空间效率是O(1)。 值得一再强调的是，空间复杂度是根据额外需要的内存空间（也叫辅助空间）来算的，也就是说原本的数据不纳入计算。尽管在第二个版本里我们有array这一入参，占用了N个元素的空间，但除此之外它并没有消耗额外的内存，所以它是O(1)。 （有些参考书在计算空间复杂度时是连原始输入也一起算的，那没问题。但此处我们不计算它，当你在其他地方看到某一算法的空间复杂度的描述时，最好留意一下它是否计算原始输入。） 我们比较一下makeUpperCase两个版本的时间复杂度和空间复杂度。 版 本 时间复杂度 空间复杂度 1 O(N) O(N) 2 O(N) O(1) 因为N项数据要花N步去处理，所以两个版本的时间复杂度都是O(N)。然而在空间复杂度方面，第二个版本只有O(1)，与第一个版本的O(N)相比，它对内存的使用效率更高。 因此选择第二个版本更为合理。 时间和空间之间权衡第4章我们写了一个用于检查数组是否含有重复值的JavaScript函数。它的第一版是这样的：1234567891011121314function hasDuplicateValue(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; for(var j = 0; j &lt; array.length; j++) &#123; if(i !== j &amp;&amp; array[i] == array[j]) &#123; return true; &#125; &#125; &#125; return false;&#125; 它用了嵌套循环，时间复杂度为O(N2)。 后来我们又写了一版效率更高的，如下所示。1234567891011121314151617function hasDuplicateValue(array) &#123; var existingNumbers = []; for(var i = 0; i &lt; array.length; i++) &#123; if(existingNumbers[array[i]] === undefined) &#123; existingNumbers[array[i]] = 1; &#125; else &#123; return true; &#125; &#125; return false;&#125; 该版本会创建一个名为existingNumbers的数组，然后以array遇到的每个数字为索引，到existingNumbers那里找到相应的格子填个 1。如果相应的格子里已被填了1，则可知该数字已经存在，证明有重复值。 因为与第一版的O(N2)相比，它的时间复杂度只有O(N)，所以我们宣称它胜过第一版。确实，单从时间角度考虑的话，第二版是更快的。 但要是把空间也考虑进去的话，你会发现它与第一版相比有一缺点。第一版除了原数组，并不会消耗额外的内存，因此它的空间复杂度为 O(1)。第二版却要创建一个与原数组大小相等的全新数组，因此它的空间复杂度为O(N)。（一般情况下不太可能大小相等，应该分析两个数组的稀疏程度。） 我们来给两个版本的hasDuplicateValue做个全面的对比。 版 本 时间复杂度 空间复杂度 1 O(N2) O(1) 2 O(N) O(N) 可见第一版所用的内存更少，但跑得更慢，第二版虽跑得快但用的内存更多。那要怎么决定该用哪个呢？ 答案当然是看情况。如果你想要程序跑得超级快，而且你的内存十分充足，那么用第二版会比较好。但如果你不看重速度，而且你的程序是跑在需要谨慎使用内存的嵌入式系统上，那你应该选择第一版。所有技术讨论都是这样的，当需要做出取舍时，你应从全局看待问题。 写在最后的话通过这次学习之旅，你已掌握了很多知识，其中最重要的是，你懂得了数据结构和算法的分析，这对代码的速度、内存占用，甚至其可读性都有着重大影响。 在此书中你收获了一套思路清晰的技术分析框架。你明白了计算包含各种细节，尽管大O之类的理论会建议你哪种做法更好，但若考虑其他因素，你可能会做出不同的选择。机器对内存的管理方式和编程语言的底层实现都会影响程序的性能，甚至有时你以为是最高效的做法也可能会随着外部环境的变化而变得低效。 因此，你最好时刻配备性能测试工具来验证你的调优是否有效。测量代码速度和内存消耗的优秀工具有很多。本书的知识只告诉你调优的方向，而测试工具会负责检验你调优的具体实现是否正确。 很多看似复杂、深奥的事物，其实都是由你所掌握的简单概念构筑而成的。不要因为某些资料没解释到位，就以为它很困难而被吓退，你一定能找到更详尽的解释资料。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第13章-连接万物的图]]></title>
    <url>%2F2018%2F07%2F14%2F%E7%AC%AC13%E7%AB%A0-%E8%BF%9E%E6%8E%A5%E4%B8%87%E7%89%A9%E7%9A%84%E5%9B%BE%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是图？怎么用代码表示图？每个顶点都是一个对象，维护一个列表。怎么理解？ 什么是顶点？什么是边？怎么才叫相邻？ 什么是有向图？什么是无向图？ 什么是二度联系人？ 什么是广度优先搜索？ 什么是加权图？要往图里加上权重，要把表示邻接点的数组换成散列表。怎么换？ 以二维数组来保存朋友关系会在查询a的朋友时有什么问题？ 遍历图还需要一个队列。怎么理解？ Neo4j是什么软件？ 本章涵盖： 图 广度优先搜索 图数据库 加权图 Dijkstra算法 假设我们正在打造一个像Facebook那样的社交网络。在该应用里，大家可以加别人为“朋友”。这种朋友关系是相互的，如果Alice是Bob的朋友，那么Bob也会是Alice的朋友。 这些关系数据要怎么管理才好呢？ 一种简单的方法是，以二维数组来保存每一对关系。123456789relationships = [ ["Alice", "Bob"], ["Bob", "Cynthia"], ["Alice", "Diana"], ["Bob", "Diana"], ["Elise", "Fred"], ["Diana", "Fred"], ["Fred", "Alice"]] 不幸的是，这样无法快速地知道Alice的朋友是哪些人。你只能在数组里按逐对关系检查，看Alice在不在那对关系中。在检查过程中，你还得创建一个列表来暂存查出的朋友（此例中有Bob、Diana和Fred）。 由于数据以这种结构存储，若想查找Alice的朋友就得检查数据库中的所有关系，需要O(N)的时间复杂度。 其实有一种更好的存储方法。使用图这种数据结构的话，我们可以在O(1)时间内找出Alice的所有朋友。 图图是一种善于处理关系型数据的数据结构，使用它可以很轻松地表示数据之间是如何关联的。 下图是我们的Facebook网络。 每个人都是一个结点，人与人之间的朋友关系则以线段表示。按照图的术语来说，每个结点都是一个顶点，每条线段都是一条边。当两个顶点通过一条边联系在一起时，我们会说这两个顶点是相邻的。 图的实现形式有很多，最简单的方法之一就是用散列表。例如，使用Ruby散列表来实现一个极为基础的社交网络。12345678friends = &#123; "Alice" =&gt; ["Bob", "Diana", "Fred"], "Bob" =&gt; ["Alice", "Cynthia", "Diana"], "Cynthia" =&gt; ["Bob"], "Diana" =&gt; ["Alice", "Bob", "Fred"], "Elise" =&gt; ["Fred"], "Fred" =&gt; ["Alice", "Diana", "Elise"]&#125; 因为从散列表里查找一个键所对应的值只需要1步，所以查找Alice的朋友能以O(1)的时间复杂度完成，如下所示。1friends["Alice"] 跟Facebook不同，Twitter里面的关系不是相互的。Alice可以关注Bob，但Bob不一定要关注Alice。让我们构造一个新的图来表示谁关注了谁。 图中箭头表示了关系的方向。Alice关注了Bob和Cynthia，但没有人关注Alice。Bob和Cynthia互相关注。 用散列表来表示的话，就是这样：12345followees = &#123; "Alice" =&gt; ["Bob", "Cynthia"], "Bob" =&gt; ["Cynthia"], "Cynthia" =&gt; ["Bob"]&#125; 虽然Facebook跟Twitter的例子很相似，但它们本质上是不一样的。Twitter中的关系是单向的，我们也在图中用箭头表示了其方向，因此它的图是有向图。Facebook中的关系则是相互的，我们只画成了普通的线段，它的图是无向图。 尽管只用散列表也可以实现一个图，但是以面向对象的方法来写会更加健壮。 以下便是一种更为健壮的实现方式，它采用的语言是Ruby。123456789101112class Person attr_accessor :name, :friends def initialize(name) @name = name @friends = [] end def add_friend(friend) @friends &lt;&lt; friend # 数组添加对象元素 endend 12345678910111213141516class Person &#123; private $name; private $friends; function __construct($name) &#123; $this-&gt;name = $name; $this-&gt;friends = []; &#125; public function add_friend($friend) &#123; $this-&gt;friends[] = $friend; &#125;&#125; 有了这个Ruby类，我们就可以创建人物并且给他们添加朋友了。1234mary = Person.new("Mary")peter = Person.new("Peter")mary.add_friend(peter)peter.add_friend(mary) 12345$mary = new Person('Mary');$peter = new Person('Peter');$mary-&gt;add_friend($peter);$peter-&gt;add_friend($mary); 广度优先搜索LinkedIn也是一个流行的社交网络，其专注于职业社交。LinkedIn的一个有名的功能就是，你除了能够看到自己直接添加的联系人，还可以发掘你的二度、三度联系人。 如图所示，Alice能直接联系到Bob，Bob能直接联系到Cynthia。但Alice无法直接联系到Cynthia。由于她们之间的联系要经过Bob，因此Cynthia是Alice的二度联系人。 如果我们想查看Alice的整个关系网，包括她那些间接的关系，需要怎么做呢？ 图有两种经典的遍历方式：广度优先搜索和深度优先搜索。在此我们会研究广度优先搜索，深度优先搜索你可以自己去学习。两者是相似的，并且在大多数情况下都一样好用。 广度优先搜索算法需要用队列（参见队列）来记录后续要处理哪些顶点。该队列最初只含有起步的顶点（对本例来说，就是Alice）。于是算法一开始，我们的队列如下所示。 [Alice] 然后处理Alice顶点。我们将其移出队列，标为“已访问”，并记为当前顶点。（很快我们就会走一遍整个流程，让你看得更明白一些。） 接着按照以下3步去做。 (1)找出当前顶点的所有邻接点。如果有哪个是没访问过的，就把它标为“已访问”，并且将它入队。（尽管该顶点并未作为“当前顶点”被访问过。） (2) 如果当前顶点没有未访问的邻接点，且队列不为空，那就再从队列中移出一个顶点作为当前顶点。 (3) 如果当前顶点没有未访问的邻接点，且队列里也没有其他顶点，那么算法完成。 下面来实际演示一遍。Alice的LinkedIn关系网如下图所示。 首先，将Alice设为当前顶点。为了在图中表示她是当前顶点，我们用线段将其围绕。为了表示Alice已被访问，我们在她旁边打了个钩。继续该算法，找出一个未访问的邻接点--本例中的Bob，在他名字旁边打个钩，如下图所示。 我们也将Bob入队，使队列变为[Bob]。这意味着Bob未曾作为当前顶点。注意，虽然当前顶点是Alice，但我们也能访问Bob。 接着，检查当前顶点Alice是否还有未访问的邻接点。发现有Candy，于是将其标为已访问。 现在队列为[Bob, Candy] 。 Alice还有邻接点Derek没访问过，于是访问他。 现在队列为[Bob, Candy, Derek] 。 Alice还有一个未访问的关系Elaine，于是我们也要访问她。 现在队列为[Bob, Candy, Derek, Elaine] 。 因为Alice已经没有未访问的邻接点了，所以执行本算法的第2条规则，从队列里移出一个顶点，把它设为当前顶点。回想第8章提到的，队列只能在队头移除数据，于是现在要移出的就是Bob。 现在队列变为[Candy, Derek, Elaine]，Bob成为了当前顶点。 然后回到第1条规则，找出当前顶点的所有未访问的邻接点。Bob有一个邻接点Fred，于是将他标记为已访问，并把他加入队列。 现在队列为[Candy, Derek, Elaine, Fred]。 因为Bob没有其他未访问的邻接点了，所以出队一个顶点--Candy--作为当前顶点。 然而Candy没有未访问的邻接点。于是再从队列中拿出一个顶点--Derek--使得队列变成[Elaine, Fred]。 Derek有一个未访问的邻接点Gina，我们将其标记为已访问。 现在队列为[Elaine, Fred, Gina]。 Derek没有邻接点需要访问了，于是我们从队列里拿出Elaine，将她标记为当前顶点。 Elaine没有未访问的邻接点，于是从队列中拿出Fred。 此时队列变为[Gina]。 Fred有一个联系人要访问--Helen--于是将其标为已访问，并且入队，使队列变成[Gina, Helen]。 Fred已经没有未访问的关系了，所以我们将Gina移出队列，将她设为当前顶点。 现在队列里只剩[Helen]了。 Gina有一个邻接点要访问--Irena。 现在队列为[Helen, Irena]。 Gina没有其他关系需要访问了，所以让Helen出队，将她设为当前顶点，于是队列里剩下的是[Irena]。Helen没有什么人需要访问，于是我们让Irena出队，将她设为当前顶点。因为Irena没有顶点需要访问，而且队列空了，所以算法结束！ 我们在Person类里加上display_network方法，以广度优先搜索的方式展示一个人的关系网里所有的名字。123456789101112131415161718192021222324252627282930313233343536373839class Person attr_accessor :name, :friends, :visited # visited表示是否标记 def initialize(name) @name = name @friends = [] @visited = false end def add_friend(friend) @friends &lt;&lt; friend end def display_network # 记下每个访问过的人，以便算法完结后能重置他们的 visited 属性为 false to_reset = [self] # 创建一个开始就含有根顶点的队列 queue = [self] self.visited = true while queue.any? # 设出队的顶点为当前顶点 current_vertex = queue.shift puts current_vertex.name # 将当前顶点的所有未访问的邻接点加入队列 current_vertex.friends.each do |friend| if !friend.visited to_reset &lt;&lt; friend queue &lt;&lt; friend friend.visited = true end end end # 算法完结时，将访问过的结点的 visited 属性重置为 false to_reset.each do |node| node.visited = false end endend 12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Person &#123; private $name; private $friends; private $visited ; function __construct($name) &#123; $this-&gt;name = $name; $this-&gt;friends = []; $this-&gt;visited = false; &#125; public function add_friend($friend) &#123; $this-&gt;friends[] = $friend; &#125; public function display_network() &#123; $to_reset = [$this]; $queue = [$this]; $this-&gt;visited = true; while (!empty($queue)) &#123; $current_vertex = array_shift($queue); echo $current_vertex-&gt;name; foreach ($current_vertex-&gt;friends as $friend) &#123; if ($friend-&gt;visited == false) &#123; $to_reset[] = $friend; $queue[] = $friend; $friend-&gt;visited = true; &#125; &#125; &#125; foreach ($to_reset as $node) &#123; $node-&gt;visited = false; &#125; &#125;&#125; 为了使它运作起来，我们还给Person类增加了visited属性，来记录一个人在本次搜索中是否已被访问。 将算法的步骤分为两类之后，我们可以看出图的广度优先搜索的效率。 让顶点出队，将其设为当前顶点。 访问每个顶点的邻接点。 这样看来，每个顶点都会有一次出队的经历。以大O记法表示，就是O(V)，意思是有V个顶点，就有V次出队。 既然要处理N个顶点，不应该表示为O(N)吗？不是的，因为在此算法（以及很多其他图的算法）中，除了处理顶点本身，还得处理边，下面就来解释。 我们观察一下访问邻接点需要多少步。 以当前顶点为Bob的时候为例。 此时我们会运行如下代码。123456current_vertex.friends.each do |friend| if !friend.visited queue &lt;&lt; friend friend.visited = true endend 12345678foreach ($current_vertex-&gt;friends as $friend) &#123; if ($friend-&gt;visited == false) &#123; $queue[] = $friend; $friend-&gt;visited = true; &#125;&#125; 就是说，我们会访问Bob所有的邻接点，其中不但有Fred，还有Alice！尽管她曾被访问过，不用再入队，但访问她还是增加了一次each循环。 要是你再认真地运行一遍整个广度优先搜索的流程，你会发现访问邻接点所用的步数，是图中边数的两倍。因为一条边连接着两个顶点，对于每个顶点，我们都要访问其所有邻接点。所以每条边都会被使用两次。 因此，有E条边，就会有2E步来访问邻接点，即每对邻接点都会被访问两次。不过由于大O忽略常数，所以只写作O(E)。 因为广度优先搜索有O(V)次出队，还有O(E)次访问，所以我们说它的效率为O(V + E)。 图数据库因为图擅长处理关系信息，所以有些数据库就以图的形式来存储数据。传统的关系型数据库（以行和列的形式保存数据的数据库）也能存储这类信息，我们不妨比较一下它们处理社交网络之类的数据时的表现。 假设有一个5人的社交网络，分别是Alice、Bob、Cindy、Dennis和Ethel，他们互相都有联系。保存他们个人信息的图数据库大概会如下图所示。 这种信息也可以用关系型数据库来存储。那得需要两张表--一张保存个人信息，另一张保存朋友关系。以下是Users表。 另一张Friendships表记录着谁是谁的朋友。 我们不会太过深入地研究数据库理论，但你得知道在Friendships表中只需以用户id来指代用户。 如果这个社交网络允许用户查看其朋友的全部信息，而Cindy也正要这么做，那意味着她想看到一切关于Alice、Bob、Dennis和Ethel的信息，包括他们的邮件地址和电话号码。 那我们就来看看以关系型数据库为后端的应用会怎样执行她的请求。首先，我们得找出User表中Cindy的id。 然后，找出Friendships表中所有user_id为3的行。 我们就得到了Cindy朋友的id列表：[1, 2, 4, 5]。 有了id列表之后，我们还得回Users表找出这些id对应的行。计算机从Users表查找一行的速度大概是O(log N)。因为数据库中的行会按照id的顺序来维护，所以我们可以用二分查找来找出id对应的行。（以上解释只适用于部分关系型数据库，其他关系型数据库可能有不同做法。） Cindy有4个朋友，所以计算机需要做4次O(log N)查询才能提取出她全部朋友的个人信息。推广开来，若有M个朋友，那么提取他们个人信息的效率就为O(M log N)。换句话说，对于每个朋友，都要执行一次步数为log N的搜索。 相比之下，后端为图数据库时，一旦在数据库中定位到Cindy，那么只需一步就能查到她任一朋友的信息。因为数据库中的每个顶点已经包含了该用户的所有信息，所以你只需遍历那些连接Cindy与朋友的边即可。如下图所示，总共也就4步。 用图数据库的话，有N个朋友就需要O(N)步去获取他们的数据。与关系型数据库的O(M log N)相比，确实是极大的效率提升。 Neo4j是开源的图数据库中比较受欢迎的一个。我建议你上它的官网去了解更多关于图数据库的知识。其他开源的图数据库还有ArangoDB和Apache Giraph。 但记住，图数据库也并不总是最好的解决方案。你得谨慎地评估每个应用场景的需求再做选择。 加权图还有一种图叫作加权图。它跟普通的图类似，但边上带有信息。 以下这个包含了美国几个主要城市的简陋地图，就是一个加权图。 此图中，每条边上都有一个数字，它表示那条边所连接的两个城市相距多少英里。例如，Chicago和New York City之间的距离为714英里。 加权图可以是有方向的。以下图为例，尽管从Dallas飞到Toronto只要138美元，但从Toronto飞到Dallas要216美元。 要往图里加上权重，得稍微更改一下我们的Ruby代码。具体来说，我们要把表示邻接点的数组换成散列表。对于上图来说，一个顶点就是一个City类的对象。12345678910111213class City attr_accessor :name, :routes def initialize(name) @name = name # 把表示邻接点的数组换成散列表 @routes = &#123;&#125; end def add_route(city, price) @routes[city] = price endend 这样就可以创建城市和不同价格的航线了。1234dallas = City.new("Dallas")toronto = City.new("Toronto")dallas.add_route(toronto, 138)toronto.add_route(dallas, 216) 我们可以借助加权图来解决最短路径问题。 下图展示了5个城市之间的航线价格。 假设我目前身在Atlanta，想飞去El Paso。不幸的是，现在没有直达航班。然而，我也可以在其他城市转机过去。例如，先从Atlanta到Denver，再从Denver到El Paso。这会花费300美元。但再看仔细一点，你会发现从Atlanta沿Denver、Chicago再到ElPaso会更加便宜。虽然多转一次，但只需花280美元。 这就是一种最短路径问题：如何以最低的价钱从Atlanta飞往El Paso。 Dijkstra算法解决最短路径问题的算法有好几种，其中一种有趣的算法是由Edsger Dijkstra于1959年发现的。该算法也很自然地被称为Dijkstra算法。 Dijkstra算法的规则如下（别担心，之后我们跟着例子运行一遍就会更明白了）。 (1)以起步的顶点为当前顶点。 (2)检查当前顶点的所有邻接点，计算起点到所有已知顶点的权重，并记录下来。 (3)从未访问过（未曾作为当前顶点）的邻接点中，选取一个起点能到达的总权重最小的顶点，作为下一个当前顶点。 (4)重复前3步，直至图中所有顶点都被访问过。 下面来一步步地运行一遍整个算法。 我们用以下表格来记录Atlanta到其他城市最便宜的价格。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** ？ ？ ？ ？ 首先，以起步顶点（Atlanta）作为当前顶点。此时我们能访问的就是当前顶点以及其邻接点。为指明哪个点是当前顶点，我们以线段将其围绕。为指明哪些点曾作为当前顶点，我们给它们打上钩。 接着检查所有邻接点，记下从起点（Atlanta）到所有已知地点的权重。可见从Atlanta到Boston是100美元，从Atlanta到Denver是160美元，于是记录到表格里。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** 100 ？ 160 ？ 接着从Atlanta可到达但又未访问过的顶点中，找出最便宜的那个。就目前所知，从Atlanta出发可以到达Boston和Denver，并且Boston（100美元）比Denver（160美元）更便宜。因此，选择Boston作为当前顶点。 然后检查从Boston出发的航线，更新从起点Atlanta到所有已知地点的花费。我们看到Boston到Chicago是120美元。Atlanta到Boston是100美元，Boston到Chicago是120美元，所以从Atlanta到Chicago最便宜的（而且是目前唯一的）路线要220美元。我们把它记在表里。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** 100 220 160 ？ 再看看从Boston出发的另一条航线--Denver--要180美元。于是我们又发现了一条从Atlanta到Denver的路线：Atlanta到Boston再到Denver。不过这条路线要280美元，而Atlanta直飞Denver才160美元，所以无须更新价格表，毕竟我们只想记录最便宜的路线。 既然从当前顶点（Boston）出发的航线都已探索过了，就得找下一个从起点Atlanta所能到达的最便宜的未访点了。根据表格来看，最便宜的还是Boston，但它已经打过钩了。这样最便宜的未访问城市应该是Denver了，因为与220美元的Chicago相比，它只要160美元。于是Denver变成了当前顶点。 那么我们就来观察由Denver出发的航线，其中一条从Denver到Chicago的航线是40美元。于是我们可以更新Atlanta到Chicago的最低价格了。因为现在的价格表里Atlanta到Chicago要220美元，但若经Denver转机，则只需200美元。所以更新一下表格。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** 100 200 160 ？ 从Denver飞出的航班还有一个，它的目的地是El Paso。我们要计算Atlanta到El Paso的最低价格，目前只能从Atlanta到Denver再到El Paso，共300美元。将价钱记下。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** 100 200 160 300 现在还没访问的顶点有两个：Chicago和El Paso。Atlanta到Chicago的最低价（200美元）比Atlanta到El Paso的最低价（300美元）要低，所以下一步选择Chicago作为当前顶点。 Chicago只有一个出发航班：80美元到El Paso。于是Atlanta到El Paso路线的最低价格得以更新：从Atlanta到Denver，再到Chicago，最后抵达El Paso，总共花费280美元。我们把它记下。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** 100 200 160 280 最后只剩一个城市可作为当前顶点了，那就是El Paso。 El Paso只有一个出发航班：100美元飞到Boston。这并没刷新Atlanta到其他地方的最低价，所以我们无须更新价格表。 现在所有顶点都访问过了，这就意味着Atlanta到其他城市的所有路径都已发掘。于是算法结束，我们也可以从价格表得知从Atlanta到地图上任一城市的最低价格了。 **从Atlanta到：** **Boston** **Chicago** **Denver** **El Paso** 100 200 160 280 以下是Dijkstra算法的Ruby实现。 我们先创建一个代表城市的Ruby类。一个城市就是图上的一个结点，它记有自己的名字以及可到达的城市。123456789101112131415class City attr_accessor :name, :routes def initialize(name) @name = name # 把表示邻接点的数组换成散列表 @routes = &#123;&#125; # 如果此城市是 Atlanta，则散列表应包含： # &#123;boston =&gt; 100, denver =&gt; 160&#125; end def add_route(city, price_info) @routes[city] = price_info endend 然后用add_route来建立城市间的航线。123456789101112atlanta = City.new("Atlanta")boston = City.new("Boston")chicago = City.new("Chicago")denver = City.new("Denver")el_paso = City.new("El Paso")atlanta.add_route(boston, 100)atlanta.add_route(denver, 160)boston.add_route(chicago, 120)boston.add_route(denver, 180)chicago.add_route(el_paso, 80)denver.add_route(chicago, 40)denver.add_route(el_paso, 140) Dijkstra算法的代码是有点复杂的，所以我在每一步都做了注释。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455def dijkstra(starting_city, other_cities) # 散列表 routes_from_city 用来保存从给定城市到其他所有城市的价格 # 以及途经的城市 routes_from_city = &#123;&#125; # 它的格式如下： # &#123;终点城市 =&gt; [价格, 到达终点城市前所要经过的那个城市]&#125; # 以上图为例，此散列表最后会是： # &#123;atlanta =&gt; [0, nil], boston =&gt; [100, atlanta], chicago =&gt; [200, denver], # denver =&gt; [160, atlanta], el_paso =&gt; [280, chicago]&#125; # 从起点城市到起点城市是免费的 routes_from_city[starting_city] = [0, staring_city] # 初始化该散列表时，因为去往所有其他城市的花费都未知，所以先设为无限 other_cities.each do |city| routes_from_city[city] = [Float::INFINITY, nil] end # 以上图为例，此散列表起初会是： # &#123;atlanta =&gt; [0, nil], boston =&gt; [Float::INFINITY, nil], # chicago =&gt; [Float::INFINITY, nil], # denver =&gt; [Float::INFINITY, nil], el_paso =&gt; [Float::INFINITY, nil]&#125; # 已访问的城市记录在这个数组里 visited_cities = [] # 一开始先访问起点城市，将 current_city 设为它 current_city = starting_city # 进入算法的核心逻辑，循环访问每个城市 while current_city # 正式访问当前城市 visited_cities &lt;&lt; current_city # 检查从当前城市出发的每条航线 current_city.routes.each do |city, price_info| # 如果起点城市到其他城市的价格比 routes_from_city 所记录的更低， # 则更新记录 if routes_from_city[city][0] &gt; price_info + routes_from_city[current_city][0] routes_from_city[city] = [price_info + routes_from_city[current_city][0], current_city] end end # 决定下一个要访问的城市 current_city = nil cheapest_route_from_current_city = Float::INFINITY # 检查所有已记录的路线 routes_from_city.each do |city, price_info| # 在未访问的城市中找出最便宜的那个， # 设为下一个要访问的城市 if price_info[0] &lt; cheapest_route_from_current_city &amp;&amp; !visited_cities.include?(city) cheapest_route_from_current_city = price_info[0] current_city = city end end end return routes_from_cityend 该方法可以这样使用：1234routes = dijkstra(atlanta, [boston, chicago, denver, el_paso])routes.each do |city, price_info|p "#&#123;city.name&#125;: #&#123;price_info[0]&#125;"end 虽然这个例子是找出最便宜的航线，但其解决方法也适用于地图软件和GPS技术。如果边上的权重不是表示价格，而是表示行车用时，那就可以用Dijkstra算法来确定从一个城市去另一个城市应该走哪条路线。 总结这一章讲的是本书最后一种重要的数据结构，我们的学习之旅也接近了尾声。我们知道了图是处理关系型数据的强大工具，它除了能让代码跑得更快，还能帮忙解决一些复杂的问题。 学习至今，我们关注的主要是代码运行的速度。我们以时间和算法的步数来衡量代码的性能。 然而，性能的衡量方法不止这些。在某些情况下，还有比速度更重要的东西，比如我们可能更关心一种数据结构或算法会消耗多少内存。下一章，我们就来学习如何分析一段代码在空间上的效率。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第12章-让一切操作都更快的二叉树]]></title>
    <url>%2F2018%2F06%2F13%2F%E7%AC%AC12%E7%AB%A0-%E8%AE%A9%E4%B8%80%E5%88%87%E6%93%8D%E4%BD%9C%E9%83%BD%E6%9B%B4%E5%BF%AB%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是树？什么是二叉树？ 二叉树既可以保持顺序，又可以快速查找、插入和删除。为什么？ 先创建节点类，然后再用节点对象构建二叉树类。怎么理解？ 二叉树查找的时间复杂度是O(log N)。因为每行进一步，我们就把剩余的结点排除了一半。怎么理解？ 本章涵盖： 二叉树 查找 插入 删除 二叉树实战 之前介绍了二分查找这一概念，并演示了当数组有序时，运用二分查找就能以O(log N)的时间复杂度找出任意值的所在位置。可见，有序的数组是多么美好。 但是有序数组存在着另一个问题。 有序数组的插入和删除是缓慢的。往有序数组中插入一个值前，你得将所有大于它的元素右移一格。从有序数组中删除一个值后，你得将所有大于它的元素左移一格。最坏情况下（插入或删除发生在数组开头）这会需要N步，平均情况则是N/2步。不管怎样，都是O(N)的效率，而O(N)算是挺慢的。 后来，学到了散列表能以O(1)的效率进行查找、插入和删除，但它又有另一明显的不足：不保持顺序。 既要保持顺序，又要快速查找、插入和删除，看来有序数组和散列表都不行。那还有什么数据结构可以选择？ 看看二叉树吧。 二叉树上一章我们通过链表见识了基于结点的数据结构。一个普通的链表里，每一个结点会包含一个连接自身和另一结点的链。树也是基于结点的数据结构，但树里面的每个结点，可以含有多个链分别指向其他多个结点。 以下是一棵典型的树 此例中，每个结点链接着另外两个结点。简单起见，我们也可以不用画出存储链的格子。 谈论树的时候，我们会用到以下术语。 最上面的那一结点（此例中的“j”）被称为根。是的，图中的根位于树的顶端，请自行意会。 此例中，“j”是“m”和“b”的父结点，反过来，“m”和“b”是“j”的子结点。“m”又是“q”和“z”的父结点，“q”和“z”是“m”的子结点。 树可以分层。此例中的树有3层。 基于树的数据结构有很多种，但本章只关注其中一种--二叉树。二叉树是一种遵守以下规则的树。 每个结点的子结点数量可为0、1、2。 如果有两个子结点，则其中一个子结点的值必须小于父结点，另一个子结点的值必须大于父结点。 以下是一个二叉树的例子，其中结点的值是数字。 注意，小于父结点的子结点用左箭头来表示，大于父结点的子结点则用右箭头来表示。 尽管下图是一棵树，但它不是二叉树。 之所以不是二叉树，是因为它的两个子结点的值都小于父结点。 以Python来实现一个树结点的话，大概是这样：12345class TreeNode: def __init__(self,val,left=None,right=None): self.value = val self.leftChild = left self.rightChild = right 然后就可以用它来构建一棵简单的树了。123node = TreeNode(1)node2 = TreeNode(10)root = TreeNode(5, node, node2) 因为二叉树具有这样独特的结构，所以我们能在其中非常快速地进行查找操作，下面就来看看。 查找这是一棵二叉树。 二叉树的查找算法先从根结点开始。 (1)检视该结点的值。 (2)如果正是所要找的值，太好了！ (3)如果要找的值小于当前结点的值，则在该结点的左子树查找。 (4)如果要找的值大于当前结点的值，则在该结点的右子树查找。 以下是用Python写的递归式查找。12345678910111213def search(value, node): # 基准情形：如果 node 不存在 # 或者 node 的值符合 if node is None or node.value == value: return node # 如果 value 小于当前结点，那就从左子结点处查找 elif value &lt; node.value: return search(value, node.leftChild) # 如果 value 大于当前结点，那就从右子结点处查找 else: # value &gt; node.value return search(value, node.rightChild) 假设现在我们要找61，那来看看整个过程要花多少步。 树的查找必须从根开始。 接着，计算机会问自己：我们要找的值与该结点的值相比，是大还是小呢？如果小于当前结点，那就在左子结点上找。如果大于当前结点，那就在右子结点上找。 本例中，因为61大于50，所以它只能在树的右侧，于是我们检查右子结点。 算法继续检查该结点的值。因为75不是我们要找的61，所以还得往下一层找。由于61小于75，它只能在75的左侧，于是下一步去的是左子结点。 因为 61大于 56，所以到 56的右子结点上找。 在这棵树里找出61，我们总共用了4步。 推广开来，我们会说二叉树查找的时间复杂度是O(log N)。因为每行进一步，我们就把剩余的结点排除了一半（不过很快就能看到，只在最好情况下，即理想的平衡二叉树才有这样的效率）。 再与二分查找比较，它也是每次尝试会排除一半可能性的O(log N)算法，可见二叉树查找跟有序数组的二分查找拥有同样的效率。 要说二叉树哪里比有序数组更亮眼，那应该是插入操作。 插入要探索二叉树插入的算法，我们还是从一个实例入手吧。假设现在要往刚才的树里插入45。 首先要做的就是找出45应该被链接到哪个结点上。先从根开始找起。 因为45小于50，所以我们转到左子结点上。 因为45大于25，所以我们检查右子结点。 45大于33，所以检查33的右子结点。 至此，我们到达了一个没有子结点的结点，也就无法再往下了。这意味着可以做插入了。 因为45大于40，所以将其作为40的右子结点来插入。 在这个例子里，插入花了5步，包括4步查找和1步插入。插入这1步总是发生在查找之后，所以总共log N+1步。按照忽略常数的大O来说，就是O(log N)步。 有序数组的插入则是O(N)，因为该过程中除了查找，还得移动大量的元素来给新元素腾出空间。 这就是二叉树的高效之处。有序数组查找需要O(log N)，插入需要O(N)，而二叉树都是只要O(log N)。当你估计应用会发生许多数据改动时，这一比较将有助你做出正确选择。 以下是二叉树插入的Python实现，它跟search一样都是递归的。12345678910111213def insert(value, node): if value &lt; node.value: # 如果左子结点不存在，则将新值作为左子结点 if node.leftChild is None: node.leftChild = TreeNode(value) else: insert(value, node.leftChild) elif value &gt; node.value: # 如果右子结点不存在，则将新值作为右子结点 if node.rightChild is None: node.rightChild = TreeNode(value) else: insert(value, node.rightChild) 注意，只有用随意打乱的数据创建出来的树才有可能是比较平衡的。要是插入的都是已排序的数据，那么这棵树就失衡了，它用起来也会比较低效。比如说，按顺序插入1、2、3、4、5的话，得出的树就会是这样。 从中查找5，效率会是O(N)。 但要是按3、2、4、1、5的顺序来插入的话，得出的树就是平衡的。 因此，假若你要用有序数组里的数据来创建二叉树，最好先把数据洗乱。 在完全失衡的最坏情况下，二叉树的查找需要O(N)。在理想平衡的最好情况下，则是O(log N)。在数据随机插入的一般情况下，因为树也大致平衡，所以查询效率也大约是O(log N)。 删除删除是二叉树的各种操作中最麻烦的一个，必须考虑周全才好动手。假设现在要删除这棵二叉树中的4。 首先，我们查找出它所在的结点，然后一步将该结点删掉。 这看起来好像很简单，那我们再试试删掉10吧。 如果删掉10的话，就会导致11的那个结点从树上脱离。当然这是不允许的，否则这个11就永远都找不到了。好在我们还有解决办法：将11放到之前10所在的位置。 至此，删除操作遵循以下规则。 如果要删除的结点没有子结点，那直接删掉它就好。 如果要删除的结点有一个子结点，那删掉它之后，还要将子结点填到被删除结点的位置上。 要删除带有两个子结点的结点是最复杂的。比如说现在要删除56。 那52和61要怎么处理呢？显然不能将它们都放到 56原本的位置上，还需要第三条规则。 如果要删除的结点有两个子结点，则将该结点替换成其后继结点。一个结点的后继结点，就是所有比被删除结点大的子结点中，最小的那个。 上面这句话听起来有点绕。或者你把这些结点按顺序排好，那么每个结点后续的那个结点就是其后继结点。就像本例中56的所有后裔中，只有61能被称为其后继结点。按照这个规则，我们将56替换成61。 那计算机是怎么找出后继结点的呢？这是有算法可循的。 跳到被删除结点的右子结点，然后一路只往左子结点上跳，直到没有左子结点为止，则所停留的结点就是被删除节点的后继结点。 再来看一个更复杂的删除，这次我们删除根结点。 现在需要找后继结点来填补根的位置。 首先，访问右子结点，然后一路往左下方向移步，直至没有左子结点的结点上。 这就找出后继结点52了，接着我们将其填到被删除结点的位置上。 删除完成！ 然而，还有一种情况我们没遇到过，那就是后继结点带有右子结点。让我们回到根被删除之前的状态，并且给52加上一个右子结点。 如此一来，就不能只将后继结点52移到根那里了，因为这样会使其子结点55悬空。于是，我们再加一条关于删除的规则。 如果后继结点带有右子结点，则在后继结点填补被删除结点以后，用此右子结点替代后继结点的父节点的左子结点。 下面运行一遍这个流程。 首先，将后继结点填到根处。 此时55便悬在半空中了。接下来，将55转换为继承节点的父节点的左子节点，本例中，61是继承结点的父结点，所以55成为61的左子结点。 这才算真正完成了。 以下为二叉树的删除算法的所有规则。 如果要删除的结点没有子结点，那直接删掉它就好。 如果要删除的结点有一个子结点，那删掉它之后，还要将子结点填到被删除结点的位置上。 如果要删除的结点有两个子结点，则将该结点替换成其后继结点。一个结点的后继结点，就是所有比被删除结点大的子结点中，最小的那个。 如果后继结点带有右子结点，则在后继结点填补被删除结点以后，用此右子结点替代后继结点的父节点的左子结点。 以下是用Python写的二叉树递归式删除算法。为了易于理解，安插了一些注释进去。12345678910111213141516171819202122232425262728293031323334353637383940414243444546def delete(valueToDelete, node): # 当前位置的上一层无子结点，已到达树的底层，即基准情形 if node is None: return None # 如果要删除的值小于（或大于）当前结点， # 则以左子树（或右子树）为参数，递归调用本方法， # 然后将当前结点的左链（或右链）指向返回的结点 elif valueToDelete &lt; node.value: node.leftChild = delete(valueToDelete, node.leftChild) # 将当前结点（及其子树，如果存在的话）返回， # 作为其父结点的新左子结点（或新右子结点） return node elif valueToDelete &gt; node.value: node.rightChild = delete(valueToDelete, node.rightChild) return node # 如果要删除的正是当前结点 elif valueToDelete == node.value: # 如果当前结点没有左子结点， # 则以右子结点（及其子树，如果存在的话）替换当前结点成为当前结点之父结点的新子结点 if node.leftChild is None: return node.rightChild # 如果当前结点没有左子结点，也没有右子结点，那这里就是返回 None elif node.rightChild is None: return node.leftChild # 如果当前结点有两个子结点，则用 lift 函数（见下方）来做删除， # 它会使当前结点的值变成其后继结点的值 else: node.rightChild = lift(node.rightChild, node) return node def lift(node, nodeToDelete): # 如果此函数的当前结点有左子结点， # 则递归调用本函数，从左子树找出后继结点 if node.leftChild: node.leftChild = lift(node.leftChild, nodeToDelete) return node # 如果此函数的当前结点无左子结点， # 则代表当前结点是后继结点，于是将其值设置为被删除结点的新值 else: nodeToDelete.value = node.value # 用后继结点的右子结点替代后继结点的父节点的左子结点 return node.rightChild 跟查找和插入一样，平均情况下二叉树的删除效率也是O(log N)。因为删除包括一次查找，以及少量额外的步骤去处理悬空的子结点。有序数组的删除则由于需要左移元素去填补被删除元素产生的空隙，最终导致O(N)的时间复杂度。 二叉树实战二叉树在查找、插入和删除上引以为傲的O(log N)效率，使其成为了存储和修改有序数据的一大利器。它尤其适用于需要经常改动的数据，虽然在查找上它跟有序数组不相伯仲，但在插入和删除方面，它迅速得多。 比如说你正在做一个书目维护的应用，它需要具备以下功能。 该应用可以将书名依照字母序打印。 该应用可以持续更新书目。 该应用可以让用户从书目中搜索书名。 如果你预期该书目不常变动的话，那么用有序数组作为存储结构是可以的。但这个应用偏偏要经常实时更新数据。要是其中包含上百万册图书，那还是用二叉树来保存比较好。 存储书名的二叉树大概是下面这个样子。 书名的搜索和更新，可以按我们之前介绍的二叉树查找、插入和删除来解决。但依照字母序打印书名该怎么做呢？ 首先，我们得学会如何访问树上的所有结点。访问数据结构中所有元素的过程，叫作遍历数据结构。 接着，为了使书名以字母序打印，我们得确保遍历也是以字母序进行。虽然有多种方法可以遍历树，但对于这个要求字母序打印的应用，我们采用中序遍历。 递归是实施中序遍历的有力工具。我们将创建一个名为traverse的递归函数，它可以在任一结点上调用。然后执行以下步骤。 (1) 如果此结点有左子结点，则在左子结点上调用自身（traverse）。(2) 访问此结点（对于书目应用来说，就是打印结点的值）。(3) 如果此结点有右子结点，则在右子结点上调用自身（traverse）。 若当前结点没有子结点，则意味着该递归算法到达了基准情形，这时我们无须再调用traverse，只需打印结点中的书名就行了。 在“Moby Dick”上调用traverse的话，就能以下图的顺序访问树上的所有结点。 这样就能依照字母序打印书目了。遍历会访问树上所有的结点，所以树的遍历效率为O(N)。 以下是用Python写的以字母序打印书目的traverse_and_print函数。123456def traverse_and_print(node): if node is None: return traverse_and_print(node.leftChild) print(node.value) traverse_and_print(node.rightChild) 总结二叉树是一种强大的基于结点的数据结构，它既能维持元素的顺序，又能快速地查找、插入和删除。尽管比它的近亲链表更为复杂，但它更有用。 值得一提的是，树形的数据结构除了二叉树以外还有很多种，包括堆、B树、红黑树、2-3-4树等。它们也各有自己适用的场景。 下一章，我们还会遇见另一种基于结点的数据结构--图。图是社交网络和地图软件等复杂应用的核心组成部分，强大且灵活。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第11章-基于结点的数据结构]]></title>
    <url>%2F2018%2F06%2F12%2F%E7%AC%AC11%E7%AB%A0-%E5%9F%BA%E4%BA%8E%E7%BB%93%E7%82%B9%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 数组和链表有什么区别？ 什么是链表？什么是结点？什么是链？每个结点需要几个格子？ 链表的第一个节点有什么作用？ 链表的物理结构与数组不同怎么理解？链表相对数组有什么好处？ 用一种语言来实现链表。写链表需要两个类，哪两个？为什么？ 链表的读取和查找如何进行？是什么时间复杂度？ 链表的开头插入和末尾插入如何进行？是什么时间复杂度？ 什么场景适合使用链表？链表在删除操作中有优势，也是可实际使用的地方。怎么理解？ 链表的另一个引人注目的应用，就是作为队列的底层数据结构。为什么？ 什么是双向链表？ 本章涵盖： 链表 实现一个链表 读取 查找 插入 删除 链表实战 双向链表 接下来的几章将要学习的各种数据结构，都涉及一种概念--结点。基于结点的数据结构拥有独特的存取方式，因此在某些时候具有性能上的优势。 本章我们会探讨链表，它是最简单的一种基于结点的数据结构，而且也是后续内容的基础。 你会发现，虽然链表和数组看上去差不多，但在性能上却各有所长。 链表像数组一样，链表也用来表示一系列的元素。事实上，能用数组来做的事情，一般也可以用链表来做。然而，链表的实现跟数组是不一样的，在不同场景它们会有不同的性能表现。 计算机的内存就像一大堆格子，每格都可以用来保存比特形式的数据。当要创建数组时，程序会在内存中找出一组连续的空格子，给它们起个名字，以便你的应用存放数据，见下图。 我们之前说过，计算机能够直接跳到数组的某一索引上。如果代码要求它读取索引4的值，那么计算机只需一步就可以完成任务。重申一次，之所以能够这样，是因为程序事先知道了数组开头所在的内存地址--例如地址是1000--当它想去索引4时，便会自动跳到1004处。 与数组不同的是，组成链表的格子不是连续的。它们可以分布在内存的各个地方。这种不相邻的格子，就叫作结点。 那么问题来了，计算机怎么知道这些分散的结点里，哪些属于这个链表，哪些属于其他链表呢？ 这就是链表的关键了：每个结点除了保存数据，它还保存着链表里的下一结点的内存地址。 这份用来指示下一结点的内存地址的额外数据，被称为链。链表如下图所示。 此例中，我们的链表包含4项数据：“a”、“b”、“c”和“d”。因为每个结点都需要2个格子，头一格用作数据存储，后一格用作指向下一结点的链（最后一个结点的链是null，因为它是终点），所以整体占用了8个格子。 若想使用链表，你只需知道第一个结点在内存的什么位置。因为每个结点都有指向下一结点的链，所以只要有给定的第一个结点，就可以用结点1的链找到结点2，再用结点2的链找到结点3……如此遍历链表的剩余部分。 链表相对于数组的一个好处就是，它可以将数据分散到内存各处，无须事先寻找连续的空格子。 实现一个链表我们用Ruby来写一个链表，最终实现包含两个类：Node和LinkedList 。先是Node。12345678class Node # 创建读写变量data,next_node attr_accessor :data, :next_node def initialize(data) @data = data endend Node类有两个属性：data表示结点所保存的数据，next_node表示指向下一结点的链，使用方法如下。1234567node_1 = Node.new("once")node_2 = Node.new("upon")node_1.next_node = node_2node_3 = Node.new("a")node_2.next_node = node_3node_4 = Node.new("time")node_3.next_node = node_4 以上代码创建了4个连起来的结点，它们分别保存着“once”、“upon”、“a”和“time”4项数据。 虽然只用Node也可以创建出链表，但我们的程序无法由此轻易地得知哪个结点是链表的开端。因此我们还得创建一个LinkedList类。下面是一个最基本的LinkedList的写法。12345678class LinkedList attr_accessor :first_node def initialize(first_node) @first_node = first_node endend 有了这个类，我们就可以用以下代码让程序知道链表的起始位置了。1list = LinkedList.new(node_1) LinkedList的作用就是一个指针，它指向链表的第一个结点。 既然知道了链表是什么，那么接下来做个它跟数组的性能对比，观察它们在读取、查找、插入和删除上有何优劣。 读取我们曾经说过，当计算机要从数组中读取一个值时，它会一步跳到对应的格子上，其效率为O(1)。但在链表中就不是这样了。 假设程序要读取链表中索引2的值，计算机不可能在一步之内完成，因为无法一下子算出它在内存的哪个位置。毕竟，链表的结点可以分布在内存的任何地方。程序知道的只有第1个结点的内存地址，要找到索引2的结点（即第3个），程序必须先读取索引0的链，然后顺着该链去找索引1。接着再读取索引1的链，去找索引2，这才能读取到索引2里的值。 下面我们在LinkedList类中加入读取操作。12345678910111213141516171819202122232425class LinkedList attr_accessor :first_node def initialize(first_node) @first_node = first_node end def read(index) # 从第一个结点开始 current_node = first_node current_index = 0 while current_index &lt; index do # 顺着链往下找，直至我们要找的那个索引值 current_node = current_node.next_node current_index += 1 # 如果读到最后一个结点之后，就说明 # 所找的索引不在链表中，因此返回 nil return nil unless current_node end return current_node.data endend 当想要读取某个索引时，可以这样写：1list.read(3) 读取链表中某个索引值的最坏情况，应该是读取最后一个索引。这种情况下，因为计算机得从第一个结点开始，沿着链一直读到最后一个结点，于是需要N步。由于大O记法默认采用最坏情况，所以我们说读取链表的时间复杂度为O(N)。这跟读取数组的O(1)相比，的确是一大劣势。 查找链表的查找效率跟数组一样。记住，所谓查找就是从列表中找出某个特定值所在的索引。对于数组和链表来说，它们都是从第一格开始逐个格子地找，直至找到。如果是最坏情况，即所找的值在列表末尾，或完全不在列表里，那就要花O(N)步。 下面是查找方法的实现。12345678910111213141516171819202122232425class LinkedList attr_accessor :first_node # 其他方法略…… def index_of(value) # 从第一个结点开始 current_node = first_node current_index = 0 begin # 如果找到，就返回 if current_node.data == value return current_index end # 否则，看下一个结点 current_node = current_node.next_node current_index += 1 end while current_node # 如果遍历整个链表都没找到，就返回 nil return nil endend 有了它我们就可以这样来查找了：1list.index_of("time") 插入在某些情况下，链表的插入跟数组相比，有着明显的优势。回想插入数组的最坏情况：当插入位置为索引0时，因为需要先将插入位置右侧的数据都右移一格，所以会导致O(N)的时间复杂度。然而，若是往链表的表头进行插入，则只需一步，即O(1)。下面看看为什么。 假设我们的链表如下所示。 要在表头增加“yellow”，我们只需创建一个新的结点，然后使其链接到“blue”那一结点。 因为无须平移其他数据，所以与数组相比，链表在前端插入数据更为便捷。 虽然理论上在链表的任何一处做插入都只需要1步，但事实上没那么简单。假设现在链表是这样的： 然后我们想在索引2（“blue”和“green”之间）插入“purple”。由于插入动作创建了一个新的结点，如下图那样改动“blue”和“purple”的链，因此实际的操作只需1步。 但是，在该动作之前，计算机还得先找到索引1的结点（“blue”），让结点1的链指向新的结点。这个过程就是之前所说的读取链表，其效率为O(N)。下面我们来演示一下。 因为新结点是加在索引1之后，所以计算机要先找出索引1。这得从第一个结点开始。 接着通过第一个链访问下一个结点。 既然已到达索引1的结点，那就可以增加新的结点进去了。 刚才添加“purple”的例子花了3步。若想将它添加到链表的末尾，就得花5步：先是用4步跳到索引3上，再用1步插入新结点。 因此，链表的插入效率为O(N)，与数组一样。 有趣的是，通过以上分析，你会发现链表的最坏情况和最好情况与数组刚好相反。在链表开头插入很方便，在数组开头插入却很麻烦；在数组的末尾插入是最好情况，在链表的末尾插入却是最坏情况。总结起来如下表所示。 场 景 数 组 链 表 在前端插入 最坏情况 最好情况 在中间插入 平均情况 平均情况 在末端插入 最好情况 最坏情况 下面给LinkedList类加上插入方法。12345678910111213141516171819202122232425262728class LinkedListattr_accessor :first_node # 其他方法略…… def insert_at_index(index, value) # 创建新结点 new_node = Node.new(value) # 如果在开头插入，则将新结点的 next_node 指向原 first_node， # 并为其设置新的 first_node if index == 0 new_node.next_node = first_node return @first_node = new_node end current_node = first_node current_index = 0 # 先找出新结点插入位置前的那一结点 prev_index = index - 1 while current_index &lt; prev_index do current_node = current_node.next_node current_index += 1 end new_node.next_node = current_node.next_node # 使前一结点的链指向新结点 current_node.next_node = new_node endend 删除从效率上来看，删除跟插入是相似的。如果删除的是链表的第一个结点，那就只要1步：将链表的first_node设置成当前的第二个结点。 回到“once”、“upon”、“a”和“time”的例子。如果要删除“once”，那直接让链表以“upon”为开头就好了。1list.first_node = node_2 再回想删除数组的第一个元素时，得把剩余的所有元素左移一格，需要O(N)的时间复杂度。 删除链表的最后一个结点，其实际的删除动作只需1步--令倒数第二的结点的链指向null。 然而，要找出倒数第二的结点，得花N步，因为我们依然只能从第一个结点顺着链往下一个个地找。 下面这个表格对比了各种情况下数组和链表删除操作的效率。注意它跟插入效率的表格几乎一模一样。 场 景 数 组 链 表 在前端删除 最坏情况 最好情况 在中间删除 平均情况 平均情况 在末端删除 最好情况 最坏情况 要在链表中间做删除，计算机需要修改被删结点的前一结点的链，看下面的例子你就会明白。 假设现在要删除刚才例子的索引2的值（“purple”），计算机就会找出索引1的结点，将其链指向”green”结点。 LinkedList类的删除操作实现如下。12345678910111213141516171819202122232425262728293031class LinkedList attr_accessor :first_node # 其他方法略…… def delete_at_index(index) # 如果删除的是第一个结点， # 则将 first_node 重置为第二个结点， # 并返回原第一个结点 if index == 0 deleted_node = first_node @first_node = first_node.next_node return deleted_node end current_node = first_node current_index = 0 # 先找出被删结点前的那一结点， # 将其命名为 current_node while current_index &lt; index - 1 do current_node = current_node.next_node current_index += 1 end # 再找出被删结点后的那一结点 deleted_node = current_node.next_node node_after_deleted_node = deleted_node.next_node # 将 current_node 的链指向 node_after_deleted_node， # 这样被删结点就被排除在链表之外了 current_node.next_node = node_after_deleted_node deleted_node endend 经过一番分析，链表与数组的性能对比如下所示。 操 作 数 组 链 表 读取 O(1) O(N) 查找 O(N) O(N) 插入 O(N)（在末端是O(1)） O(N)（在前端是O(1)） 删除 O(N)（在末端是 O(1)） O(N)（在前端是O(1)） 尽管两者的查找、插入、删除的效率看起来差不多，但在读取方面，数组比链表要快得多。 既然如此，那为什么还要用链表呢？ 链表实战高效地遍历单个列表并删除其中多个元素，是链表的亮点之一。假设我们正在写一个整理电子邮件地址的应用，它会删掉列表中无效格式的地址。具体算法是，每次读取一个地址，然后用正则表达式（一种用于识别数据格式的特定模式）来校验其有效性。如果发现该地址无效，就将它从列表中移除。 不管这个列表是数组还是链表，要检查每个元素的话，都得花N步。然而，当要删除邮件地址时，它们的效率却不同，下面我们来验证一下。 用数组的话，每次删除邮件地址，我们就要另外再花O(N)步去左移后面的数据，以填补删除所产生的空隙。而且还必须完成这些平移才能执行下一次邮件地址的检查。 所以如果存在需要删除的无效地址，那么除了遍历邮件地址的N步，还得加上N步乘以无效地址数。 假设每10个地址就有1个是无效的。如果列表包含1000个地址，那么无效的就应该会有100个。于是我们的算法就要花1000步来读取，再加上删除所带来的大约100000步的操作（100个无效地址 × N）。 但要是链表的话，每次删除只需1步就好，因为只需改动结点中链的指向，然后就可以继续检查下一邮件地址了。按这种算法去处理1000个邮件地址，只需要1100步（1000步读取和100步删除）。 双向链表链表的另一个引人注目的应用，就是作为队列的底层数据结构。第8章我们已经介绍过队列，你应该还记得它就是一种只能在末尾插入元素，在开头删除元素的数据结构。当时我们用数组作为队列的底层，并解释说队列只是有约束条件的数组。其实，改用链表来做队列的底层也可以，同样地，只要使该链表的元素只在末尾插入，并在开头删除就好了。那么用链表来代替数组有什么好处呢？下面来分析一下。 再强调一次，队列插入数据只能在末尾。如上文所述，在数组的末尾插入是极快的，时间复杂度为O(1)。链表则要O(N)。所以在插入方面，选择数组比链表更好。 但到了删除的话，就是链表更快了，因为它只要O(1)，而数组是O(N)。 基于以上分析，似乎用数组还是链表都无所谓。因为它们总有一种操作是O(1)，另一种是O(N)：数组的插入是O(1)，删除是O(N)；链表则反过来，分别是O(N)和O(1)。 然而，要是采用双向链表这一链表的变种，就能使队列的插入和删除都为O(1)。 双向链表跟链表差不多，只是它每个结点都含有两个链--一个指向下一结点，另一个指向前一结点。此外，它还能直接访问第一个和最后一个结点。 以下是一个双向链表。 用代码来表述的话，如下所示。123456789101112131415161718class Node attr_accessor :data, :next_node, :previous_node def initialize(data) @data = data endendclass DoublyLinkedList attr_accessor :first_node, :last_node def initialize(first_node=nil, last_node=nil) @first_node = first_node @last_node = last_node endend 由于双向链表总会记住第一个和最后一个结点，因此能够一步（以O(1)的时间）访问到它们。 更进一步地，在末尾插入数据也可以一步完成，如下所示。 这里创建了一个新结点（“Sue”），并使其previous_node指向双向链表的last_node(“Greg”)。然后，再将last_node(“Greg”)的next_node指向这个新结点（“Sue”）。最后，把last_node改为新结点（“Sue”）。 以下是在双向链表中实现的新方法insert_at_end 。1234567891011121314151617181920212223class DoublyLinkedList attr_accessor :first_node, :last_node def initialize(first_node=nil, last_node=nil) @first_node = first_node @last_node = last_node end def insert_at_end(value) new_node = Node.new(value) # 如果链表还没有任何结点 if !first_node @first_node = new_node @last_node = new_node else new_node.previous_node = @last_node @last_node.next_node = new_node @last_node = new_node end endend 因为双向链表能直接访问前端和末端的结点，所以在两端插入的效率都为O(1)，在两端删除的效率也为O(1)。由于在末尾插入和在开头删除都能在O(1)的时间内完成，因此拿双向链表作为队列的底层数据结构就最好不过了。 以下是基于双向链表的队列的完整代码示例。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758class Node attr_accessor :data, :next_node, :previous_node def initialize(data) @data = data endendclass DoublyLinkedList attr_accessor :first_node, :last_node def initialize(first_node=nil, last_node=nil) @first_node = first_node @last_node = last_node end def insert_at_end(value) new_node = Node.new(value) # 如果链表还没有任何结点 if !first_node @first_node = new_node @last_node = new_node else new_node.previous_node = @last_node @last_node.next_node = new_node @last_node = new_node end end def remove_from_front removed_node = @first_node @first_node = @first_node.next_node return removed_node endendclass Queue attr_accessor :queue def initialize @queue = DoublyLinkedList.new end def enque(value) @queue.insert_at_end(value) end def deque removed_node = @queue.remove_from_front return removed_node.data end def tail return @queue.last_node.data endend 总结尽管目前还没用到队列，或者用了数组但没用双向链表也运行得很好。但是现在，你知道了还有其他选择，也学习了什么时候应该做出什么选择。 你学会了在特定情况下使用链表来改善性能。后面还会介绍更复杂的基于结点的数据结构，它们更常用，并且对性能的提升更大。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第10章-飞快的递归算法]]></title>
    <url>%2F2018%2F06%2F11%2F%E7%AC%AC10%E7%AB%A0-%E9%A3%9E%E5%BF%AB%E7%9A%84%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么大多数编程语言都使用快速排序？ 快速排序依赖于一个名为分区的概念。怎么理解？ 本章涵盖： 分区 快速排序 快速排序的效率 最坏情况 快速选择 递归给我们带来了新的算法实现方式，例如上一章的文件系统遍历。本章我们还会看到，递归能使算法效率大大提高。 前几章我们学会了一些排序算法，包括冒泡排序、选择排序和插入排序。但在现实中，数组排序不是通过它们来做的。为了免去大家重复编写排序算法的烦恼，大多数编程语言都自带用于数组排序的函数，其中很多采用的都是快速排序。 虽然它已经实现好了，但我们还是想研究一下它的原理，因为其运用递归来给算法提速的做法极具推广意义。 快速排序真的很快。尽管在最坏情况（数组逆序）下它跟插入排序、选择排序的效率差不多，但在日常多见的平均情况中，它的确表现优异。 快速排序依赖于一个名为分区的概念，所以我们先从它开始了解。 分区此处的分区指的是从数组随机选取一个值，以其为轴，将比它小的值放到它左边，比它大的值放到它右边。分区的算法实现起来很简单，例子如下所示。 假设有一个下面这样的数组。 从技术上来说，选任意值为轴都可以，我们就以数组最右的值为轴吧。现在轴就是3了，我们把它圈起来。 然后放置指针，它们应该分别指向排除轴元素的数组最左和最右的元素。 接着就可以分区了，步骤如下。 (1)左指针逐个格子向右移动，当遇到大于或等于轴的值时，就停下来。 (2)右指针逐个格子向左移动，当遇到小于或等于轴的值时，就停下来。 (3)将两指针所指的值交换位置。 (4)重复上述步骤，直至两指针重合，或左指针移到右指针的右边。 (5)将轴与左指针所指的值交换位置。 当分区完成时，在轴左侧的那些值肯定比轴要小，在轴右侧的那些值肯定比轴要大。因此，轴的位置也就确定了，虽然其他值的位置还没有完全确定。 让我们来把此流程套到示例数组上。 第1步：拿左指针（正指向0）与轴（值为3）比较。 由于0比轴小，左指针可以右移。 第2步：右移左指针。 将左指针（值为5）与轴比较。它比轴小吗？不。于是左指针停在这里，下一步我们启动右指针。 第3步：比较右指针（值为6）和轴。它比轴大吗？对。于是右指针左移。 第4步：左移右指针。 比较右指针（值为1）和轴。它比轴大吗？不。于是右指针停下。 第5步：因为两个指针都停住了，所以交换它们的值。 随后，再次启动左指针。 第6步：右移左指针。 比较左指针（值为2）和轴。它比轴小吗？对。于是继续右移。 第7步：左指针移到下一格子。注意，这时两个指针都指向同一个值了。 比较左指针和轴。由于左指针的值比轴要大，我们将其停在那里。而且现在左指针与右指针重合，无须再移动指针了。 第8步：到了分区的最后一步，将左指针的值与轴交换位置。 虽然数组还没完全排好序，但我们已完成了一次分区。即比轴（值为3）小的值都聚在了它的左侧，比轴大的值都聚在了它的右侧，这就意味着3已经被放置到正确的位置上了。 下面是用Ruby写的SortableArray类，其中的partition!方法能如上所述对数组进行分区。12345678910111213141516171819202122232425262728293031323334353637383940414243class SortableArray attr_reader :array def initialize(array) @array = array end def partition!(left_pointer, right_pointer) # 总是取最右的值作为轴 pivot_position = right_pointer pivot = @array[pivot_position] # 将右指针指向轴左边的一格 right_pointer -= 1 while true do while @array[left_pointer] &lt; pivot do left_pointer += 1 end while @array[right_pointer] &gt; pivot do right_pointer -= 1 end if left_pointer &gt;= right_pointer break else swap(left_pointer, right_pointer) end end # 最后将左指针的值与轴交换 swap(left_pointer, pivot_position) # 根据快速排序的需要，返回左指针 # 具体原因接下来会解释 return left_pointer end def swap(pointer_1, pointer_2) temp_value = @array[pointer_1] @array[pointer_1] = @array[pointer_2] @array[pointer_2] = temp_value endend 此partition!方法接受两个参数作为左指针和右指针的起始位置，并在结束时返回左指针的最终位置。这是实现快速排序所必需的，下面我们将会看到。 快速排序快速排序严重依赖于分区。它的运作方式如下所示。 (1)把数组分区。使轴到正确的位置上去。 (2)对轴左右的两个子数组递归地重复第1、2步，也就是说，两个子数组都各自分区，并形成各自的轴以及由轴分隔的更小的子数组。然后也对这些子数组分区，以此类推。 (3)当分出的子数组长度为0或1时，即达到基准情形，无须进一步操作。 将以下quicksort!方法加到刚才的SortableArray类中，快速排序就完整了。12345678910111213def quicksort!(left_index, right_index) # 基准情形：分出的子数组长度为 0 或 1 if right_index - left_index &lt;= 0 return end # 将数组分成两部分，并返回分隔所用的轴的索引 pivot_position = partition!(left_index, right_index) # 对轴左侧的部分递归调用 quicksort quicksort!(left_index, pivot_position - 1) # 对轴右侧的部分递归调用 quicksort quicksort!(pivot_position + 1, right_index)end 想看实际效果的话，可执行以下代码。1234array = [0, 5, 2, 1, 6, 3]sortable_array = SortableArray.new(array)sortable_array.quicksort!(0, array.length - 1)p sortable_array.array 再回到刚才的例子。最初的数组是[0, 5, 2, 1, 6, 3]，然后我们做了一次分区。所以我们的快速排序已经有一点进度了，目前状态如下。 正如你看到的，其中3为轴。它已经处于正确的位置，接下来对其左右两侧的元素进行排序。 注意，虽然我们看到左侧的元素碰巧已经按顺序排好了，但计算机是不知道的。 下一步，我们把轴左侧的那些元素当作一个独立的数组来分区。 除此之外的元素则先不用看，暂时给它们涂上阴影。 现在，对于这个 [0, 1, 2]的子数组，我们选取其最右端的元素作为轴。于是，轴为 2。 然后，设置左右指针。 让我们接着之前的第 8步，开始子数组的分区。 第9步：比较左指针（值为0）与轴（值为2）。由于0小于轴，可将左指针右移。 第10步：将左指针右移一格，这时它刚好跟右指针重合了。 比较左指针与轴。由于 1小于轴，继续右移。 第11步：将左指针右移一格，它便指向轴了。 这时左指针的值与轴相等了（因为它正指向轴），左指针停下。 第12步：启动右指针。然而，右指针（值为 1）小于轴，所以不用动。 因为左指针已经跑到右指针的右边了，所以本次分区无须再移动指针。 第13步：最后，将左指针的值跟轴交换。但左指针已经指向轴，因此轴与自身交换，结果没有任何改变。至此，分区完成，轴（值为 2）也到达正确位置了。 于是轴（值为 2）分出了左侧的子数组[0, 1]，右侧没有子数组。那么接下来将左侧的[0, 1]分区。 为了专注于 [0, 1] ，我们将其余的元素涂上阴影。 然后选取其最右的元素（值为 1）作为轴。但是左右指针应该如何放置呢？是的，左指针指向0，右指针因为总是从轴左侧那格开始，所以也是指向0，如下所示。 可以开始分区了。 第14步：比较左指针（值为 0）与轴（值为 1）。 它比轴小，继续右移。 第15步：将左指针往右移一格，这时它指向了轴。 由于左指针不再小于轴了（因为它的值就是轴），于是停下。 第16步：比较右指针与轴。由于其值小于轴，就不用再左移了。而且现在左指针走到了右指针的右边，所以指针无须继续移动，可以进入最后一步。 第17步：将左指针与轴交换。但同样地，这次左指针也指向了轴，所以交换不会产生什么位置改变。于是轴的位置便排好了，分区结束。 此时数组如下所示。 接着，对最近一次的轴的左侧子数组 [0] 进行分区。因为它只包含一个元素，到达了“数组长度为0或1”的基准情形，所以我们什么都不用干。该元素已随着之前的分区被挪到了正确的位置。现在数组如下所示。 最开始我们以3为轴，然后把其左侧的子数组[0, 1, 2]做了分区。按照约定，现在轮到了它右侧的[6, 5] 。 [0, 1, 2, 3]已经排好了，所以将它们涂上阴影，以便我们专注于[6, 5] 。 接下来的分区以最右端的元素（值为5）为轴，如下所示。 左右指针只能同时指向6。 第18步：比较左指针（值为6）与轴（值为5）。由于6大于轴，左指针不再右移。 第19步：本来指着6的右指针应该左移，但6的左边已经没有其他元素了，所以右指针停止。由于左指针与右指针重合，也不用再做任何移动了，可以跳到最后一步。 第20步：将左指针的值与轴交换。 这样轴（值为5）就放到正确位置上了，数组变成了下面这样。 尽管随后我们应该递归地对[5, 6]左右两侧的子数组进行分区，但现在轴左侧没有元素，右侧也只有长度为1的子数组，即到达了基准情形--6已自动挪到了正确位置。 于是整个排序完成！ 快速排序的效率为了搞清楚快速排序的效率，我们先从分区开始。分解来看，你会发现它包含两种步骤。 比较：每个值都要与轴做比较。 交换：在适当时候将左右指针所指的两个值交换位置。 一次分区至少有N次比较，即数组的每个值都要与轴做比较。因为每次分区时，左右指针都会从两端开始靠近，直到相遇。 交换的次数则取决于数据的排列情况。一次分区里，交换最少会有1次，最多会有N/2次，因为即使所有元素都需要交换，我们也只是将左半部分与右半部分进行交换，如下图所示。 对于随机排列的数据，粗略来算就是N/2的一半，即N/4次交换。于是，N次比较加上N/4次交换，共1.25N步。最后根据大O记法的规则，忽略常数项，得出分区操作的时间为O(N)。 这就是一次分区的效率。但完整的快速排序需要对多个数组以及不同大小的子数组分区，想知道整个过程所花的时间，还要再进一步分析才行。 为了更形象地描述，我们将一个含有8个元素的数组的快速排序过程画了出来。它旁边有每一次分区所作用的元素个数。由于元素值并不重要，因此就不显示了。注意，作用范围就是那些白色的格子。 这里有8次分区，但每次作用的范围大小不一。因为只含1个元素的子数组就是基准情形，无须任何交换和比较，所以只有元素量大于或等于2的子数组才要算分区。 由于此例属于平均情况的一种，因此我们假设每次分区大约要花1.25N步，得出：1234 8 个元素 * 1.25 = 10 步 3 个元素 * 1.25 = 3.75 步 4 个元素 * 1.25 = 5 步+ 2 个元素 * 1.25 = 2.5 步 总共约为21步 如果再对不同大小的数组做统计，你会发现N个元素，就要N×log N步。想体会什么是N log N的话，可参考下表。 N log N N×log N 4 2 8 8 3 24 16 4 64 在上面一个数组含8个元素的例子中，快速排序花了大约21步，也很接近8×log8（等于 24）。这种时间复杂度的算法我们还是第一次遇到，用大O记法来表达的话，它是O(N log N)算法。 快速排序的步数接近N×log N绝非偶然。如果我们以更平均的情况来考察快速排序，就能看出原因了。 快速排序开始时会对整个数组进行分区。假设此次分区会将轴最终安放到数组中央--这也是平均情况--然后我们就要对由此切开的两半进行分区。巧合的是，它们的轴也最终落在各自的中央，分出4个大小为原数组四分之一的子数组。并且，接下来所有分区都出现了这种轴在中央的情况。 这样一来，我们基本上就是在不断地对半切分子数组，直至产生出的子数组长度为1。那么，一个数组要经历多少次分区才能切到这么小呢？如果数组元素有N个，那就是log N次。假设元素有8个，那就要对半切3次，才能分出只有1个元素的子数组。这个原理你应该在二分查找那节学过了。 对两个新的子数组所执行的分区操作，需要处理的数据量还是相当于对原数组所做的分区。如下图所示。 因为等分发生了log N次，而每次都要对总共N个元素做分区，所以总步数为N×log N。 之前我们看到的很多算法，最佳情况都发生在元素有序的时候。但在快速排序里，最佳情况应该是每次分区后轴都刚好落在子数组的中间。 最坏情况快速排序最坏的情况就是每次分区都使轴落在数组的开头或结尾。导致这种情况的原因有好几种，包括数组已升序排列，或已降序排列。下面我们把这种情况用图来说明一下。 虽然在此情况下，每次分区都只有一次交换，但比较的次数却变得很多。在轴总落在中央的例子里，每次分区都能划分出比原数组小得多的子数组（过程中产生的最大的子数组长度为4），使各部分都能很快地到达基准情形。然而如果轴落在其中一端，前5次分区就需要处理长度大于4的数组。而且这5次分区里，每次所需的比较次数还是和子数组的元素量一样多。 于是在最坏情况下，对8 + 7 + 6 + 5 + 4 + 3 + 2个元素进行分区，一共35次比较。 写成公式的话，就是N个元素，需要N + (N - 1) + (N - 2) + (N - 3) + … + 2步，即N2/ 2步，如下图所示。 又因为大O忽略常数，所以最终我们会说，快速排序最坏情况下的效率为O(N2)。 既然把快速排序分析完了，我们将它与插入排序比较一下。 最好情况 平均情况 最坏情况 插入排序 O(N) O(N2) O(N2) 快速排序 O(N log N) O(N log N) O(N2) 虽然快速排序在最好情况和最坏情况都没能超越插入排序，但在最常遇见的平均情况，前者的O(N log N)比后者的O(N2)好得多，所以总体来说，快速排序优于插入排序。 以下是各种时间复杂度的对比。 由于快速排序在平均情况下表现优异，于是很多编程语言自带的排序函数都采用它来实现。因此一般你不需要自己写快速排序。但你可能需要学会写快速选择--它是一种类似快速排序的实用算法。 快速选择假设有一个无序的数组，你不需要将它排序，只要找出里面第10小的值，或第5大的值。就像从一堆测试成绩中找出第25百分位，或找出中等成绩那样。 你首先想到的，可能是把整个数组排序，然后再跳到对应的格子里去找。 但这样做的话，即使是用快速排序那样高效的算法，一般也需要O(N log N)。虽然这也不算差，但一种名为快速选择的算法可以做得更好。快速选择需要对数组分区，这跟快速排序类似，或者你可以把它想象成是快速排序和二分查找的结合。 如之前所述，分区的作用就是把轴排到正确的格子上。快速选择就利用了这一点。 例如要在一个长度为8的数组里，找出第2小的值。 先对整个数组分区。 轴很可能落到数组中间某个地方。 现在轴已安放在正确位置了，因为那是第5个格子，所以我们掌握了数组第5小的值是什么。虽然我们要找的是第2小的值，但刚才的操作足以让我们忽略轴右侧的那些元素，将查找范围缩小到轴左侧的子数组上。这看起来就像是不断地把查找范围缩小一半的二分查找。 然后，继续对轴左侧的子数组分区。 假设子数组的轴最后落到第3个格子上。 现在第3个格子的值已经确定了，该值就是数组第3小的值，第2小的值也就是它左侧的某个元素。于是再对它左侧的元素分区。 这次分区过后，最小和第 2小的元素也就能确定了。 这么一来，我们就可以拿出第2个格子的值，告诉别人找到第2小的元素了。快速选择的优势就在于它不需要把整个数组都排序就可以找到正确位置的值。 如果像快速排序那样，每次分区后还是要处理原数组那么多的数据，就会导致O(N log N)的步数。但快速选择不同，下一次的分区操作只需在上一次分出的一半区域上进行，即值可能存在的那一半。 分析快速选择的效率，你会发现它的平均情况是O(N)。回想每次分区的步数大约等于作用数组的元素量，你便可算出，对于一个含有 8个元素的数组，会有3次分区：第一次处理整个数组的8个元素，第二次处理子数组的4个元素，还有一次处理更小的子数组的2个元素。加起来就是8 + 4 + 2 = 14步。于是8个元素大概是14步。 如果是64个元素，就会是64 + 32 + 16 + 8 + 4 + 2 = 126步；如果是128个元素，就会是254步；如果是256个元素，就会是510步。 用公式来表达，就是对于N个元素，会有N + (N / 2) + (N / 4) + (N / 8) + … + 2步。结果大概是2N步。由于大O忽略常数，我们最终会说快速选择的效率为O(N)。 你可以把以下实现了快速选择的quickselect!方法加到刚才的SortableArray里。你会发现它跟quicksort!很像。1234567891011121314151617181920def quickselect!(kth_lowest_value, left_index, right_index) # 当子数组只剩一个格子——即达到基准情形时， # 那我们就找到所需的值了 if right_index - left_index &lt;= 0 return @array[left_index] end # 将数组分成两部分，并返回分隔所用的轴的索引 pivot_position = partition!(left_index, right_index) if kth_lowest_value &lt; pivot_position quickselect!(kth_lowest_value, left_index, pivot_position - 1) elsif kth_lowest_value &gt; pivot_position quickselect!(kth_lowest_value, pivot_position + 1, right_index) else # 至此 kth_lowest_value 只会等于 pivot_position # 如果分区后返回的轴的索引等于 kth_lowest_value， # 那这个轴就是我们要找的值 return @array[pivot_position] endend 想要从一个无序数组中找出第2小的值，可以运行如下代码。123array = [0, 50, 20, 10, 60, 30]sortable_array = SortableArray.new(array)p sortable_array.quickselect!(1, 0, array.length - 1) 此方法的第一个参数是查找的位置。因为数组索引从0开始算起，所以我们传入1来查找第2小的值。 总结由于运用了递归，快速排序和快速选择可以将棘手的问题解决得既巧妙又高效。这也提醒了我们，有些看上去很普通的算法，可能是经过反复推敲的高性能解法。 其实能递归的不只有算法，还有数据结构。后面几章将要接触的链表、二叉树以及图，就利用了自身递归的特性，给我们提供了迅速的数据操作方式。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第9章-递归]]></title>
    <url>%2F2018%2F06%2F10%2F%E7%AC%AC9%E7%AB%A0-%E9%80%92%E5%BD%92%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是递归？递归适用于什么场景？ 几乎所有循环都能够转换成递归怎么理解？ 什么是基准情形？ 如何阅读递归代码？ 什么是调用栈？递归发生时内存是怎么处理的？ 计算机处理3的阶乘的过程是什么样的？ 什么是栈溢出，为什么会发生？ 本章涵盖： 用递归代替循环 基准情形 阅读递归代码 计算机眼中的递归 递归实战 总结 在学习本书其余算法之前，你得先学会递归。解决很多看似复杂的问题时，如果从递归的角度去思考，会出人意料地简单，而且代码量还会大大减少。 不过，我们先做一个突击测试！ 运行一个定义如下的blah()函数，会发生什么？1234function blah() &#123; blah();&#125; 正如你所想的，blah()会调用blah()，后者也会调用blah()，于是就这样无限地调用下去。 函数调用自身，就叫作递归。无限递归用处不大，甚至还挺危险，但是有限的递归很强大。掌控好递归能帮助我们解决某些棘手的问题，我很快就会证明给你看。 用递归代替循环假设在NASA工作的你，需要写一个用于发射飞船的倒数程序。该程序接收一个数字，例如10，然后显示从10到0的数字。现在先暂停一下，选择一门编程语言来实现这个程序，做完以后，再往下阅读。 或许你用了JavaScript，并且写了如下循环。12345678function countdown(number) &#123; for(var i = number; i &gt;= 0; i--) &#123; console.log(i); &#125;&#125;countdown(10); 这样写没什么问题，只是你可能没想到循环以外的做法。 那还能怎么做呢？ 试试换成递归吧。以下是初级版的递归countdown 。123456function countdown(number) &#123; console.log(number); countdown(number - 1);&#125;countdown(10) 让我们一步步来分析。 第1步：调用countdown(10)，因此参数number为 10。 第2步：将number（值为10）打印到控制台。 第3步：countdown函数在结束前，调用了countdown(9)（因为number - 1等于 9）。 第4步：countdown(9)被执行，会将number（值为9）打印到控制台。 第5步：countdown(9)结束前，调用了countdown(8) 。 第6步：countdown(8)被执行，会将number（值为8）打印到控制台。 在继续步骤分解之前，先回顾下该递归是怎样实现我们的需求的。countdown里并没有任何循环结构，它通过调用自身就能够从10开始倒数并将每个数字打印出来。 几乎所有循环都能够转换成递归。但能用不代表该用。递归的强项在于巧妙地解决问题，但在上面的例子中，它并不比普通的循环更加优雅、高效。我们很快就会看到能让递归发挥威力的场景，但在那之前，还是先理清递归的运作方式。 基准情形让我们把countdown函数继续下去。为了简洁一点，我们跳过一些步骤。 第21步：调用countdown(0) 。 第22步：将number（值为0）打印到控制台。 第23步：调用countdown(-1) 。 第24步：将number（值为1）打印到控制台。 糟了，你也看到了，这种写法不够完善，这样下去我们就会不断地打印负数。 要解决这个问题，得在数到0时就停住，以免递归一直往下数。 我们可以加个条件判断，来保证当number为0时，不再调用countdown()。12345678910111213function countdown(number) &#123; console.log(number); if(number === 0) &#123; return; &#125; else &#123; countdown(number - 1); &#125;&#125;countdown(10); 这样，当number为0时，我们的代码就不会再去调用countdown()，而是直接返回。 在递归领域（真有这么一个地方），不再递归的情形称为基准情形。对于刚才的countdown()函数来说，0就是基准情形。 阅读递归代码递归是需要时间和练习才能适应的，到那时候，你会掌握两种技巧：阅读递归代码和编写递归代码。阅读递归代码相对简单一点，所以就先从这里入手吧。 我们会以阶乘作为例子。阶乘的演示如下所示。 3的阶乘是：3 2 1 = 6 5的阶乘是：5 4 3 2 1 = 120 以此类推。以下Ruby代码会以递归计算的方式返回一个数的阶乘。1234567def factorial(number) if number == 1 return 1 else return number * factorial(number - 1) endend 此代码初看可能会让人有点困惑，可以按照以下流程来读。 (1) 找出基准情形。 (2) 看该函数在基准情形下会做什么。 (3) 看该函数在到达基准情形的前一步会做什么。 (4) 就这样往前推，看每一步都在做什么。 让我们将此流程应用到刚才的代码上。稍作分析，就可以看出里面有两条路径。12345if number == 1 return 1else return number * factorial(number - 1)end 第二条路的factorial有调用自身，是递归发生的地方。123else return number * factorial(number - 1)end 第一条路并没有调用自身，因此这里是基准情形。12if number == 1 return 1 于是，number为1时，是基准情形。 接着，想象factorial方法在基准情形下，即factorial(1) 的处理流程。其相关代码如下。12if number == 1 return 1 好，这很简单，因为是基准情形，所以没有递归。调用factorial(1)就会直接返回1。于是找来一张纸，记下该结果。 然后，回到上一步的factorial(2)，相关代码如下。123else return number * factorial(number - 1)end 调用factorial(2)就会返回2 factorial(1) 。要计算2 factorial(1)，就得先知道factorial(1)的结果。要是检查下前面所记，你会发现那是1。因此，2 factorial(1)就是2 1 ，即是2。 把这个也记到纸上。 那么，factorial(3)又会是什么呢？再回看代码。123else return number * factorial(number - 1)end 代入参数便是3 factorial(2) 。那么factorial(2)是什么呢？你不用从头计算，因为它的结果已经写在纸上了，是2。于是factorial(3)会返回 6（3 2 = 6）。将结果记下，然后继续。 现在请自行计算factorial(4) 。 如你所见，这种从基准情形入手再往上分析的思路，对理解递归代码是多么有益。 事实上，此方法不仅为人类所利用，计算机也差不多是这样做的。下面就来看看。 计算机眼中的递归细想一下我们的factorial方法，你会发觉当factorial(3)执行时，会有如下事情发生。 计算机调用factorial(3)，并在该方法返回前，调用了factorial(2)，而在factorial(2)返回前，又调用了factorial(1)。从技术上来说，当计算机执行factorial(1)时，它其实还在factorial(2)之中，而factorial(2)又正在factorial(3)之中。 计算机是用栈来记录每个调用中的函数。这个栈就叫作调用栈。 让我们以factorial为例来观察调用栈如何运作。 起初计算机调用的是factorial(3)。然而，在该方法完成之前，它又调用了factorial(2)。为了记住自己还在factorial(3)中，计算机将此事压入调用栈中。 接着计算机开始处理factorial(2)。该factorial(2)会调用factorial(1)。不过在进入factorial(1)前，计算机得记住自己还在factorial(2)中，于是，它将此事也压入调用栈中。 然后计算机执行factorial(1)。因为1已经是基准情形了，所以它可以返回，不用再调用factorial。 尽管factorial(1)结束了，但调用栈内仍存在数据，意味着整件事还没完，计算机还处于其他函数当中。你应该还记得，栈的规定是只有栈顶元素（即最后的元素）才能被看到。所以，计算机接下来就去检查了调用栈的栈顶，发现那是factorial(2)。 由于factorial(2)是调用栈的最后一项，因此代表最近调用并且最应该先完成的是factorial(2)。 于是计算机将factorial(2)从调用栈弹出。 并将其结束。 然后计算机再次检查调用栈，看下一步应该结束哪个方法。调用栈如下所示。 于是计算机将factorial(3)从调用栈弹出，并将其结束。 到这里，调用栈就清空了，计算机也因此得知所有方法都执行完了，递归结束。 从更高的角度去看，可以看出计算机处理3的阶乘时，步骤如下。 (1)factorial(3)被第一个调用。 (2)factorial(2)被第二个调用。 (3)factorial(1)被第三个调用。 (4)factorial(1)被第一个完成。 (5)factorial(2)在factorial(1)的基础上完成。 (6)最后，factorial(3)在factorial(2)的基础上完成。 有趣的是，无限递归（如本章开头的例子）的程序会一直将同一方法加到调用栈上，直到计算机的内存空间不足，最终导致栈溢出的错误。 递归实战虽然上面的NASA倒数程序和阶乘计算能用递归来解决，但用普通的循环来做也不难。除了好玩以外，递归在这些问题上没体现出什么优势。 事实上，递归可以自然地用于实现那些需要重复自身的算法。在这些情况下，递归可以增强代码的可读性，你接下来就会看到。 比如说遍历文件系统。假设你现在要写一个脚本，它用于对一个目录下的所有文件进行某种操作。这里的“所有文件”，不仅指的是该目录中的文件，还包括其子目录的文件，以及子目录里的子目录的文件，以此类推。 我们先用Ruby写一个打印某目录下所有子目录名字的脚本。123456789def find_directories(directory) Dir.foreach(directory) do |filename| if File.directory?("#&#123;directory&#125;/#&#123;filename&#125;") &amp;&amp; filename != "." &amp;&amp; filename != ".." puts "#&#123;directory&#125;/#&#123;filename&#125;" end endend# 以当前目录为参数，调用 find_directoriesfind_directories(".") 此脚本遍历给定目录下的所有文件。当遇到的某个文件为子目录时（即文件类型为目录，但又不是代表“当前目录”“上级目录”的句号和双句号的那些文件），将其名字打印出来。 虽然这跑起来没问题，但它只打印了当前目录的直属子目录的名字，并没有打印出那些子目录的子目录的名字。 接着我们改进一下，使该脚本能再深入到下一层目录。1234567891011121314151617def find_directories(directory) # 遍历给定目录下的文件 Dir.foreach(directory) do |filename| if File.directory?("#&#123;directory&#125;/#&#123;filename&#125;") &amp;&amp; filename != "." &amp;&amp; filename != ".." puts "#&#123;directory&#125;/#&#123;filename&#125;" # 遍历其子目录下的文件 Dir.foreach("#&#123;directory&#125;/#&#123;filename&#125;") do |inner_filename| if File.directory?("#&#123;directory&#125;/#&#123;filename&#125;/#&#123;inner_filename&#125;") &amp;&amp;inner_filename != "." &amp;&amp; inner_filename != ".." puts "#&#123;directory&#125;/#&#123;filename&#125;/#&#123;inner_filename&#125;" end end end endend# 以当前目录为参数，调用 find_directoriesfind_directories(".") 这样，我们就可以对每个子目录再发起另一个循环去遍历其中的孙子目录了。不过，它只能进到两层目录的深度而已。如果我们还想进到第三层、第四层、第五层，甚至最底层，那要怎么做呢？以目前的思路似乎不可能实现。 这就是递归出马的时候了。使用递归的话，我们可以写一个进入任意深度的脚本，而且很简洁！1234567891011def find_directories(directory) Dir.foreach(directory) do |filename| if File.directory?("#&#123;directory&#125;/#&#123;filename&#125;") &amp;&amp; filename != "." &amp;&amp; filename != ".." puts "#&#123;directory&#125;/#&#123;filename&#125;" find_directories("#&#123;directory&#125;/#&#123;filename&#125;") end endend# 以当前目录为参数，调用 find_directoriesfind_directories(".") find_directories会对所遇到的每个子目录再调用find_directories 。这样一来，所有子目录都会被挖出来，没有一个会漏掉。 此算法如下图所示，其中的号码代表目录被访问的顺序。 注意，改用递归并不会改变算法的大O。但是，在下一章你会看到，递归可以作为算法的核心组件，影响算法的速度。 总结正如文件系统的例子所示，递归十分适用于那些无法预估计算深度的问题。 掌握递归，你就解锁了一批高效但更为高深的算法。它们都离不开递归的原理。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第8章-用栈和队列来构造灵巧的代码]]></title>
    <url>%2F2018%2F06%2F05%2F%E7%AC%AC8%E7%AB%A0-%E7%94%A8%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E6%9D%A5%E6%9E%84%E9%80%A0%E7%81%B5%E5%B7%A7%E7%9A%84%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 为什么栈和队列都是处理临时数据的灵活工具？ 栈的数据结构是什么样的？应用场景有哪些？ 队列的数据结构是什么样的？应用场景有哪些？ 本章涵盖： 栈 栈实战 队列 队列实战 迄今为止，我们对数据结构的讨论都集中于它们在各种操作上表现出的性能。但其实，掌握多种数据结构还有助于简化代码，提高可读性。 本章你将会学习两种新的数据结构：栈和队列。事实上它们并不是全新的东西，只不过是多加了一些约束条件的数组而已。但正是这些约束条件为它们赋予了巧妙的用法。 具体一点说，栈和队列都是处理临时数据的灵活工具。在操作系统、打印任务、数据遍历等各种需要临时容器才能构造出美妙算法的场景，它们都大有作为。 处理临时数据就像是点餐。在菜做好并送到客人手上之前，订单是有用的，但过后，你无须保留那张订单。临时数据就是一些处理完便不再有用的信息，因此没有保留的必要。此外，就像出菜时应先出给早下单的客人，你可能还得注意数据按什么顺序去处理。栈和队列就正好能把数据按顺序处理，并在处理完成后将其抛弃。 栈栈存储数据的方式跟数组一样，都是将元素排成一行。只不过它还有以下 3条约束。 只能在末尾插入数据。 只能读取末尾的数据。 只能移除末尾的数据。 你可以将栈看成一叠碟子：你只能看到最顶端那只碟子的碟面，其他都看不到。另外，要加碟子只能往上加，不能往中间塞，要拿碟子只能从上面拿，不能从中间拿（至少你不应该这么做）。绝大部分计算机科学家都把栈的末尾称为栈顶，把栈的开头称为栈底。 尽管这些约束看上去令人很拘束，但很快你就会发现它们带来的好处。 我们先从一个空栈开始演示。 往栈里插入数据，也叫作压栈。你可以想象把一个碟子压在其他碟子上的画面。 首先，将5压入栈中。 这没什么特别的，就如往数组插入数据一样平常。 接着，将3压入栈中。 再将0压入栈中。 注意，每次压栈都是把数据加到栈顶（也就是栈的末尾）。如果想把0插入到栈底或中间，那是不允许的，因为这就是栈的特性：只能在末尾插入数据。 从栈顶移除数据叫作出栈。这也是栈的限制：只能移除末尾的数据。 来把栈中的一些数据弹出。 首先，弹出0。 现在剩下两个元素，5和3。 接着，弹出3。 这就剩下5了。 压栈和出栈可被形容为LIFO（last in，first out）后进先出。解释起来就是最后入栈的元素，会最先出栈。就像无心向学的学生，最迟到校的总是他，最早回家的也是他。 栈实战栈很少用于需要长期保留数据的场景，却常用于各种处理临时数据的算法。 下面我们来写一个初级的JavaScript分析器--一种用来检查JavaScript代码的语法是否正确的工具。因为JavaScript的语法规则很多，所以它可以做得很复杂。简单起见，我们就只专注于检查括号的闭合情况吧，包括圆括号、方括号、花括号，这些地方搞错的话是很令人郁闷的。 在写之前，先分析一下括号的语法错误会有哪些情况。分类就是以下3种。 首先是有左括号没有右括号的情况。1(var x = 2; 这种归为第1类。 接着是没有左括号但有右括号的情况。1var x = 2;) 这种归为第2类。 还有第3类，右括号类型与其前面最近的左括号不匹配，例如：1(var x = [1, 2, 3)]; 此例中，虽然圆括号和方括号都左右成对出现，但位置不对，右圆括号前面最近的竟是左方括号。 那么怎样才能实现一种能检查一行代码里括号写得对不对的算法呢？用栈就好办了。 先准备一个空栈，然后从左至右读取代码的每一个字符，并执行以下规则。 (1) 如果读到的字符不是任一种括号（圆括号、方括号、花括号），就忽略它，继续下一个。 (2) 如果读到左括号，就将其压入栈中，意味着后面需要有对应的右括号来做闭合。 (3) 如果读到右括号，就查看栈顶的元素，并做如下分析。 如果栈里没有任何元素，也就是遇到了右括号但没有左括号，即第2类语法错误。 如果栈里有数据，但与刚才读到的右括号类型不匹配，那就是第3类语法错误。 如果栈顶元素是匹配的左括号，则表示它已经闭合。那么就可以将其弹出，因为已经不需要再记住它了。(4) 如果一行代码读完，栈里还留有数据，那就表示存在左括号，没有右括号与之匹配，即第1类语法错误。 让我们用以下代码作为例子来演示一遍。 备好一个空栈之后，就可以开始从左至右读取代码的每个字符了。 第1步：首先是第一个字符，它是一个左圆括号。 第2步：因为它是一个左括号，所以将其压入栈中。 接下来的var x = ，没有一个是括号，因此会被忽略。 第3步：遇到一个左花括号。 第4步：将其压入栈中。 然后忽略y:。 第5步：遇到一个左方括号。 第6步：同样把它压入栈中。 然后忽略1, 2, 3 。 第7步：这时我们第一次看到了右括号，是一个右方括号。 第8步：于是检查栈顶的元素，发现那是一个左方括号。因为刚才读到的右方括号能与其配对，所以将左方括号弹出。 第9步：继续，下一个读到的是右花括号。 第10步：检查栈里的最后一个元素，刚好是可以配对的左花括号。于是将其弹出。 第11步：读到一个右圆括号。 第12步：检查栈里的最后一个元素，刚好是可以配对的左圆括号。于是将其弹出，剩下一个空栈。 至此，代码读完了，栈也空着，所以我们的分析器可以定论，这段代码在括号方面没有语法错误。 以下是上述算法的Ruby实现。Ruby的数组自带push和pop方法，是在数组结尾插入和删除元素的便捷调用。只使用这两个方法的话，数组便形同于栈。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354class Linter attr_reader :error def initialize # 用一个普通的数组来当作栈 @stack = [] end def lint(text) # 循环读取文本的每个字符 text.each_char.with_index do |char, index| if opening_brace?(char) # 如果读到左括号，则将其压入栈中 @stack.push(char) elsif closing_brace?(char) if closes_most_recent_opening_brace?(char) # 如果读到右括号，并且它与栈顶的左括号匹配， # 则将栈顶弹出 @stack.pop else # 如果读到右括号，但它与栈顶的左括号不匹配 @error = "Incorrect closing brace: #&#123;char&#125; at index #&#123;index&#125;" return end end end if @stack.any? # 如果读完所有字符后栈不为空，就表示文中存在着没有相应右括号的左括号 @error = "#&#123;@stack.last&#125; does not have a closing brace" end end private def opening_brace?(char) ["(", "[", "&#123;"].include?(char) end def closing_brace?(char) [")", "]", "&#125;"].include?(char) end def opening_brace_of(char) &#123;")" =&gt; "(", "]" =&gt; "[", "&#125;" =&gt; "&#123;"&#125;[char] end def most_recent_opening_brace @stack.last end def closes_most_recent_opening_brace?(char) opening_brace_of(char) == most_recent_opening_brace endend 如果这样使用的话：123linter = Linter.newlinter.lint("( var x = &#123; y: [1, 2, 3] &#125; )")puts linter.error 因为该段代码语法正确，所以不会有错误信息打印出来。然而，要是不小心调转了最后两个字符：123linter = Linter.newlinter.lint("( var x = &#123; y: [1, 2, 3] ) &#125;")puts linter.error 就会出现以下信息。1Incorrect closing brace: ) at index 25 如果丢掉最后那个右括号：123linter = Linter.newlinter.lint("( var x = &#123; y: [1, 2, 3] &#125;")puts linter.error 就会出现如下的报错。1( does not have a closing brace 在刚才的例子中，栈被巧妙地用来跟踪那些还没有配对的左括号。到了下一章，我们会类似地用栈去跟踪函数的调用，那也是递归的核心思想。 当数据的处理顺序要与接收顺序相反时（LIFO），用栈就对了。像文字处理器的“撤销”动作，或网络应用程序的函数调用，你应该都会需要栈来实现。 队列队列对于临时数据的处理也十分有趣，它跟栈一样都是有约束条件的数组。区别在于我们想要按什么顺序去处理数据，而这个顺序当然是要取决于具体的应用场景。 你可以将队列想象成是电影院排队。排在最前面的人会最先离队进入影院。套用到队列上，就是首先加入队列的，将会首先从队列移出。因此计算机科学家都用缩写“FIFO”（first in, first out）先进先出，来形容它。 与栈类似，队列也有3个限制（但内容不同）。 只能在末尾插入数据（这跟栈一样）。 只能读取开头的数据（这跟栈相反）。 只能移除开头的数据（这也跟栈相反）。 下面来看看它是怎么运作的，先准备一个空队列。 首先，插入5（虽然栈的插入就叫压栈，但队列的插入却没有固定的叫法，一般可以叫放入、加入、入队）。 然后，插入9。 接着，插入100。 目前为止，队列表现得还跟栈一样，但要是移除数据的话，就会跟栈反着来了，因为队列是从开头移除数据的。 想移除数据，得先从5开始，因为开头就是它。 接着，移除9。 这样一来，队列就只剩下100了。 队列实战队列应用广泛，从打印机的作业设置，到网络应用程序的后台任务，都有队列的存在。 假设你正在用Ruby编写一个简单的打印机接口，以接收网络上不同计算机的打印任务。利用Ruby数组的push 方法，将数据加到数组末尾，以及 shift方法，将数据从数组开头移除。 你可以这样来编写接口类。123456789101112131415161718192021class PrintManager def initialize @queue = [] end def queue_print_job(document) @queue.push(document) end def run while @queue.any? # Ruby 的 shift 方法可移出并返回数组的第一个元素 print(@queue.shift) end end private def print(document) # 让打印机去打印文档（为了演示，暂时先打到终端上） puts document endend 然后这样使用它。12345print_manager = PrintManager.newprint_manager.queue_print_job("First Document")print_manager.queue_print_job("Second Document")print_manager.queue_print_job("Third Document")print_manager.run 接着打印机就会按3份文档的接收顺序来把它们打印出来。123First DocumentSecond DocumentThird Document 尽管这个例子把打印机的工作方式写得很抽象，简化了细节，但其中对队列基本用法的描述是真实的，以此为基础去构建真正的打印系统是可行的。 队列也是处理异步请求的理想工具--它能保证请求按接收的顺序来执行。此外，它也常用于模拟现实世界中需要有序处理事情的场景，例如飞机排队起飞、病人排队看医生。 总结如你所见，栈和队列是能巧妙解决各种现实问题的编程工具。 掌握了栈和队列，就解锁出了下一个目标：学习基于栈的递归。递归也是其他高级算法的基础，我们将会在本书余下的部分讲解它们。 数组与数据结构 在强类型编程语言中，有专用的数据结构解决方案。通常是创建一个容器，在这个容器中可以存储任意类型的数据，并且可以根据容器中存储的数据决定容器的容量，达到可以变长的容器结构，比如链表、堆栈和队列等都是数据结构中常用的形式。在PHP中，通常都是使用数组来完成其它语言使用数据结构才能完成的工作。它是弱类型语言，在同一个数组中就可以存储多种类型的数据，而且php中的数组没有长度限制，数组存储数据的容量还可以根据里面元素个数的增减自动调整。 1、使用数组实现堆栈 堆栈是数据结构的一种实现形式，数据存储时采用“先进后出”的数据结构。在php中，将数组当作一个栈使用array_push()和array_pop()两个函数即可完成数据的进栈和出栈操作。12--&gt;array_push():将一个或多个单元压入数组末尾（入栈），然后返回新组的长度。--&gt;array_pop():将数组最有一个单元弹出数组（出栈） 2、使用数组实现队列 队列是数据结构的一种实现形式，数据存储时采用“先进先出”的数据结构。在php中，将数组当作一个栈使用array_push()和array_shift()两个函数即可完成数据的队列操作。12--&gt;array_shift():将数组开头的单元移出数组，然后返回被删元素值。--&gt;array_shift():在数组开头插入一个或多个单元]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第7章-查找迅速的散列表]]></title>
    <url>%2F2018%2F06%2F02%2F%E7%AC%AC7%E7%AB%A0-%E6%9F%A5%E6%89%BE%E8%BF%85%E9%80%9F%E7%9A%84%E6%95%A3%E5%88%97%E8%A1%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 散列表是一种什么数据结构？优势在哪里？ 为什么查找值只要一步？ 什么是散列？什么是散列函数？ 散列函数需要满足什么条件？ 散列表是如何存储数据的？为什么会产生冲突？ 分离链接法是怎么解决冲突的？ 散列表的效率取决于什么因素？ 什么是负载因子？理想的负载因子是多少？ 本章涵盖： 探索散列表 用散列函数来做散列 一个好玩又赚钱的同义词典 处理冲突 找到平衡 一个实例 总结 试想你在写一个快餐店的点单程序，准备实现一个展示各种食物及相应价格的菜单。你可能会用数组来做（当然这没问题）。1menu = [ ["french fries", 0.75], ["hamburger", 2.5], ["hot dog", 1.5], ["soda", 0.6] ] 该数组由一些子数组构成，每个子数组包含两个元素。第一个元素是表示食物名称的字符串，第二个元素是该食物的价格。 就如第2章学到的，在无序的数组里查找某种食物的价格，得用线性查找，需要O(N)步。 有序数组则可以用二分查找，只需要O(log N)步。 尽管O(log N)也不错，但我们可以做得更好。事实上，可以好很多。到了本章结尾，你会掌握一种名为散列表的数据结构，只用O(1)步就能找出数据。理解此数据结构的原理以及其适用场景，你就能依靠其快速查找的能力来应对各种状况。 探索散列表大多数编程语言都自带散列表这种能够快速读取的数据结构。但在不同的语言中，它有不同的名字，除了散列表，还有散列、映射、散列映射、字典、关联数组。散列就是hash。 以下便是用Ruby的散列表来实现的菜单。1menu = &#123; "french fries" =&gt; 0.75, "hamburger" =&gt; 2.5, "hot dog" =&gt; 1.5, "soda" =&gt; 0.6 &#125; 散列表由一对对的数据组成。一对数据里，一个叫作键，另一个叫作值。键和值应该具有某种意义上的关系。如上例，”french fries”是键，0.75是值，把它们组成一对就表示“炸薯条的价格为75美分”。 在Ruby中，查找一个键所对应的值，语法是：1menu["french fries"] 这会返回值0.75。 在散列表中查找值的平均效率为O(1)，因为只要一步。下面来看看为什么。 用散列函数来做散列还记得你小时候创建和解析密文时用的密码吗？ 例如以下这种字母和数字的简单转化方式。12345A = 1B = 2C = 3D = 4E = 5 以此类推。 由此可得，ACE会转化为135，CAB会转化为312，DAB会转化为412，BAD会转化为214。 将字符串转为数字串的过程就是散列，其中用于对照的密码，就是散列函数。 当然散列函数不只是这一种，例如对各字母匹配的数字求和的过程，也可以作为散列函数。 按此函数来做的话，BAD就是7，过程如下。 第1步：BAD转成214。 第2步：把每一位数字相加，2 + 1 + 4 = 7。 散列函数也可以是对各字母匹配的数字求积的过程。这样的话，BAD就会得出8。 第1步：BAD转成214。 第2步：把每一位数字相乘，2 × 1 × 4 = 8。 本章剩余部分将会采用最后一种散列函数。虽然现实世界中的散列函数比这复杂得多，但以简单的乘法函数为例会比较易懂。 一个散列函数需满足以下条件才有效：每次对同一字符串调用该散列函数，返回的都应是同一数字串。如果每次都返回不一样的结果，那就无效。 例如，计算过程中使用随机数或当前时间的函数就不是有效的散列函数。这种函数会将BAD一下转成12，一下又转成106。 我们刚才的乘法函数就只会把BAD转成8。因为B总是2，A总是1，D总是4，2 × 1 × 4总会是8，不可能有其他输出。 注意，经由此函数转换，DAB也会得到8，跟BAD一样。这确实会带来一些问题，我们之后会说明。 认识了散列函数，就可以进一步学习散列表的运作了。 一个好玩又赚钱的同义词典假设工作之余，你还一个人秘密研发着一款将要征服世界的软件。那是一个同义词典，它叫Quickasaurus。你相信它势必一鸣惊人，因为它只会返回一个最常用的同义词，而不是像其他词典那样，返回所有的同义词。 因为每个词都有一个同义词，所以正好作为散列表的用例。毕竟，散列表就是一堆成对的元素。下面我们马上来开发。 该词典可以用一个散列表来表示。1thesaurus = &#123;&#125; 散列表可以看成是一行能够存储数据的格子，就像数组那样。每个格子都有对应的编号，如下所示。 现在往散列表里加入我们的第一条同义词。1thesaurus["bad"] = "evil" 散列表变成了下面这样。1&#123;"bad" =&gt; "evil"&#125; 再看看散列表是如何存储数据的。 首先，计算机用散列函数对键进行计算。为了方便演示，这里我们依然使用之前提及的那个乘法函数。1BAD = 2 * 1 * 4 = 8 “bad”的散列值为8，于是计算机将”evil”放到第8个格子里。 接着，我们再试另一对键值。1thesaurus["cab"] = "taxi" 同样地，计算机要计算散列值。1CAB = 3 * 1 * 2 = 6 因其结果为6，所以将”taxi”放到第6格。 再多加一对试试。1thesaurus["ace"] = "star" ACE的散列值为15（ACE = 1 × 3 × 5 = 15），于是”star”被放到第15格。 现在，用代码来表示这个散列表的话，就是这样：1&#123;"bad" =&gt; "evil", "cab" =&gt; "taxi", "ace" =&gt; "star"&#125; 既然散列表词典建好了，那就来看看从里面查词时会发生什么吧。假设现在要查”bad”的同义词，写成代码的话，如下所示。1thesaurus["bad"] 收到命令后，计算机就会进行如下两步简单的操作。 (1)计算这个键的散列值：BAD = 2 × 1 × 4 = 8。 (2)由于结果是 8，因此去到第8格并返回其中的值。在本例中，该值为 “evil” 。 这下你应该明白为什么从散列表里读取数据只需O(1)了吧，因为其过程所花的时间是恒定的。它总是先计算出键的散列值，然后根据散列值跳到对应的格子去。 现在总算理解为什么我们的快餐店菜单用散列表会比用数组要快了。当要查询某种食物的价格时，如果是用数组，那么就得一个格子一个格子地去找，直至找到为止。无序数组需要O(N)，有序数组需要O(log N)。但用散列表的话，我们就能够以食物作为键来做O(1)的查找。这就是散列表的好处。 处理冲突不过，散列表也会带来一些麻烦。 继续同义词典的例子：把下面这条同义词也加到表里，会发生什么呢？1thesaurus["dab"] = "pat" 首先，计算散列值。1DAB = 4 * 1 * 2 = 8 然后，将”pat”放进第8个格子。 噢，第8格已经是”evil”了，这的确不好（evil）。 往已被占用的格子里放东西，会造成冲突。幸好，我们有解决办法。 一种经典的做法就是分离链接。当冲突发生时，我们不是将值放到格子里，而是放到该格子所关联的数组里。 现在仔细观察该散列表的冲突位置。 因为要放入”pat”的第8格，已经存在”evil”了，于是我们将第8格的内容换成一个数组。 该数组又以子数组构成，每个子数组含两个元素，第一个是被检索的词，后一个是其相应的同义词。 下面运行一遍”dab”的查找过程，执行：1thesaurus["dab"] 计算机就会按如下步骤执行。(1)计算散列值DAB = 4 × 1 × 2 = 8。(2)读取第8格，发现其中不是一个单独的值，而是一个数组。(3)于是线性地在该数组中查找，检查每个子数组的索引0位置，如果碰到要找的词（”dab”），就返回该子数组的索引1的值。 再图形化地演示一次。 求得DAB的散列值为8，于是计算机读取第8格。 因为第8格里面是一个数组，所以对该数组进行线性查找。首先是第1格，它又是一个数组，于是查看这个子数组的索引0。 它并非我们要找的词（”dab”），于是跳到下一格。 这一格的子数组的索引0正是”dab”，因此其索引1的值就是我们要找的同义词（”pat”）。 若散列表的格子含有数组，因为要在这些数组上做线性查找，所以步数会多于1。如果数据都刚好存在同一个格子里，那么查找就相当于在数组上进行。因此散列表的最坏情况就是O(N)。 为了避免这种情况，散列表的设计应该尽量减少冲突，以便查找都能以O(1)完成。 接着，我们就来看一下现实中的散列表是如何做到的。 找到平衡归根到底，散列表的效率取决于以下因素。 要存多少数据。 有多少可用的格子。 用什么样的散列函数。 前两点很明显。如果要放的数据很多，格子却很少，就会造成大量冲突，导致效率降低。但为什么和散列函数本身也有关系呢？我们这就来看看。 假设你准备用一个散列值总是落在1至9之间的散列函数，例如，将字母转成其对应的序号，然后一直相加，直至结果只剩一位数字的函数。 就像这样：PUT = 16 + 21 + 20 = 57因为57不止一位数字，于是将57拆成5 + 7。5 + 7 = 1212也不止一位数字，于是拆成1 + 2。1 + 2 = 3最终，PUT的散列值为3。因为这种计算逻辑，该散列函数只会返回1到9的数字。 再回到散列表的样子。如果是用刚才的散列函数，那么该散列表的10到16号格子就都用不上了，数据只会被放到1到9的格子里。 所以，一个好的散列函数，应当能将数据分散到所有可用的格子里去。 如果一个散列表只需要保存5个值，那么它应该多大，以及采用什么散列函数呢？ 要是散列表只有5个格子，那么散列函数需要算出1到 5的散列值。但就算我们想保存的值也只有5个，冲突还是很可能发生，因为散列值只有5种可能。 然而，如果散列表有100个格子，散列函数的结果为1到100之间的数，存5个值进去时发生冲突的可能性就小得多，因为落入的格子有100种可能。 尽管100个格子能很好地避免冲突，但只用来放5个值的话，就太浪费空间了。 这就是使用散列表时所需要权衡的：既要避免冲突，又要节约空间。 要想解决这个问题，可参考计算机科学家研究出的黄金法则：每增加7个元素，就增加10个格子。 如果要保存14个元素，那就得准备20个格子，以此类推。 数据量与格子数的比值称为负载因子。把这个术语代入刚才的理论，就是：理想的负载因子是0.7（7个元素/10个格子）。 如果你一开始就将7个元素放进散列表，那么计算机应该会创建出一个含有10个格子的散列表。随着你添加元素，计算机也会添加更多的格子来扩展这个散列表，并改变散列函数，使新数据能均匀地分布到新的格子里去。 幸运的是，一般编程语言都自带散列表的管理机制，它会帮你决定散列表的大小、散列函数的逻辑以及扩展的时机。既然你已经理解了散列表的原理，那么在处理一些问题时你就可以用它取代数组，利用其O(1)的查找速度来提升代码性能。 一个实例散列表有各种用途，但目前我们只考虑用它来提高算法速度。 第1章我们学习了基于数组的集合--一种能保证元素不重复的数组。每次往其中插入新元素时，都要先做一次线性查找来确定该元素是否已存在（如果是无序数组）。 如果要在一个大集合上进行多次插入，效率将会下降得很快，因为每次插入都需要O(N)。 很多时候，我们都可以把散列表当成集合来用。 把数组作为集合的话，数据是直接放到格子里的。用散列表时，则是将数据作为键，值可以为任何形式，例如数字1，或者布尔值true也行。 假设在Javascript里建立了如下所示的散列表。1var set = &#123;&#125;; 并加入一些数据。123set["apple"] = 1;set["banana"] = 1;set["cucumber"] = 1; 这样每次插入新值，都只需花O(1)的时间，而不是线性查找的O(N)。即使数据已存在时也是这个速度。1set["banana"] = 1; 再次插入”banana”时，我们并不需要检查它存在与否，因为即使存在，也只是将其对应的值重写成1。 散列表确实非常适用于检查数据的存在性。第4章我们讨论过如何在Javascript 里检查一个数组有没有重复数据。一开始的方案如下所示。1234567891011121314function hasDuplicateValue(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; for(var j = 0; j &lt; array.length; j++) &#123; if(i !== j &amp;&amp; array[i] == array[j]) &#123; return true; &#125; &#125; &#125; return false;&#125; 当时我们说了，该嵌套循环的效率是O(N2)。 于是有了第二个O(N)的方案，不过它只能处理数据全为非负整数的数组。如果数组含有其他东西，例如字符串，那怎么办呢？ 使用类似的逻辑，但换成散列表（在Javascript里叫作对象），就可以处理字符串了。12345678910111213141516function hasDuplicateValue(array) &#123; var existingValues = &#123;&#125;; for(var i = 0; i &lt; array.length; i++) &#123; if(existingValues[array[i]] === undefined) &#123; existingValues[array[i]] = 1; &#125; else &#123; return true; &#125; &#125; return false;&#125; 这种方法也是O(N)，其中的existingValues不是数组而是散列表，用字符串作为键（索引）是没有问题的。 假设我们要做一个电子投票机，投票者可以投给现有的候选人，也可以推荐新的候选人。因为会在选举的最后统计票数，我们可以将票保存在一个数组里，每投一票就将其插入到末尾。12345var votes = [];function addVote(candidate) &#123; votes.push(candidate);&#125; 最终数组就会变得很长。1["Thomas Jefferson", "John Adams", "John Adams", "Thomas Jefferson", "John Adams", ...] 这样插入很快，只有O(1)。 那点票的效率又如何呢？因为票都在数组里，所以我们会用循环来遍历它们，并用一个散列表来记录每人的票数。12345678910111213141516function countVotes(votes) &#123; var tally = &#123;&#125;; for(var i = 0; i &lt; votes.length; i++) &#123; if(tally[votes[i]]) &#123; tally[votes[i]]++; &#125; else &#123; tally[votes[i]] = 1; &#125; &#125; return tally;&#125; 不过这样需要O(N)，也太慢了！ 不如换种方式，一开始就用散列表来收集票数。123456789101112131415161718var votes = &#123;&#125;;function addVote(candidate) &#123; if(votes[candidate]) &#123; votes[candidate]++; &#125; else &#123; votes[candidate] = 1; &#125;&#125;function countVotes() &#123; return votes;&#125; 这样一来，投票是O(1)，并且因为投票时就已经在计数，所以已完成了点票的步骤。 总结高效的软件离不开散列表，因为其O(1)的读取和插入带来了无与伦比的性能优势。 到现在为止，我们探讨各种数据结构时都只考虑了性能。但你知道有些数据结构的优点并不在于性能吗？下一章就研究两种能帮助改善代码可读性和可维护性的数据结构。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第6章-乐观地调优]]></title>
    <url>%2F2018%2F05%2F31%2F%E7%AC%AC6%E7%AB%A0-%E4%B9%90%E8%A7%82%E5%9C%B0%E8%B0%83%E4%BC%98%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 插入排序的第二层为什么是while循环？ 插入排序包含4种步骤：移除、比较、平移和插入。各需要多少步？ 用Python和C#实现插入排序。 冒泡排序、选择排序、插入排序都需要双循环吗？ 本章涵盖： 插入排序 插入排序实战 插入排序的实现 插入排序的效率 平均情况 之前我们衡量一个算法的效率时，都是着眼于它在最坏情况下需要多少步。原因很简单，连最坏的情况都做足准备了，其他情况自然不在话下。 然而，本章会告诉你最坏情况不是唯一值得考虑的情况。全面分析各种情况，能帮助你为不同场景选择适当的算法。 插入排序我们已经学过两种排序算法：冒泡排序和选择排序。虽然它们的效率都是O(N2)，但其实选择排序比冒泡排序快一倍。现在来学第三种排序算法--插入排序。你会发现，顾及最坏情况以外的场景将是多么有用。 插入排序包括以下步骤。 (1)在第一轮里，暂时将索引1（第2格）的值移走，并用一个临时变量来保存它。这使得该索引处留下一个空隙，因为它不包含值。 在之后的轮回，我们会移走后面索引的值。 (2)接着便是平移阶段，我们会拿空隙左侧的每一个值与临时变量的值进行比较。 如果空隙左侧的值大于临时变量的值，则将该值右移一格。 随着值右移，空隙会左移。如果遇到比临时变量小的值，或者空隙已经到了数组的最左端，就结束平移阶段。 (3)将临时移走的值插入当前空隙。 (4)重复第(1)至(3)步，直至数组完全有序。 插入排序实战下面尝试对[4, 2, 7, 1, 3]数组运用插入排序。 第1轮先从索引1开始，其值为2。 准备工作：暂时移走2，并将其保存在变量temp_value中。图中被移到数组上方的就是temp_value。 第1步：比较4与temp_value中的2。 第2步：因为4大于2，所以把4右移。 于是空隙移到了数组最左端，没有其他值可以比较了。 第3步：将temp_value插回数组，完成第一轮。 开始第2轮。 准备工作：暂时移走索引2的值，并保存到temp_value中。于是temp_value等于7。 第4步：比较4与temp_value 。 4小于7，所以无须平移。因为遇到了小于temp_value的值，所以平移阶段直接结束。 第5步：将temp_value插回到空隙中，结束第2轮。 开始第3轮。 准备工作：暂时移走1，并将其保存到temp_value中。 第6步：比较7与temp_value。 第7步：7大于1，于是将7右移。 第8步：比较4与temp_value。 第9步：4大于1，于是也要将4右移。 第10步：比较2与temp_value。 第11步：2比较大，所以将2右移。 第12步：空隙到了数组最左端，因此我们将temp_value插进去，结束这一轮。 开始第4轮。 准备工作：暂时移走索引4的值3，保存到temp_value中。 第13步：比较7和temp_value。 第14步：7更大，于是将7右移。 第15步：比较4与temp_value 。 第16步：4大于3，所以将4右移。 第17步：比较2与temp_value。2小于3，于是平移阶段完成。 第18步：把temp_value插回到空隙。 至此整个数组都排好序了。 插入排序的实现以下是插入排序的Python实现。12345678910def insertion_sort(array): for index in range(1, len(array)): position = index temp_value = array[index] while position &gt; 0 and array[position - 1] &gt; temp_value: array[position] = array[position - 1] position = position - 1 array[position] = temp_value 让我们来一步步地讲解。我会先摘出代码片段，然后给出解释。1for index in range(1, len(array)): 首先，发起一个从索引1开始的循环来遍历数组。变量 index保存的是当前索引。12position = indextemp_value = array[index] 接着，给position赋值为index，给temp_value赋值为index所指的值。123while position &gt; 0 and array[position - 1] &gt; temp_value: array[position] = array[position - 1] position = position - 1 然后在内部发起一个while循环，以检查position左侧的值是否大于temp_value。若是，则用array[position] = array[position - 1]将该值右移一格，并将position减1。然后继续检查新position左侧的值是否大于temp_value……如此重复，直至遇到的值比temp_value小。1array[position] = temp_value 最后，将temp_value放回到数组的空隙中。 插入排序的效率插入排序包含4种步骤：移除、比较、平移和插入。要分析插入算法的效率，就得把每种步骤都统计一遍。 首先看看比较。每次拿temp_value跟空隙左侧的值比大小就是比较。 在数组完全逆序的最坏情况下，我们每一轮都要将temp_value左侧的所有值与temp_value比较。因为那些值全都大于temp_value，所以每一轮都要等到空隙移到最左端才能结束。 在第一轮，temp_value为索引1的值，由于temp_value左侧只有一个值，所以最多进行一次比较。到了第二轮，最多进行两次比较，以此类推。到最后一轮时，就要拿temp_value以外的所有值与其进行比较。换言之，如果数组有N个元素，则最后一轮中最多进行N - 1次比较。 因而可以得出比较的总次数为：1 + 2 + 3 + … + N - 1次。 对于有 5个元素的数组，最多需要：1 + 2 + 3 + 4 = 10次比较。 对于有 10个元素的数组，最多需要：1 + 2 + 3 + 4 + 5 + 6 + 7 + 8 + 9 = 45次比较。 （对于有20个元素的数组，最多需要190次比较，以此类推。） 由此可发现一个规律：对于有N个元素的数组，大约需要N2/2次比较（102/2是50，202/2是200）。 接下来看看其他几种步骤。 我们每次将值右移一格，就是平移操作。当数组完全逆序时，有多少次比较就要多少次平移，因为每次比较的结果都会使你将值右移。 把最坏情况下的比较步数和平移步数相加。N2/2次比较 + N2/2次平移 = N2步 temp_value的移除跟插入在每一轮里都会各发生一次。因为总是有N - 1轮，所以可以得出结论：有N - 1次移除和N - 1次插入。 把它们都相加。 N2比较和平移的合计 + N - 1次移除 + N - 1次插入 = N2 + 2N - 2步 我们已经知道大O有一条重要规则--忽略常数，于是你可能会将其简化成O(N2 + N)。 不过，现在来学习一下大O的另一条重要规则： 大O只保留最高阶的N。 换句话说，如果有个算法需要N4 + N3 + N2 + N步，我们就只会关注其中的N4，即以O(N4)来表示。为什么呢？ 请看下表。 N N2 N3 N4 2 4 8 16 5 25 125 625 10 100 1000 10000 100 10000 1000000 1000000000 1000 1000000 1000000000 1000000000000 随着N的变大，N4的增长越来越抛离其他阶。当N为1000时，N4就比N3大了1000倍。因此，我们只关心最高阶的N。 所以在插入排序的例子中，O(N2 + N)还得进一步简化成O(N2)。 你会发现，在最坏的情况里，插入排序的时间复杂度跟冒泡排序、选择排序一样，都是O(N2)。 不过上一章曾指出，虽然冒泡排序和选择排序都是O(N2)，但选择排序实际上是N2/2步，比N2步的冒泡排序更快。乍一看，你可能会觉得插入排序跟冒泡排序一样，因为它们都是O(N2)，其实插入排序是N2 + 2N - 2步。 如果本书到此为止，你或许会认为比冒泡排序和插入排序快一倍的选择排序是三者中最优的，但事情并没有这么简单。 平均情况确实，在最坏情况里，选择排序比插入排序快。但是我们还应该考虑平均情况。 为什么呢？ 所谓平均情况，就是那些最常遇见的情况。最坏情况和最好情况都是不常见的。看下面这个钟形的曲线。 最好情况和最坏情况很少发生。现实世界里，最常出现的是平均情况。 这是很有道理的。你设想一个随便洗乱的数组，出现完全升序或完全降序的可能性有多大？ 最可能出现的情况应该是随机分布。 下面试试在各种场景中测试插入排序。 完全降序的最坏情况之前已经见过，它每一轮都要比较和平移所遇到的值（这两种操作合计N2步）。 对于完全升序的最好情况，因为所有值都已在其正确的位置上，所以每一轮只需要一次比较，完全不用平移。 但若是随机分布的数组，你就可能要在一轮里进行比较并平移所有数据、部分数据，或无须平移。回头看看之前步骤分解的例子，可以发现在第 1、3轮，我们比较并平移了所有遇到的数据。在第4轮，我们只对部分数据进行了操作。在第2轮，则没有平移，只有一次比较。 最坏情况是所有数据都要比较和平移；最好情况是每轮一次比较、零次平移；对于平均情况，总的来看，是比较和平移一半的数据。 如果说插入排序的最坏情况需要N2步，那么平均情况就是N2/2步。尽管最终大O都会写成O(N2)。 来看一些具体的例子。 最好情况就像[1 ,2, 3, 4]，已经预先排好序。用同样的数据，最坏情况就是[4, 3, 2, 1] 。 平均情况，则如[1, 3, 4, 2] 。 这里的最坏情况需要6次比较和6次平移，共12步。平均情况需要4次比较和2次平移，共6步。最好情况是3次比较、0次平移。 可以看到插入排序的性能在不同场景中差异很大。最坏、平均、最好情况，分别需要N2、N2/2、N步。 这是由于有些轮次需要比较temp_value左侧的所有值，有些轮次却因为遇到了小于temp_value的值而提早结束。 3种情况的步数如下图所示。 再跟选择排序对比一下。选择排序是无论何种情况，最坏、平均、最好，都要N2/2步。 因为这个算法没有提早结束某一轮的机制，不管遇到什么，每一轮都得比较所选索引右边的所有值。 那么哪种算法更好？选择排序还是插入排序？答案是：看情况。对于平均情况（数组里的值随机分布），它们性能相近。如果你确信数组是大致有序的，那么插入排序比较好。如果是大致逆序，则选择排序更快。如果你无法确定数据是什么样，那就算是平均情况了，两种都可以。 一个实例假设你在写一个Javascript应用，你需要找出其中两个数组的交集。所谓交集，就是两个数组都有的值所组成的集合。举个例子，[3, 1, 4, 2]和[4, 5, 3, 6]的交集为[3, 4]，因为两个数组都有3和4。 Javascript并没有自带求交集的函数，因此我们只能自己写一个。以下是其中一种写法。1234567891011121314151617function intersection(first_array, second_array)&#123; var result = []; for (var i = 0; i &lt; first_array.length; i++) &#123; for (var j = 0; j &lt; second_array.length; j++) &#123; if (first_array[i] == second_array[j]) &#123; result.push(first_array[i]); &#125; &#125; &#125; return result;&#125; 它运用了一个简单嵌套循环。外部循环用来遍历第一个数组，并在每遇到一个值时，就发起内部循环去检查第二个数组有没有值与其相同。 此算法有两种步骤：比较和插入。也就是将两个数组的所有值相互比较，并把相同的值插入到result。插入的步数微不足道，因为即使两个数组完全一致，步数也不过是其中一个数组的数据量。所以这里主要考虑的是比较。 要是两个数组同样大小，那么比较需要N2步。这是因为数组一的每个值，都要与数组二的每个值进行对比。于是，两个数据量都为5的数组，最终会比较25次。这种算法效率为O(N 2)。 （如果数组大小不一，比如说分别含N、M个元素，那么此过程的步数就是O(N × M)，但简单起见，就当它们大小一样吧。） 那能不能改进一下呢？ 这就是为什么我们不能只考虑最坏情况的原因了。以现在的intersection函数的实现，无论遇到什么情况都是O(N2)的，不管你输入的两个数组完全不同还是完全相同。 如果两个数组真的没有交集，那你别无选择，只能检查完每个值才能确定。 但若是二者有交集，我们其实不用拿数组一的每个值去跟数组二的每个值对比。下面我就来解释为什么。 在以上例子中，一旦找到一个共有的值（8），那就没必要跑完内部循环了。再跑下去是为了检查什么呢？既然知道数组二中也存在数组一的那个值这就够了。 要改进的话，加一个命令就可以。123456789101112131415161718function intersection(first_array, second_array)&#123; var result = []; for (var i = 0; i &lt; first_array.length; i++) &#123; for (var j = 0; j &lt; second_array.length; j++) &#123; if (first_array[i] == second_array[j]) &#123; result.push(first_array[i]); break; &#125; &#125; &#125; return result;&#125; break可以中断内部循环，节省步数和时间。 这样的话，在没有交集的最坏情况下，我们仍然要做N2次比较；在数组完全一样的最好情况下，就只需要N次比较；在数组不同但有部分重复的平均情况下，步数会介于N到N2之间。 其性能提升是很明显的，因为在最初的实现里，无论什么情况，步数都是N2。 总结懂得区分最好、平均、最坏情况，是为当前场景选择最优算法以及给现有算法调优以适应环境变化的关键。记住，虽然为最坏情况做好准备十分重要，但大部分时间我们面对的是平均情况。 下一章我们会学习一种跟数组类似的数据结构，它的一些特点使其在某些场景中的性能优于数组。就像现在你得根据需求选择合适的算法，数据结构的性能也有差异，你也需要为此做出选择。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第5章-用或不用大O来优化代码]]></title>
    <url>%2F2018%2F05%2F29%2F%E7%AC%AC5%E7%AB%A0-%E7%94%A8%E6%88%96%E4%B8%8D%E7%94%A8%E5%A4%A7O%E6%9D%A5%E4%BC%98%E5%8C%96%E4%BB%A3%E7%A0%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 选择排序算法是怎么样的？是两层循环吗？用js实现选择排序算法。 选择排序的步骤可分为两类：比较和交换，次数分别是什么样？ 选择排序比冒泡排序快在哪里？ 选择排序的效率如何？ 为什么两种算法的大O记法完全一样，但实际上其中一个比另一个要快得多？ 大O记法忽略常数是什么意思？ 本章涵盖： 选择排序 选择排序实战 选择排序的实现 选择排序的效率 忽略常数 大O的作用 大O是一种能够比较算法效率，并告诉我们在特定环境下应采用何种算法的伟大工具。但我们不能完全依赖于它。因为有时候即使两种算法的大O记法完全一样，但实际上其中一个比另一个要快得多。 本章我们就来学习如何分辨那些效率貌似一样的算法，从而选出较快的那个。 选择排序上一章分析了冒泡排序算法，其效率是O(N2)。现在我们再来探索另一种排序算法，选择排序，并将它跟冒泡排序对比一下。 选择排序的步骤如下： (1)从左至右检查数组的每个格子，找出值最小的那个。在此过程中，我们会用一个变量来记住检查过的数字的最小值（事实上记住的是索引，但为了看起来方便，下图就直接写出数值）。如果一个格子中的数字比记录的最小值还要小，就把变量改成该格子的索引，如图所示。 (2)知道哪个格子的值最小之后，将该格与本次检查的起点交换。第1次检查的起点是索引0，第2次是索引1，以此类推。下图展示的是第一次检查后的交换动作。 (3)重复第(1)(2)步，直至数组排好序。 选择排序实战以数组[4,2,7,1,3]为例，步骤如下。 开始第1轮检查。 首先读取索引0。根据此算法的定义，它是目前遇到的最小值（因为现在只检查了一个格子），于是记下其索引。 第1步：将索引1的值2与目前的最小值4进行比较。 2比4还要小，于是将目前的最小值改为2。 第2步：再与下一个值做比较。因为7大于2，所以最小值还是2。 第3步：将1和目前的最小值做比较。 1比2还要小，于是目前的最小值更新为1。 第4步：比较3和目前的最小值1。因为现在已经走到数组尽头了，所以可以断定1是整个数组的最小值。 第5步：本次检查的起点是索引0，不管那里的值是什么，我们都应该将最小值1换到那里。 现在1就排到正确的位置上了。 可以开始第2轮检查了。 准备工作：因为索引0的值已符合其排位，所以这一轮从下一个格子开始，即索引1，其值为2，也是目前本轮所遇到的最小值。 第6步：将7跟目前的最小值2进行比较。因为2小于7，所以最小值仍为2。 第7步：将4跟目前的最小值2进行比较。因为2小于4，所以最小值仍为2。 第8步：将3跟目前的最小值2进行比较。因为2小于3，所以最小值仍为2。 又走到数组尽头了。本轮不需要做任何交换，2已在其正确位置上。于是第2轮检查结束，现在数组如下图所示。 开始第3轮检查。 准备工作：从索引2起，其值为7。于是本轮目前最小值为7。 第9步：比较4与7。 将4记为目前的最小值。 第10步：遇到3，它比4还小。 于是3成了目前的最小值。 第11步：到数组尽头了，将3跟本轮起点7进行交换。 于是3排到正确位置上了。 虽然我们可以看到现在整个数组都有序了，但计算机是看不到的，它只会继续第4轮检查。 准备工作：此轮检查从索引3开始，其值4是目前的最小值。 第12步：比较4和7。 4仍为最小值，而且它也处于本轮起点，因此无须任何交换。 因为最后一个格子左侧的那些值都已在各自的正确位置上，所以最后一格也必然正确，于是排序结束。 选择排序的实现以下是用Javascript写的选择排序。123456789101112131415161718192021222324function selectionSort(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; var lowestNumberIndex = i; for(var j = i + 1; j &lt; array.length; j++) &#123; if(array[j] &lt; array[lowestNumberIndex]) &#123; lowestNumberIndex = j; &#125; &#125; if(lowestNumberIndex != i) &#123; var temp = array[i]; array[i] = array[lowestNumberIndex]; array[lowestNumberIndex] = temp; &#125; &#125; return array;&#125; 让我们来一行行地分析。我会先摘出代码片段，然后给出解释。1for(var i = 0; i &lt; array.length; i++) &#123;&#125; 这个外层的循环代表每一轮检查。在一轮检查之初，我们会先记住目前的最小值的索引。1var lowestNumberIndex = i; 因此每轮开始时lowestNumberIndex都会是该轮的起点索引i。注意我们实际上记录的是最小值的索引，而非最小值本身。于是，第1轮开始时最小值的索引是0，到第2轮则是1，以此类推。1for(var j = i + 1; j &lt; array.length; j++) &#123;&#125; 此行代码发起一个以i + 1开始的内层循环。1234if(array[j] &lt; array[lowestNumberIndex]) &#123; lowestNumberIndex = j;&#125; 循环内逐个检查数组未排序的格子，若遇到比之前记录的本轮最小值还小的格子值，就将lowestNumberIndex更新为该格子的索引。 内层循环结束时，会得到未排序数值中最小值的索引。123456if(lowestNumberIndex != i) &#123; var temp = array[i]; array[i] = array[lowestNumberIndex]; array[lowestNumberIndex] = temp;&#125; 然后再看看这个最小值是否已在正确位置，即该索引是否等于i。如果不是，就将i所指的值与最小值交换。 选择排序的效率选择排序的步骤可分为两类：比较和交换，也就是在每轮检查中把未排序的值跟该轮已遇到的最小值做比较，以及将最小值与该轮起点的值交换以使其位置正确。 在之前5个元素的例子里，我们总共进行了10次比较。每轮分别如下。 第#轮 #次比较 1 4 2 3 3 2 4 1 于是4 + 3 + 2 + 1 = 10次比较。 推广开来，若有N个元素，就会有(N - 1) + (N - 2) + (N - 3) + … + 1次比较。 但每轮的交换最多只有1次。如果该轮的最小值已在正确位置，就无须交换，否则要做1次交换。相比之下，冒泡排序在最坏情况（完全逆序）时，每次比较过后都要进行1次交换。 下表为冒泡排序和选择排序的并列对比。 N个元素 冒泡排序最多要#步 选择排序最多要#步 5 20 14(10次比较 + 4次交换) 10 90 54(45次比较 + 9次交换) 20 380 199(180次比较 + 19次交换) 40 1560 819(780次比较 + 39次交换) 80 6320 3239(3160次比较 + 79次交换) 从表中可以清晰地看到，选择排序的步数大概只有冒泡排序的一半，即选择排序比冒泡排序快一倍。 忽略常数但有趣的是，选择排序的大O记法跟冒泡排序是一样的。 还记得我们说过，大O记法用来表示步数与数据量的关系。所以你可能会以为步数约为N2的一半的选择排序，其大O会写成O(N2/2)，以表示N个元素需要N2/2步。如下表所示。 N个元素 N2/2 选择排序最多要#步 5 52 / 2 = 12.5 14 10 102 / 2 = 50 54 20 202 / 2 = 200 199 40 402 / 2 = 800 819 80 802 / 2 = 3200 3239 但事实上，选择排序的大O记法为O(N2)，跟冒泡排序一样。这是因为大O记法的一条重要规则我们至今还没提到： 大O记法忽略常数。 换一种不那么数学的表达方式，就是：大O记法不包含一般数字，除非是指数。 如刚才的例子，严格来说本应为O(N2/2)，最终得写成O(N2)。类似地，O(2N)要写成O(N)；O(N/2)也写成O(N)；就算是比O(N)慢100倍的O(100N)，也要写成O(N)。 速度相差100倍的两种算法，它们的大O记法却一样，这或许会让人觉得大O没什么意义。就像同为O(N)的选择排序和冒泡排序，其实前者比后者快1倍，要在二者之中挑选，无疑是用选择排序。 那么，大O还凭什么值得我们学习呢？ 大O的作用尽管不能比较冒泡排序和选择排序，大O还是很重要的，因为它能够区分不同算法的长期增长率。当数据量达到一定程度时，O(N)的算法就会永远快过O(N2)，无论这个O(N)实际上是O(2N)还是O(100N)。即使是O(100N)，这个临界点也是存在的。（第3章在比较一个100步的算法与O(N)算法时，也提过这个概念，不过这次我们会用另一个例子来讲解。） 下图为O(N)和O(N2)的对比。 此图在上一章里出现过。它显示了不管数据量是多少，O(N)总是快过O(N2)。 在第二幅图中，我们看到当数据量少于某个值时，O(N2)是比O(100N)要快的，但过了这个值之后，O(100N)便反超O(N2)，并一直保持优势。 这就是大O记法忽略常数的原因。大O记法只表明，对于不同分类，存在一临界点，在这一点之后，一类算法会快于另一类，并永远保持下去。至于这个点在哪里，大O并不关心。 因此，不需要写成O(100N)，归类到O(N)就好了。 同样地，在数据量增大到某个点时，O(log N)便会永远超越O(N)，即使该O(log N)算法的实际步数为O(2log N)。 所以大O是极为有用的工具，当两种算法落在不同的大O类别时，你就很自然地知道应该选择哪种。因为在大数据的情况下，必然存在一临界点使这两种算法的速度永远区分开来。 不过，本章的主要结论是即使两种算法的大O记法一样，但实际速度也可能并不一样。虽然选择排序比冒泡排序快1倍，但它们的大O记法都是O(N2)。因此，大O记法非常适合用于不同大O分类下的算法的对比，对于大O同类的算法，我们还需要进一步的解析才能分辨出具体差异。 一个实例假设你要写一个Ruby程序，从一个数组里取出间隔的元素，来组成新的数组。你可能会用数组的each_with_index方法来做如下遍历。 123456789def every_other(array) new_array = [] array.each_with_index do |element, index| new_array &lt;&lt; element if index.even? end return new_arrayend 它迭代原数组的每一个元素，如果元素索引值为偶数，则将该元素插入到新数组里。 分析其中步骤，会发现它们可分为两种：一种是读取数组元素，另一种是插入元素到新数组。 因为要读取数组的每一个元素，所以读取有N步。插入则只有N/2步，因为只有间隔的元素才被放到新数组里。从技术上来说，N次读取加N/2次插入，这算法的效率应该是O(N+(N/2))，或者是O(1.5N)。但因为大O记法要把常数丢掉，所以只写成O(N)。 此算法虽然能达到效果，但我们还是要再审视一下它有没有提升的空间。事实上，有。 与其迭代每个元素并检查它们的索引是否为偶数，不如只读取数组中间隔的元素。123456789def every_other(array) new_array = [] index = 0 while index &lt; array.length new_array &lt;&lt; array[index] index += 2 end return new_arrayend 这种做法的while循环会跳过间隔的元素，因此避免了检查每个元素。结果就是有N个元素，会有N/2次读取，N/2次插入。它跟第一种做法一样，记为O(N)。 然而，第一种做法实际有1.5N步，比只有N步的第二种明显要慢。虽然第一种的写法在Ruby界更为惯用，但如果要处理的数据量庞大，不妨尝试第二种，以获得性能的飞升。 总结现在我们已经掌握了一些非常强大的算法分析手法。我们能够使用大O去判断各种算法的效率，即便两种算法的大O记法一样，也知道如何对比它们。 不过在对比算法时，还需要考虑一个重要因素。至今我们关注的都是最坏情况下算法会跑得多慢，但其实最坏情况并不总会发生。没错，我们遇到的大都是平均情况。下一章，我们会学习怎样顾及所有情况。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第4章-运用大O来给代码提速]]></title>
    <url>%2F2018%2F05%2F28%2F%E7%AC%AC4%E7%AB%A0-%E8%BF%90%E7%94%A8%E5%A4%A7O%E6%9D%A5%E7%BB%99%E4%BB%A3%E7%A0%81%E6%8F%90%E9%80%9F%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 冒泡排序为什么叫冒泡排序？冒泡排序的大O记法是什么？为什么？ 冒泡排序的执行步骤是哪两步？图是什么样的？也叫作什么？ 嵌套循环算法的效率是怎么样的？ 检查数组中是否有重复值怎么进行线性解决？ 本章涵盖： 冒泡排序 冒泡排序实战 冒泡排序的实现 冒泡排序的效率 二次问题 线性解决 大O记法能客观地衡量各种算法的时间复杂度，是比较算法的利器。我们也试过用它来对比二分查找和线性查找的步数差异，发现二分查找的步数为O(log N)，比线性查找的O(N)快得多。 然而，写代码的时候并不总有这样明确的二选一，更多时候你可能就直接采用首先想到的那种算法了。不过有了大O的话，你就可以与其他常用的算法比较，然后问自己：“我的算法跟它们相比，是快还是慢？” 如果你通过大O发现自己的算法比其他的要慢，你就应该退一步，好好想想怎样优化它，才能使它变成更快的那种大O。虽然并不总有提升空间，但在确定编码之前多加考虑还是好的。 本章我们会写些代码来解决一个实际问题，并且会用大O来测量算法的性能，然后看看是否能对算法做些修改，使得性能提升。（剧透：能。） 冒泡排序但在讨论实际问题之前，先来学习一种新的时间复杂度。我们会从计算机科学的经典算法之一开始阐述。 排序算法是计算机科学中被广泛研究的一个课题。历时多年，它发展出了数十种算法，这些算法都着眼于一个问题： 如何将一个无序的数字数组整理成升序？ 你会在本章以及下一章看到这些算法。起初我们会学习一些“简单排序”，它们很好懂，但效率不如其他排序算法。 冒泡排序是一种很基本的排序算法，步骤如下。 (1)指向数组中两个相邻的元素（最开始是数组的头两个元素），比较它们的大小。 (2)如果它们的顺序错了（即左边的值大于右边），就互换位置。 如果顺序已经是正确的，那这一步就什么都不用做。 (3)将两个指针右移一格。 重复第(1)步和第(2)步，直至指针到达数组末尾。 (4)重复第(1)至(3)步，直至从头到尾都无须再做交换，这时数组就排好序了。 这里被重复的第(1)至(3)步是一个轮回，也就是说，这个算法的主要步骤被“轮回”执行，直到整个数组的顺序正确。 冒泡排序实战下面来举一个完整的例子。假设要对[4, 2, 7, 1, 3]进行排序。它现在是无序的，我们的目标是产生一个包含相同元素、升序的数组。 开始第1次轮回。 数组一开始如下图所示。 第1步：首先，比较4和2。如图可见它们的顺序是错的。 第2步：交换它们的位置。 第3步：比较4和7。 它们的顺序正确，所以不用做什么交换。 第4步：比较7和1。 第5步：顺序错误，于是进行交换。 第6步：比较7和3。 第7步：顺序错误，于是进行交换。 因为我们一直把较大的元素换到右边，所以现在最右侧的7正处于其正确位置上。我将那个格子用虚线圈起来了。 这也正是此种算法名为冒泡排序的原因：每一次轮回过后，未排序的值中最大的那个都会“冒”到正确的位置上。 因为刚才那次轮回做了不止一次的交换，所以得继续轮回。 下面来第2次轮回。 此时7已经在正确的位置上了。 第8步：从比较2和4开始。 它们已经按顺序排好了，所以直接进行下一步。 第9步：比较4和1。 第10步：它们的顺序错误，于是交换。 第11步：比较4和3。 第12步：顺序错误，进行交换。 因为7已经在上一次轮回里排好了，所以无须比较4和7。此外，4移到了正确的位置，本次轮回结束。因为这次轮回也做了不止一次的交换，所以得继续轮回。 下面来第3次轮回。 第13步：比较2和1。 第14步：顺序错误，进行交换。 第15步：比较2和3。 顺序正确，不用交换。 这时3也“冒”到其正确位置了。因为这次轮回做了不止一次的交换，所以还要继续。 于是开始第4次轮回。 第 16步：比较1和2。 顺序正确，不用交换。而且剩下的元素也都排好序了，轮回结束。 因为刚才的轮回没有任何交换，可知整个数组都已排好序。 冒泡排序的实现以下是用Python写的冒泡排序。1234567891011121314def bubble_sort(list): unsorted_until_index = len(list) - 1 sorted = False while not sorted: sorted = True for i in range(unsorted_until_index): if list[i] &gt; list[i+1]: sorted = False list[i], list[i+1] = list[i+1], list[i] unsorted_until_index = unsorted_until_index - 1list = [65, 55, 45, 35, 25, 15, 10]bubble_sort(list)print list 让我们来一行行地分析。我会先摘出代码片段，然后给出解释。1unsorted_until_index = len(list) - 1 变量unsorted_until_index表示“该索引之前的数据都没排过序”。一开始整个数组都是没排过序的，所以此变量赋值为数组的最后一个索引。1sorted = False 另外还有一个sorted变量，被用来记录数组是否已完全排好序。当然一开始它应该是False 。12while not sorted: sorted = True 接着是一个while循环，除非数组排好了序，不然它不会停下来。然后，我们先将sorted初步设置为True。当发生任何交换时，我们会将其改为False。如果在一次轮回里没有做过交换，那么sorted就确定为True，我们知道数组已排好序了。1234for i in range(unsorted_until_index): if list[i] &gt; list[i+1]: sorted = False list[i], list[i+1] = list[i+1], list[i] 在while循环里，还有一个for循环会迭代未排序元素的索引值。此循环中，我们会比较相邻的元素，如果有顺序错误，就会进行交换，并将sorted改为False 。1unsorted_until_index = unsorted_until_index - 1 到了这一行，就意味着一次轮回结束了，同时该次轮回中冒泡到右侧的值处于正确位置。因为unsorted_until_index所指的位置已放上了正确的元素，所以减1，以便下一次轮回能略过该位置。 一次while 循环就是一次轮回，循环会持续直至sorted确定为True 。 冒泡排序的效率冒泡排序的执行步骤可分为两种。 比较：比较两个数看哪个更大。 交换：交换两个数的位置以使它们按顺序排列。 先看看冒泡排序要进行多少次比较。 回顾之前那个5个元素的数组，你会发现在第1次轮回我们为4对元素进行了4次比较。 到了第2次轮回，则只做了3次比较。这是因为第1次轮回已经确定了最后一个格子的元素，所以不用再比较最后两个元素了。 第3次轮回，只比较2次；第4次，只比较1次。 算起来就是： 4 + 3 + 2 + 1 = 10 次比较。 推广到N个元素，需要 (N - 1) + (N - 2) + (N - 3) + … + 1次比较。 分析过比较之后，再来看看交换。 如果数组不只是随机打乱，而是完全反序，在这种最坏的情况下，每次比较过后都得进行一次交换。因此10次比较加10次交换，总共20步。 现在把两种步骤放在一起来看。一个含有10个元素的数组，需要： 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 45次比较，以及45次交换，共90步。 20个元素的话，就是： 19 + 18 + 17 + 16 + 15 + 14 + 13 + 12 + 11 + 10 + 9 + 8 + 7 + 6 + 5 + 4 + 3 + 2 + 1 = 190次比较，以及190次交换，共380步。 效率太低了。元素量呈倍数增长，步数却呈指数增长，如下表所示。 N个元素 最多步数 5 20 10 90 20 380 40 1560 80 6320 再看仔细一点，你会发现随着N的增长，步数大约增长为N2 。 N个元素 最多步数 N2 5 20 25 10 90 100 20 380 400 40 1560 1600 80 6320 6400 因此描述冒泡排序效率的大O记法，是O(N2)。 规范一些来说：用O(N2)算法处理N个元素，大约需要N2步。 O(N2)算法是比较低效的，随着数据量变多，其步数也剧增，如下图所示。 注意O(N2)代表步数的曲线非常陡峭，O(N)的则只呈对角线状。 最后一点：O(N2)也被叫作二次时间。 二次问题假设你正在写一个JavaScript应用，它要检查数组中是否有重复值。 首先想到的做法可能是类似下面的嵌套for循环。123456789101112131415function hasDuplicateValue(array) &#123; for(var i = 0; i &lt; array.length; i++) &#123; for(var j = 0; j &lt; array.length; j++) &#123; if(i !== j &amp;&amp; array[i] == array[j]) &#123; return true; &#125; &#125; &#125; return false;&#125; 此函数用var i来遍历数组元素。每当i指向下一元素时，我们又发起第二个for循环，用var j来遍历数组元素，并在这第二个循环过程中检查i和j两个位置的值是否相同。若相同，则表示数组有重复值。如果两层循环都没遇到重复值，则最终返回false，以示数组没有重复值。 虽然可以这么做，但它的效率高吗？既然我们学过一点大O记法，那么就试试用大O来评价一下这个函数吧。 记住，大O测量的是步数与数据量的关系。因此，我们要测的就是：给hasDuplicateValue函数传入一个含有N个元素的数组，最坏情况下需要多少步才能完成。 要回答这个问题，得先搞清楚这个函数有哪些步骤，以及其最坏情况是什么。 该函数只有一种步骤，就是比较。它重复地比较i和j所指的值，看它们是否相等，以判断数组有没有重复值。最坏的情况就是没有重复，这将使我们跑遍内外两层循环，比较完所有i、j组合，才返回false 。 由此可知N个元素要比较N2次。因为外层循环需要N步来遍历数组，而这里的每1步，又会发起内层循环去用N步遍历数组。所以N步乘以N步等于N2步，此函数为一个O(N2)算法。 想要证明的话，还可以往函数里添加一些跟踪步数的代码。12345678910111213141516171819function hasDuplicateValue(array) &#123; var steps = 0; for(var i = 0; i &lt; array.length; i++) &#123; for(var j = 0; j &lt; array.length; j++) &#123; steps++; if(i !== j &amp;&amp; array[i] == array[j]) &#123; return true; &#125; &#125; &#125; console.log(steps); return false;&#125; 执行hasDuplicateValue([1,2,3])的话，你会看到Javascript console输出9，表示9次比较。3个元素需要9次比较，这个函数是O(N2)的经典例子。 毫无疑问，嵌套循环算法的效率就是O(N2)。一旦看到嵌套循环，你就应该马上想到O(N2)。 虽然hasDuplicateValue是我们目前唯一想到的解决方法，但在确定采用之前，应意识到它的O(N2)意味着低效。当遇到低效的算法时，我们都应该花些时间思考下有没有更快的做法。 特别是当数据量巨大的时候，优化不足的应用甚至可能会突然挂掉。尽管这可能已经是最佳方案，但你还是要确认一下。 线性解决以下是hasDuplicateValue的另一种实现，它没有嵌套循环。看看它是否会比之前的更加高效。1234567891011121314151617function hasDuplicateValue(array) &#123; var existingNumbers = []; for(var i = 0; i &lt; array.length; i++) &#123; if(existingNumbers[array[i]] === undefined) &#123; existingNumbers[array[i]] = 1; &#125; else &#123; return true; &#125; &#125; return false;&#125; 此实现只有一个循环，并将迭代过程中遇到的数字用数组existingNumbers记录下来。其记录方法很有趣：每发现一个新的数字，就以其为索引找出existingNumbers中对应的格子，将其赋值为1。 举个例子，如果参数array为[3,5,8]，那么循环结束时，existingNumbers就会变成以下这样。1[undefined, undefined, undefined, 1, undefined, 1, undefined, undefined, 1] // 第一次索引为3,5,8的时候和undefined比较是相等的，所以赋值为1。0,1,2,4等索引没有赋值，所以是undefined 里面那些1的位置为索引3、5、8，因为array包含的这些数字已被发现。 不过，在将1赋值到对应的索引上之前，还得先检查索引上是否已有1。如果有，那就意味着这个数字曾经遇到过，也就是传入的数组有重复值。 为了确定这一新算法的时间复杂度符合哪种大O，我们得考察其最坏情况下需要多少步。与上一算法类似，此算法的主要步骤也是比较。读取existingNumbers上某索引的值，并与undefined比较，代码如下。1if(existingNumbers[array[i]] === undefined) （其实除了比较，我们还要对existingNumbers进行插入，但这无关紧要，原因会在下一章进行讲解。） 同样，最坏的情况就是无重复，因为你得跑完整个循环才能发现。 可见N个元素就要N次比较。因为这里只有一个循环，数组有多少个元素，它就要迭代多少次。要证明这个猜想，可以用JavaScript console来打印步数。12345678910111213141516171819202122function hasDuplicateValue(array) &#123; var steps = 0; var existingNumbers = []; for(var i = 0; i &lt; array.length; i++) &#123; steps++; if(existingNumbers[array[i]] === undefined) &#123; existingNumbers[array[i]] = 1; &#125; else &#123; return true; &#125; &#125; console.log(steps); return false;&#125; 执行hasDuplicateValue([1,2,3])的话，你会看到输出为3，跟元素个数一致。 因此其大O记法是O(N)。 我们知道O(N)远远快于O(N2)，所以采用第二种算法能极大地提升hasDuplicateValue的效率。如果这个程序处理的数据量很大，那么性能差别是很明显的（其实第二种算法有一个缺点，不过我们在最后一章才会讲到）。 总结毫无疑问，熟悉大O记法能使我们发现低效的代码，有助于我们挑选出更快的算法。然而，偶尔也会有两种算法的大O相同，但实际上二者快慢不一的情况。下一章我们就来学习当大O记法太过粗略的时候，如何识别两种算法的效率高低。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第3章-大O记法]]></title>
    <url>%2F2018%2F05%2F27%2F%E7%AC%AC3%E7%AB%A0-%E5%A4%A7O%E8%AE%B0%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 什么是大O记法？解答的是什么样的问题？ O(1)是什么意思？有哪些算法是O(1)？ O(N)是什么意思？哪些算法是O(N)？ O(1)和O(N)分别又叫做什么？ 线性查找的最好情况是O(1)，最坏情况是O(N)如何理解？大O记法一般都是指最坏情况如何理解？ 二分查找的大O记法是什么样的？也叫作什么？ 什么是对数和指数？ O(log N)算法是什么意思？ O(1)、O(log N)、O(N)的效率比较是什么样的？在图中如何表示？ 本章涵盖： 大O：数步数 常数时间与线性时间 同一算法，不同场景 第三种算法 对数 解释O(log N) 从之前的章节中我们了解到，影响算法性能的主要因素是其所需的步数。 然而，我们不能简单地把一个算法记为“22步算法”，把另一个算法记为“400步算法”，因为一个算法的步数并不是固定的。以线性查找为例，它的步数等于数组的元素数量。如果数组有22个元素，线性查找就需要22步；如果数组有400个元素，线性查找就需要400步。 量化线性查找效率的更准确的方式应该是：对于具有N个元素的数组，线性查找最多需要N步。当然，这听起来很啰唆。 为了方便表达数据结构和算法的时间复杂度，计算机科学家从数学界借鉴了一种简洁又通用的方式，那就是大O记法。这种规范化语言使得我们可以轻松地指出一个算法的性能级别，也令学术交流变得简单。 掌握了大O记法，就掌握了算法分析的专业工具。 虽说大O记法源于数学领域，但接下来我们不会讲解任何数学术语，只介绍跟计算机科学相关的部分。并且，我们会循序渐进，先用简单的词汇来解释它，然后在接下来的三章中将其构建完善。大O记法不复杂，但我们还是分成了几个章节来细述，使其更容易理解。 大O：数步数为了统一描述，大O不关注算法所用的时间，只关注其所用的步数。 第1章介绍过，数组不论多大，读取都只需1步。用大O记法来表示，就是： O(1) 很多人将其读作“大O1”，也有些人读成“1数量级”。我一般读成“O1”。虽然大O记法有很多种读法，但写法只有一种。 O(1)意味着一种算法无论面对多大的数据量，其步数总是相同的。就像无论数组有多大，读取元素都只要1步。这1步在旧机器上也许要花20分钟，而用现代的硬件却只要1纳秒。但这两种情况下，读取数组都是1步。 其他也属于O(1)的操作还包括数组末尾的插入与删除。之前已证明，无论数组有多大，这两种操作都只需1步，所以它们的效率都是O(1)。 下面研究一下大O记法如何描述线性查找的效率。回想一下，线性查找在数组上要逐个检查每个格子。在最坏情况下，线性查找所需的步数等于格子数。即如前所述：对于N个元素的数组，线性查找需要花N步。 用大O记法来表示，即为： O(N) 我将其读作“O N”。 若用大O记法来描述一种处理一个N元素的数组需花N步的算法的效率，很简单，就是O(N)。 数学解释前面提过，本书要采用一种易于理解的方式来讨论大O。当然这不是唯一的方式，如果你去上传统的大学算法课程，老师很可能从数学角度来介绍大O。因为大O本就是一个数学概念，所以人们经常用数学词汇介绍它，比如说“大O记法可用来描述一个函数的增长率的上限”，或者“如果函数g(x)的增长速度不比函数f(x)快，那么就称g属于O(f)”。大家数学背景不同，所以这些说法可能对你有意义，也可能没什么帮助。有了这本书，你不需要了解太多数学知识，就可以理解大O。 常数时间与线性时间从O(N)可以看出，大O记法不只是用固定的数字（如22、440）来表示算法的步数，而是基于要处理的数据量来描述算法所需的步数。或者说，大O解答的是这样的问题：当数据增长时，步数如何变化？ O(N)算法所需的步数等于数据量，意思是当数组增加一个元素时，O(N)算法就要增加1步。而O(1)算法无论面对多大的数组，其步数都不变。 下图展示了这两种时间复杂度。 从图中可以看出，O(N)呈现为一条对角线。当数据增加一个单位时，算法也随之增加一步。也就是说，数据越多，算法所需的步数就越多。O(N)也被称为线性时间。 相比之下，O(1)则为一条水平线，因为不管数据量是多少，算法的步数都恒定。所以，O(1)也被称为常数时间。 因为大O主要关注的是数据量变动时算法的性能变化，所以你会发现，即使一个算法的恒定步数不是1，它也可以被归类为O(1)。假设有个算法不能1步完成，而要花3步，但无论数据量多大，它都需要3步。如果用图形来展示，该算法应该是这样： 因为不管数据量怎样变化，算法的步数都恒定，所以这也是常数时间，也可以表示为O(1)。虽然从技术上来说它需要3步而不是1步，但大O记法并不纠结于此。简单来说，O(1)就是用来表示所有数据增长但步数不变的算法。 如果说只要步数恒定，3步的算法也属于O(1)，那么恒为100步的算法也属于O(1)。虽然100步的算法在效率上不如1步的算法，但如果它的步数是恒定的，那么它还是比O(N)更高效。 为什么呢？如图所示。 对于元素量少于100的数组，O(N)算法的步数会少于100步的O(1)算法。当元素刚好为100个时，两者的步数同为100。而一旦超过100个元素，注意，O(N)的步数就多于O(1)。 因为数据量从这个临界点开始，直至无限，O(N)都会比O(1)花更多步数，所以总体上来说，O(N)比O(1)低效。 这对于步数恒为1000000的O(1)算法来说也是一样的。当数据量一直增长时，一定会到达一个临界点，使得O(N)算法比O(1)算法低效，而且这种落后的状况会持续到数据量无限大的时候。 同一算法，不同场景之前的章节我们提到，线性查找并不总是O(N)的。当要找的元素在数组末尾，那确实是O(N)。但如果它在数组开头，1步就能找到的话，那么技术上来说应该是O(1)。所以概括来说，线性查找的最好情况是O(1)，最坏情况是 O(N)。 虽然大O可以用来表示给定算法的最好和最坏的情景，但若无特别说明，大O记法一般都是指最坏情况。因此尽管线性查找有O(1)的最好情况，但大多数资料还是把它归类为O(N)。 这种悲观主义其实是很有用的：知道各种算法会差到什么程度，能使我们做好最坏打算，以选出最适合的算法。 第三种算法上一章我们学到：在同一个有序数组里，二分查找比线性查找要快。下面就来看看如何用大O记法描述二分查找。 它不能写成O(1)，因为二分查找的步数会随着数据量的增长而增长。它也不能写成O(N)，因为步数比元素数量要少得多，正如之前我们看到的，包含100个元素的数组只要7步就能找完。 看来，二分查找的时间复杂度介于O(1)和O(N)之间。 好了，二分查找的大O记法是： O(log N) 我将其读作“O log N”。归于此类的算法，它们的时间复杂度都叫作对数时间。 简单来说，O(log N)意味着该算法当数据量翻倍时，步数加1。这确实符合之前章节我们所介绍的二分查找。下面我们先整理一下至今学到的东西，之后马上就解释采取这种记法的原因。 到这里我们所提过的3种时间复杂度，按照效率由高到低来排序的话，会是这样： O(1) O(log N) O(N) 下图为它们三者的对比。 注意O(log N)曲线的微弯，使其效率略差于O(1)，却远胜于O(N)。 若想理解这种时间复杂度为什么是O(log N)，我们得先学习一下对数。如果你对这个数学概念已经很熟悉了，那么可以跳过下一节。 对数让我们来研究下为什么二分查找之类的算法被记为O(log N)，到底log是什么？ log即是对数（logarithm）。注意，虽然它的英文看起来和读起来都跟算法（algorithm）很像，但它与算法无关。 对数是指数的反函数，所以我们先回顾一下指数。 23等于：12 × 2 × 2 结果为8。 log28 则将上述计算反过来，它意思是：要把2乘以自身多少次，才能得到8。因为需要3次，所以，log28 = 3。 再来一个例子。 26可以解释为：12 × 2 × 2 × 2 × 2 × 2 = 64 因为2要乘以自身6次才得到64，所以，log264 = 6。 不过以上都是教科书式的定义，我打算换一种更形象和更易于理解的方式来解释。 log2 8可以表达为：将8不断地除以2直到1，需要多少个2。（注：按照从左到右的顺序计算。） 18 / 2 / 2 / 2 = 1 或者说，将8不断地除以2，要除多少次才能到1呢？答案是3，所以，log28 = 3。 类似地，log264可以解释为：将64除以2多少次，才能得到1。 164 / 2 / 2 / 2 / 2 / 2 / 2 = 1 因为这里有6个2，所以，log264 = 6。 现在你应该明白对数是怎么回事了，那么O(log N)就很好懂了。 解释O(log N)现在回到大O记法。当我们说O(log N)时，其实指的是O(log2N)，不过为了方便就省略了2而已。 你应该还记得O(N)代表算法处理N个元素需要N步。如果元素有8个，那么这种算法就需要8步。 O(log N)则代表算法处理N个元素需要log2N步。如果有8个元素，那么这种算法需要3步，因为log28 = 3。 从另一个角度来看，如果要把8个元素不断地分成两半，那么得拆分3次才能拆到只剩1个元素。 这正是二分查找所干的事情。它就是不断地将数组拆成两半，直至范围缩小到只剩你要找的那个元素。 简单来说，O(log N)算法的步数等于二分数据直至元素剩余1个的次数。 下表是O(N)和O(log N)的效率对比。 N个元素 O(N) O(log N) 8 8 3 16 16 4 32 32 5 64 64 6 128 128 7 256 256 8 512 512 9 1024 1024 10 每次数据量翻倍时，O(N)算法的步数也跟着翻倍，O(log N)算法却只需加 1。 后面的章节我们还会学到除了这3种时间复杂度以外的算法。不过现在，我们还是先把已经学会的实践到日常的代码中。 实例以下是打印列表所有元素的典型Python代码。123things = ['apples', 'baboons', 'cribs', 'dulcimers']for thing in things: print "Here's a thing: %s" % thing 它的效率要怎么用大O记法来表示呢？ 首先，这是一个算法的例子。虽然它并没有多么厉害，但不管一段代码做什么事情，技术上来说它都是一个算法--因为它是解决某种问题的一个独特的过程。在此例中，问题是打印列表的所有元素，而算法是在for循环中使用print 。 为了得出它的大O记法，我们需要分析这个算法的步数。这段代码的主要部分--for循环会走4步，因为列表总共有4个元素。 然而，此过程不一定总是这样。如果列表有10个元素，那么for循环就会是10步。因为这里for的步数等于元素数量，所以整个算法的效率是O(N)。 再来一个例子，这是大家都知道的最基础的代码。1print('Hello world!') 它永远都只会是1步，所以是O(1)。 以下的例子是代码判断一个数字是否为质数。12345def is_prime(number): for i in range(2, number): if number % i == 0: return Falsereturn True 它接受一个参数，名为number ，然后用一个for 循环来测试number除以2到number之间的数，看是否有余数。如果没有，则number非质数，可以马上返回False。但如果一直测到number除以number的前一个数都有余数，那么它就是一个质数，最后会返回True。 此算法的效率为O(N)。它不以数组为参数，而是用一个数字。如果is_prime传入的是7，那么for循环就要差不多走7次（准确来说是5步，因为是从2开始，直到该数字的前一个数）。如果是101，那就循环差不多101次。因为步数与参数的大小一致，所以它的效率是O(N)。 总结学会大O记法，我们在比较算法时就有了一致的参考系。有了它，我们就可以在现实场景中测量各种数据结构和算法，写出更快的代码，更轻松地应对高负荷的环境。 下一章会用一个实际的例子，让你看到大O记法如何帮助我们显著地提高代码的性能。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第2章-算法为何重要]]></title>
    <url>%2F2018%2F05%2F26%2F%E7%AC%AC2%E7%AB%A0-%E7%AE%97%E6%B3%95%E4%B8%BA%E4%BD%95%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 有序数组和普通数组在线性查找方面有什么不同？ 有序数组还可以使用什么查找方法？为什么普通数组无法使用？ 有序数组在插入方面和普通数组有什么区别？谁快谁慢？ 用Python或Ruby代码实现线性查找和二分查找。 本章涵盖： 有序数组 查找有序数组 二分查找 二分查找与线性查找 上一章我们学习了两种数据结构，并明白了选择合适的数据结构将会显著地提升代码的性能。即使是像数组和集合这样相似的两种数据结构，在高负荷的运行环境下也会表现得天差地别。 在本章，你将会发现，就算数据结构确定了，代码的速度也还会受另一重要因素影响，那就是算法。 算法这个词听起来很深奥，其实不然。它只是解决某个问题的一套流程。准备一碗麦片的流程也可以说是一种算法，它包含以下4步（对我来说是4步吧）。 (1) 拿个碗。(2) 把麦片倒进碗里。(3) 把牛奶倒进碗里。(4) 把勺子放到碗里。 在计算机的世界里，算法则是指某项操作的过程。上一章我们研究了4种主要操作，包括读取、查找、插入和删除。这一章我们还是会经常提到它们，而且一种操作可能会有不止一种做法。 也就是说，一种操作会有多种算法的实现。我们很快会看到不同的算法能使代码变快或者变慢——高负载时甚至慢到停止工作。不过，现在先来认识一种新的数据结构：有序数组。它的查找算法就不止一种，我们将会学习如何选出正确的那种。 有序数组有序数组跟上一章讨论的数组几乎一样，唯一区别就是有序数组要求其值总是保持有序（你猜对了）。即每次插入新值时，它会被插入到适当的位置，使整个数组的值仍然按顺序排列。常规的数组则并不考虑是否有序，直接把值加到末尾也没问题。 以数组[3, 17, 80, 202]为例。 假设这是个常规的数组，你准备将75插入，那就可以把它放到尾端，如下所示。 如上一章所述，计算机只要1步就能完成这种操作。 但如果这是一个有序数组，你就必须要找到一个适当的位置，使插入75之后整个数组依然有序。 做起来可不像说的那么简单。整个过程不可能一步完成，因为计算机需要先找出那个适当的位置，然后将其及以后的值右移来腾出空间给75。下面就来介绍分解的步骤。 先回顾一下原始的数组。 第1步：检查索引0的值，看75应该在它的左边还是右边。 因为75大于3，所以75应该在它右边的某个位置。而具体的位置，目前还是不能确定，于是，再检查下一个格子。 第2步：检查下一格的值。 因为75大于17，所以继续。 第3步：检查下一格的值。 这次是80，大于75。因为这是第一次遇到大于75的值，可想而知，必须把75放在80的左侧以使整个数组维持有序。但要在这里插入75，还得先将它的位置空出来。 第4步：将最后一个值右移。 第5步：将倒数第二个值右移。 第6步：终于可以把75插入到正确的位置上了。 可以看到，往有序数组中插入新值，需要先做一次查找以确定插入的位置。这是它跟常规数组的关键区别（在性能方面）之一。 虽然插入的性能比不上常规数组，但在查找方面，有序数组却有着特殊优势。 查找有序数组上一章介绍了常规数组的查找方式：从左至右，逐个格子检查，直至找到。这种方式称为线性查找。 接下来看看有序数组的线性查找跟常规数组有何不同。 设一个常规数组[17,3,75,202,80]，如果想在里面查找22（其实并不存在），那你就得逐个元素去检查，因为22可能在任何一个位置上。要想在到达末尾之前结束检查，那么所找的值必须在末尾之前出现。 然而对于有序数组来说，即便它不包含要找的值，我们也可以提早停止查找。假设要在有序数组[3,17,75,80,202]里查找22，我们可以在查到75的时候就结束，因为22不可能出现在75的右边。 以下是用Ruby语言实现的有序数组线性查找。1234567891011121314def linear_search(array, value) # 遍历数组的每一个元素 array.each do |element| # 如果这个元素等于我们要找的值，则将其返回 if element == value return value # 如果这个值大于我们要找的值，则提早退出循环 elsif element &gt; value break end end # 如果没找到，则返回空值 return nilend 因此，有序数组的线性查找大多数情况下都会快于常规数组。除非要找的值是最后那个，或者比最后的值还大，那就只能一直查到最后了。 只看到这里的话，可能你还是不会觉得两种数组在性能上有什么巨大区别。 这是因为我们还没释放算法的潜能。这是接下来就要做的。 至今我们提到的查找有序数组的方法就只有线性查找。但其实，线性查找只不过是查找算法的其中一种而已。这种逐个格子检查直至找到为止的过程，并不是查找的唯一途径。 有序数组相比常规数组的一大优势就是它可以使用另一种查找算法。此种算法名为二分查找，它比线性查找要快得多。 二分查找你小时候或许玩过这样一种猜谜游戏（或者现在跟你的小孩玩过）：我心里想着一个1到100之间的数字，在你猜出它之前，我会提示你的答案应该大一点还是小一点。 你应该凭直觉就知道这个游戏的策略。一开始你会先猜处于中间的50，而不是1。为什么？ 因为不管我接下来告诉你更大或是更小，你都能排除掉一半的错误答案！ 如果你说50，然后我提示要再大一点，那么你应该会选75，以排除掉剩余数字的一半。如果在75之后我告诉你要小一点，你就会选62或63。总之，一直都猜中间值，就能不断地缩小一半的范围。 下面来演示这个过程，但仅以1到10为例。 这就是二分查找的通俗描述。 有序数组相比常规数组的一大优势就是它除了可以用线性查找，还可以用二分查找。常规数组因为无序，所以不可能运用二分查找。 为了看出它的实际效果，假设有一个包含9个元素的有序数组。计算机不知道每个格子的值，如下图所示。 然后，用二分查找来找出7，过程如下。 第1步：检查正中间的格子。因为数组的长度是已知的，将长度除以2，我们就可以跳到确切的内存地址上，然后检查其值。 值为9，可推测出7应该在其左边的某个格子里。而且，这下我们也排除了一半的格子，即9右边的那些（以及9本身）。 第2步：检查9左边的那些格子的最中间那个。因为这里最中间有两个，我们就随便挑了左边的。 它的值为4，那么7就在它的右边了。由此4左边的格子也就排除了。 第3步：还剩两个格子里可能有7。我们随便挑个左边的。 第4步：就剩一个了。（如果还没有，那就说明这个有序数组里真的没有7。） 终于找到7了，总共4步。是的，这个有序数组要是用线性查找也会是4步，但稍后你就会见识到二分查找的强大。 以下是二分查找的Ruby实现。1234567891011121314151617181920212223242526272829def binary_search(array, value) # 首先，设定下界和上界，以限定所查之值可能出现的区域。 # 在开始时，以数组的第一个元素为下界，以最后一个元素为上界 lower_bound = 0 upper_bound = array.length - 1 # 循环检查上界和下界之间的最中间的元素 while lower_bound &lt;= upper_bound do # 如此找出最中间的格子之索引 #（无须担心商是不是整数，因为 Ruby 总是把两个整数相除所得的小数部分去掉） midpoint = (upper_bound + lower_bound) / 2 # 获取该中间格子的值 value_at_midpoint = array[midpoint] # 如果该值正是我们想查的，那就完事了。 # 否则，看你是要往上找还是往下找，来调整下界或上界 if value &lt; value_at_midpoint upper_bound = midpoint - 1 elsif value &gt; value_at_midpoint lower_bound = midpoint + 1 elsif value == value_at_midpoint return midpoint end end # 当下界超越上界，便知数组里并没有我们所要找的值 return nilend 二分查找与线性查找对于长度太小的有序数组，二分查找并不比线性查找好多少。但我们来看看更大的数组。 对于拥有100个值的数组来说，两种查找需要的最多步数如下所示。 线性查找：100步 二分查找：7步 用线性查找的话，如果要找的值在最后一个格子，或者比最后一格的值还大，那么就得查遍每个格子。有100个格子，就是100步。 二分查找则会在每次猜测后排除掉一半的元素。100个格子，在第一次猜测后，便排除了50个。 再换个角度来看，你就会发现一个规律。 长度为3的有序数组，二分查找所需的最多步数是2。 若长度翻倍，变成7（以奇数为例会方便选择正中间的格子，于是我们把长度翻倍后又增加了一个数），则最多步数会是3。 若再翻倍（并加1），变成15个元素，那么最多步数会是4。 规律就是，每次有序数组长度乘以2，二分查找所需的最多步数只会加1。 这真是出奇地高效。 相反，在3个元素的数组上线性查找，最多要3步，7个元素就最多要7步，100个元素就最多要100步，即元素有多少，最多步数就是多少。数组长度翻倍，线性查找的最多步数就会翻倍，而二分查找则只是增加1步。 这种规律可以用下图来展示。 如果数组变得更大，比如说10000个元素，那么线性查找最多会有10000步，而二分查找最多只有14步。再增大到1000000个元素，则线性查找最多有1000000步，二分查找最多只有20步。 不过还要记住，有序数组并不是所有操作都比常规数组要快。如你所见，它的插入就相对要慢。衡量起来，虽然插入是慢了一些，但查找却快了许多。还是那句话，你得根据应用场景来判断哪种更合适。 总结关于算法的内容就是这些。很多时候，计算一样东西并不只有一种方法，换种算法可能会极大地影响程序的性能。 同时你还应意识到，世界上并没有哪种适用于所有场景的数据结构或者算法。你不能因为有序数组能使用二分查找就永远只用有序数组。在经常插入而很少查找的情况下，显然插入迅速的常规数组会是更好的选择。 如之前所述，比较算法的方式就是比较各自的步数。 下一章，我们将会学习如何规范地描述数据结构和算法的时间复杂度。有了这种通用的表达方式，就能更容易地观察出哪种算法符合我们的实际需求。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[第1章-数据结构为何重要]]></title>
    <url>%2F2018%2F05%2F25%2F%E7%AC%AC1%E7%AB%A0-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%BA%E4%BD%95%E9%87%8D%E8%A6%81%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 数据结构是什么？为什么重要？举几个数据结构。 内存是什么样子的？ 数组读取为什么快？ 什么是线性查找？在含有N个元素的数组上进行线性查找最多要多少步呢？ 一个含有N个元素的数组，其插入数据的最好情况会花费多少步？最坏呢？ 一个含有N个元素的数组，其删除数据的最好情况会花费多少步？最坏呢？ 集合作为不重复的数组在插入上与数组有什么区别？ 什么是时间复杂度？ 本章涵盖： 基础数据结构：数组 读取 查找 插入 删除 集合：一条规则决定性能 总结 哪怕只写过几行代码的人都会发现，编程基本上就是在跟数据打交道。计算机程序总是在接收数据、操作数据或返回数据。不管是求两数之和的小程序，还是管理公司的企业级软件，都运行在数据之上。 数据是一个广义的术语，可以指代各种类型的信息，包括最基本的数字和字符串。在经典的“Hello World!”这个简单程序中，字符串“Hello World!”就是一条数据。事实上，无论是多么复杂的数据，我们都可以将其拆成一堆数字和字符串来看待。 数据结构则是指数据的组织形式。看看以下代码。12345x = "Hello!"y = "How are you"z = "today?"print(x + y + z) 这个非常简单的程序把3条数据串成了一句连贯的话。如果要描述该程序中的数据结构，我们会说，这里有3个独立的变量，分别引用着3个独立的字符串。 但数据结构不只是用于组织数据，它还极大地影响着代码的运行速度。因为数据结构不同，程序的运行速度可能相差多个数量级。如果你写的程序要处理大量的数据，或者要让数千人同时使用，那么你采用何种数据结构，将决定它是能够运行，还是会因为不堪重负而崩溃。 一旦对各种数据结构有了深刻的理解，并明白它们对程序性能方面的影响，你就能写出快速而优雅的代码，从而使软件运行得快速且流畅。当然，你的编程技能也会更上一层楼。 本章接下来将会分析两种数据结构：数组和集合。它们从表面上看好像差不多，但通过即将介绍的分析工具，你将会观察到它们在性能上的差异。 基础数据结构：数组数组是计算机科学中最基本的数据结构之一。如果你用过数组，那么应该知道它就是一个含有数据的列表。它有多种用途，适用于各种场景，下面就举个简单的例子。 一个允许用户创建和使用购物清单的食杂店应用软件，其源代码可能会包含以下的片段。1array = ["apples", "bananas", "cucumbers", "dates", "elderberries"] 这就是一个数组，它刚好包含5个字符串，每个代表我会从超市买的食物。 此外，我们会用一些名为索引的数字来标识每项数据在数组中的位置。 在大多数的编程语言中，索引是从0算起的，因此在这个例子中，“apples”的索引为0，“elderberries”的索引为4，如下所示。 若想了解某个数据结构（例如数组）的性能，得分析程序怎样操作这一数据结构。 一般数据结构都有以下4种操作（或者说用法）。 读取：查看数据结构中某一位置上的数据。对于数组来说，这意味着查看某个索引所指的数据值。例如，查看索引2上有什么食品，就是一种读取。 查找：从数据结构中找出某个数据值的所在。对于数组来说，这意味着检查其是否包含某个值，如果包含，那么还得给出其索引。例如，检查“dates”是否存在于食品清单之中，给出其对应的索引，就是一种查找。 插入：给数据结构增加一个数据值。对于数组来说，这意味着多加一个格子并填入一个值。例如，往购物清单中多加一项“figs”，就是一种插入。 删除：从数据结构中移走一个数据值。对于数组来说，这意味着把数组中的某个数据项移走。例如，把购物清单中的“bananas”移走，就是一种删除。 本章我们将会研究这些操作在数组上的运行速度。 同时，我们也将学到本书的第一个重要理论：操作的速度，并不按时间计算，而是按步数计算。 为什么呢？ 因为，你不可能很绝对地说，某项操作要花5秒。它在某台机器上要跑5秒，但换到一台旧一点的机器，可能就要多于5秒，而换到一台未来的超级计算机，运行时间又将显著缩短。所以，受硬件影响的计时方法，非常不可靠。 然而，若按步数来算，则确切得多。如果A操作要5步，B操作要500步，那么我们可以很肯定地说，无论是在什么样的硬件上对比，A都快过B。因此，衡量步数是分析速度的关键。 此外，操作的速度，也常被称为时间复杂度。在本书中，我们会提到速度、时间复杂度、效率、性能，但它们其实指的都是步数。 事不宜迟，我们现在就来探索上述4种操作方式在数组上要花多少步。 读取首先看看读取，即查看数组中某个索引所指的数据值。 这只要一步就够了，因为计算机本身就有跳到任一索引位置的能力。在 [“apples”, “bananas”, “cucumbers”, “dates”, “elderberries”]的例子中，如果要查看索引2的值，那么计算机就会直接跳到索引2，并告诉你那里有“cucumbers”。 计算机为什么能一步到位呢？原因如下。 计算机的内存可以被看成一堆格子。下图是一片网格，其中有些格子有数据，有些则是空白。 当程序声明一个数组时，它会先划分出一些连续的空格子以备使用。换句话说，如果你想创建一个包含5个元素的数组，计算机就会找出5个排成一行的空格子，将其当成数组。 内存中的每个格子都有各自的地址，就像街道地址，例如大街123号。不过内存地址就只用一个普通的数字来表示。而且，每个格子的内存地址都比前一个大1，如下图所示。 购物清单数组的索引和内存地址，如下图所示。 计算机之所以在读取数组中某个索引所指的值时，能直接跳到那个位置上，是因为它具备以下条件。 (1)计算机可以一步就跳到任意一个内存地址上。（就好比，要是你知道大街123号在哪儿，那么就可以直奔过去。） (2)数组本身会记有第一个格子的内存地址，因此，计算机知道这个数组的开头在哪里。 (3)数组的索引从0算起。 回到刚才的例子，当我们叫计算机读取索引3的值时，它会做以下演算。 (1)该数组的索引从0算起，其开头的内存地址为1010。 (2)索引3在索引0后的第3个格子上。 (3)于是索引3的内存地址为1013，因为1010 + 3 = 1013。 当计算机一步跳到1013时，我们就能获取到“dates”这个值了。 所以，数组的读取是一种非常高效的操作，因为它只要一步就好。一步自然也是最快的速度。这种一步读取任意索引的能力，也是数组好用的原因之一。 如果我们问的不是“索引3有什么值”，而是“”dates”在不在数组里”，那么这就需要进行查找操作了。下面我们就来看看。 查找如前所述，对于数组来说，查找就是检查它是否包含某个值，如果包含，还得给出其索引。那么，我们就试试在数组中查找“dates”要用多少步。 对于我们人来说，可以一眼就看到这个购物清单上的“dates”，并数出它的索引为3。但是，计算机并没有眼睛，它只能一步一步地检查整个数组。 想要查找数组中是否存在某个值，计算机会先从索引0开始，检查其值，如果不匹配，则继续下一个索引，以此类推，直至找到为止。 我们用以下图来演示计算机如何从购物清单中查找“dates”。 首先，计算机检查索引0。 因为索引0的值是“apples”，并非我们所要的“dates”，所以计算机跳到下一个索引上。 索引1也不是“dates”，于是计算机再跳到索引2。 但索引2的值仍不匹配，计算机只好再跳到下一格。 啊，真是千辛万苦，我们找到“dates”了，它就在索引3那里。自此，计算机不用再往后跳了，因为结果已经得到。 在这个例子中，因为我们检查了4个格子才找到想要的值，所以这次操作总计是4步。 这种逐个格子去检查的做法，就是最基本的查找方法--线性查找。第2章我们还会学习另一种查找方法。 但在那之前，我们再思考一下，在数组上进行线性查找最多要多少步呢？ 如果我们要找的值刚好在数组的最后一个格子里（如本例的elderberries），那么计算机从头到尾检查每个格子，会在最后才找到。同样，如果我们要找的值并不存在于数组中，那么计算机也还是得查遍每个格子，才能确定这个值不在数组中。 于是，一个5格的数组，其线性查找的步数最大值是5，而对于一个500格的数组，则是500。 以此类推，一个N格的数组，其线性查找的最多步数是N（N可以是任何自然数）。 可见，无论是多长的数组，查找都比读取要慢，因为读取永远都只需要一步，而查找却可能需要多步。 接下来，我们再研究一下插入，准确地说，是插入一个新值到数组之中。 插入往数组里插入一个新元素的速度，取决于你想把它插入到哪个位置上。 假设我们想要在购物清单的末尾插入“figs”。那么只需一步。因为之前说过了，计算机知道数组开头的内存地址，也知道数组包含多少个元素，所以可以算出要插入的内存地址，然后一步跳到那里插入就行了。图示如下。 但在数组开头或中间插入，就另当别论了。这种情况下，我们需要移动其他元素以腾出空间，于是得花费额外的步数。 例如往索引2处插入”figs”，如下所示。 为了达到目的，我们必须先把“cucumbers”、“dates”和“elderberries”往右移，以便空出索引2。而这也不是一步就能移好，因为我们首先要将“elderberries”右移一格，以空出位置给“dates”，然后再将“dates”右移，以空出位置给“cucumbers”，下面来演示这个过程。 第1步：“elderberries”右移。 第2步：“date”右移。 第3步：“cucembers”右移。 第4步：至此，可以在索引2处插入“figs”了。 如上所示，整个过程有4步，开始3步都是在移动数据，剩下1步才是真正的插入数据。 最低效（花费最多步数）的插入是插入在数组开头。因为这时候需要把数组所有的元素都往右移。 于是，一个含有N个元素的数组，其插入数据的最坏情况会花费N + 1步。即插入在数组开头，导致N次移动，加上一次插入。 最后要说的“删除”，则相当于插入的反向操作。 删除数组的删除就是消掉其某个索引上的数据。 我们找回最开始的那个数组，删除索引2上的值，即“cucumbers”。 第1步：删除“cucumbers”。 虽然删除“cucumbers”好像一步就搞定了，但这带来了新的问题：数组中间空出了一个格子。因为数组中间是不应该有空格的，所以，我们得把“dates”和“elderberries”往左移。 第2步：将”dates”左移。 第3步：将”elderberries”左移。 结果，整个删除操作花了3步。其中第1步是真正的删除，剩下的2步是移数据去填空格。 所以，删除本身只需要1步，但接下来需要额外的步骤将数据左移以填补删除所带来的空隙。 跟插入一样，删除的最坏情况就是删掉数组的第一个元素。因为数组不允许空元素，当索引0空出，那么剩下的所有元素都要往左移去填空。 对于含有5个元素的数组，删除第一个元素需要1步，左移剩余的元素需要4步。而对于500个元素的数组，删除第一个元素需要1步，左移剩余的元素需要499步。可以推出，对于含有N个元素的数组，删除操作最多需要N步。 既然学会了如何分析数据结构的时间复杂度，那就可以开始探索各种数据结构的性能差异了。了解这些非常重要，因为数据结构的性能差异会直接造成程序的性能差异。 下一个要介绍的数据结构是集合，它跟数组似乎很像，甚至让人以为就是同一种东西。然而，我们将会看到它跟数组在性能上是有区别的。 集合：一条规则决定性能来看看另一种数据结构：集合。它是一种不允许元素重复的数据结构。 其实集合是有不同形式的，但现在我们只讨论基于数组的那种。这种集合跟数组差不多，都是一个普通的元素列表，唯一的区别在于，集合不允许插入重复的值。 要是你想往集合[“a”, “b”, “c”]再插入一个“b”，计算机是不会允许的，因为集合中已经有“b”了。 集合就是用于确保数据不重复。 如果你要创建一个线上电话本，你应该不会希望相同的号码出现两次吧。如果这个电话本程序用集合来处理，那就不会搞出这种麻烦了。 总之，集合就是一个带有“不允许重复”这种简单限制的数组。而该限制也导致它在4种基本操作中有1种与数组性能不同。 下面就来分析读取、查找、插入和删除在基于数组的集合上表现如何。 集合的读取跟数组的读取完全一样，计算机只要一步就能获取指定索引上的值。如之前解释的那样，这是因为计算机知道集合开头的内存地址，所以能够一步跳到集合的任意索引。 集合的查找也跟数组的查找无异，需要N步去检查某个值在不在集合当中。删除也是，总共需要N步去删除和左移填空。 但插入就不同了。先看看在集合末尾的插入。对于数组来说，末尾插入是最高效的，它只需要1步。 而对于集合，计算机得先确定要插入的值不存在于其中--因为这就是集合：不允许重复值。于是每次插入都要先来一次查找。 假设我们的购物清单是一个集合--用集合还是不错的，毕竟你不会想买重复的东西。如果当前集合是[“apples”, “bananas”, “cucumbers”, “dates”, “elderberries”]，然后想插入“figs”，那么就需要做一次如下的查找。 第1步：检查索引0有没有“figs”。 没有，不过说不定其他索引会有。为了在真正插入前确保它不存在于任何索引上，我们继续。 第2步：检查索引1。 第3步：检查索引2。 第4步：检查索引3。 第5步：检查索引4。 直到检查完整个集合，才能确定插入“figs”是安全的。于是，到最后一步。 第6步：在集合末尾插入“figs”。 在集合的末尾插入也属于最好的情况，不过对于一个含有5个元素的集合，你仍然要花6步。因为，在最终插入的那一步之前，要把5个元素都检查一遍。 换句话说，在N个元素的集合中进行插入的最好情况需要N+1步--N步去确认被插入的值不在集合中，加上最后插入的1步。 最坏的情况则是在集合的开头插入，这时计算机得检查N个格子以保证集合不包含那个值，然后用N步来把所有值右移，最后再用1步来插入新值。总共2N+1步。 这是否意味着因为它的插入比一般的数组慢，所以就不要用了呢？当然不是。在需要保证数据不重复的场景中，集合是非常重要的。但如果没有这种需求，那么选择插入比集合快的数组会更好一些。具体哪种数据结构更合适，当然要根据你的实际应用场景而定。 总结理解数据结构的性能，关键在于分析操作所需的步数。采取哪种数据结构将决定你的程序是能够承受住压力，还是崩溃。本章特别讲解了如何通过步数分析来判断某种应用该选择数组还是集合。 不同的数据结构有不同的时间复杂度，类似地，不同的算法（即使是用在同一种数据结构上）也有不同的时间复杂度。既然我们已经学会了时间复杂度的分析方法，那么现在就可以用它来对比各种算法，找出能够发挥代码极限性能的那个。这正是下一章所要讲的。]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>数据结构与算法图解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Nginx负载均衡与高可用]]></title>
    <url>%2F2018%2F04%2F07%2FNginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%8E%E9%AB%98%E5%8F%AF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[思考并回答以下问题： 正向代理Nginx不仅可以做反向代理，实现负载均衡。还能用作正向代理来进行上网等功能。 正向代理：如果把局域网外的Internet想象成一个巨大的资源库，则局域网中的客户端要访问Internet，则需要通过代理服务器来访问，这种代理服务就称为正向代理。 反向代理反向代理，其实客户端对代理是无感知的，因为客户端不需要任何配置就可以访问，我们只需要将请求发送到反向代理服务器，由反向代理服务器去选择目标服务器获取数据后，在返回给客户端，此时反向代理服务器和目标服务器对外就是一个服务器，暴露的是代理服务器地址，隐藏了真实服务器IP地址。 负载均衡客户端发送多个请求到服务器，服务器处理请求，有一些可能要与数据库进行交互，服务器处理完毕后，再将结果返回给客户端。 这种架构模式对于早期的系统相对单一，并发请求相对较少的情况下是比较适合的，成本也低。但是随着信息数量的不断增长，访问量和数据量的飞速增长，以及系统业务的复杂度增加，这种架构会造成服务器相应客户端的请求日益缓慢，并发量特别大的时候，还容易造成服务器直接崩溃。很明显这是由于服务器性能的瓶颈造成的问题，那么如何解决这种情况呢？ 我们首先想到的可能是升级服务器的配置，比如提高CPU执行频率，加大内存等提高机器的物理性能来解决此问题，但是我们知道摩尔定律的日益失效，硬件的性能提升已经不能满足日益提升的需求了。最明显的一个例子，天猫双十一当天，某个热销商品的瞬时访问量是极其庞大的，那么类似上面的系统架构，将机器都增加到现有的顶级物理配置，都是不能够满足需求的。那么怎么办呢？ 上面的分析我们去掉了增加服务器物理配置来解决问题的办法，也就是说纵向解决问题的办法行不通了，那么横向增加服务器的数量呢？这时候集群的概念产生了，单个服务器解决不了，我们增加服务器的数量，然后将请求分发到各个服务器上，将原先请求集中到单个服务器上的情况改为将请求分发到多个服务器上，将负载分发到不同的服务器，也就是我们所说的负载均衡。 动静分离为了加快网站的解析速度，可以把动态页面和静态页面由不同的服务器来解析，加快解析速度。降低原来单个服务器的压力。 配置可以将nginx.conf配置文件分为三部分： 第一部分：全局块 从配置文件开始到events块之间的内容，主要会设置一些影响nginx 服务器整体运行的配置指令，主要包括配置运行Nginx服务器的用户（组）、允许生成的worker process数，进程PID存放路径、日志存放路径和类型以及配置文件的引入等。 比如第一行配置的：1worker_processes 1; 这是Nginx服务器并发处理服务的关键配置，worker_processes值越大，可以支持的并发处理量也越多，但是会受到硬件、软件等设备的制约。 第二部分：events块 123events&#123; worker_connections 1024;&#125; events块涉及的指令主要影响Nginx服务器与用户的网络连接，常用的设置包括是否开启对多work process下的网络连接进行序列化，是否允许同时接收多个网络连接，选取哪种事件驱动模型来处理连接请求，每个word process可以同时支持的最大连接数等。 上述例子就表示每个work process支持的最大连接数为1024。 这部分的配置对Nginx的性能影响较大，在实际中应该灵活配置。 第三部分：http块 123456789101112131415161718192021222324http &#123; include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; server &#123; listen 80; server_name localhost; location / &#123; root html; index index.html index.htm; &#125; error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root html; &#125; &#125;&#125; 这算是Nginx服务器配置中最频繁的部分，代理、缓存和日志定义等绝大多数功能和第三方模块的配置都在这里。 需要注意的是：http块也可以包括http全局块、server块。 ①http全局块 http全局块配置的指令包括文件引入、MIME-TYPE定义、日志自定义、连接超时时间、单链接请求数上限等。 ②server块 这块和虚拟主机有密切关系，虚拟主机从用户角度看，和一台独立的硬件主机是完全一样的，该技术的产生是为了节省互联网服务器硬件成本。 每个http块可以包括多个server块，而每个server块就相当于一个虚拟主机。 而每个server块也分为全局server块，以及可以同时包含多个locaton块。 1、全局server块 最常见的配置是本虚拟机主机的监听配置和本虚拟主机的名称或IP配置。 2、location块 一个server块可以配置多个location块。 这块的主要作用是基于Nginx服务器接收到的请求字符串（例如server_name/uri-string），对虚拟主机名称（也可以是IP别名）之外的字符串（例如 前面的 /uri-string）进行匹配，对特定的请求进行处理。地址定向、数据缓存和应答控制等功能，还有许多第三方模块的配置也在这里进行。 配置实例-反向代理实例一 实现效果：使用nginx反向代理，访问www.123.com直接跳转到127.0.0.1:8080 123456789server&#123; listen 80; server_name www.123.com; location / &#123; proxy_pass http://127.0.0.1:8080; index index.html index.htm index.jsp; &#125;&#125; 实例二 实现效果：使用nginx反向代理，根据访问的路径跳转到不同端口的服务中。 nginx监听端口为9001访问http://127.0.0.1:9001/edu/ 直接跳转到 127.0.0.1:8001访问http://127.0.0.1:9001/vod/ 直接跳转到 127.0.0.1:8002 123456789101112server&#123; listen 9001; server_name localhost; location ~ /edu/ &#123; proxy_pass http://localhost:8001; &#125; location ~ /vod/ &#123; proxy_pass http://localhost:8002; &#125;&#125; location指令说明 该指令用于匹配URL。语法如下：123location [ = | ~ | ~* | ^~ ] uri&#123;&#125; 1、=：用于不含正则表达式的uri前，要求请求字符串与uri严格匹配，如果匹配成功，就停止继续向下搜索并立即处理该请求。2、~：用于表示uri包含正则表达式，并且区分大小写。3、~*：用于表示uri包含正则表达式，并且不区分大小写。4、\^~：用于不含正则表达式的uri前，要求Nginx服务器找到标识uri和请求字符串匹配度最高的location后，立即使用此location处理请求，而不再使用location块中的正则uri和请求字符串做匹配。 注意：如果uri包含正则表达式，则必须要有~或者~*标识。 配置实例-负载均衡实现效果：配置负载均衡 123456789101112131415161718http&#123; ... upstream myserver&#123; ip_hash; server 115.28.52.63:8080 weight=1; server 115.28.52.63:8180 weight=1; &#125; ... server&#123; location / &#123; ... proxy_pass http://myserver; proxy_connect_timeout 10; &#125; ... &#125;&#125; 随着互联网信息的爆炸性增长，负载均衡（load balance）已经不再是一个很陌生的话题，顾名思义，负载均衡即是将负载分摊到不同的服务单元，既保证服务的可用性，又保证响应足够快，给用户很好的体验。快速增长的访问量和数据流量催生了各式各样的负载均衡产品，很多专业的负载均衡硬件提供了很好的功能，但却价格不菲，这使得负载均衡软件大受欢迎，nginx就是其中的一个，在linux下有Nginx、LVS、Haproxy等等服务可以提供负载均衡服务，而且Nginx提供了几种分配方式（策略）： 1、轮询（默认） 每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。 2、weight weight代表权重，默认为1，权重越高被分配的客户端越多指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如：1234upstream server_pool&#123; server 192.168.5.21 weight=10; server 192.168.5.22 weight=10;&#125; 3、ip_hash 每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。 例如：12345upstream server_pool &#123; ip_hash ; server 192.168.5.21:80; server 192.168.5.22:80;&#125; 4、fair（第三方） 按后端服务器的响应时间来分配请求，响应时间短的优先分配。 12345upstream server_pool &#123; server 192.168.5.21:80; server 192.168.5.22:80; fair ;&#125; 配置实例-动静分离Nginx动静分离简单来说就是把动态跟静态请求分开，不能理解成只是单纯的把动态页面和静态页面物理分离。严格意义上说应该是动态请求跟静态请求分开，可以理解成使用Nginx处理静态页面，Tomcat处理动态页面。动静分离从目前实现角度来讲大致分为两种，一种是纯粹把静态文件独立成单独的域名，放在独立的服务器上，也是目前主流推崇的方案； 另外一种方法就是动态跟静态文件混合在一起发布，通过 nginx 来分开。 通过location指定不同的后缀名实现不同的请求转发。通过expires 参数设置，可以使浏览器缓存过期时间，减少与服务器之前的请求和流量。具体Expires定义：是给一个资源设定一个过期时间，也就是说无需去服务端验证，直接通过浏览器自身确认是否过期即可，所以不会产生额外的流量。此种方法非常适合不经常变动的资源。（如果经常更新的文件，不建议使用Expires来缓存），我这里设置3d，表示在这3天之内访问这个URL，发送一个请求，比对服务器该文件最后更新时间没有变化，则不会从服务器抓取，返回状态码304，如果有修改，则直接从服务器重新下载，返回状态码200。 1234567891011121314server&#123; listen 9001; server_name 192.168.17.129; location /www/ &#123; root /data/; index index.html index.htm; &#125; location /image/ &#123; root /data/; autoindex on; &#125;&#125; 重点是添加location 最后检查Nginx配置是否正确即可，然后测试动静分离是否成功，之需要删除后端tomcat服务器上的某个静态文件，查看是否能访问，如果可以访问说明静态资源nginx直接返回了，不走后端tomcat服务器 Nginx原理与优化参数配置 master-workers的机制的好处 首先，对于每个worker进程来说，独立的进程，不需要加锁，所以省掉了锁带来的开销，同时在编程以及问题查找时，也会方便很多。其次，采用独立的进程，可以让互相之间不会影响，一个进程退出后，其它进程还在工作，服务不会中断，master进程则很快启动新的worker进程。当然，worker 进程的异常退出，肯定是程序有 bug 了，异常退出，会导致当前worker上的所有请求失败，不过不会影响到所有请求，所以降低了风险。 需要设置多少个worker Nginx 同 redis 类似都采用了io多路复用机制，每个 worker 都是一个独立的进程，但每个进程里只有一个主线程，通过异步非阻塞的方式来处理请求，即使是千上万个请求也不在话下。每个worker的线程可以把一个 cpu的性能发挥到极致。所以worker数和服务器的cpu数相等是最为适宜的。设少了会浪费cpu，设多了会造成cpu频繁切换上下文带来的损耗。123456# 设置 worker 数量。worker_processes 4#work 绑定 cpu(4 work 绑定 4cpu)。worker_cpu_affinity 0001 0010 0100 1000#work 绑定 cpu (4 work 绑定 8cpu 中的 4 个) 。worker_cpu_affinity 0000001 00000010 00000100 00001000 连接数worker_connection 这个值是表示每个worker进程所能建立连接的最大值，所以，一个 nginx 能建立的最大连接数，应该是 worker_connections * worker_processes。当然，这里说的是最大连接数，对于HTTP请求 本 地 资 源 来 说 ， 能够支持的最大并发数量是worker_connections * worker_processes，如果是支持http1.1的浏览器每次访问要占两个连接，所以普通的静态访问最大并发数是： worker_connections * worker_processes/2，而如果是HTTP作为反向代理来说，最大并发数量应该是 worker_connections * worker_processes/4。因为作为反向代理服务器，每个并发会建立与客户端的连接和与后端服务的连接，会占用两个连接。 Nginx搭建高可用集群Keepalived+Nginx高可用集群（主从模式）&lt;/span&gt; Keepalived+Nginx高可用集群（双主模式）&lt;/span&gt;]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
</search>
